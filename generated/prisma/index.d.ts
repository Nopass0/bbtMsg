
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model BalanceEntry
 * 
 */
export type BalanceEntry = $Result.DefaultSelection<Prisma.$BalanceEntryPayload>
/**
 * Model BybitMatch
 * 
 */
export type BybitMatch = $Result.DefaultSelection<Prisma.$BybitMatchPayload>
/**
 * Model BybitOrderInfo
 * 
 */
export type BybitOrderInfo = $Result.DefaultSelection<Prisma.$BybitOrderInfoPayload>
/**
 * Model BybitTransaction
 * 
 */
export type BybitTransaction = $Result.DefaultSelection<Prisma.$BybitTransactionPayload>
/**
 * Model Card
 * 
 */
export type Card = $Result.DefaultSelection<Prisma.$CardPayload>
/**
 * Model CardBalance
 * 
 */
export type CardBalance = $Result.DefaultSelection<Prisma.$CardBalancePayload>
/**
 * Model CardPouring
 * 
 */
export type CardPouring = $Result.DefaultSelection<Prisma.$CardPouringPayload>
/**
 * Model Cell
 * 
 */
export type Cell = $Result.DefaultSelection<Prisma.$CellPayload>
/**
 * Model Column
 * 
 */
export type Column = $Result.DefaultSelection<Prisma.$ColumnPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Filter
 * 
 */
export type Filter = $Result.DefaultSelection<Prisma.$FilterPayload>
/**
 * Model FinRow
 * 
 */
export type FinRow = $Result.DefaultSelection<Prisma.$FinRowPayload>
/**
 * Model FinRowExpense
 * 
 */
export type FinRowExpense = $Result.DefaultSelection<Prisma.$FinRowExpensePayload>
/**
 * Model IdexCabinet
 * 
 */
export type IdexCabinet = $Result.DefaultSelection<Prisma.$IdexCabinetPayload>
/**
 * Model IdexSyncOrder
 * 
 */
export type IdexSyncOrder = $Result.DefaultSelection<Prisma.$IdexSyncOrderPayload>
/**
 * Model IdexTransaction
 * 
 */
export type IdexTransaction = $Result.DefaultSelection<Prisma.$IdexTransactionPayload>
/**
 * Model ImportExport
 * 
 */
export type ImportExport = $Result.DefaultSelection<Prisma.$ImportExportPayload>
/**
 * Model Match
 * 
 */
export type Match = $Result.DefaultSelection<Prisma.$MatchPayload>
/**
 * Model NotificationSettings
 * 
 */
export type NotificationSettings = $Result.DefaultSelection<Prisma.$NotificationSettingsPayload>
/**
 * Model Password
 * 
 */
export type Password = $Result.DefaultSelection<Prisma.$PasswordPayload>
/**
 * Model ReportNotification
 * 
 */
export type ReportNotification = $Result.DefaultSelection<Prisma.$ReportNotificationPayload>
/**
 * Model Row
 * 
 */
export type Row = $Result.DefaultSelection<Prisma.$RowPayload>
/**
 * Model Salary
 * 
 */
export type Salary = $Result.DefaultSelection<Prisma.$SalaryPayload>
/**
 * Model SalaryDebt
 * 
 */
export type SalaryDebt = $Result.DefaultSelection<Prisma.$SalaryDebtPayload>
/**
 * Model SalaryEarning
 * 
 */
export type SalaryEarning = $Result.DefaultSelection<Prisma.$SalaryEarningPayload>
/**
 * Model SalaryPayment
 * 
 */
export type SalaryPayment = $Result.DefaultSelection<Prisma.$SalaryPaymentPayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model ShiftReport
 * 
 */
export type ShiftReport = $Result.DefaultSelection<Prisma.$ShiftReportPayload>
/**
 * Model ShiftReportExpense
 * 
 */
export type ShiftReportExpense = $Result.DefaultSelection<Prisma.$ShiftReportExpensePayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>
/**
 * Model Table
 * 
 */
export type Table = $Result.DefaultSelection<Prisma.$TablePayload>
/**
 * Model TelegramAccount
 * 
 */
export type TelegramAccount = $Result.DefaultSelection<Prisma.$TelegramAccountPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model WorkSession
 * 
 */
export type WorkSession = $Result.DefaultSelection<Prisma.$WorkSessionPayload>
/**
 * Model WorkSessionIdexCabinet
 * 
 */
export type WorkSessionIdexCabinet = $Result.DefaultSelection<Prisma.$WorkSessionIdexCabinetPayload>
/**
 * Model BybitCabinet
 * 
 */
export type BybitCabinet = $Result.DefaultSelection<Prisma.$BybitCabinetPayload>
/**
 * Model BybitClipMatch
 * 
 */
export type BybitClipMatch = $Result.DefaultSelection<Prisma.$BybitClipMatchPayload>
/**
 * Model BybitTransactionFromCabinet
 * 
 */
export type BybitTransactionFromCabinet = $Result.DefaultSelection<Prisma.$BybitTransactionFromCabinetPayload>
/**
 * Model MatchBybitReport
 * 
 */
export type MatchBybitReport = $Result.DefaultSelection<Prisma.$MatchBybitReportPayload>
/**
 * Model MatchViresReport
 * 
 */
export type MatchViresReport = $Result.DefaultSelection<Prisma.$MatchViresReportPayload>
/**
 * Model ViresCabinet
 * 
 */
export type ViresCabinet = $Result.DefaultSelection<Prisma.$ViresCabinetPayload>
/**
 * Model ViresClipMatch
 * 
 */
export type ViresClipMatch = $Result.DefaultSelection<Prisma.$ViresClipMatchPayload>
/**
 * Model ViresTransactionPayin
 * 
 */
export type ViresTransactionPayin = $Result.DefaultSelection<Prisma.$ViresTransactionPayinPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const CardStatus: {
  ACTIVE: 'ACTIVE',
  WARNING: 'WARNING',
  BLOCKED: 'BLOCKED'
};

export type CardStatus = (typeof CardStatus)[keyof typeof CardStatus]


export const ColumnType: {
  TEXT: 'TEXT',
  NUMBER: 'NUMBER',
  DATE: 'DATE',
  DATETIME: 'DATETIME',
  BOOLEAN: 'BOOLEAN',
  SELECT: 'SELECT',
  BUTTON: 'BUTTON',
  CALCULATED: 'CALCULATED',
  CURRENCY: 'CURRENCY',
  LINK: 'LINK',
  COMMENT: 'COMMENT'
};

export type ColumnType = (typeof ColumnType)[keyof typeof ColumnType]


export const FilterOperator: {
  EQUALS: 'EQUALS',
  NOT_EQUALS: 'NOT_EQUALS',
  GREATER_THAN: 'GREATER_THAN',
  LESS_THAN: 'LESS_THAN',
  GREATER_OR_EQUAL: 'GREATER_OR_EQUAL',
  LESS_OR_EQUAL: 'LESS_OR_EQUAL',
  CONTAINS: 'CONTAINS',
  NOT_CONTAINS: 'NOT_CONTAINS',
  STARTS_WITH: 'STARTS_WITH',
  ENDS_WITH: 'ENDS_WITH',
  BETWEEN: 'BETWEEN',
  IN_LIST: 'IN_LIST'
};

export type FilterOperator = (typeof FilterOperator)[keyof typeof FilterOperator]


export const IdexSyncOrderStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type IdexSyncOrderStatus = (typeof IdexSyncOrderStatus)[keyof typeof IdexSyncOrderStatus]


export const PeriodType: {
  TWICE_MONTH: 'TWICE_MONTH',
  THRICE_MONTH: 'THRICE_MONTH',
  ONCE_MONTH: 'ONCE_MONTH'
};

export type PeriodType = (typeof PeriodType)[keyof typeof PeriodType]


export const SalarySection: {
  PAYMENTS: 'PAYMENTS',
  TRACTOR: 'TRACTOR'
};

export type SalarySection = (typeof SalarySection)[keyof typeof SalarySection]


export const UserRole: {
  USER: 'USER',
  USERCARDS: 'USERCARDS'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const PasswordType: {
  BYBIT: 'BYBIT'
};

export type PasswordType = (typeof PasswordType)[keyof typeof PasswordType]

}

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type CardStatus = $Enums.CardStatus

export const CardStatus: typeof $Enums.CardStatus

export type ColumnType = $Enums.ColumnType

export const ColumnType: typeof $Enums.ColumnType

export type FilterOperator = $Enums.FilterOperator

export const FilterOperator: typeof $Enums.FilterOperator

export type IdexSyncOrderStatus = $Enums.IdexSyncOrderStatus

export const IdexSyncOrderStatus: typeof $Enums.IdexSyncOrderStatus

export type PeriodType = $Enums.PeriodType

export const PeriodType: typeof $Enums.PeriodType

export type SalarySection = $Enums.SalarySection

export const SalarySection: typeof $Enums.SalarySection

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type PasswordType = $Enums.PasswordType

export const PasswordType: typeof $Enums.PasswordType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balanceEntry`: Exposes CRUD operations for the **BalanceEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BalanceEntries
    * const balanceEntries = await prisma.balanceEntry.findMany()
    * ```
    */
  get balanceEntry(): Prisma.BalanceEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bybitMatch`: Exposes CRUD operations for the **BybitMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BybitMatches
    * const bybitMatches = await prisma.bybitMatch.findMany()
    * ```
    */
  get bybitMatch(): Prisma.BybitMatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bybitOrderInfo`: Exposes CRUD operations for the **BybitOrderInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BybitOrderInfos
    * const bybitOrderInfos = await prisma.bybitOrderInfo.findMany()
    * ```
    */
  get bybitOrderInfo(): Prisma.BybitOrderInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bybitTransaction`: Exposes CRUD operations for the **BybitTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BybitTransactions
    * const bybitTransactions = await prisma.bybitTransaction.findMany()
    * ```
    */
  get bybitTransaction(): Prisma.BybitTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.card`: Exposes CRUD operations for the **Card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cards
    * const cards = await prisma.card.findMany()
    * ```
    */
  get card(): Prisma.CardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cardBalance`: Exposes CRUD operations for the **CardBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardBalances
    * const cardBalances = await prisma.cardBalance.findMany()
    * ```
    */
  get cardBalance(): Prisma.CardBalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cardPouring`: Exposes CRUD operations for the **CardPouring** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardPourings
    * const cardPourings = await prisma.cardPouring.findMany()
    * ```
    */
  get cardPouring(): Prisma.CardPouringDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cell`: Exposes CRUD operations for the **Cell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cells
    * const cells = await prisma.cell.findMany()
    * ```
    */
  get cell(): Prisma.CellDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.column`: Exposes CRUD operations for the **Column** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Columns
    * const columns = await prisma.column.findMany()
    * ```
    */
  get column(): Prisma.ColumnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.filter`: Exposes CRUD operations for the **Filter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Filters
    * const filters = await prisma.filter.findMany()
    * ```
    */
  get filter(): Prisma.FilterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.finRow`: Exposes CRUD operations for the **FinRow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinRows
    * const finRows = await prisma.finRow.findMany()
    * ```
    */
  get finRow(): Prisma.FinRowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.finRowExpense`: Exposes CRUD operations for the **FinRowExpense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinRowExpenses
    * const finRowExpenses = await prisma.finRowExpense.findMany()
    * ```
    */
  get finRowExpense(): Prisma.FinRowExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.idexCabinet`: Exposes CRUD operations for the **IdexCabinet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IdexCabinets
    * const idexCabinets = await prisma.idexCabinet.findMany()
    * ```
    */
  get idexCabinet(): Prisma.IdexCabinetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.idexSyncOrder`: Exposes CRUD operations for the **IdexSyncOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IdexSyncOrders
    * const idexSyncOrders = await prisma.idexSyncOrder.findMany()
    * ```
    */
  get idexSyncOrder(): Prisma.IdexSyncOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.idexTransaction`: Exposes CRUD operations for the **IdexTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IdexTransactions
    * const idexTransactions = await prisma.idexTransaction.findMany()
    * ```
    */
  get idexTransaction(): Prisma.IdexTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.importExport`: Exposes CRUD operations for the **ImportExport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportExports
    * const importExports = await prisma.importExport.findMany()
    * ```
    */
  get importExport(): Prisma.ImportExportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.match`: Exposes CRUD operations for the **Match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.match.findMany()
    * ```
    */
  get match(): Prisma.MatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationSettings`: Exposes CRUD operations for the **NotificationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSettings
    * const notificationSettings = await prisma.notificationSettings.findMany()
    * ```
    */
  get notificationSettings(): Prisma.NotificationSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password`: Exposes CRUD operations for the **Password** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passwords
    * const passwords = await prisma.password.findMany()
    * ```
    */
  get password(): Prisma.PasswordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportNotification`: Exposes CRUD operations for the **ReportNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportNotifications
    * const reportNotifications = await prisma.reportNotification.findMany()
    * ```
    */
  get reportNotification(): Prisma.ReportNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.row`: Exposes CRUD operations for the **Row** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rows
    * const rows = await prisma.row.findMany()
    * ```
    */
  get row(): Prisma.RowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salary`: Exposes CRUD operations for the **Salary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salaries
    * const salaries = await prisma.salary.findMany()
    * ```
    */
  get salary(): Prisma.SalaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salaryDebt`: Exposes CRUD operations for the **SalaryDebt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryDebts
    * const salaryDebts = await prisma.salaryDebt.findMany()
    * ```
    */
  get salaryDebt(): Prisma.SalaryDebtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salaryEarning`: Exposes CRUD operations for the **SalaryEarning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryEarnings
    * const salaryEarnings = await prisma.salaryEarning.findMany()
    * ```
    */
  get salaryEarning(): Prisma.SalaryEarningDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salaryPayment`: Exposes CRUD operations for the **SalaryPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryPayments
    * const salaryPayments = await prisma.salaryPayment.findMany()
    * ```
    */
  get salaryPayment(): Prisma.SalaryPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shiftReport`: Exposes CRUD operations for the **ShiftReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftReports
    * const shiftReports = await prisma.shiftReport.findMany()
    * ```
    */
  get shiftReport(): Prisma.ShiftReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shiftReportExpense`: Exposes CRUD operations for the **ShiftReportExpense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftReportExpenses
    * const shiftReportExpenses = await prisma.shiftReportExpense.findMany()
    * ```
    */
  get shiftReportExpense(): Prisma.ShiftReportExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.table`: Exposes CRUD operations for the **Table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.table.findMany()
    * ```
    */
  get table(): Prisma.TableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telegramAccount`: Exposes CRUD operations for the **TelegramAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelegramAccounts
    * const telegramAccounts = await prisma.telegramAccount.findMany()
    * ```
    */
  get telegramAccount(): Prisma.TelegramAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workSession`: Exposes CRUD operations for the **WorkSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkSessions
    * const workSessions = await prisma.workSession.findMany()
    * ```
    */
  get workSession(): Prisma.WorkSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workSessionIdexCabinet`: Exposes CRUD operations for the **WorkSessionIdexCabinet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkSessionIdexCabinets
    * const workSessionIdexCabinets = await prisma.workSessionIdexCabinet.findMany()
    * ```
    */
  get workSessionIdexCabinet(): Prisma.WorkSessionIdexCabinetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bybitCabinet`: Exposes CRUD operations for the **BybitCabinet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BybitCabinets
    * const bybitCabinets = await prisma.bybitCabinet.findMany()
    * ```
    */
  get bybitCabinet(): Prisma.BybitCabinetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bybitClipMatch`: Exposes CRUD operations for the **BybitClipMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BybitClipMatches
    * const bybitClipMatches = await prisma.bybitClipMatch.findMany()
    * ```
    */
  get bybitClipMatch(): Prisma.BybitClipMatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bybitTransactionFromCabinet`: Exposes CRUD operations for the **BybitTransactionFromCabinet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BybitTransactionFromCabinets
    * const bybitTransactionFromCabinets = await prisma.bybitTransactionFromCabinet.findMany()
    * ```
    */
  get bybitTransactionFromCabinet(): Prisma.BybitTransactionFromCabinetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchBybitReport`: Exposes CRUD operations for the **MatchBybitReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchBybitReports
    * const matchBybitReports = await prisma.matchBybitReport.findMany()
    * ```
    */
  get matchBybitReport(): Prisma.MatchBybitReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchViresReport`: Exposes CRUD operations for the **MatchViresReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchViresReports
    * const matchViresReports = await prisma.matchViresReport.findMany()
    * ```
    */
  get matchViresReport(): Prisma.MatchViresReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viresCabinet`: Exposes CRUD operations for the **ViresCabinet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViresCabinets
    * const viresCabinets = await prisma.viresCabinet.findMany()
    * ```
    */
  get viresCabinet(): Prisma.ViresCabinetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viresClipMatch`: Exposes CRUD operations for the **ViresClipMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViresClipMatches
    * const viresClipMatches = await prisma.viresClipMatch.findMany()
    * ```
    */
  get viresClipMatch(): Prisma.ViresClipMatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viresTransactionPayin`: Exposes CRUD operations for the **ViresTransactionPayin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViresTransactionPayins
    * const viresTransactionPayins = await prisma.viresTransactionPayin.findMany()
    * ```
    */
  get viresTransactionPayin(): Prisma.ViresTransactionPayinDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    AuditLog: 'AuditLog',
    BalanceEntry: 'BalanceEntry',
    BybitMatch: 'BybitMatch',
    BybitOrderInfo: 'BybitOrderInfo',
    BybitTransaction: 'BybitTransaction',
    Card: 'Card',
    CardBalance: 'CardBalance',
    CardPouring: 'CardPouring',
    Cell: 'Cell',
    Column: 'Column',
    Comment: 'Comment',
    Filter: 'Filter',
    FinRow: 'FinRow',
    FinRowExpense: 'FinRowExpense',
    IdexCabinet: 'IdexCabinet',
    IdexSyncOrder: 'IdexSyncOrder',
    IdexTransaction: 'IdexTransaction',
    ImportExport: 'ImportExport',
    Match: 'Match',
    NotificationSettings: 'NotificationSettings',
    Password: 'Password',
    ReportNotification: 'ReportNotification',
    Row: 'Row',
    Salary: 'Salary',
    SalaryDebt: 'SalaryDebt',
    SalaryEarning: 'SalaryEarning',
    SalaryPayment: 'SalaryPayment',
    Section: 'Section',
    ShiftReport: 'ShiftReport',
    ShiftReportExpense: 'ShiftReportExpense',
    SystemSettings: 'SystemSettings',
    Table: 'Table',
    TelegramAccount: 'TelegramAccount',
    Transaction: 'Transaction',
    User: 'User',
    WorkSession: 'WorkSession',
    WorkSessionIdexCabinet: 'WorkSessionIdexCabinet',
    BybitCabinet: 'BybitCabinet',
    BybitClipMatch: 'BybitClipMatch',
    BybitTransactionFromCabinet: 'BybitTransactionFromCabinet',
    MatchBybitReport: 'MatchBybitReport',
    MatchViresReport: 'MatchViresReport',
    ViresCabinet: 'ViresCabinet',
    ViresClipMatch: 'ViresClipMatch',
    ViresTransactionPayin: 'ViresTransactionPayin'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin" | "auditLog" | "balanceEntry" | "bybitMatch" | "bybitOrderInfo" | "bybitTransaction" | "card" | "cardBalance" | "cardPouring" | "cell" | "column" | "comment" | "filter" | "finRow" | "finRowExpense" | "idexCabinet" | "idexSyncOrder" | "idexTransaction" | "importExport" | "match" | "notificationSettings" | "password" | "reportNotification" | "row" | "salary" | "salaryDebt" | "salaryEarning" | "salaryPayment" | "section" | "shiftReport" | "shiftReportExpense" | "systemSettings" | "table" | "telegramAccount" | "transaction" | "user" | "workSession" | "workSessionIdexCabinet" | "bybitCabinet" | "bybitClipMatch" | "bybitTransactionFromCabinet" | "matchBybitReport" | "matchViresReport" | "viresCabinet" | "viresClipMatch" | "viresTransactionPayin"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      BalanceEntry: {
        payload: Prisma.$BalanceEntryPayload<ExtArgs>
        fields: Prisma.BalanceEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalanceEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalanceEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceEntryPayload>
          }
          findFirst: {
            args: Prisma.BalanceEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalanceEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceEntryPayload>
          }
          findMany: {
            args: Prisma.BalanceEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceEntryPayload>[]
          }
          create: {
            args: Prisma.BalanceEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceEntryPayload>
          }
          createMany: {
            args: Prisma.BalanceEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BalanceEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceEntryPayload>[]
          }
          delete: {
            args: Prisma.BalanceEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceEntryPayload>
          }
          update: {
            args: Prisma.BalanceEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceEntryPayload>
          }
          deleteMany: {
            args: Prisma.BalanceEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalanceEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BalanceEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceEntryPayload>[]
          }
          upsert: {
            args: Prisma.BalanceEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceEntryPayload>
          }
          aggregate: {
            args: Prisma.BalanceEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalanceEntry>
          }
          groupBy: {
            args: Prisma.BalanceEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalanceEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalanceEntryCountArgs<ExtArgs>
            result: $Utils.Optional<BalanceEntryCountAggregateOutputType> | number
          }
        }
      }
      BybitMatch: {
        payload: Prisma.$BybitMatchPayload<ExtArgs>
        fields: Prisma.BybitMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BybitMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BybitMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitMatchPayload>
          }
          findFirst: {
            args: Prisma.BybitMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BybitMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitMatchPayload>
          }
          findMany: {
            args: Prisma.BybitMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitMatchPayload>[]
          }
          create: {
            args: Prisma.BybitMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitMatchPayload>
          }
          createMany: {
            args: Prisma.BybitMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BybitMatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitMatchPayload>[]
          }
          delete: {
            args: Prisma.BybitMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitMatchPayload>
          }
          update: {
            args: Prisma.BybitMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitMatchPayload>
          }
          deleteMany: {
            args: Prisma.BybitMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BybitMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BybitMatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitMatchPayload>[]
          }
          upsert: {
            args: Prisma.BybitMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitMatchPayload>
          }
          aggregate: {
            args: Prisma.BybitMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBybitMatch>
          }
          groupBy: {
            args: Prisma.BybitMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BybitMatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BybitMatchCountArgs<ExtArgs>
            result: $Utils.Optional<BybitMatchCountAggregateOutputType> | number
          }
        }
      }
      BybitOrderInfo: {
        payload: Prisma.$BybitOrderInfoPayload<ExtArgs>
        fields: Prisma.BybitOrderInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BybitOrderInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitOrderInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BybitOrderInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitOrderInfoPayload>
          }
          findFirst: {
            args: Prisma.BybitOrderInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitOrderInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BybitOrderInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitOrderInfoPayload>
          }
          findMany: {
            args: Prisma.BybitOrderInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitOrderInfoPayload>[]
          }
          create: {
            args: Prisma.BybitOrderInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitOrderInfoPayload>
          }
          createMany: {
            args: Prisma.BybitOrderInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BybitOrderInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitOrderInfoPayload>[]
          }
          delete: {
            args: Prisma.BybitOrderInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitOrderInfoPayload>
          }
          update: {
            args: Prisma.BybitOrderInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitOrderInfoPayload>
          }
          deleteMany: {
            args: Prisma.BybitOrderInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BybitOrderInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BybitOrderInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitOrderInfoPayload>[]
          }
          upsert: {
            args: Prisma.BybitOrderInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitOrderInfoPayload>
          }
          aggregate: {
            args: Prisma.BybitOrderInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBybitOrderInfo>
          }
          groupBy: {
            args: Prisma.BybitOrderInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BybitOrderInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BybitOrderInfoCountArgs<ExtArgs>
            result: $Utils.Optional<BybitOrderInfoCountAggregateOutputType> | number
          }
        }
      }
      BybitTransaction: {
        payload: Prisma.$BybitTransactionPayload<ExtArgs>
        fields: Prisma.BybitTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BybitTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BybitTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionPayload>
          }
          findFirst: {
            args: Prisma.BybitTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BybitTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionPayload>
          }
          findMany: {
            args: Prisma.BybitTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionPayload>[]
          }
          create: {
            args: Prisma.BybitTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionPayload>
          }
          createMany: {
            args: Prisma.BybitTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BybitTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionPayload>[]
          }
          delete: {
            args: Prisma.BybitTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionPayload>
          }
          update: {
            args: Prisma.BybitTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionPayload>
          }
          deleteMany: {
            args: Prisma.BybitTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BybitTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BybitTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionPayload>[]
          }
          upsert: {
            args: Prisma.BybitTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionPayload>
          }
          aggregate: {
            args: Prisma.BybitTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBybitTransaction>
          }
          groupBy: {
            args: Prisma.BybitTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BybitTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BybitTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<BybitTransactionCountAggregateOutputType> | number
          }
        }
      }
      Card: {
        payload: Prisma.$CardPayload<ExtArgs>
        fields: Prisma.CardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findFirst: {
            args: Prisma.CardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findMany: {
            args: Prisma.CardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          create: {
            args: Prisma.CardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          createMany: {
            args: Prisma.CardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          delete: {
            args: Prisma.CardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          update: {
            args: Prisma.CardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          deleteMany: {
            args: Prisma.CardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          upsert: {
            args: Prisma.CardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          aggregate: {
            args: Prisma.CardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCard>
          }
          groupBy: {
            args: Prisma.CardGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardCountArgs<ExtArgs>
            result: $Utils.Optional<CardCountAggregateOutputType> | number
          }
        }
      }
      CardBalance: {
        payload: Prisma.$CardBalancePayload<ExtArgs>
        fields: Prisma.CardBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardBalancePayload>
          }
          findFirst: {
            args: Prisma.CardBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardBalancePayload>
          }
          findMany: {
            args: Prisma.CardBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardBalancePayload>[]
          }
          create: {
            args: Prisma.CardBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardBalancePayload>
          }
          createMany: {
            args: Prisma.CardBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CardBalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardBalancePayload>[]
          }
          delete: {
            args: Prisma.CardBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardBalancePayload>
          }
          update: {
            args: Prisma.CardBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardBalancePayload>
          }
          deleteMany: {
            args: Prisma.CardBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CardBalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardBalancePayload>[]
          }
          upsert: {
            args: Prisma.CardBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardBalancePayload>
          }
          aggregate: {
            args: Prisma.CardBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardBalance>
          }
          groupBy: {
            args: Prisma.CardBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<CardBalanceCountAggregateOutputType> | number
          }
        }
      }
      CardPouring: {
        payload: Prisma.$CardPouringPayload<ExtArgs>
        fields: Prisma.CardPouringFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardPouringFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPouringPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardPouringFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPouringPayload>
          }
          findFirst: {
            args: Prisma.CardPouringFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPouringPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardPouringFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPouringPayload>
          }
          findMany: {
            args: Prisma.CardPouringFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPouringPayload>[]
          }
          create: {
            args: Prisma.CardPouringCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPouringPayload>
          }
          createMany: {
            args: Prisma.CardPouringCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CardPouringCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPouringPayload>[]
          }
          delete: {
            args: Prisma.CardPouringDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPouringPayload>
          }
          update: {
            args: Prisma.CardPouringUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPouringPayload>
          }
          deleteMany: {
            args: Prisma.CardPouringDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardPouringUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CardPouringUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPouringPayload>[]
          }
          upsert: {
            args: Prisma.CardPouringUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPouringPayload>
          }
          aggregate: {
            args: Prisma.CardPouringAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardPouring>
          }
          groupBy: {
            args: Prisma.CardPouringGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardPouringGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardPouringCountArgs<ExtArgs>
            result: $Utils.Optional<CardPouringCountAggregateOutputType> | number
          }
        }
      }
      Cell: {
        payload: Prisma.$CellPayload<ExtArgs>
        fields: Prisma.CellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CellFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CellFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CellPayload>
          }
          findFirst: {
            args: Prisma.CellFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CellFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CellPayload>
          }
          findMany: {
            args: Prisma.CellFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CellPayload>[]
          }
          create: {
            args: Prisma.CellCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CellPayload>
          }
          createMany: {
            args: Prisma.CellCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CellCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CellPayload>[]
          }
          delete: {
            args: Prisma.CellDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CellPayload>
          }
          update: {
            args: Prisma.CellUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CellPayload>
          }
          deleteMany: {
            args: Prisma.CellDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CellUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CellUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CellPayload>[]
          }
          upsert: {
            args: Prisma.CellUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CellPayload>
          }
          aggregate: {
            args: Prisma.CellAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCell>
          }
          groupBy: {
            args: Prisma.CellGroupByArgs<ExtArgs>
            result: $Utils.Optional<CellGroupByOutputType>[]
          }
          count: {
            args: Prisma.CellCountArgs<ExtArgs>
            result: $Utils.Optional<CellCountAggregateOutputType> | number
          }
        }
      }
      Column: {
        payload: Prisma.$ColumnPayload<ExtArgs>
        fields: Prisma.ColumnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ColumnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ColumnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          findFirst: {
            args: Prisma.ColumnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ColumnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          findMany: {
            args: Prisma.ColumnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>[]
          }
          create: {
            args: Prisma.ColumnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          createMany: {
            args: Prisma.ColumnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ColumnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>[]
          }
          delete: {
            args: Prisma.ColumnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          update: {
            args: Prisma.ColumnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          deleteMany: {
            args: Prisma.ColumnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ColumnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ColumnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>[]
          }
          upsert: {
            args: Prisma.ColumnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          aggregate: {
            args: Prisma.ColumnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateColumn>
          }
          groupBy: {
            args: Prisma.ColumnGroupByArgs<ExtArgs>
            result: $Utils.Optional<ColumnGroupByOutputType>[]
          }
          count: {
            args: Prisma.ColumnCountArgs<ExtArgs>
            result: $Utils.Optional<ColumnCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Filter: {
        payload: Prisma.$FilterPayload<ExtArgs>
        fields: Prisma.FilterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          findFirst: {
            args: Prisma.FilterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          findMany: {
            args: Prisma.FilterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>[]
          }
          create: {
            args: Prisma.FilterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          createMany: {
            args: Prisma.FilterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FilterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>[]
          }
          delete: {
            args: Prisma.FilterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          update: {
            args: Prisma.FilterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          deleteMany: {
            args: Prisma.FilterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FilterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>[]
          }
          upsert: {
            args: Prisma.FilterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          aggregate: {
            args: Prisma.FilterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilter>
          }
          groupBy: {
            args: Prisma.FilterGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilterGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilterCountArgs<ExtArgs>
            result: $Utils.Optional<FilterCountAggregateOutputType> | number
          }
        }
      }
      FinRow: {
        payload: Prisma.$FinRowPayload<ExtArgs>
        fields: Prisma.FinRowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinRowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinRowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowPayload>
          }
          findFirst: {
            args: Prisma.FinRowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinRowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowPayload>
          }
          findMany: {
            args: Prisma.FinRowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowPayload>[]
          }
          create: {
            args: Prisma.FinRowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowPayload>
          }
          createMany: {
            args: Prisma.FinRowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinRowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowPayload>[]
          }
          delete: {
            args: Prisma.FinRowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowPayload>
          }
          update: {
            args: Prisma.FinRowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowPayload>
          }
          deleteMany: {
            args: Prisma.FinRowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinRowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinRowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowPayload>[]
          }
          upsert: {
            args: Prisma.FinRowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowPayload>
          }
          aggregate: {
            args: Prisma.FinRowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinRow>
          }
          groupBy: {
            args: Prisma.FinRowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinRowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinRowCountArgs<ExtArgs>
            result: $Utils.Optional<FinRowCountAggregateOutputType> | number
          }
        }
      }
      FinRowExpense: {
        payload: Prisma.$FinRowExpensePayload<ExtArgs>
        fields: Prisma.FinRowExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinRowExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinRowExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowExpensePayload>
          }
          findFirst: {
            args: Prisma.FinRowExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinRowExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowExpensePayload>
          }
          findMany: {
            args: Prisma.FinRowExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowExpensePayload>[]
          }
          create: {
            args: Prisma.FinRowExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowExpensePayload>
          }
          createMany: {
            args: Prisma.FinRowExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinRowExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowExpensePayload>[]
          }
          delete: {
            args: Prisma.FinRowExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowExpensePayload>
          }
          update: {
            args: Prisma.FinRowExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowExpensePayload>
          }
          deleteMany: {
            args: Prisma.FinRowExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinRowExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinRowExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowExpensePayload>[]
          }
          upsert: {
            args: Prisma.FinRowExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinRowExpensePayload>
          }
          aggregate: {
            args: Prisma.FinRowExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinRowExpense>
          }
          groupBy: {
            args: Prisma.FinRowExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinRowExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinRowExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<FinRowExpenseCountAggregateOutputType> | number
          }
        }
      }
      IdexCabinet: {
        payload: Prisma.$IdexCabinetPayload<ExtArgs>
        fields: Prisma.IdexCabinetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdexCabinetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexCabinetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdexCabinetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexCabinetPayload>
          }
          findFirst: {
            args: Prisma.IdexCabinetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexCabinetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdexCabinetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexCabinetPayload>
          }
          findMany: {
            args: Prisma.IdexCabinetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexCabinetPayload>[]
          }
          create: {
            args: Prisma.IdexCabinetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexCabinetPayload>
          }
          createMany: {
            args: Prisma.IdexCabinetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdexCabinetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexCabinetPayload>[]
          }
          delete: {
            args: Prisma.IdexCabinetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexCabinetPayload>
          }
          update: {
            args: Prisma.IdexCabinetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexCabinetPayload>
          }
          deleteMany: {
            args: Prisma.IdexCabinetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdexCabinetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdexCabinetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexCabinetPayload>[]
          }
          upsert: {
            args: Prisma.IdexCabinetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexCabinetPayload>
          }
          aggregate: {
            args: Prisma.IdexCabinetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdexCabinet>
          }
          groupBy: {
            args: Prisma.IdexCabinetGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdexCabinetGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdexCabinetCountArgs<ExtArgs>
            result: $Utils.Optional<IdexCabinetCountAggregateOutputType> | number
          }
        }
      }
      IdexSyncOrder: {
        payload: Prisma.$IdexSyncOrderPayload<ExtArgs>
        fields: Prisma.IdexSyncOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdexSyncOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexSyncOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdexSyncOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexSyncOrderPayload>
          }
          findFirst: {
            args: Prisma.IdexSyncOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexSyncOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdexSyncOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexSyncOrderPayload>
          }
          findMany: {
            args: Prisma.IdexSyncOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexSyncOrderPayload>[]
          }
          create: {
            args: Prisma.IdexSyncOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexSyncOrderPayload>
          }
          createMany: {
            args: Prisma.IdexSyncOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdexSyncOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexSyncOrderPayload>[]
          }
          delete: {
            args: Prisma.IdexSyncOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexSyncOrderPayload>
          }
          update: {
            args: Prisma.IdexSyncOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexSyncOrderPayload>
          }
          deleteMany: {
            args: Prisma.IdexSyncOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdexSyncOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdexSyncOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexSyncOrderPayload>[]
          }
          upsert: {
            args: Prisma.IdexSyncOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexSyncOrderPayload>
          }
          aggregate: {
            args: Prisma.IdexSyncOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdexSyncOrder>
          }
          groupBy: {
            args: Prisma.IdexSyncOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdexSyncOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdexSyncOrderCountArgs<ExtArgs>
            result: $Utils.Optional<IdexSyncOrderCountAggregateOutputType> | number
          }
        }
      }
      IdexTransaction: {
        payload: Prisma.$IdexTransactionPayload<ExtArgs>
        fields: Prisma.IdexTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdexTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdexTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexTransactionPayload>
          }
          findFirst: {
            args: Prisma.IdexTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdexTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexTransactionPayload>
          }
          findMany: {
            args: Prisma.IdexTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexTransactionPayload>[]
          }
          create: {
            args: Prisma.IdexTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexTransactionPayload>
          }
          createMany: {
            args: Prisma.IdexTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdexTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexTransactionPayload>[]
          }
          delete: {
            args: Prisma.IdexTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexTransactionPayload>
          }
          update: {
            args: Prisma.IdexTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexTransactionPayload>
          }
          deleteMany: {
            args: Prisma.IdexTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdexTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdexTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexTransactionPayload>[]
          }
          upsert: {
            args: Prisma.IdexTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdexTransactionPayload>
          }
          aggregate: {
            args: Prisma.IdexTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdexTransaction>
          }
          groupBy: {
            args: Prisma.IdexTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdexTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdexTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<IdexTransactionCountAggregateOutputType> | number
          }
        }
      }
      ImportExport: {
        payload: Prisma.$ImportExportPayload<ExtArgs>
        fields: Prisma.ImportExportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportExportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportExportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportExportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportExportPayload>
          }
          findFirst: {
            args: Prisma.ImportExportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportExportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportExportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportExportPayload>
          }
          findMany: {
            args: Prisma.ImportExportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportExportPayload>[]
          }
          create: {
            args: Prisma.ImportExportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportExportPayload>
          }
          createMany: {
            args: Prisma.ImportExportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportExportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportExportPayload>[]
          }
          delete: {
            args: Prisma.ImportExportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportExportPayload>
          }
          update: {
            args: Prisma.ImportExportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportExportPayload>
          }
          deleteMany: {
            args: Prisma.ImportExportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportExportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImportExportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportExportPayload>[]
          }
          upsert: {
            args: Prisma.ImportExportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportExportPayload>
          }
          aggregate: {
            args: Prisma.ImportExportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportExport>
          }
          groupBy: {
            args: Prisma.ImportExportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportExportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportExportCountArgs<ExtArgs>
            result: $Utils.Optional<ImportExportCountAggregateOutputType> | number
          }
        }
      }
      Match: {
        payload: Prisma.$MatchPayload<ExtArgs>
        fields: Prisma.MatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findFirst: {
            args: Prisma.MatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findMany: {
            args: Prisma.MatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          create: {
            args: Prisma.MatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          createMany: {
            args: Prisma.MatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          delete: {
            args: Prisma.MatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          update: {
            args: Prisma.MatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          deleteMany: {
            args: Prisma.MatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          upsert: {
            args: Prisma.MatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          aggregate: {
            args: Prisma.MatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatch>
          }
          groupBy: {
            args: Prisma.MatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchCountArgs<ExtArgs>
            result: $Utils.Optional<MatchCountAggregateOutputType> | number
          }
        }
      }
      NotificationSettings: {
        payload: Prisma.$NotificationSettingsPayload<ExtArgs>
        fields: Prisma.NotificationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findFirst: {
            args: Prisma.NotificationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findMany: {
            args: Prisma.NotificationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          create: {
            args: Prisma.NotificationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          createMany: {
            args: Prisma.NotificationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          delete: {
            args: Prisma.NotificationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          update: {
            args: Prisma.NotificationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          upsert: {
            args: Prisma.NotificationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          aggregate: {
            args: Prisma.NotificationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSettings>
          }
          groupBy: {
            args: Prisma.NotificationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsCountAggregateOutputType> | number
          }
        }
      }
      Password: {
        payload: Prisma.$PasswordPayload<ExtArgs>
        fields: Prisma.PasswordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          findFirst: {
            args: Prisma.PasswordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          findMany: {
            args: Prisma.PasswordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>[]
          }
          create: {
            args: Prisma.PasswordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          createMany: {
            args: Prisma.PasswordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>[]
          }
          delete: {
            args: Prisma.PasswordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          update: {
            args: Prisma.PasswordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          deleteMany: {
            args: Prisma.PasswordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>[]
          }
          upsert: {
            args: Prisma.PasswordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          aggregate: {
            args: Prisma.PasswordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword>
          }
          groupBy: {
            args: Prisma.PasswordGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordCountAggregateOutputType> | number
          }
        }
      }
      ReportNotification: {
        payload: Prisma.$ReportNotificationPayload<ExtArgs>
        fields: Prisma.ReportNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportNotificationPayload>
          }
          findFirst: {
            args: Prisma.ReportNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportNotificationPayload>
          }
          findMany: {
            args: Prisma.ReportNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportNotificationPayload>[]
          }
          create: {
            args: Prisma.ReportNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportNotificationPayload>
          }
          createMany: {
            args: Prisma.ReportNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportNotificationPayload>[]
          }
          delete: {
            args: Prisma.ReportNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportNotificationPayload>
          }
          update: {
            args: Prisma.ReportNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportNotificationPayload>
          }
          deleteMany: {
            args: Prisma.ReportNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportNotificationPayload>[]
          }
          upsert: {
            args: Prisma.ReportNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportNotificationPayload>
          }
          aggregate: {
            args: Prisma.ReportNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportNotification>
          }
          groupBy: {
            args: Prisma.ReportNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<ReportNotificationCountAggregateOutputType> | number
          }
        }
      }
      Row: {
        payload: Prisma.$RowPayload<ExtArgs>
        fields: Prisma.RowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          findFirst: {
            args: Prisma.RowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          findMany: {
            args: Prisma.RowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>[]
          }
          create: {
            args: Prisma.RowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          createMany: {
            args: Prisma.RowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>[]
          }
          delete: {
            args: Prisma.RowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          update: {
            args: Prisma.RowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          deleteMany: {
            args: Prisma.RowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>[]
          }
          upsert: {
            args: Prisma.RowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          aggregate: {
            args: Prisma.RowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRow>
          }
          groupBy: {
            args: Prisma.RowGroupByArgs<ExtArgs>
            result: $Utils.Optional<RowGroupByOutputType>[]
          }
          count: {
            args: Prisma.RowCountArgs<ExtArgs>
            result: $Utils.Optional<RowCountAggregateOutputType> | number
          }
        }
      }
      Salary: {
        payload: Prisma.$SalaryPayload<ExtArgs>
        fields: Prisma.SalaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          findFirst: {
            args: Prisma.SalaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          findMany: {
            args: Prisma.SalaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>[]
          }
          create: {
            args: Prisma.SalaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          createMany: {
            args: Prisma.SalaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>[]
          }
          delete: {
            args: Prisma.SalaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          update: {
            args: Prisma.SalaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          deleteMany: {
            args: Prisma.SalaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>[]
          }
          upsert: {
            args: Prisma.SalaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          aggregate: {
            args: Prisma.SalaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalary>
          }
          groupBy: {
            args: Prisma.SalaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryCountAggregateOutputType> | number
          }
        }
      }
      SalaryDebt: {
        payload: Prisma.$SalaryDebtPayload<ExtArgs>
        fields: Prisma.SalaryDebtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryDebtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDebtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryDebtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDebtPayload>
          }
          findFirst: {
            args: Prisma.SalaryDebtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDebtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryDebtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDebtPayload>
          }
          findMany: {
            args: Prisma.SalaryDebtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDebtPayload>[]
          }
          create: {
            args: Prisma.SalaryDebtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDebtPayload>
          }
          createMany: {
            args: Prisma.SalaryDebtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryDebtCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDebtPayload>[]
          }
          delete: {
            args: Prisma.SalaryDebtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDebtPayload>
          }
          update: {
            args: Prisma.SalaryDebtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDebtPayload>
          }
          deleteMany: {
            args: Prisma.SalaryDebtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryDebtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryDebtUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDebtPayload>[]
          }
          upsert: {
            args: Prisma.SalaryDebtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDebtPayload>
          }
          aggregate: {
            args: Prisma.SalaryDebtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryDebt>
          }
          groupBy: {
            args: Prisma.SalaryDebtGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryDebtGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryDebtCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryDebtCountAggregateOutputType> | number
          }
        }
      }
      SalaryEarning: {
        payload: Prisma.$SalaryEarningPayload<ExtArgs>
        fields: Prisma.SalaryEarningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryEarningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryEarningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryEarningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryEarningPayload>
          }
          findFirst: {
            args: Prisma.SalaryEarningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryEarningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryEarningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryEarningPayload>
          }
          findMany: {
            args: Prisma.SalaryEarningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryEarningPayload>[]
          }
          create: {
            args: Prisma.SalaryEarningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryEarningPayload>
          }
          createMany: {
            args: Prisma.SalaryEarningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryEarningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryEarningPayload>[]
          }
          delete: {
            args: Prisma.SalaryEarningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryEarningPayload>
          }
          update: {
            args: Prisma.SalaryEarningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryEarningPayload>
          }
          deleteMany: {
            args: Prisma.SalaryEarningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryEarningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryEarningUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryEarningPayload>[]
          }
          upsert: {
            args: Prisma.SalaryEarningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryEarningPayload>
          }
          aggregate: {
            args: Prisma.SalaryEarningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryEarning>
          }
          groupBy: {
            args: Prisma.SalaryEarningGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryEarningGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryEarningCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryEarningCountAggregateOutputType> | number
          }
        }
      }
      SalaryPayment: {
        payload: Prisma.$SalaryPaymentPayload<ExtArgs>
        fields: Prisma.SalaryPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          findFirst: {
            args: Prisma.SalaryPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          findMany: {
            args: Prisma.SalaryPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>[]
          }
          create: {
            args: Prisma.SalaryPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          createMany: {
            args: Prisma.SalaryPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>[]
          }
          delete: {
            args: Prisma.SalaryPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          update: {
            args: Prisma.SalaryPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          deleteMany: {
            args: Prisma.SalaryPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>[]
          }
          upsert: {
            args: Prisma.SalaryPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          aggregate: {
            args: Prisma.SalaryPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryPayment>
          }
          groupBy: {
            args: Prisma.SalaryPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      ShiftReport: {
        payload: Prisma.$ShiftReportPayload<ExtArgs>
        fields: Prisma.ShiftReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportPayload>
          }
          findFirst: {
            args: Prisma.ShiftReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportPayload>
          }
          findMany: {
            args: Prisma.ShiftReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportPayload>[]
          }
          create: {
            args: Prisma.ShiftReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportPayload>
          }
          createMany: {
            args: Prisma.ShiftReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportPayload>[]
          }
          delete: {
            args: Prisma.ShiftReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportPayload>
          }
          update: {
            args: Prisma.ShiftReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportPayload>
          }
          deleteMany: {
            args: Prisma.ShiftReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportPayload>[]
          }
          upsert: {
            args: Prisma.ShiftReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportPayload>
          }
          aggregate: {
            args: Prisma.ShiftReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftReport>
          }
          groupBy: {
            args: Prisma.ShiftReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftReportCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftReportCountAggregateOutputType> | number
          }
        }
      }
      ShiftReportExpense: {
        payload: Prisma.$ShiftReportExpensePayload<ExtArgs>
        fields: Prisma.ShiftReportExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftReportExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftReportExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportExpensePayload>
          }
          findFirst: {
            args: Prisma.ShiftReportExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftReportExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportExpensePayload>
          }
          findMany: {
            args: Prisma.ShiftReportExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportExpensePayload>[]
          }
          create: {
            args: Prisma.ShiftReportExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportExpensePayload>
          }
          createMany: {
            args: Prisma.ShiftReportExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftReportExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportExpensePayload>[]
          }
          delete: {
            args: Prisma.ShiftReportExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportExpensePayload>
          }
          update: {
            args: Prisma.ShiftReportExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportExpensePayload>
          }
          deleteMany: {
            args: Prisma.ShiftReportExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftReportExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftReportExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportExpensePayload>[]
          }
          upsert: {
            args: Prisma.ShiftReportExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftReportExpensePayload>
          }
          aggregate: {
            args: Prisma.ShiftReportExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftReportExpense>
          }
          groupBy: {
            args: Prisma.ShiftReportExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftReportExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftReportExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftReportExpenseCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
      Table: {
        payload: Prisma.$TablePayload<ExtArgs>
        fields: Prisma.TableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findFirst: {
            args: Prisma.TableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findMany: {
            args: Prisma.TableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          create: {
            args: Prisma.TableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          createMany: {
            args: Prisma.TableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          delete: {
            args: Prisma.TableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          update: {
            args: Prisma.TableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          deleteMany: {
            args: Prisma.TableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          upsert: {
            args: Prisma.TableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          aggregate: {
            args: Prisma.TableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable>
          }
          groupBy: {
            args: Prisma.TableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TableCountArgs<ExtArgs>
            result: $Utils.Optional<TableCountAggregateOutputType> | number
          }
        }
      }
      TelegramAccount: {
        payload: Prisma.$TelegramAccountPayload<ExtArgs>
        fields: Prisma.TelegramAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelegramAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelegramAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramAccountPayload>
          }
          findFirst: {
            args: Prisma.TelegramAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelegramAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramAccountPayload>
          }
          findMany: {
            args: Prisma.TelegramAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramAccountPayload>[]
          }
          create: {
            args: Prisma.TelegramAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramAccountPayload>
          }
          createMany: {
            args: Prisma.TelegramAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TelegramAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramAccountPayload>[]
          }
          delete: {
            args: Prisma.TelegramAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramAccountPayload>
          }
          update: {
            args: Prisma.TelegramAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramAccountPayload>
          }
          deleteMany: {
            args: Prisma.TelegramAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TelegramAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TelegramAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramAccountPayload>[]
          }
          upsert: {
            args: Prisma.TelegramAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramAccountPayload>
          }
          aggregate: {
            args: Prisma.TelegramAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelegramAccount>
          }
          groupBy: {
            args: Prisma.TelegramAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelegramAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelegramAccountCountArgs<ExtArgs>
            result: $Utils.Optional<TelegramAccountCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      WorkSession: {
        payload: Prisma.$WorkSessionPayload<ExtArgs>
        fields: Prisma.WorkSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionPayload>
          }
          findFirst: {
            args: Prisma.WorkSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionPayload>
          }
          findMany: {
            args: Prisma.WorkSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionPayload>[]
          }
          create: {
            args: Prisma.WorkSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionPayload>
          }
          createMany: {
            args: Prisma.WorkSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionPayload>[]
          }
          delete: {
            args: Prisma.WorkSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionPayload>
          }
          update: {
            args: Prisma.WorkSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionPayload>
          }
          deleteMany: {
            args: Prisma.WorkSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionPayload>[]
          }
          upsert: {
            args: Prisma.WorkSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionPayload>
          }
          aggregate: {
            args: Prisma.WorkSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkSession>
          }
          groupBy: {
            args: Prisma.WorkSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkSessionCountArgs<ExtArgs>
            result: $Utils.Optional<WorkSessionCountAggregateOutputType> | number
          }
        }
      }
      WorkSessionIdexCabinet: {
        payload: Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>
        fields: Prisma.WorkSessionIdexCabinetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkSessionIdexCabinetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionIdexCabinetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkSessionIdexCabinetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionIdexCabinetPayload>
          }
          findFirst: {
            args: Prisma.WorkSessionIdexCabinetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionIdexCabinetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkSessionIdexCabinetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionIdexCabinetPayload>
          }
          findMany: {
            args: Prisma.WorkSessionIdexCabinetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionIdexCabinetPayload>[]
          }
          create: {
            args: Prisma.WorkSessionIdexCabinetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionIdexCabinetPayload>
          }
          createMany: {
            args: Prisma.WorkSessionIdexCabinetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkSessionIdexCabinetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionIdexCabinetPayload>[]
          }
          delete: {
            args: Prisma.WorkSessionIdexCabinetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionIdexCabinetPayload>
          }
          update: {
            args: Prisma.WorkSessionIdexCabinetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionIdexCabinetPayload>
          }
          deleteMany: {
            args: Prisma.WorkSessionIdexCabinetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkSessionIdexCabinetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkSessionIdexCabinetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionIdexCabinetPayload>[]
          }
          upsert: {
            args: Prisma.WorkSessionIdexCabinetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSessionIdexCabinetPayload>
          }
          aggregate: {
            args: Prisma.WorkSessionIdexCabinetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkSessionIdexCabinet>
          }
          groupBy: {
            args: Prisma.WorkSessionIdexCabinetGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkSessionIdexCabinetGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkSessionIdexCabinetCountArgs<ExtArgs>
            result: $Utils.Optional<WorkSessionIdexCabinetCountAggregateOutputType> | number
          }
        }
      }
      BybitCabinet: {
        payload: Prisma.$BybitCabinetPayload<ExtArgs>
        fields: Prisma.BybitCabinetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BybitCabinetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitCabinetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BybitCabinetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitCabinetPayload>
          }
          findFirst: {
            args: Prisma.BybitCabinetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitCabinetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BybitCabinetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitCabinetPayload>
          }
          findMany: {
            args: Prisma.BybitCabinetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitCabinetPayload>[]
          }
          create: {
            args: Prisma.BybitCabinetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitCabinetPayload>
          }
          createMany: {
            args: Prisma.BybitCabinetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BybitCabinetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitCabinetPayload>[]
          }
          delete: {
            args: Prisma.BybitCabinetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitCabinetPayload>
          }
          update: {
            args: Prisma.BybitCabinetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitCabinetPayload>
          }
          deleteMany: {
            args: Prisma.BybitCabinetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BybitCabinetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BybitCabinetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitCabinetPayload>[]
          }
          upsert: {
            args: Prisma.BybitCabinetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitCabinetPayload>
          }
          aggregate: {
            args: Prisma.BybitCabinetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBybitCabinet>
          }
          groupBy: {
            args: Prisma.BybitCabinetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BybitCabinetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BybitCabinetCountArgs<ExtArgs>
            result: $Utils.Optional<BybitCabinetCountAggregateOutputType> | number
          }
        }
      }
      BybitClipMatch: {
        payload: Prisma.$BybitClipMatchPayload<ExtArgs>
        fields: Prisma.BybitClipMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BybitClipMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitClipMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BybitClipMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitClipMatchPayload>
          }
          findFirst: {
            args: Prisma.BybitClipMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitClipMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BybitClipMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitClipMatchPayload>
          }
          findMany: {
            args: Prisma.BybitClipMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitClipMatchPayload>[]
          }
          create: {
            args: Prisma.BybitClipMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitClipMatchPayload>
          }
          createMany: {
            args: Prisma.BybitClipMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BybitClipMatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitClipMatchPayload>[]
          }
          delete: {
            args: Prisma.BybitClipMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitClipMatchPayload>
          }
          update: {
            args: Prisma.BybitClipMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitClipMatchPayload>
          }
          deleteMany: {
            args: Prisma.BybitClipMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BybitClipMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BybitClipMatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitClipMatchPayload>[]
          }
          upsert: {
            args: Prisma.BybitClipMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitClipMatchPayload>
          }
          aggregate: {
            args: Prisma.BybitClipMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBybitClipMatch>
          }
          groupBy: {
            args: Prisma.BybitClipMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BybitClipMatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BybitClipMatchCountArgs<ExtArgs>
            result: $Utils.Optional<BybitClipMatchCountAggregateOutputType> | number
          }
        }
      }
      BybitTransactionFromCabinet: {
        payload: Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>
        fields: Prisma.BybitTransactionFromCabinetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BybitTransactionFromCabinetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionFromCabinetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BybitTransactionFromCabinetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionFromCabinetPayload>
          }
          findFirst: {
            args: Prisma.BybitTransactionFromCabinetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionFromCabinetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BybitTransactionFromCabinetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionFromCabinetPayload>
          }
          findMany: {
            args: Prisma.BybitTransactionFromCabinetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionFromCabinetPayload>[]
          }
          create: {
            args: Prisma.BybitTransactionFromCabinetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionFromCabinetPayload>
          }
          createMany: {
            args: Prisma.BybitTransactionFromCabinetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BybitTransactionFromCabinetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionFromCabinetPayload>[]
          }
          delete: {
            args: Prisma.BybitTransactionFromCabinetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionFromCabinetPayload>
          }
          update: {
            args: Prisma.BybitTransactionFromCabinetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionFromCabinetPayload>
          }
          deleteMany: {
            args: Prisma.BybitTransactionFromCabinetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BybitTransactionFromCabinetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BybitTransactionFromCabinetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionFromCabinetPayload>[]
          }
          upsert: {
            args: Prisma.BybitTransactionFromCabinetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BybitTransactionFromCabinetPayload>
          }
          aggregate: {
            args: Prisma.BybitTransactionFromCabinetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBybitTransactionFromCabinet>
          }
          groupBy: {
            args: Prisma.BybitTransactionFromCabinetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BybitTransactionFromCabinetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BybitTransactionFromCabinetCountArgs<ExtArgs>
            result: $Utils.Optional<BybitTransactionFromCabinetCountAggregateOutputType> | number
          }
        }
      }
      MatchBybitReport: {
        payload: Prisma.$MatchBybitReportPayload<ExtArgs>
        fields: Prisma.MatchBybitReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchBybitReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchBybitReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchBybitReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchBybitReportPayload>
          }
          findFirst: {
            args: Prisma.MatchBybitReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchBybitReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchBybitReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchBybitReportPayload>
          }
          findMany: {
            args: Prisma.MatchBybitReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchBybitReportPayload>[]
          }
          create: {
            args: Prisma.MatchBybitReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchBybitReportPayload>
          }
          createMany: {
            args: Prisma.MatchBybitReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchBybitReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchBybitReportPayload>[]
          }
          delete: {
            args: Prisma.MatchBybitReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchBybitReportPayload>
          }
          update: {
            args: Prisma.MatchBybitReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchBybitReportPayload>
          }
          deleteMany: {
            args: Prisma.MatchBybitReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchBybitReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchBybitReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchBybitReportPayload>[]
          }
          upsert: {
            args: Prisma.MatchBybitReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchBybitReportPayload>
          }
          aggregate: {
            args: Prisma.MatchBybitReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchBybitReport>
          }
          groupBy: {
            args: Prisma.MatchBybitReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchBybitReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchBybitReportCountArgs<ExtArgs>
            result: $Utils.Optional<MatchBybitReportCountAggregateOutputType> | number
          }
        }
      }
      MatchViresReport: {
        payload: Prisma.$MatchViresReportPayload<ExtArgs>
        fields: Prisma.MatchViresReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchViresReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchViresReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchViresReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchViresReportPayload>
          }
          findFirst: {
            args: Prisma.MatchViresReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchViresReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchViresReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchViresReportPayload>
          }
          findMany: {
            args: Prisma.MatchViresReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchViresReportPayload>[]
          }
          create: {
            args: Prisma.MatchViresReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchViresReportPayload>
          }
          createMany: {
            args: Prisma.MatchViresReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchViresReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchViresReportPayload>[]
          }
          delete: {
            args: Prisma.MatchViresReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchViresReportPayload>
          }
          update: {
            args: Prisma.MatchViresReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchViresReportPayload>
          }
          deleteMany: {
            args: Prisma.MatchViresReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchViresReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchViresReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchViresReportPayload>[]
          }
          upsert: {
            args: Prisma.MatchViresReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchViresReportPayload>
          }
          aggregate: {
            args: Prisma.MatchViresReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchViresReport>
          }
          groupBy: {
            args: Prisma.MatchViresReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchViresReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchViresReportCountArgs<ExtArgs>
            result: $Utils.Optional<MatchViresReportCountAggregateOutputType> | number
          }
        }
      }
      ViresCabinet: {
        payload: Prisma.$ViresCabinetPayload<ExtArgs>
        fields: Prisma.ViresCabinetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViresCabinetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresCabinetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViresCabinetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresCabinetPayload>
          }
          findFirst: {
            args: Prisma.ViresCabinetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresCabinetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViresCabinetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresCabinetPayload>
          }
          findMany: {
            args: Prisma.ViresCabinetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresCabinetPayload>[]
          }
          create: {
            args: Prisma.ViresCabinetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresCabinetPayload>
          }
          createMany: {
            args: Prisma.ViresCabinetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViresCabinetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresCabinetPayload>[]
          }
          delete: {
            args: Prisma.ViresCabinetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresCabinetPayload>
          }
          update: {
            args: Prisma.ViresCabinetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresCabinetPayload>
          }
          deleteMany: {
            args: Prisma.ViresCabinetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViresCabinetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViresCabinetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresCabinetPayload>[]
          }
          upsert: {
            args: Prisma.ViresCabinetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresCabinetPayload>
          }
          aggregate: {
            args: Prisma.ViresCabinetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViresCabinet>
          }
          groupBy: {
            args: Prisma.ViresCabinetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViresCabinetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViresCabinetCountArgs<ExtArgs>
            result: $Utils.Optional<ViresCabinetCountAggregateOutputType> | number
          }
        }
      }
      ViresClipMatch: {
        payload: Prisma.$ViresClipMatchPayload<ExtArgs>
        fields: Prisma.ViresClipMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViresClipMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresClipMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViresClipMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresClipMatchPayload>
          }
          findFirst: {
            args: Prisma.ViresClipMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresClipMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViresClipMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresClipMatchPayload>
          }
          findMany: {
            args: Prisma.ViresClipMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresClipMatchPayload>[]
          }
          create: {
            args: Prisma.ViresClipMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresClipMatchPayload>
          }
          createMany: {
            args: Prisma.ViresClipMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViresClipMatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresClipMatchPayload>[]
          }
          delete: {
            args: Prisma.ViresClipMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresClipMatchPayload>
          }
          update: {
            args: Prisma.ViresClipMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresClipMatchPayload>
          }
          deleteMany: {
            args: Prisma.ViresClipMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViresClipMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViresClipMatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresClipMatchPayload>[]
          }
          upsert: {
            args: Prisma.ViresClipMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresClipMatchPayload>
          }
          aggregate: {
            args: Prisma.ViresClipMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViresClipMatch>
          }
          groupBy: {
            args: Prisma.ViresClipMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViresClipMatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViresClipMatchCountArgs<ExtArgs>
            result: $Utils.Optional<ViresClipMatchCountAggregateOutputType> | number
          }
        }
      }
      ViresTransactionPayin: {
        payload: Prisma.$ViresTransactionPayinPayload<ExtArgs>
        fields: Prisma.ViresTransactionPayinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViresTransactionPayinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresTransactionPayinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViresTransactionPayinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresTransactionPayinPayload>
          }
          findFirst: {
            args: Prisma.ViresTransactionPayinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresTransactionPayinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViresTransactionPayinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresTransactionPayinPayload>
          }
          findMany: {
            args: Prisma.ViresTransactionPayinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresTransactionPayinPayload>[]
          }
          create: {
            args: Prisma.ViresTransactionPayinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresTransactionPayinPayload>
          }
          createMany: {
            args: Prisma.ViresTransactionPayinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViresTransactionPayinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresTransactionPayinPayload>[]
          }
          delete: {
            args: Prisma.ViresTransactionPayinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresTransactionPayinPayload>
          }
          update: {
            args: Prisma.ViresTransactionPayinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresTransactionPayinPayload>
          }
          deleteMany: {
            args: Prisma.ViresTransactionPayinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViresTransactionPayinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViresTransactionPayinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresTransactionPayinPayload>[]
          }
          upsert: {
            args: Prisma.ViresTransactionPayinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViresTransactionPayinPayload>
          }
          aggregate: {
            args: Prisma.ViresTransactionPayinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViresTransactionPayin>
          }
          groupBy: {
            args: Prisma.ViresTransactionPayinGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViresTransactionPayinGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViresTransactionPayinCountArgs<ExtArgs>
            result: $Utils.Optional<ViresTransactionPayinCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin?: AdminOmit
    auditLog?: AuditLogOmit
    balanceEntry?: BalanceEntryOmit
    bybitMatch?: BybitMatchOmit
    bybitOrderInfo?: BybitOrderInfoOmit
    bybitTransaction?: BybitTransactionOmit
    card?: CardOmit
    cardBalance?: CardBalanceOmit
    cardPouring?: CardPouringOmit
    cell?: CellOmit
    column?: ColumnOmit
    comment?: CommentOmit
    filter?: FilterOmit
    finRow?: FinRowOmit
    finRowExpense?: FinRowExpenseOmit
    idexCabinet?: IdexCabinetOmit
    idexSyncOrder?: IdexSyncOrderOmit
    idexTransaction?: IdexTransactionOmit
    importExport?: ImportExportOmit
    match?: MatchOmit
    notificationSettings?: NotificationSettingsOmit
    password?: PasswordOmit
    reportNotification?: ReportNotificationOmit
    row?: RowOmit
    salary?: SalaryOmit
    salaryDebt?: SalaryDebtOmit
    salaryEarning?: SalaryEarningOmit
    salaryPayment?: SalaryPaymentOmit
    section?: SectionOmit
    shiftReport?: ShiftReportOmit
    shiftReportExpense?: ShiftReportExpenseOmit
    systemSettings?: SystemSettingsOmit
    table?: TableOmit
    telegramAccount?: TelegramAccountOmit
    transaction?: TransactionOmit
    user?: UserOmit
    workSession?: WorkSessionOmit
    workSessionIdexCabinet?: WorkSessionIdexCabinetOmit
    bybitCabinet?: BybitCabinetOmit
    bybitClipMatch?: BybitClipMatchOmit
    bybitTransactionFromCabinet?: BybitTransactionFromCabinetOmit
    matchBybitReport?: MatchBybitReportOmit
    matchViresReport?: MatchViresReportOmit
    viresCabinet?: ViresCabinetOmit
    viresClipMatch?: ViresClipMatchOmit
    viresTransactionPayin?: ViresTransactionPayinOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BybitTransactionCountOutputType
   */

  export type BybitTransactionCountOutputType = {
    bybitMatch: number
  }

  export type BybitTransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bybitMatch?: boolean | BybitTransactionCountOutputTypeCountBybitMatchArgs
  }

  // Custom InputTypes
  /**
   * BybitTransactionCountOutputType without action
   */
  export type BybitTransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionCountOutputType
     */
    select?: BybitTransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BybitTransactionCountOutputType without action
   */
  export type BybitTransactionCountOutputTypeCountBybitMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitMatchWhereInput
  }


  /**
   * Count Type CardCountOutputType
   */

  export type CardCountOutputType = {
    AuditLog: number
    CardBalance: number
    CardPouring: number
  }

  export type CardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | CardCountOutputTypeCountAuditLogArgs
    CardBalance?: boolean | CardCountOutputTypeCountCardBalanceArgs
    CardPouring?: boolean | CardCountOutputTypeCountCardPouringArgs
  }

  // Custom InputTypes
  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardCountOutputType
     */
    select?: CardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountCardBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardBalanceWhereInput
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountCardPouringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardPouringWhereInput
  }


  /**
   * Count Type CardBalanceCountOutputType
   */

  export type CardBalanceCountOutputType = {
    AuditLog: number
  }

  export type CardBalanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | CardBalanceCountOutputTypeCountAuditLogArgs
  }

  // Custom InputTypes
  /**
   * CardBalanceCountOutputType without action
   */
  export type CardBalanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalanceCountOutputType
     */
    select?: CardBalanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CardBalanceCountOutputType without action
   */
  export type CardBalanceCountOutputTypeCountAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type CardPouringCountOutputType
   */

  export type CardPouringCountOutputType = {
    AuditLog: number
  }

  export type CardPouringCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | CardPouringCountOutputTypeCountAuditLogArgs
  }

  // Custom InputTypes
  /**
   * CardPouringCountOutputType without action
   */
  export type CardPouringCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouringCountOutputType
     */
    select?: CardPouringCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CardPouringCountOutputType without action
   */
  export type CardPouringCountOutputTypeCountAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type CellCountOutputType
   */

  export type CellCountOutputType = {
    Comment: number
  }

  export type CellCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | CellCountOutputTypeCountCommentArgs
  }

  // Custom InputTypes
  /**
   * CellCountOutputType without action
   */
  export type CellCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CellCountOutputType
     */
    select?: CellCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CellCountOutputType without action
   */
  export type CellCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ColumnCountOutputType
   */

  export type ColumnCountOutputType = {
    Cell: number
    Filter: number
  }

  export type ColumnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cell?: boolean | ColumnCountOutputTypeCountCellArgs
    Filter?: boolean | ColumnCountOutputTypeCountFilterArgs
  }

  // Custom InputTypes
  /**
   * ColumnCountOutputType without action
   */
  export type ColumnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColumnCountOutputType
     */
    select?: ColumnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ColumnCountOutputType without action
   */
  export type ColumnCountOutputTypeCountCellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CellWhereInput
  }

  /**
   * ColumnCountOutputType without action
   */
  export type ColumnCountOutputTypeCountFilterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilterWhereInput
  }


  /**
   * Count Type FinRowCountOutputType
   */

  export type FinRowCountOutputType = {
    FinRowExpense: number
  }

  export type FinRowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FinRowExpense?: boolean | FinRowCountOutputTypeCountFinRowExpenseArgs
  }

  // Custom InputTypes
  /**
   * FinRowCountOutputType without action
   */
  export type FinRowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowCountOutputType
     */
    select?: FinRowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FinRowCountOutputType without action
   */
  export type FinRowCountOutputTypeCountFinRowExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinRowExpenseWhereInput
  }


  /**
   * Count Type IdexCabinetCountOutputType
   */

  export type IdexCabinetCountOutputType = {
    IdexSyncOrder: number
    IdexTransaction: number
    WorkSessionIdexCabinet: number
  }

  export type IdexCabinetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexSyncOrder?: boolean | IdexCabinetCountOutputTypeCountIdexSyncOrderArgs
    IdexTransaction?: boolean | IdexCabinetCountOutputTypeCountIdexTransactionArgs
    WorkSessionIdexCabinet?: boolean | IdexCabinetCountOutputTypeCountWorkSessionIdexCabinetArgs
  }

  // Custom InputTypes
  /**
   * IdexCabinetCountOutputType without action
   */
  export type IdexCabinetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinetCountOutputType
     */
    select?: IdexCabinetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IdexCabinetCountOutputType without action
   */
  export type IdexCabinetCountOutputTypeCountIdexSyncOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdexSyncOrderWhereInput
  }

  /**
   * IdexCabinetCountOutputType without action
   */
  export type IdexCabinetCountOutputTypeCountIdexTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdexTransactionWhereInput
  }

  /**
   * IdexCabinetCountOutputType without action
   */
  export type IdexCabinetCountOutputTypeCountWorkSessionIdexCabinetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkSessionIdexCabinetWhereInput
  }


  /**
   * Count Type IdexTransactionCountOutputType
   */

  export type IdexTransactionCountOutputType = {
    BybitClipMatch: number
    BybitMatch: number
    Match: number
  }

  export type IdexTransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitClipMatch?: boolean | IdexTransactionCountOutputTypeCountBybitClipMatchArgs
    BybitMatch?: boolean | IdexTransactionCountOutputTypeCountBybitMatchArgs
    Match?: boolean | IdexTransactionCountOutputTypeCountMatchArgs
  }

  // Custom InputTypes
  /**
   * IdexTransactionCountOutputType without action
   */
  export type IdexTransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransactionCountOutputType
     */
    select?: IdexTransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IdexTransactionCountOutputType without action
   */
  export type IdexTransactionCountOutputTypeCountBybitClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitClipMatchWhereInput
  }

  /**
   * IdexTransactionCountOutputType without action
   */
  export type IdexTransactionCountOutputTypeCountBybitMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitMatchWhereInput
  }

  /**
   * IdexTransactionCountOutputType without action
   */
  export type IdexTransactionCountOutputTypeCountMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }


  /**
   * Count Type RowCountOutputType
   */

  export type RowCountOutputType = {
    Cell: number
  }

  export type RowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cell?: boolean | RowCountOutputTypeCountCellArgs
  }

  // Custom InputTypes
  /**
   * RowCountOutputType without action
   */
  export type RowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RowCountOutputType
     */
    select?: RowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RowCountOutputType without action
   */
  export type RowCountOutputTypeCountCellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CellWhereInput
  }


  /**
   * Count Type SalaryCountOutputType
   */

  export type SalaryCountOutputType = {
    FinRow: number
    SalaryDebt: number
    SalaryEarning: number
    SalaryPayment: number
    ShiftReport: number
  }

  export type SalaryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FinRow?: boolean | SalaryCountOutputTypeCountFinRowArgs
    SalaryDebt?: boolean | SalaryCountOutputTypeCountSalaryDebtArgs
    SalaryEarning?: boolean | SalaryCountOutputTypeCountSalaryEarningArgs
    SalaryPayment?: boolean | SalaryCountOutputTypeCountSalaryPaymentArgs
    ShiftReport?: boolean | SalaryCountOutputTypeCountShiftReportArgs
  }

  // Custom InputTypes
  /**
   * SalaryCountOutputType without action
   */
  export type SalaryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryCountOutputType
     */
    select?: SalaryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalaryCountOutputType without action
   */
  export type SalaryCountOutputTypeCountFinRowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinRowWhereInput
  }

  /**
   * SalaryCountOutputType without action
   */
  export type SalaryCountOutputTypeCountSalaryDebtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryDebtWhereInput
  }

  /**
   * SalaryCountOutputType without action
   */
  export type SalaryCountOutputTypeCountSalaryEarningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryEarningWhereInput
  }

  /**
   * SalaryCountOutputType without action
   */
  export type SalaryCountOutputTypeCountSalaryPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentWhereInput
  }

  /**
   * SalaryCountOutputType without action
   */
  export type SalaryCountOutputTypeCountShiftReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftReportWhereInput
  }


  /**
   * Count Type SectionCountOutputType
   */

  export type SectionCountOutputType = {
    Table: number
  }

  export type SectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Table?: boolean | SectionCountOutputTypeCountTableArgs
  }

  // Custom InputTypes
  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     */
    select?: SectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
  }


  /**
   * Count Type ShiftReportCountOutputType
   */

  export type ShiftReportCountOutputType = {
    ShiftReportExpense: number
  }

  export type ShiftReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShiftReportExpense?: boolean | ShiftReportCountOutputTypeCountShiftReportExpenseArgs
  }

  // Custom InputTypes
  /**
   * ShiftReportCountOutputType without action
   */
  export type ShiftReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportCountOutputType
     */
    select?: ShiftReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftReportCountOutputType without action
   */
  export type ShiftReportCountOutputTypeCountShiftReportExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftReportExpenseWhereInput
  }


  /**
   * Count Type TableCountOutputType
   */

  export type TableCountOutputType = {
    Column: number
    Filter: number
    Row: number
  }

  export type TableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Column?: boolean | TableCountOutputTypeCountColumnArgs
    Filter?: boolean | TableCountOutputTypeCountFilterArgs
    Row?: boolean | TableCountOutputTypeCountRowArgs
  }

  // Custom InputTypes
  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableCountOutputType
     */
    select?: TableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountColumnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColumnWhereInput
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountFilterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilterWhereInput
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountRowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RowWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    Match: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Match?: boolean | TransactionCountOutputTypeCountMatchArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    AuditLog: number
    BybitClipMatch: number
    BybitTransaction: number
    MatchBybitReport: number
    MatchViresReport: number
    ReportNotification: number
    TelegramAccount: number
    Transaction: number
    ViresCabinet: number
    ViresClipMatch: number
    WorkSession: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | UserCountOutputTypeCountAuditLogArgs
    BybitClipMatch?: boolean | UserCountOutputTypeCountBybitClipMatchArgs
    BybitTransaction?: boolean | UserCountOutputTypeCountBybitTransactionArgs
    MatchBybitReport?: boolean | UserCountOutputTypeCountMatchBybitReportArgs
    MatchViresReport?: boolean | UserCountOutputTypeCountMatchViresReportArgs
    ReportNotification?: boolean | UserCountOutputTypeCountReportNotificationArgs
    TelegramAccount?: boolean | UserCountOutputTypeCountTelegramAccountArgs
    Transaction?: boolean | UserCountOutputTypeCountTransactionArgs
    ViresCabinet?: boolean | UserCountOutputTypeCountViresCabinetArgs
    ViresClipMatch?: boolean | UserCountOutputTypeCountViresClipMatchArgs
    WorkSession?: boolean | UserCountOutputTypeCountWorkSessionArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBybitClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitClipMatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBybitTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchBybitReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchBybitReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchViresReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchViresReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTelegramAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountViresCabinetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViresCabinetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountViresClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViresClipMatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkSessionWhereInput
  }


  /**
   * Count Type WorkSessionCountOutputType
   */

  export type WorkSessionCountOutputType = {
    WorkSessionIdexCabinet: number
  }

  export type WorkSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WorkSessionIdexCabinet?: boolean | WorkSessionCountOutputTypeCountWorkSessionIdexCabinetArgs
  }

  // Custom InputTypes
  /**
   * WorkSessionCountOutputType without action
   */
  export type WorkSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionCountOutputType
     */
    select?: WorkSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkSessionCountOutputType without action
   */
  export type WorkSessionCountOutputTypeCountWorkSessionIdexCabinetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkSessionIdexCabinetWhereInput
  }


  /**
   * Count Type BybitCabinetCountOutputType
   */

  export type BybitCabinetCountOutputType = {
    BybitTransactionFromCabinet: number
    BybitOrderInfo: number
  }

  export type BybitCabinetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitTransactionFromCabinet?: boolean | BybitCabinetCountOutputTypeCountBybitTransactionFromCabinetArgs
    BybitOrderInfo?: boolean | BybitCabinetCountOutputTypeCountBybitOrderInfoArgs
  }

  // Custom InputTypes
  /**
   * BybitCabinetCountOutputType without action
   */
  export type BybitCabinetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinetCountOutputType
     */
    select?: BybitCabinetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BybitCabinetCountOutputType without action
   */
  export type BybitCabinetCountOutputTypeCountBybitTransactionFromCabinetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitTransactionFromCabinetWhereInput
  }

  /**
   * BybitCabinetCountOutputType without action
   */
  export type BybitCabinetCountOutputTypeCountBybitOrderInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitOrderInfoWhereInput
  }


  /**
   * Count Type BybitTransactionFromCabinetCountOutputType
   */

  export type BybitTransactionFromCabinetCountOutputType = {
    BybitClipMatch: number
    ViresClipMatch: number
  }

  export type BybitTransactionFromCabinetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitClipMatch?: boolean | BybitTransactionFromCabinetCountOutputTypeCountBybitClipMatchArgs
    ViresClipMatch?: boolean | BybitTransactionFromCabinetCountOutputTypeCountViresClipMatchArgs
  }

  // Custom InputTypes
  /**
   * BybitTransactionFromCabinetCountOutputType without action
   */
  export type BybitTransactionFromCabinetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinetCountOutputType
     */
    select?: BybitTransactionFromCabinetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BybitTransactionFromCabinetCountOutputType without action
   */
  export type BybitTransactionFromCabinetCountOutputTypeCountBybitClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitClipMatchWhereInput
  }

  /**
   * BybitTransactionFromCabinetCountOutputType without action
   */
  export type BybitTransactionFromCabinetCountOutputTypeCountViresClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViresClipMatchWhereInput
  }


  /**
   * Count Type MatchBybitReportCountOutputType
   */

  export type MatchBybitReportCountOutputType = {
    BybitClipMatch: number
  }

  export type MatchBybitReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitClipMatch?: boolean | MatchBybitReportCountOutputTypeCountBybitClipMatchArgs
  }

  // Custom InputTypes
  /**
   * MatchBybitReportCountOutputType without action
   */
  export type MatchBybitReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReportCountOutputType
     */
    select?: MatchBybitReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatchBybitReportCountOutputType without action
   */
  export type MatchBybitReportCountOutputTypeCountBybitClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitClipMatchWhereInput
  }


  /**
   * Count Type MatchViresReportCountOutputType
   */

  export type MatchViresReportCountOutputType = {
    ViresClipMatch: number
  }

  export type MatchViresReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ViresClipMatch?: boolean | MatchViresReportCountOutputTypeCountViresClipMatchArgs
  }

  // Custom InputTypes
  /**
   * MatchViresReportCountOutputType without action
   */
  export type MatchViresReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReportCountOutputType
     */
    select?: MatchViresReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatchViresReportCountOutputType without action
   */
  export type MatchViresReportCountOutputTypeCountViresClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViresClipMatchWhereInput
  }


  /**
   * Count Type ViresCabinetCountOutputType
   */

  export type ViresCabinetCountOutputType = {
    ViresTransactionPayin: number
  }

  export type ViresCabinetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ViresTransactionPayin?: boolean | ViresCabinetCountOutputTypeCountViresTransactionPayinArgs
  }

  // Custom InputTypes
  /**
   * ViresCabinetCountOutputType without action
   */
  export type ViresCabinetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinetCountOutputType
     */
    select?: ViresCabinetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ViresCabinetCountOutputType without action
   */
  export type ViresCabinetCountOutputTypeCountViresTransactionPayinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViresTransactionPayinWhereInput
  }


  /**
   * Count Type ViresTransactionPayinCountOutputType
   */

  export type ViresTransactionPayinCountOutputType = {
    ViresClipMatch: number
  }

  export type ViresTransactionPayinCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ViresClipMatch?: boolean | ViresTransactionPayinCountOutputTypeCountViresClipMatchArgs
  }

  // Custom InputTypes
  /**
   * ViresTransactionPayinCountOutputType without action
   */
  export type ViresTransactionPayinCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayinCountOutputType
     */
    select?: ViresTransactionPayinCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ViresTransactionPayinCountOutputType without action
   */
  export type ViresTransactionPayinCountOutputTypeCountViresClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViresClipMatchWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    telegramId: number
    username: number
    firstName: number
    lastName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    telegramId: string
    username: string | null
    firstName: string | null
    lastName: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "telegramId" | "username" | "firstName" | "lastName" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      telegramId: string
      username: string | null
      firstName: string | null
      lastName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly telegramId: FieldRef<"Admin", 'String'>
    readonly username: FieldRef<"Admin", 'String'>
    readonly firstName: FieldRef<"Admin", 'String'>
    readonly lastName: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    entityId: number | null
    userId: number | null
    cardBalanceId: number | null
    cardId: number | null
    cardPouringId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    entityId: number | null
    userId: number | null
    cardBalanceId: number | null
    cardId: number | null
    cardPouringId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    action: $Enums.AuditAction | null
    userId: number | null
    timestamp: Date | null
    cardBalanceId: number | null
    cardId: number | null
    cardPouringId: number | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    action: $Enums.AuditAction | null
    userId: number | null
    timestamp: Date | null
    cardBalanceId: number | null
    cardId: number | null
    cardPouringId: number | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    action: number
    userId: number
    timestamp: number
    oldValue: number
    newValue: number
    cardBalanceId: number
    cardId: number
    cardPouringId: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    entityId?: true
    userId?: true
    cardBalanceId?: true
    cardId?: true
    cardPouringId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    entityId?: true
    userId?: true
    cardBalanceId?: true
    cardId?: true
    cardPouringId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    userId?: true
    timestamp?: true
    cardBalanceId?: true
    cardId?: true
    cardPouringId?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    userId?: true
    timestamp?: true
    cardBalanceId?: true
    cardId?: true
    cardPouringId?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    userId?: true
    timestamp?: true
    oldValue?: true
    newValue?: true
    cardBalanceId?: true
    cardId?: true
    cardPouringId?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    userId: number
    timestamp: Date
    oldValue: JsonValue | null
    newValue: JsonValue | null
    cardBalanceId: number | null
    cardId: number | null
    cardPouringId: number | null
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    timestamp?: boolean
    oldValue?: boolean
    newValue?: boolean
    cardBalanceId?: boolean
    cardId?: boolean
    cardPouringId?: boolean
    CardBalance?: boolean | AuditLog$CardBalanceArgs<ExtArgs>
    Card?: boolean | AuditLog$CardArgs<ExtArgs>
    CardPouring?: boolean | AuditLog$CardPouringArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    timestamp?: boolean
    oldValue?: boolean
    newValue?: boolean
    cardBalanceId?: boolean
    cardId?: boolean
    cardPouringId?: boolean
    CardBalance?: boolean | AuditLog$CardBalanceArgs<ExtArgs>
    Card?: boolean | AuditLog$CardArgs<ExtArgs>
    CardPouring?: boolean | AuditLog$CardPouringArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    timestamp?: boolean
    oldValue?: boolean
    newValue?: boolean
    cardBalanceId?: boolean
    cardId?: boolean
    cardPouringId?: boolean
    CardBalance?: boolean | AuditLog$CardBalanceArgs<ExtArgs>
    Card?: boolean | AuditLog$CardArgs<ExtArgs>
    CardPouring?: boolean | AuditLog$CardPouringArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    timestamp?: boolean
    oldValue?: boolean
    newValue?: boolean
    cardBalanceId?: boolean
    cardId?: boolean
    cardPouringId?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "action" | "userId" | "timestamp" | "oldValue" | "newValue" | "cardBalanceId" | "cardId" | "cardPouringId", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CardBalance?: boolean | AuditLog$CardBalanceArgs<ExtArgs>
    Card?: boolean | AuditLog$CardArgs<ExtArgs>
    CardPouring?: boolean | AuditLog$CardPouringArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CardBalance?: boolean | AuditLog$CardBalanceArgs<ExtArgs>
    Card?: boolean | AuditLog$CardArgs<ExtArgs>
    CardPouring?: boolean | AuditLog$CardPouringArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CardBalance?: boolean | AuditLog$CardBalanceArgs<ExtArgs>
    Card?: boolean | AuditLog$CardArgs<ExtArgs>
    CardPouring?: boolean | AuditLog$CardPouringArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      CardBalance: Prisma.$CardBalancePayload<ExtArgs> | null
      Card: Prisma.$CardPayload<ExtArgs> | null
      CardPouring: Prisma.$CardPouringPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entityType: string
      entityId: number
      action: $Enums.AuditAction
      userId: number
      timestamp: Date
      oldValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      cardBalanceId: number | null
      cardId: number | null
      cardPouringId: number | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CardBalance<T extends AuditLog$CardBalanceArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$CardBalanceArgs<ExtArgs>>): Prisma__CardBalanceClient<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Card<T extends AuditLog$CardArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$CardArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CardPouring<T extends AuditLog$CardPouringArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$CardPouringArgs<ExtArgs>>): Prisma__CardPouringClient<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
    readonly oldValue: FieldRef<"AuditLog", 'Json'>
    readonly newValue: FieldRef<"AuditLog", 'Json'>
    readonly cardBalanceId: FieldRef<"AuditLog", 'Int'>
    readonly cardId: FieldRef<"AuditLog", 'Int'>
    readonly cardPouringId: FieldRef<"AuditLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.CardBalance
   */
  export type AuditLog$CardBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
    where?: CardBalanceWhereInput
  }

  /**
   * AuditLog.Card
   */
  export type AuditLog$CardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    where?: CardWhereInput
  }

  /**
   * AuditLog.CardPouring
   */
  export type AuditLog$CardPouringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
    where?: CardPouringWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model BalanceEntry
   */

  export type AggregateBalanceEntry = {
    _count: BalanceEntryCountAggregateOutputType | null
    _avg: BalanceEntryAvgAggregateOutputType | null
    _sum: BalanceEntrySumAggregateOutputType | null
    _min: BalanceEntryMinAggregateOutputType | null
    _max: BalanceEntryMaxAggregateOutputType | null
  }

  export type BalanceEntryAvgAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type BalanceEntrySumAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type BalanceEntryMinAggregateOutputType = {
    id: number | null
    date: Date | null
    time: string | null
    amount: number | null
    currency: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    section: $Enums.SalarySection | null
  }

  export type BalanceEntryMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    time: string | null
    amount: number | null
    currency: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    section: $Enums.SalarySection | null
  }

  export type BalanceEntryCountAggregateOutputType = {
    id: number
    date: number
    time: number
    amount: number
    currency: number
    comment: number
    createdAt: number
    updatedAt: number
    section: number
    _all: number
  }


  export type BalanceEntryAvgAggregateInputType = {
    id?: true
    amount?: true
  }

  export type BalanceEntrySumAggregateInputType = {
    id?: true
    amount?: true
  }

  export type BalanceEntryMinAggregateInputType = {
    id?: true
    date?: true
    time?: true
    amount?: true
    currency?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    section?: true
  }

  export type BalanceEntryMaxAggregateInputType = {
    id?: true
    date?: true
    time?: true
    amount?: true
    currency?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    section?: true
  }

  export type BalanceEntryCountAggregateInputType = {
    id?: true
    date?: true
    time?: true
    amount?: true
    currency?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    section?: true
    _all?: true
  }

  export type BalanceEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BalanceEntry to aggregate.
     */
    where?: BalanceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceEntries to fetch.
     */
    orderBy?: BalanceEntryOrderByWithRelationInput | BalanceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalanceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BalanceEntries
    **/
    _count?: true | BalanceEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalanceEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalanceEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalanceEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalanceEntryMaxAggregateInputType
  }

  export type GetBalanceEntryAggregateType<T extends BalanceEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateBalanceEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalanceEntry[P]>
      : GetScalarType<T[P], AggregateBalanceEntry[P]>
  }




  export type BalanceEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceEntryWhereInput
    orderBy?: BalanceEntryOrderByWithAggregationInput | BalanceEntryOrderByWithAggregationInput[]
    by: BalanceEntryScalarFieldEnum[] | BalanceEntryScalarFieldEnum
    having?: BalanceEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalanceEntryCountAggregateInputType | true
    _avg?: BalanceEntryAvgAggregateInputType
    _sum?: BalanceEntrySumAggregateInputType
    _min?: BalanceEntryMinAggregateInputType
    _max?: BalanceEntryMaxAggregateInputType
  }

  export type BalanceEntryGroupByOutputType = {
    id: number
    date: Date
    time: string
    amount: number
    currency: string
    comment: string | null
    createdAt: Date
    updatedAt: Date
    section: $Enums.SalarySection
    _count: BalanceEntryCountAggregateOutputType | null
    _avg: BalanceEntryAvgAggregateOutputType | null
    _sum: BalanceEntrySumAggregateOutputType | null
    _min: BalanceEntryMinAggregateOutputType | null
    _max: BalanceEntryMaxAggregateOutputType | null
  }

  type GetBalanceEntryGroupByPayload<T extends BalanceEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalanceEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalanceEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalanceEntryGroupByOutputType[P]>
            : GetScalarType<T[P], BalanceEntryGroupByOutputType[P]>
        }
      >
    >


  export type BalanceEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    amount?: boolean
    currency?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean
  }, ExtArgs["result"]["balanceEntry"]>

  export type BalanceEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    amount?: boolean
    currency?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean
  }, ExtArgs["result"]["balanceEntry"]>

  export type BalanceEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    amount?: boolean
    currency?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean
  }, ExtArgs["result"]["balanceEntry"]>

  export type BalanceEntrySelectScalar = {
    id?: boolean
    date?: boolean
    time?: boolean
    amount?: boolean
    currency?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean
  }

  export type BalanceEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "time" | "amount" | "currency" | "comment" | "createdAt" | "updatedAt" | "section", ExtArgs["result"]["balanceEntry"]>

  export type $BalanceEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BalanceEntry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      time: string
      amount: number
      currency: string
      comment: string | null
      createdAt: Date
      updatedAt: Date
      section: $Enums.SalarySection
    }, ExtArgs["result"]["balanceEntry"]>
    composites: {}
  }

  type BalanceEntryGetPayload<S extends boolean | null | undefined | BalanceEntryDefaultArgs> = $Result.GetResult<Prisma.$BalanceEntryPayload, S>

  type BalanceEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BalanceEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BalanceEntryCountAggregateInputType | true
    }

  export interface BalanceEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BalanceEntry'], meta: { name: 'BalanceEntry' } }
    /**
     * Find zero or one BalanceEntry that matches the filter.
     * @param {BalanceEntryFindUniqueArgs} args - Arguments to find a BalanceEntry
     * @example
     * // Get one BalanceEntry
     * const balanceEntry = await prisma.balanceEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalanceEntryFindUniqueArgs>(args: SelectSubset<T, BalanceEntryFindUniqueArgs<ExtArgs>>): Prisma__BalanceEntryClient<$Result.GetResult<Prisma.$BalanceEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BalanceEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BalanceEntryFindUniqueOrThrowArgs} args - Arguments to find a BalanceEntry
     * @example
     * // Get one BalanceEntry
     * const balanceEntry = await prisma.balanceEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalanceEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, BalanceEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalanceEntryClient<$Result.GetResult<Prisma.$BalanceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BalanceEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceEntryFindFirstArgs} args - Arguments to find a BalanceEntry
     * @example
     * // Get one BalanceEntry
     * const balanceEntry = await prisma.balanceEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalanceEntryFindFirstArgs>(args?: SelectSubset<T, BalanceEntryFindFirstArgs<ExtArgs>>): Prisma__BalanceEntryClient<$Result.GetResult<Prisma.$BalanceEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BalanceEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceEntryFindFirstOrThrowArgs} args - Arguments to find a BalanceEntry
     * @example
     * // Get one BalanceEntry
     * const balanceEntry = await prisma.balanceEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalanceEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, BalanceEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalanceEntryClient<$Result.GetResult<Prisma.$BalanceEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BalanceEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BalanceEntries
     * const balanceEntries = await prisma.balanceEntry.findMany()
     * 
     * // Get first 10 BalanceEntries
     * const balanceEntries = await prisma.balanceEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balanceEntryWithIdOnly = await prisma.balanceEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalanceEntryFindManyArgs>(args?: SelectSubset<T, BalanceEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BalanceEntry.
     * @param {BalanceEntryCreateArgs} args - Arguments to create a BalanceEntry.
     * @example
     * // Create one BalanceEntry
     * const BalanceEntry = await prisma.balanceEntry.create({
     *   data: {
     *     // ... data to create a BalanceEntry
     *   }
     * })
     * 
     */
    create<T extends BalanceEntryCreateArgs>(args: SelectSubset<T, BalanceEntryCreateArgs<ExtArgs>>): Prisma__BalanceEntryClient<$Result.GetResult<Prisma.$BalanceEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BalanceEntries.
     * @param {BalanceEntryCreateManyArgs} args - Arguments to create many BalanceEntries.
     * @example
     * // Create many BalanceEntries
     * const balanceEntry = await prisma.balanceEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalanceEntryCreateManyArgs>(args?: SelectSubset<T, BalanceEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BalanceEntries and returns the data saved in the database.
     * @param {BalanceEntryCreateManyAndReturnArgs} args - Arguments to create many BalanceEntries.
     * @example
     * // Create many BalanceEntries
     * const balanceEntry = await prisma.balanceEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BalanceEntries and only return the `id`
     * const balanceEntryWithIdOnly = await prisma.balanceEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BalanceEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, BalanceEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BalanceEntry.
     * @param {BalanceEntryDeleteArgs} args - Arguments to delete one BalanceEntry.
     * @example
     * // Delete one BalanceEntry
     * const BalanceEntry = await prisma.balanceEntry.delete({
     *   where: {
     *     // ... filter to delete one BalanceEntry
     *   }
     * })
     * 
     */
    delete<T extends BalanceEntryDeleteArgs>(args: SelectSubset<T, BalanceEntryDeleteArgs<ExtArgs>>): Prisma__BalanceEntryClient<$Result.GetResult<Prisma.$BalanceEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BalanceEntry.
     * @param {BalanceEntryUpdateArgs} args - Arguments to update one BalanceEntry.
     * @example
     * // Update one BalanceEntry
     * const balanceEntry = await prisma.balanceEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalanceEntryUpdateArgs>(args: SelectSubset<T, BalanceEntryUpdateArgs<ExtArgs>>): Prisma__BalanceEntryClient<$Result.GetResult<Prisma.$BalanceEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BalanceEntries.
     * @param {BalanceEntryDeleteManyArgs} args - Arguments to filter BalanceEntries to delete.
     * @example
     * // Delete a few BalanceEntries
     * const { count } = await prisma.balanceEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalanceEntryDeleteManyArgs>(args?: SelectSubset<T, BalanceEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BalanceEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BalanceEntries
     * const balanceEntry = await prisma.balanceEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalanceEntryUpdateManyArgs>(args: SelectSubset<T, BalanceEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BalanceEntries and returns the data updated in the database.
     * @param {BalanceEntryUpdateManyAndReturnArgs} args - Arguments to update many BalanceEntries.
     * @example
     * // Update many BalanceEntries
     * const balanceEntry = await prisma.balanceEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BalanceEntries and only return the `id`
     * const balanceEntryWithIdOnly = await prisma.balanceEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BalanceEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, BalanceEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BalanceEntry.
     * @param {BalanceEntryUpsertArgs} args - Arguments to update or create a BalanceEntry.
     * @example
     * // Update or create a BalanceEntry
     * const balanceEntry = await prisma.balanceEntry.upsert({
     *   create: {
     *     // ... data to create a BalanceEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BalanceEntry we want to update
     *   }
     * })
     */
    upsert<T extends BalanceEntryUpsertArgs>(args: SelectSubset<T, BalanceEntryUpsertArgs<ExtArgs>>): Prisma__BalanceEntryClient<$Result.GetResult<Prisma.$BalanceEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BalanceEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceEntryCountArgs} args - Arguments to filter BalanceEntries to count.
     * @example
     * // Count the number of BalanceEntries
     * const count = await prisma.balanceEntry.count({
     *   where: {
     *     // ... the filter for the BalanceEntries we want to count
     *   }
     * })
    **/
    count<T extends BalanceEntryCountArgs>(
      args?: Subset<T, BalanceEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalanceEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BalanceEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalanceEntryAggregateArgs>(args: Subset<T, BalanceEntryAggregateArgs>): Prisma.PrismaPromise<GetBalanceEntryAggregateType<T>>

    /**
     * Group by BalanceEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalanceEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalanceEntryGroupByArgs['orderBy'] }
        : { orderBy?: BalanceEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalanceEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalanceEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BalanceEntry model
   */
  readonly fields: BalanceEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BalanceEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalanceEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BalanceEntry model
   */
  interface BalanceEntryFieldRefs {
    readonly id: FieldRef<"BalanceEntry", 'Int'>
    readonly date: FieldRef<"BalanceEntry", 'DateTime'>
    readonly time: FieldRef<"BalanceEntry", 'String'>
    readonly amount: FieldRef<"BalanceEntry", 'Float'>
    readonly currency: FieldRef<"BalanceEntry", 'String'>
    readonly comment: FieldRef<"BalanceEntry", 'String'>
    readonly createdAt: FieldRef<"BalanceEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"BalanceEntry", 'DateTime'>
    readonly section: FieldRef<"BalanceEntry", 'SalarySection'>
  }
    

  // Custom InputTypes
  /**
   * BalanceEntry findUnique
   */
  export type BalanceEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
    /**
     * Filter, which BalanceEntry to fetch.
     */
    where: BalanceEntryWhereUniqueInput
  }

  /**
   * BalanceEntry findUniqueOrThrow
   */
  export type BalanceEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
    /**
     * Filter, which BalanceEntry to fetch.
     */
    where: BalanceEntryWhereUniqueInput
  }

  /**
   * BalanceEntry findFirst
   */
  export type BalanceEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
    /**
     * Filter, which BalanceEntry to fetch.
     */
    where?: BalanceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceEntries to fetch.
     */
    orderBy?: BalanceEntryOrderByWithRelationInput | BalanceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BalanceEntries.
     */
    cursor?: BalanceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BalanceEntries.
     */
    distinct?: BalanceEntryScalarFieldEnum | BalanceEntryScalarFieldEnum[]
  }

  /**
   * BalanceEntry findFirstOrThrow
   */
  export type BalanceEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
    /**
     * Filter, which BalanceEntry to fetch.
     */
    where?: BalanceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceEntries to fetch.
     */
    orderBy?: BalanceEntryOrderByWithRelationInput | BalanceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BalanceEntries.
     */
    cursor?: BalanceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BalanceEntries.
     */
    distinct?: BalanceEntryScalarFieldEnum | BalanceEntryScalarFieldEnum[]
  }

  /**
   * BalanceEntry findMany
   */
  export type BalanceEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
    /**
     * Filter, which BalanceEntries to fetch.
     */
    where?: BalanceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceEntries to fetch.
     */
    orderBy?: BalanceEntryOrderByWithRelationInput | BalanceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BalanceEntries.
     */
    cursor?: BalanceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceEntries.
     */
    skip?: number
    distinct?: BalanceEntryScalarFieldEnum | BalanceEntryScalarFieldEnum[]
  }

  /**
   * BalanceEntry create
   */
  export type BalanceEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
    /**
     * The data needed to create a BalanceEntry.
     */
    data: XOR<BalanceEntryCreateInput, BalanceEntryUncheckedCreateInput>
  }

  /**
   * BalanceEntry createMany
   */
  export type BalanceEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BalanceEntries.
     */
    data: BalanceEntryCreateManyInput | BalanceEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BalanceEntry createManyAndReturn
   */
  export type BalanceEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
    /**
     * The data used to create many BalanceEntries.
     */
    data: BalanceEntryCreateManyInput | BalanceEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BalanceEntry update
   */
  export type BalanceEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
    /**
     * The data needed to update a BalanceEntry.
     */
    data: XOR<BalanceEntryUpdateInput, BalanceEntryUncheckedUpdateInput>
    /**
     * Choose, which BalanceEntry to update.
     */
    where: BalanceEntryWhereUniqueInput
  }

  /**
   * BalanceEntry updateMany
   */
  export type BalanceEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BalanceEntries.
     */
    data: XOR<BalanceEntryUpdateManyMutationInput, BalanceEntryUncheckedUpdateManyInput>
    /**
     * Filter which BalanceEntries to update
     */
    where?: BalanceEntryWhereInput
    /**
     * Limit how many BalanceEntries to update.
     */
    limit?: number
  }

  /**
   * BalanceEntry updateManyAndReturn
   */
  export type BalanceEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
    /**
     * The data used to update BalanceEntries.
     */
    data: XOR<BalanceEntryUpdateManyMutationInput, BalanceEntryUncheckedUpdateManyInput>
    /**
     * Filter which BalanceEntries to update
     */
    where?: BalanceEntryWhereInput
    /**
     * Limit how many BalanceEntries to update.
     */
    limit?: number
  }

  /**
   * BalanceEntry upsert
   */
  export type BalanceEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
    /**
     * The filter to search for the BalanceEntry to update in case it exists.
     */
    where: BalanceEntryWhereUniqueInput
    /**
     * In case the BalanceEntry found by the `where` argument doesn't exist, create a new BalanceEntry with this data.
     */
    create: XOR<BalanceEntryCreateInput, BalanceEntryUncheckedCreateInput>
    /**
     * In case the BalanceEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalanceEntryUpdateInput, BalanceEntryUncheckedUpdateInput>
  }

  /**
   * BalanceEntry delete
   */
  export type BalanceEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
    /**
     * Filter which BalanceEntry to delete.
     */
    where: BalanceEntryWhereUniqueInput
  }

  /**
   * BalanceEntry deleteMany
   */
  export type BalanceEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BalanceEntries to delete
     */
    where?: BalanceEntryWhereInput
    /**
     * Limit how many BalanceEntries to delete.
     */
    limit?: number
  }

  /**
   * BalanceEntry without action
   */
  export type BalanceEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceEntry
     */
    select?: BalanceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceEntry
     */
    omit?: BalanceEntryOmit<ExtArgs> | null
  }


  /**
   * Model BybitMatch
   */

  export type AggregateBybitMatch = {
    _count: BybitMatchCountAggregateOutputType | null
    _avg: BybitMatchAvgAggregateOutputType | null
    _sum: BybitMatchSumAggregateOutputType | null
    _min: BybitMatchMinAggregateOutputType | null
    _max: BybitMatchMaxAggregateOutputType | null
  }

  export type BybitMatchAvgAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    bybitTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
  }

  export type BybitMatchSumAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    bybitTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
  }

  export type BybitMatchMinAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    bybitTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BybitMatchMaxAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    bybitTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BybitMatchCountAggregateOutputType = {
    id: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BybitMatchAvgAggregateInputType = {
    id?: true
    idexTransactionId?: true
    bybitTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
  }

  export type BybitMatchSumAggregateInputType = {
    id?: true
    idexTransactionId?: true
    bybitTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
  }

  export type BybitMatchMinAggregateInputType = {
    id?: true
    idexTransactionId?: true
    bybitTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BybitMatchMaxAggregateInputType = {
    id?: true
    idexTransactionId?: true
    bybitTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BybitMatchCountAggregateInputType = {
    id?: true
    idexTransactionId?: true
    bybitTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BybitMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitMatch to aggregate.
     */
    where?: BybitMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitMatches to fetch.
     */
    orderBy?: BybitMatchOrderByWithRelationInput | BybitMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BybitMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BybitMatches
    **/
    _count?: true | BybitMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BybitMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BybitMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BybitMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BybitMatchMaxAggregateInputType
  }

  export type GetBybitMatchAggregateType<T extends BybitMatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBybitMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBybitMatch[P]>
      : GetScalarType<T[P], AggregateBybitMatch[P]>
  }




  export type BybitMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitMatchWhereInput
    orderBy?: BybitMatchOrderByWithAggregationInput | BybitMatchOrderByWithAggregationInput[]
    by: BybitMatchScalarFieldEnum[] | BybitMatchScalarFieldEnum
    having?: BybitMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BybitMatchCountAggregateInputType | true
    _avg?: BybitMatchAvgAggregateInputType
    _sum?: BybitMatchSumAggregateInputType
    _min?: BybitMatchMinAggregateInputType
    _max?: BybitMatchMaxAggregateInputType
  }

  export type BybitMatchGroupByOutputType = {
    id: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt: Date
    updatedAt: Date
    _count: BybitMatchCountAggregateOutputType | null
    _avg: BybitMatchAvgAggregateOutputType | null
    _sum: BybitMatchSumAggregateOutputType | null
    _min: BybitMatchMinAggregateOutputType | null
    _max: BybitMatchMaxAggregateOutputType | null
  }

  type GetBybitMatchGroupByPayload<T extends BybitMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BybitMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BybitMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BybitMatchGroupByOutputType[P]>
            : GetScalarType<T[P], BybitMatchGroupByOutputType[P]>
        }
      >
    >


  export type BybitMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idexTransactionId?: boolean
    bybitTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    BybitTransaction?: boolean | BybitTransactionDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitMatch"]>

  export type BybitMatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idexTransactionId?: boolean
    bybitTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    BybitTransaction?: boolean | BybitTransactionDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitMatch"]>

  export type BybitMatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idexTransactionId?: boolean
    bybitTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    BybitTransaction?: boolean | BybitTransactionDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitMatch"]>

  export type BybitMatchSelectScalar = {
    id?: boolean
    idexTransactionId?: boolean
    bybitTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BybitMatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idexTransactionId" | "bybitTransactionId" | "timeDifference" | "grossExpense" | "grossIncome" | "grossProfit" | "profitPercentage" | "createdAt" | "updatedAt", ExtArgs["result"]["bybitMatch"]>
  export type BybitMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitTransaction?: boolean | BybitTransactionDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
  }
  export type BybitMatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitTransaction?: boolean | BybitTransactionDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
  }
  export type BybitMatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitTransaction?: boolean | BybitTransactionDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
  }

  export type $BybitMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BybitMatch"
    objects: {
      BybitTransaction: Prisma.$BybitTransactionPayload<ExtArgs>
      IdexTransaction: Prisma.$IdexTransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idexTransactionId: number
      bybitTransactionId: number
      timeDifference: number
      grossExpense: number
      grossIncome: number
      grossProfit: number
      profitPercentage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bybitMatch"]>
    composites: {}
  }

  type BybitMatchGetPayload<S extends boolean | null | undefined | BybitMatchDefaultArgs> = $Result.GetResult<Prisma.$BybitMatchPayload, S>

  type BybitMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BybitMatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BybitMatchCountAggregateInputType | true
    }

  export interface BybitMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BybitMatch'], meta: { name: 'BybitMatch' } }
    /**
     * Find zero or one BybitMatch that matches the filter.
     * @param {BybitMatchFindUniqueArgs} args - Arguments to find a BybitMatch
     * @example
     * // Get one BybitMatch
     * const bybitMatch = await prisma.bybitMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BybitMatchFindUniqueArgs>(args: SelectSubset<T, BybitMatchFindUniqueArgs<ExtArgs>>): Prisma__BybitMatchClient<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BybitMatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BybitMatchFindUniqueOrThrowArgs} args - Arguments to find a BybitMatch
     * @example
     * // Get one BybitMatch
     * const bybitMatch = await prisma.bybitMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BybitMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, BybitMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BybitMatchClient<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitMatchFindFirstArgs} args - Arguments to find a BybitMatch
     * @example
     * // Get one BybitMatch
     * const bybitMatch = await prisma.bybitMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BybitMatchFindFirstArgs>(args?: SelectSubset<T, BybitMatchFindFirstArgs<ExtArgs>>): Prisma__BybitMatchClient<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitMatchFindFirstOrThrowArgs} args - Arguments to find a BybitMatch
     * @example
     * // Get one BybitMatch
     * const bybitMatch = await prisma.bybitMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BybitMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, BybitMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BybitMatchClient<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BybitMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BybitMatches
     * const bybitMatches = await prisma.bybitMatch.findMany()
     * 
     * // Get first 10 BybitMatches
     * const bybitMatches = await prisma.bybitMatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bybitMatchWithIdOnly = await prisma.bybitMatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BybitMatchFindManyArgs>(args?: SelectSubset<T, BybitMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BybitMatch.
     * @param {BybitMatchCreateArgs} args - Arguments to create a BybitMatch.
     * @example
     * // Create one BybitMatch
     * const BybitMatch = await prisma.bybitMatch.create({
     *   data: {
     *     // ... data to create a BybitMatch
     *   }
     * })
     * 
     */
    create<T extends BybitMatchCreateArgs>(args: SelectSubset<T, BybitMatchCreateArgs<ExtArgs>>): Prisma__BybitMatchClient<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BybitMatches.
     * @param {BybitMatchCreateManyArgs} args - Arguments to create many BybitMatches.
     * @example
     * // Create many BybitMatches
     * const bybitMatch = await prisma.bybitMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BybitMatchCreateManyArgs>(args?: SelectSubset<T, BybitMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BybitMatches and returns the data saved in the database.
     * @param {BybitMatchCreateManyAndReturnArgs} args - Arguments to create many BybitMatches.
     * @example
     * // Create many BybitMatches
     * const bybitMatch = await prisma.bybitMatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BybitMatches and only return the `id`
     * const bybitMatchWithIdOnly = await prisma.bybitMatch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BybitMatchCreateManyAndReturnArgs>(args?: SelectSubset<T, BybitMatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BybitMatch.
     * @param {BybitMatchDeleteArgs} args - Arguments to delete one BybitMatch.
     * @example
     * // Delete one BybitMatch
     * const BybitMatch = await prisma.bybitMatch.delete({
     *   where: {
     *     // ... filter to delete one BybitMatch
     *   }
     * })
     * 
     */
    delete<T extends BybitMatchDeleteArgs>(args: SelectSubset<T, BybitMatchDeleteArgs<ExtArgs>>): Prisma__BybitMatchClient<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BybitMatch.
     * @param {BybitMatchUpdateArgs} args - Arguments to update one BybitMatch.
     * @example
     * // Update one BybitMatch
     * const bybitMatch = await prisma.bybitMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BybitMatchUpdateArgs>(args: SelectSubset<T, BybitMatchUpdateArgs<ExtArgs>>): Prisma__BybitMatchClient<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BybitMatches.
     * @param {BybitMatchDeleteManyArgs} args - Arguments to filter BybitMatches to delete.
     * @example
     * // Delete a few BybitMatches
     * const { count } = await prisma.bybitMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BybitMatchDeleteManyArgs>(args?: SelectSubset<T, BybitMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BybitMatches
     * const bybitMatch = await prisma.bybitMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BybitMatchUpdateManyArgs>(args: SelectSubset<T, BybitMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitMatches and returns the data updated in the database.
     * @param {BybitMatchUpdateManyAndReturnArgs} args - Arguments to update many BybitMatches.
     * @example
     * // Update many BybitMatches
     * const bybitMatch = await prisma.bybitMatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BybitMatches and only return the `id`
     * const bybitMatchWithIdOnly = await prisma.bybitMatch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BybitMatchUpdateManyAndReturnArgs>(args: SelectSubset<T, BybitMatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BybitMatch.
     * @param {BybitMatchUpsertArgs} args - Arguments to update or create a BybitMatch.
     * @example
     * // Update or create a BybitMatch
     * const bybitMatch = await prisma.bybitMatch.upsert({
     *   create: {
     *     // ... data to create a BybitMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BybitMatch we want to update
     *   }
     * })
     */
    upsert<T extends BybitMatchUpsertArgs>(args: SelectSubset<T, BybitMatchUpsertArgs<ExtArgs>>): Prisma__BybitMatchClient<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BybitMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitMatchCountArgs} args - Arguments to filter BybitMatches to count.
     * @example
     * // Count the number of BybitMatches
     * const count = await prisma.bybitMatch.count({
     *   where: {
     *     // ... the filter for the BybitMatches we want to count
     *   }
     * })
    **/
    count<T extends BybitMatchCountArgs>(
      args?: Subset<T, BybitMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BybitMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BybitMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BybitMatchAggregateArgs>(args: Subset<T, BybitMatchAggregateArgs>): Prisma.PrismaPromise<GetBybitMatchAggregateType<T>>

    /**
     * Group by BybitMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BybitMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BybitMatchGroupByArgs['orderBy'] }
        : { orderBy?: BybitMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BybitMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBybitMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BybitMatch model
   */
  readonly fields: BybitMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BybitMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BybitMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BybitTransaction<T extends BybitTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BybitTransactionDefaultArgs<ExtArgs>>): Prisma__BybitTransactionClient<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    IdexTransaction<T extends IdexTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IdexTransactionDefaultArgs<ExtArgs>>): Prisma__IdexTransactionClient<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BybitMatch model
   */
  interface BybitMatchFieldRefs {
    readonly id: FieldRef<"BybitMatch", 'Int'>
    readonly idexTransactionId: FieldRef<"BybitMatch", 'Int'>
    readonly bybitTransactionId: FieldRef<"BybitMatch", 'Int'>
    readonly timeDifference: FieldRef<"BybitMatch", 'Int'>
    readonly grossExpense: FieldRef<"BybitMatch", 'Float'>
    readonly grossIncome: FieldRef<"BybitMatch", 'Float'>
    readonly grossProfit: FieldRef<"BybitMatch", 'Float'>
    readonly profitPercentage: FieldRef<"BybitMatch", 'Float'>
    readonly createdAt: FieldRef<"BybitMatch", 'DateTime'>
    readonly updatedAt: FieldRef<"BybitMatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BybitMatch findUnique
   */
  export type BybitMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
    /**
     * Filter, which BybitMatch to fetch.
     */
    where: BybitMatchWhereUniqueInput
  }

  /**
   * BybitMatch findUniqueOrThrow
   */
  export type BybitMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
    /**
     * Filter, which BybitMatch to fetch.
     */
    where: BybitMatchWhereUniqueInput
  }

  /**
   * BybitMatch findFirst
   */
  export type BybitMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
    /**
     * Filter, which BybitMatch to fetch.
     */
    where?: BybitMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitMatches to fetch.
     */
    orderBy?: BybitMatchOrderByWithRelationInput | BybitMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitMatches.
     */
    cursor?: BybitMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitMatches.
     */
    distinct?: BybitMatchScalarFieldEnum | BybitMatchScalarFieldEnum[]
  }

  /**
   * BybitMatch findFirstOrThrow
   */
  export type BybitMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
    /**
     * Filter, which BybitMatch to fetch.
     */
    where?: BybitMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitMatches to fetch.
     */
    orderBy?: BybitMatchOrderByWithRelationInput | BybitMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitMatches.
     */
    cursor?: BybitMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitMatches.
     */
    distinct?: BybitMatchScalarFieldEnum | BybitMatchScalarFieldEnum[]
  }

  /**
   * BybitMatch findMany
   */
  export type BybitMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
    /**
     * Filter, which BybitMatches to fetch.
     */
    where?: BybitMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitMatches to fetch.
     */
    orderBy?: BybitMatchOrderByWithRelationInput | BybitMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BybitMatches.
     */
    cursor?: BybitMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitMatches.
     */
    skip?: number
    distinct?: BybitMatchScalarFieldEnum | BybitMatchScalarFieldEnum[]
  }

  /**
   * BybitMatch create
   */
  export type BybitMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a BybitMatch.
     */
    data: XOR<BybitMatchCreateInput, BybitMatchUncheckedCreateInput>
  }

  /**
   * BybitMatch createMany
   */
  export type BybitMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BybitMatches.
     */
    data: BybitMatchCreateManyInput | BybitMatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BybitMatch createManyAndReturn
   */
  export type BybitMatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * The data used to create many BybitMatches.
     */
    data: BybitMatchCreateManyInput | BybitMatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BybitMatch update
   */
  export type BybitMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a BybitMatch.
     */
    data: XOR<BybitMatchUpdateInput, BybitMatchUncheckedUpdateInput>
    /**
     * Choose, which BybitMatch to update.
     */
    where: BybitMatchWhereUniqueInput
  }

  /**
   * BybitMatch updateMany
   */
  export type BybitMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BybitMatches.
     */
    data: XOR<BybitMatchUpdateManyMutationInput, BybitMatchUncheckedUpdateManyInput>
    /**
     * Filter which BybitMatches to update
     */
    where?: BybitMatchWhereInput
    /**
     * Limit how many BybitMatches to update.
     */
    limit?: number
  }

  /**
   * BybitMatch updateManyAndReturn
   */
  export type BybitMatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * The data used to update BybitMatches.
     */
    data: XOR<BybitMatchUpdateManyMutationInput, BybitMatchUncheckedUpdateManyInput>
    /**
     * Filter which BybitMatches to update
     */
    where?: BybitMatchWhereInput
    /**
     * Limit how many BybitMatches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BybitMatch upsert
   */
  export type BybitMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the BybitMatch to update in case it exists.
     */
    where: BybitMatchWhereUniqueInput
    /**
     * In case the BybitMatch found by the `where` argument doesn't exist, create a new BybitMatch with this data.
     */
    create: XOR<BybitMatchCreateInput, BybitMatchUncheckedCreateInput>
    /**
     * In case the BybitMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BybitMatchUpdateInput, BybitMatchUncheckedUpdateInput>
  }

  /**
   * BybitMatch delete
   */
  export type BybitMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
    /**
     * Filter which BybitMatch to delete.
     */
    where: BybitMatchWhereUniqueInput
  }

  /**
   * BybitMatch deleteMany
   */
  export type BybitMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitMatches to delete
     */
    where?: BybitMatchWhereInput
    /**
     * Limit how many BybitMatches to delete.
     */
    limit?: number
  }

  /**
   * BybitMatch without action
   */
  export type BybitMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
  }


  /**
   * Model BybitOrderInfo
   */

  export type AggregateBybitOrderInfo = {
    _count: BybitOrderInfoCountAggregateOutputType | null
    _avg: BybitOrderInfoAvgAggregateOutputType | null
    _sum: BybitOrderInfoSumAggregateOutputType | null
    _min: BybitOrderInfoMinAggregateOutputType | null
    _max: BybitOrderInfoMaxAggregateOutputType | null
  }

  export type BybitOrderInfoAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    totalPrice: number | null
    unitPrice: number | null
    bybitCabinetId: number | null
  }

  export type BybitOrderInfoSumAggregateOutputType = {
    id: number | null
    amount: number | null
    totalPrice: number | null
    unitPrice: number | null
    bybitCabinetId: number | null
  }

  export type BybitOrderInfoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    orderNo: string | null
    dateTime: Date | null
    status: string | null
    type: string | null
    amount: number | null
    totalPrice: number | null
    processed: boolean | null
    unitPrice: number | null
    bybitCabinetId: number | null
  }

  export type BybitOrderInfoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    orderNo: string | null
    dateTime: Date | null
    status: string | null
    type: string | null
    amount: number | null
    totalPrice: number | null
    processed: boolean | null
    unitPrice: number | null
    bybitCabinetId: number | null
  }

  export type BybitOrderInfoCountAggregateOutputType = {
    id: number
    phoneNumbers: number
    createdAt: number
    updatedAt: number
    orderNo: number
    dateTime: number
    originalData: number
    status: number
    type: number
    amount: number
    totalPrice: number
    processed: number
    unitPrice: number
    bybitCabinetId: number
    _all: number
  }


  export type BybitOrderInfoAvgAggregateInputType = {
    id?: true
    amount?: true
    totalPrice?: true
    unitPrice?: true
    bybitCabinetId?: true
  }

  export type BybitOrderInfoSumAggregateInputType = {
    id?: true
    amount?: true
    totalPrice?: true
    unitPrice?: true
    bybitCabinetId?: true
  }

  export type BybitOrderInfoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderNo?: true
    dateTime?: true
    status?: true
    type?: true
    amount?: true
    totalPrice?: true
    processed?: true
    unitPrice?: true
    bybitCabinetId?: true
  }

  export type BybitOrderInfoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderNo?: true
    dateTime?: true
    status?: true
    type?: true
    amount?: true
    totalPrice?: true
    processed?: true
    unitPrice?: true
    bybitCabinetId?: true
  }

  export type BybitOrderInfoCountAggregateInputType = {
    id?: true
    phoneNumbers?: true
    createdAt?: true
    updatedAt?: true
    orderNo?: true
    dateTime?: true
    originalData?: true
    status?: true
    type?: true
    amount?: true
    totalPrice?: true
    processed?: true
    unitPrice?: true
    bybitCabinetId?: true
    _all?: true
  }

  export type BybitOrderInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitOrderInfo to aggregate.
     */
    where?: BybitOrderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitOrderInfos to fetch.
     */
    orderBy?: BybitOrderInfoOrderByWithRelationInput | BybitOrderInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BybitOrderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitOrderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitOrderInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BybitOrderInfos
    **/
    _count?: true | BybitOrderInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BybitOrderInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BybitOrderInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BybitOrderInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BybitOrderInfoMaxAggregateInputType
  }

  export type GetBybitOrderInfoAggregateType<T extends BybitOrderInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateBybitOrderInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBybitOrderInfo[P]>
      : GetScalarType<T[P], AggregateBybitOrderInfo[P]>
  }




  export type BybitOrderInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitOrderInfoWhereInput
    orderBy?: BybitOrderInfoOrderByWithAggregationInput | BybitOrderInfoOrderByWithAggregationInput[]
    by: BybitOrderInfoScalarFieldEnum[] | BybitOrderInfoScalarFieldEnum
    having?: BybitOrderInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BybitOrderInfoCountAggregateInputType | true
    _avg?: BybitOrderInfoAvgAggregateInputType
    _sum?: BybitOrderInfoSumAggregateInputType
    _min?: BybitOrderInfoMinAggregateInputType
    _max?: BybitOrderInfoMaxAggregateInputType
  }

  export type BybitOrderInfoGroupByOutputType = {
    id: number
    phoneNumbers: string[]
    createdAt: Date
    updatedAt: Date
    orderNo: string
    dateTime: Date
    originalData: JsonValue | null
    status: string
    type: string
    amount: number
    totalPrice: number
    processed: boolean
    unitPrice: number
    bybitCabinetId: number
    _count: BybitOrderInfoCountAggregateOutputType | null
    _avg: BybitOrderInfoAvgAggregateOutputType | null
    _sum: BybitOrderInfoSumAggregateOutputType | null
    _min: BybitOrderInfoMinAggregateOutputType | null
    _max: BybitOrderInfoMaxAggregateOutputType | null
  }

  type GetBybitOrderInfoGroupByPayload<T extends BybitOrderInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BybitOrderInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BybitOrderInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BybitOrderInfoGroupByOutputType[P]>
            : GetScalarType<T[P], BybitOrderInfoGroupByOutputType[P]>
        }
      >
    >


  export type BybitOrderInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumbers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderNo?: boolean
    dateTime?: boolean
    originalData?: boolean
    status?: boolean
    type?: boolean
    amount?: boolean
    totalPrice?: boolean
    processed?: boolean
    unitPrice?: boolean
    bybitCabinetId?: boolean
    cabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitOrderInfo"]>

  export type BybitOrderInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumbers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderNo?: boolean
    dateTime?: boolean
    originalData?: boolean
    status?: boolean
    type?: boolean
    amount?: boolean
    totalPrice?: boolean
    processed?: boolean
    unitPrice?: boolean
    bybitCabinetId?: boolean
    cabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitOrderInfo"]>

  export type BybitOrderInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumbers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderNo?: boolean
    dateTime?: boolean
    originalData?: boolean
    status?: boolean
    type?: boolean
    amount?: boolean
    totalPrice?: boolean
    processed?: boolean
    unitPrice?: boolean
    bybitCabinetId?: boolean
    cabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitOrderInfo"]>

  export type BybitOrderInfoSelectScalar = {
    id?: boolean
    phoneNumbers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderNo?: boolean
    dateTime?: boolean
    originalData?: boolean
    status?: boolean
    type?: boolean
    amount?: boolean
    totalPrice?: boolean
    processed?: boolean
    unitPrice?: boolean
    bybitCabinetId?: boolean
  }

  export type BybitOrderInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phoneNumbers" | "createdAt" | "updatedAt" | "orderNo" | "dateTime" | "originalData" | "status" | "type" | "amount" | "totalPrice" | "processed" | "unitPrice" | "bybitCabinetId", ExtArgs["result"]["bybitOrderInfo"]>
  export type BybitOrderInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
  }
  export type BybitOrderInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
  }
  export type BybitOrderInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
  }

  export type $BybitOrderInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BybitOrderInfo"
    objects: {
      cabinet: Prisma.$BybitCabinetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      phoneNumbers: string[]
      createdAt: Date
      updatedAt: Date
      orderNo: string
      dateTime: Date
      originalData: Prisma.JsonValue | null
      status: string
      type: string
      amount: number
      totalPrice: number
      processed: boolean
      unitPrice: number
      bybitCabinetId: number
    }, ExtArgs["result"]["bybitOrderInfo"]>
    composites: {}
  }

  type BybitOrderInfoGetPayload<S extends boolean | null | undefined | BybitOrderInfoDefaultArgs> = $Result.GetResult<Prisma.$BybitOrderInfoPayload, S>

  type BybitOrderInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BybitOrderInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BybitOrderInfoCountAggregateInputType | true
    }

  export interface BybitOrderInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BybitOrderInfo'], meta: { name: 'BybitOrderInfo' } }
    /**
     * Find zero or one BybitOrderInfo that matches the filter.
     * @param {BybitOrderInfoFindUniqueArgs} args - Arguments to find a BybitOrderInfo
     * @example
     * // Get one BybitOrderInfo
     * const bybitOrderInfo = await prisma.bybitOrderInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BybitOrderInfoFindUniqueArgs>(args: SelectSubset<T, BybitOrderInfoFindUniqueArgs<ExtArgs>>): Prisma__BybitOrderInfoClient<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BybitOrderInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BybitOrderInfoFindUniqueOrThrowArgs} args - Arguments to find a BybitOrderInfo
     * @example
     * // Get one BybitOrderInfo
     * const bybitOrderInfo = await prisma.bybitOrderInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BybitOrderInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, BybitOrderInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BybitOrderInfoClient<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitOrderInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitOrderInfoFindFirstArgs} args - Arguments to find a BybitOrderInfo
     * @example
     * // Get one BybitOrderInfo
     * const bybitOrderInfo = await prisma.bybitOrderInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BybitOrderInfoFindFirstArgs>(args?: SelectSubset<T, BybitOrderInfoFindFirstArgs<ExtArgs>>): Prisma__BybitOrderInfoClient<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitOrderInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitOrderInfoFindFirstOrThrowArgs} args - Arguments to find a BybitOrderInfo
     * @example
     * // Get one BybitOrderInfo
     * const bybitOrderInfo = await prisma.bybitOrderInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BybitOrderInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, BybitOrderInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BybitOrderInfoClient<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BybitOrderInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitOrderInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BybitOrderInfos
     * const bybitOrderInfos = await prisma.bybitOrderInfo.findMany()
     * 
     * // Get first 10 BybitOrderInfos
     * const bybitOrderInfos = await prisma.bybitOrderInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bybitOrderInfoWithIdOnly = await prisma.bybitOrderInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BybitOrderInfoFindManyArgs>(args?: SelectSubset<T, BybitOrderInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BybitOrderInfo.
     * @param {BybitOrderInfoCreateArgs} args - Arguments to create a BybitOrderInfo.
     * @example
     * // Create one BybitOrderInfo
     * const BybitOrderInfo = await prisma.bybitOrderInfo.create({
     *   data: {
     *     // ... data to create a BybitOrderInfo
     *   }
     * })
     * 
     */
    create<T extends BybitOrderInfoCreateArgs>(args: SelectSubset<T, BybitOrderInfoCreateArgs<ExtArgs>>): Prisma__BybitOrderInfoClient<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BybitOrderInfos.
     * @param {BybitOrderInfoCreateManyArgs} args - Arguments to create many BybitOrderInfos.
     * @example
     * // Create many BybitOrderInfos
     * const bybitOrderInfo = await prisma.bybitOrderInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BybitOrderInfoCreateManyArgs>(args?: SelectSubset<T, BybitOrderInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BybitOrderInfos and returns the data saved in the database.
     * @param {BybitOrderInfoCreateManyAndReturnArgs} args - Arguments to create many BybitOrderInfos.
     * @example
     * // Create many BybitOrderInfos
     * const bybitOrderInfo = await prisma.bybitOrderInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BybitOrderInfos and only return the `id`
     * const bybitOrderInfoWithIdOnly = await prisma.bybitOrderInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BybitOrderInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, BybitOrderInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BybitOrderInfo.
     * @param {BybitOrderInfoDeleteArgs} args - Arguments to delete one BybitOrderInfo.
     * @example
     * // Delete one BybitOrderInfo
     * const BybitOrderInfo = await prisma.bybitOrderInfo.delete({
     *   where: {
     *     // ... filter to delete one BybitOrderInfo
     *   }
     * })
     * 
     */
    delete<T extends BybitOrderInfoDeleteArgs>(args: SelectSubset<T, BybitOrderInfoDeleteArgs<ExtArgs>>): Prisma__BybitOrderInfoClient<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BybitOrderInfo.
     * @param {BybitOrderInfoUpdateArgs} args - Arguments to update one BybitOrderInfo.
     * @example
     * // Update one BybitOrderInfo
     * const bybitOrderInfo = await prisma.bybitOrderInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BybitOrderInfoUpdateArgs>(args: SelectSubset<T, BybitOrderInfoUpdateArgs<ExtArgs>>): Prisma__BybitOrderInfoClient<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BybitOrderInfos.
     * @param {BybitOrderInfoDeleteManyArgs} args - Arguments to filter BybitOrderInfos to delete.
     * @example
     * // Delete a few BybitOrderInfos
     * const { count } = await prisma.bybitOrderInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BybitOrderInfoDeleteManyArgs>(args?: SelectSubset<T, BybitOrderInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitOrderInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitOrderInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BybitOrderInfos
     * const bybitOrderInfo = await prisma.bybitOrderInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BybitOrderInfoUpdateManyArgs>(args: SelectSubset<T, BybitOrderInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitOrderInfos and returns the data updated in the database.
     * @param {BybitOrderInfoUpdateManyAndReturnArgs} args - Arguments to update many BybitOrderInfos.
     * @example
     * // Update many BybitOrderInfos
     * const bybitOrderInfo = await prisma.bybitOrderInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BybitOrderInfos and only return the `id`
     * const bybitOrderInfoWithIdOnly = await prisma.bybitOrderInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BybitOrderInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, BybitOrderInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BybitOrderInfo.
     * @param {BybitOrderInfoUpsertArgs} args - Arguments to update or create a BybitOrderInfo.
     * @example
     * // Update or create a BybitOrderInfo
     * const bybitOrderInfo = await prisma.bybitOrderInfo.upsert({
     *   create: {
     *     // ... data to create a BybitOrderInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BybitOrderInfo we want to update
     *   }
     * })
     */
    upsert<T extends BybitOrderInfoUpsertArgs>(args: SelectSubset<T, BybitOrderInfoUpsertArgs<ExtArgs>>): Prisma__BybitOrderInfoClient<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BybitOrderInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitOrderInfoCountArgs} args - Arguments to filter BybitOrderInfos to count.
     * @example
     * // Count the number of BybitOrderInfos
     * const count = await prisma.bybitOrderInfo.count({
     *   where: {
     *     // ... the filter for the BybitOrderInfos we want to count
     *   }
     * })
    **/
    count<T extends BybitOrderInfoCountArgs>(
      args?: Subset<T, BybitOrderInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BybitOrderInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BybitOrderInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitOrderInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BybitOrderInfoAggregateArgs>(args: Subset<T, BybitOrderInfoAggregateArgs>): Prisma.PrismaPromise<GetBybitOrderInfoAggregateType<T>>

    /**
     * Group by BybitOrderInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitOrderInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BybitOrderInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BybitOrderInfoGroupByArgs['orderBy'] }
        : { orderBy?: BybitOrderInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BybitOrderInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBybitOrderInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BybitOrderInfo model
   */
  readonly fields: BybitOrderInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BybitOrderInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BybitOrderInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends BybitCabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BybitCabinetDefaultArgs<ExtArgs>>): Prisma__BybitCabinetClient<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BybitOrderInfo model
   */
  interface BybitOrderInfoFieldRefs {
    readonly id: FieldRef<"BybitOrderInfo", 'Int'>
    readonly phoneNumbers: FieldRef<"BybitOrderInfo", 'String[]'>
    readonly createdAt: FieldRef<"BybitOrderInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"BybitOrderInfo", 'DateTime'>
    readonly orderNo: FieldRef<"BybitOrderInfo", 'String'>
    readonly dateTime: FieldRef<"BybitOrderInfo", 'DateTime'>
    readonly originalData: FieldRef<"BybitOrderInfo", 'Json'>
    readonly status: FieldRef<"BybitOrderInfo", 'String'>
    readonly type: FieldRef<"BybitOrderInfo", 'String'>
    readonly amount: FieldRef<"BybitOrderInfo", 'Int'>
    readonly totalPrice: FieldRef<"BybitOrderInfo", 'Float'>
    readonly processed: FieldRef<"BybitOrderInfo", 'Boolean'>
    readonly unitPrice: FieldRef<"BybitOrderInfo", 'Float'>
    readonly bybitCabinetId: FieldRef<"BybitOrderInfo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BybitOrderInfo findUnique
   */
  export type BybitOrderInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoInclude<ExtArgs> | null
    /**
     * Filter, which BybitOrderInfo to fetch.
     */
    where: BybitOrderInfoWhereUniqueInput
  }

  /**
   * BybitOrderInfo findUniqueOrThrow
   */
  export type BybitOrderInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoInclude<ExtArgs> | null
    /**
     * Filter, which BybitOrderInfo to fetch.
     */
    where: BybitOrderInfoWhereUniqueInput
  }

  /**
   * BybitOrderInfo findFirst
   */
  export type BybitOrderInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoInclude<ExtArgs> | null
    /**
     * Filter, which BybitOrderInfo to fetch.
     */
    where?: BybitOrderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitOrderInfos to fetch.
     */
    orderBy?: BybitOrderInfoOrderByWithRelationInput | BybitOrderInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitOrderInfos.
     */
    cursor?: BybitOrderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitOrderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitOrderInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitOrderInfos.
     */
    distinct?: BybitOrderInfoScalarFieldEnum | BybitOrderInfoScalarFieldEnum[]
  }

  /**
   * BybitOrderInfo findFirstOrThrow
   */
  export type BybitOrderInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoInclude<ExtArgs> | null
    /**
     * Filter, which BybitOrderInfo to fetch.
     */
    where?: BybitOrderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitOrderInfos to fetch.
     */
    orderBy?: BybitOrderInfoOrderByWithRelationInput | BybitOrderInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitOrderInfos.
     */
    cursor?: BybitOrderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitOrderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitOrderInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitOrderInfos.
     */
    distinct?: BybitOrderInfoScalarFieldEnum | BybitOrderInfoScalarFieldEnum[]
  }

  /**
   * BybitOrderInfo findMany
   */
  export type BybitOrderInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoInclude<ExtArgs> | null
    /**
     * Filter, which BybitOrderInfos to fetch.
     */
    where?: BybitOrderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitOrderInfos to fetch.
     */
    orderBy?: BybitOrderInfoOrderByWithRelationInput | BybitOrderInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BybitOrderInfos.
     */
    cursor?: BybitOrderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitOrderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitOrderInfos.
     */
    skip?: number
    distinct?: BybitOrderInfoScalarFieldEnum | BybitOrderInfoScalarFieldEnum[]
  }

  /**
   * BybitOrderInfo create
   */
  export type BybitOrderInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a BybitOrderInfo.
     */
    data: XOR<BybitOrderInfoCreateInput, BybitOrderInfoUncheckedCreateInput>
  }

  /**
   * BybitOrderInfo createMany
   */
  export type BybitOrderInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BybitOrderInfos.
     */
    data: BybitOrderInfoCreateManyInput | BybitOrderInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BybitOrderInfo createManyAndReturn
   */
  export type BybitOrderInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * The data used to create many BybitOrderInfos.
     */
    data: BybitOrderInfoCreateManyInput | BybitOrderInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BybitOrderInfo update
   */
  export type BybitOrderInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a BybitOrderInfo.
     */
    data: XOR<BybitOrderInfoUpdateInput, BybitOrderInfoUncheckedUpdateInput>
    /**
     * Choose, which BybitOrderInfo to update.
     */
    where: BybitOrderInfoWhereUniqueInput
  }

  /**
   * BybitOrderInfo updateMany
   */
  export type BybitOrderInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BybitOrderInfos.
     */
    data: XOR<BybitOrderInfoUpdateManyMutationInput, BybitOrderInfoUncheckedUpdateManyInput>
    /**
     * Filter which BybitOrderInfos to update
     */
    where?: BybitOrderInfoWhereInput
    /**
     * Limit how many BybitOrderInfos to update.
     */
    limit?: number
  }

  /**
   * BybitOrderInfo updateManyAndReturn
   */
  export type BybitOrderInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * The data used to update BybitOrderInfos.
     */
    data: XOR<BybitOrderInfoUpdateManyMutationInput, BybitOrderInfoUncheckedUpdateManyInput>
    /**
     * Filter which BybitOrderInfos to update
     */
    where?: BybitOrderInfoWhereInput
    /**
     * Limit how many BybitOrderInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BybitOrderInfo upsert
   */
  export type BybitOrderInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the BybitOrderInfo to update in case it exists.
     */
    where: BybitOrderInfoWhereUniqueInput
    /**
     * In case the BybitOrderInfo found by the `where` argument doesn't exist, create a new BybitOrderInfo with this data.
     */
    create: XOR<BybitOrderInfoCreateInput, BybitOrderInfoUncheckedCreateInput>
    /**
     * In case the BybitOrderInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BybitOrderInfoUpdateInput, BybitOrderInfoUncheckedUpdateInput>
  }

  /**
   * BybitOrderInfo delete
   */
  export type BybitOrderInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoInclude<ExtArgs> | null
    /**
     * Filter which BybitOrderInfo to delete.
     */
    where: BybitOrderInfoWhereUniqueInput
  }

  /**
   * BybitOrderInfo deleteMany
   */
  export type BybitOrderInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitOrderInfos to delete
     */
    where?: BybitOrderInfoWhereInput
    /**
     * Limit how many BybitOrderInfos to delete.
     */
    limit?: number
  }

  /**
   * BybitOrderInfo without action
   */
  export type BybitOrderInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoInclude<ExtArgs> | null
  }


  /**
   * Model BybitTransaction
   */

  export type AggregateBybitTransaction = {
    _count: BybitTransactionCountAggregateOutputType | null
    _avg: BybitTransactionAvgAggregateOutputType | null
    _sum: BybitTransactionSumAggregateOutputType | null
    _min: BybitTransactionMinAggregateOutputType | null
    _max: BybitTransactionMaxAggregateOutputType | null
  }

  export type BybitTransactionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    totalPrice: number | null
    unitPrice: number | null
  }

  export type BybitTransactionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    totalPrice: number | null
    unitPrice: number | null
  }

  export type BybitTransactionMinAggregateOutputType = {
    id: number | null
    orderNo: string | null
    counterparty: string | null
    status: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    amount: number | null
    asset: string | null
    dateTime: Date | null
    totalPrice: number | null
    type: string | null
    unitPrice: number | null
    processed: boolean | null
    lastAttemptError: string | null
  }

  export type BybitTransactionMaxAggregateOutputType = {
    id: number | null
    orderNo: string | null
    counterparty: string | null
    status: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    amount: number | null
    asset: string | null
    dateTime: Date | null
    totalPrice: number | null
    type: string | null
    unitPrice: number | null
    processed: boolean | null
    lastAttemptError: string | null
  }

  export type BybitTransactionCountAggregateOutputType = {
    id: number
    orderNo: number
    counterparty: number
    status: number
    userId: number
    createdAt: number
    updatedAt: number
    amount: number
    asset: number
    dateTime: number
    originalData: number
    totalPrice: number
    type: number
    unitPrice: number
    processed: number
    extractedPhones: number
    lastAttemptError: number
    _all: number
  }


  export type BybitTransactionAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    totalPrice?: true
    unitPrice?: true
  }

  export type BybitTransactionSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    totalPrice?: true
    unitPrice?: true
  }

  export type BybitTransactionMinAggregateInputType = {
    id?: true
    orderNo?: true
    counterparty?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    amount?: true
    asset?: true
    dateTime?: true
    totalPrice?: true
    type?: true
    unitPrice?: true
    processed?: true
    lastAttemptError?: true
  }

  export type BybitTransactionMaxAggregateInputType = {
    id?: true
    orderNo?: true
    counterparty?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    amount?: true
    asset?: true
    dateTime?: true
    totalPrice?: true
    type?: true
    unitPrice?: true
    processed?: true
    lastAttemptError?: true
  }

  export type BybitTransactionCountAggregateInputType = {
    id?: true
    orderNo?: true
    counterparty?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    amount?: true
    asset?: true
    dateTime?: true
    originalData?: true
    totalPrice?: true
    type?: true
    unitPrice?: true
    processed?: true
    extractedPhones?: true
    lastAttemptError?: true
    _all?: true
  }

  export type BybitTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitTransaction to aggregate.
     */
    where?: BybitTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitTransactions to fetch.
     */
    orderBy?: BybitTransactionOrderByWithRelationInput | BybitTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BybitTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BybitTransactions
    **/
    _count?: true | BybitTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BybitTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BybitTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BybitTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BybitTransactionMaxAggregateInputType
  }

  export type GetBybitTransactionAggregateType<T extends BybitTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateBybitTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBybitTransaction[P]>
      : GetScalarType<T[P], AggregateBybitTransaction[P]>
  }




  export type BybitTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitTransactionWhereInput
    orderBy?: BybitTransactionOrderByWithAggregationInput | BybitTransactionOrderByWithAggregationInput[]
    by: BybitTransactionScalarFieldEnum[] | BybitTransactionScalarFieldEnum
    having?: BybitTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BybitTransactionCountAggregateInputType | true
    _avg?: BybitTransactionAvgAggregateInputType
    _sum?: BybitTransactionSumAggregateInputType
    _min?: BybitTransactionMinAggregateInputType
    _max?: BybitTransactionMaxAggregateInputType
  }

  export type BybitTransactionGroupByOutputType = {
    id: number
    orderNo: string
    counterparty: string | null
    status: string
    userId: number
    createdAt: Date
    updatedAt: Date
    amount: number
    asset: string
    dateTime: Date
    originalData: JsonValue | null
    totalPrice: number
    type: string
    unitPrice: number
    processed: boolean
    extractedPhones: string[]
    lastAttemptError: string | null
    _count: BybitTransactionCountAggregateOutputType | null
    _avg: BybitTransactionAvgAggregateOutputType | null
    _sum: BybitTransactionSumAggregateOutputType | null
    _min: BybitTransactionMinAggregateOutputType | null
    _max: BybitTransactionMaxAggregateOutputType | null
  }

  type GetBybitTransactionGroupByPayload<T extends BybitTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BybitTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BybitTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BybitTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], BybitTransactionGroupByOutputType[P]>
        }
      >
    >


  export type BybitTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    counterparty?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    amount?: boolean
    asset?: boolean
    dateTime?: boolean
    originalData?: boolean
    totalPrice?: boolean
    type?: boolean
    unitPrice?: boolean
    processed?: boolean
    extractedPhones?: boolean
    lastAttemptError?: boolean
    bybitMatch?: boolean | BybitTransaction$bybitMatchArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | BybitTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitTransaction"]>

  export type BybitTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    counterparty?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    amount?: boolean
    asset?: boolean
    dateTime?: boolean
    originalData?: boolean
    totalPrice?: boolean
    type?: boolean
    unitPrice?: boolean
    processed?: boolean
    extractedPhones?: boolean
    lastAttemptError?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitTransaction"]>

  export type BybitTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    counterparty?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    amount?: boolean
    asset?: boolean
    dateTime?: boolean
    originalData?: boolean
    totalPrice?: boolean
    type?: boolean
    unitPrice?: boolean
    processed?: boolean
    extractedPhones?: boolean
    lastAttemptError?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitTransaction"]>

  export type BybitTransactionSelectScalar = {
    id?: boolean
    orderNo?: boolean
    counterparty?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    amount?: boolean
    asset?: boolean
    dateTime?: boolean
    originalData?: boolean
    totalPrice?: boolean
    type?: boolean
    unitPrice?: boolean
    processed?: boolean
    extractedPhones?: boolean
    lastAttemptError?: boolean
  }

  export type BybitTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNo" | "counterparty" | "status" | "userId" | "createdAt" | "updatedAt" | "amount" | "asset" | "dateTime" | "originalData" | "totalPrice" | "type" | "unitPrice" | "processed" | "extractedPhones" | "lastAttemptError", ExtArgs["result"]["bybitTransaction"]>
  export type BybitTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bybitMatch?: boolean | BybitTransaction$bybitMatchArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | BybitTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BybitTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BybitTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BybitTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BybitTransaction"
    objects: {
      bybitMatch: Prisma.$BybitMatchPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderNo: string
      counterparty: string | null
      status: string
      userId: number
      createdAt: Date
      updatedAt: Date
      amount: number
      asset: string
      dateTime: Date
      originalData: Prisma.JsonValue | null
      totalPrice: number
      type: string
      unitPrice: number
      processed: boolean
      extractedPhones: string[]
      lastAttemptError: string | null
    }, ExtArgs["result"]["bybitTransaction"]>
    composites: {}
  }

  type BybitTransactionGetPayload<S extends boolean | null | undefined | BybitTransactionDefaultArgs> = $Result.GetResult<Prisma.$BybitTransactionPayload, S>

  type BybitTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BybitTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BybitTransactionCountAggregateInputType | true
    }

  export interface BybitTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BybitTransaction'], meta: { name: 'BybitTransaction' } }
    /**
     * Find zero or one BybitTransaction that matches the filter.
     * @param {BybitTransactionFindUniqueArgs} args - Arguments to find a BybitTransaction
     * @example
     * // Get one BybitTransaction
     * const bybitTransaction = await prisma.bybitTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BybitTransactionFindUniqueArgs>(args: SelectSubset<T, BybitTransactionFindUniqueArgs<ExtArgs>>): Prisma__BybitTransactionClient<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BybitTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BybitTransactionFindUniqueOrThrowArgs} args - Arguments to find a BybitTransaction
     * @example
     * // Get one BybitTransaction
     * const bybitTransaction = await prisma.bybitTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BybitTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, BybitTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BybitTransactionClient<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionFindFirstArgs} args - Arguments to find a BybitTransaction
     * @example
     * // Get one BybitTransaction
     * const bybitTransaction = await prisma.bybitTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BybitTransactionFindFirstArgs>(args?: SelectSubset<T, BybitTransactionFindFirstArgs<ExtArgs>>): Prisma__BybitTransactionClient<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionFindFirstOrThrowArgs} args - Arguments to find a BybitTransaction
     * @example
     * // Get one BybitTransaction
     * const bybitTransaction = await prisma.bybitTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BybitTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, BybitTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BybitTransactionClient<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BybitTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BybitTransactions
     * const bybitTransactions = await prisma.bybitTransaction.findMany()
     * 
     * // Get first 10 BybitTransactions
     * const bybitTransactions = await prisma.bybitTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bybitTransactionWithIdOnly = await prisma.bybitTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BybitTransactionFindManyArgs>(args?: SelectSubset<T, BybitTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BybitTransaction.
     * @param {BybitTransactionCreateArgs} args - Arguments to create a BybitTransaction.
     * @example
     * // Create one BybitTransaction
     * const BybitTransaction = await prisma.bybitTransaction.create({
     *   data: {
     *     // ... data to create a BybitTransaction
     *   }
     * })
     * 
     */
    create<T extends BybitTransactionCreateArgs>(args: SelectSubset<T, BybitTransactionCreateArgs<ExtArgs>>): Prisma__BybitTransactionClient<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BybitTransactions.
     * @param {BybitTransactionCreateManyArgs} args - Arguments to create many BybitTransactions.
     * @example
     * // Create many BybitTransactions
     * const bybitTransaction = await prisma.bybitTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BybitTransactionCreateManyArgs>(args?: SelectSubset<T, BybitTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BybitTransactions and returns the data saved in the database.
     * @param {BybitTransactionCreateManyAndReturnArgs} args - Arguments to create many BybitTransactions.
     * @example
     * // Create many BybitTransactions
     * const bybitTransaction = await prisma.bybitTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BybitTransactions and only return the `id`
     * const bybitTransactionWithIdOnly = await prisma.bybitTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BybitTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, BybitTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BybitTransaction.
     * @param {BybitTransactionDeleteArgs} args - Arguments to delete one BybitTransaction.
     * @example
     * // Delete one BybitTransaction
     * const BybitTransaction = await prisma.bybitTransaction.delete({
     *   where: {
     *     // ... filter to delete one BybitTransaction
     *   }
     * })
     * 
     */
    delete<T extends BybitTransactionDeleteArgs>(args: SelectSubset<T, BybitTransactionDeleteArgs<ExtArgs>>): Prisma__BybitTransactionClient<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BybitTransaction.
     * @param {BybitTransactionUpdateArgs} args - Arguments to update one BybitTransaction.
     * @example
     * // Update one BybitTransaction
     * const bybitTransaction = await prisma.bybitTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BybitTransactionUpdateArgs>(args: SelectSubset<T, BybitTransactionUpdateArgs<ExtArgs>>): Prisma__BybitTransactionClient<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BybitTransactions.
     * @param {BybitTransactionDeleteManyArgs} args - Arguments to filter BybitTransactions to delete.
     * @example
     * // Delete a few BybitTransactions
     * const { count } = await prisma.bybitTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BybitTransactionDeleteManyArgs>(args?: SelectSubset<T, BybitTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BybitTransactions
     * const bybitTransaction = await prisma.bybitTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BybitTransactionUpdateManyArgs>(args: SelectSubset<T, BybitTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitTransactions and returns the data updated in the database.
     * @param {BybitTransactionUpdateManyAndReturnArgs} args - Arguments to update many BybitTransactions.
     * @example
     * // Update many BybitTransactions
     * const bybitTransaction = await prisma.bybitTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BybitTransactions and only return the `id`
     * const bybitTransactionWithIdOnly = await prisma.bybitTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BybitTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, BybitTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BybitTransaction.
     * @param {BybitTransactionUpsertArgs} args - Arguments to update or create a BybitTransaction.
     * @example
     * // Update or create a BybitTransaction
     * const bybitTransaction = await prisma.bybitTransaction.upsert({
     *   create: {
     *     // ... data to create a BybitTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BybitTransaction we want to update
     *   }
     * })
     */
    upsert<T extends BybitTransactionUpsertArgs>(args: SelectSubset<T, BybitTransactionUpsertArgs<ExtArgs>>): Prisma__BybitTransactionClient<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BybitTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionCountArgs} args - Arguments to filter BybitTransactions to count.
     * @example
     * // Count the number of BybitTransactions
     * const count = await prisma.bybitTransaction.count({
     *   where: {
     *     // ... the filter for the BybitTransactions we want to count
     *   }
     * })
    **/
    count<T extends BybitTransactionCountArgs>(
      args?: Subset<T, BybitTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BybitTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BybitTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BybitTransactionAggregateArgs>(args: Subset<T, BybitTransactionAggregateArgs>): Prisma.PrismaPromise<GetBybitTransactionAggregateType<T>>

    /**
     * Group by BybitTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BybitTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BybitTransactionGroupByArgs['orderBy'] }
        : { orderBy?: BybitTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BybitTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBybitTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BybitTransaction model
   */
  readonly fields: BybitTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BybitTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BybitTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bybitMatch<T extends BybitTransaction$bybitMatchArgs<ExtArgs> = {}>(args?: Subset<T, BybitTransaction$bybitMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BybitTransaction model
   */
  interface BybitTransactionFieldRefs {
    readonly id: FieldRef<"BybitTransaction", 'Int'>
    readonly orderNo: FieldRef<"BybitTransaction", 'String'>
    readonly counterparty: FieldRef<"BybitTransaction", 'String'>
    readonly status: FieldRef<"BybitTransaction", 'String'>
    readonly userId: FieldRef<"BybitTransaction", 'Int'>
    readonly createdAt: FieldRef<"BybitTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"BybitTransaction", 'DateTime'>
    readonly amount: FieldRef<"BybitTransaction", 'Float'>
    readonly asset: FieldRef<"BybitTransaction", 'String'>
    readonly dateTime: FieldRef<"BybitTransaction", 'DateTime'>
    readonly originalData: FieldRef<"BybitTransaction", 'Json'>
    readonly totalPrice: FieldRef<"BybitTransaction", 'Float'>
    readonly type: FieldRef<"BybitTransaction", 'String'>
    readonly unitPrice: FieldRef<"BybitTransaction", 'Float'>
    readonly processed: FieldRef<"BybitTransaction", 'Boolean'>
    readonly extractedPhones: FieldRef<"BybitTransaction", 'String[]'>
    readonly lastAttemptError: FieldRef<"BybitTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BybitTransaction findUnique
   */
  export type BybitTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BybitTransaction to fetch.
     */
    where: BybitTransactionWhereUniqueInput
  }

  /**
   * BybitTransaction findUniqueOrThrow
   */
  export type BybitTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BybitTransaction to fetch.
     */
    where: BybitTransactionWhereUniqueInput
  }

  /**
   * BybitTransaction findFirst
   */
  export type BybitTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BybitTransaction to fetch.
     */
    where?: BybitTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitTransactions to fetch.
     */
    orderBy?: BybitTransactionOrderByWithRelationInput | BybitTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitTransactions.
     */
    cursor?: BybitTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitTransactions.
     */
    distinct?: BybitTransactionScalarFieldEnum | BybitTransactionScalarFieldEnum[]
  }

  /**
   * BybitTransaction findFirstOrThrow
   */
  export type BybitTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BybitTransaction to fetch.
     */
    where?: BybitTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitTransactions to fetch.
     */
    orderBy?: BybitTransactionOrderByWithRelationInput | BybitTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitTransactions.
     */
    cursor?: BybitTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitTransactions.
     */
    distinct?: BybitTransactionScalarFieldEnum | BybitTransactionScalarFieldEnum[]
  }

  /**
   * BybitTransaction findMany
   */
  export type BybitTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BybitTransactions to fetch.
     */
    where?: BybitTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitTransactions to fetch.
     */
    orderBy?: BybitTransactionOrderByWithRelationInput | BybitTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BybitTransactions.
     */
    cursor?: BybitTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitTransactions.
     */
    skip?: number
    distinct?: BybitTransactionScalarFieldEnum | BybitTransactionScalarFieldEnum[]
  }

  /**
   * BybitTransaction create
   */
  export type BybitTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a BybitTransaction.
     */
    data: XOR<BybitTransactionCreateInput, BybitTransactionUncheckedCreateInput>
  }

  /**
   * BybitTransaction createMany
   */
  export type BybitTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BybitTransactions.
     */
    data: BybitTransactionCreateManyInput | BybitTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BybitTransaction createManyAndReturn
   */
  export type BybitTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many BybitTransactions.
     */
    data: BybitTransactionCreateManyInput | BybitTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BybitTransaction update
   */
  export type BybitTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a BybitTransaction.
     */
    data: XOR<BybitTransactionUpdateInput, BybitTransactionUncheckedUpdateInput>
    /**
     * Choose, which BybitTransaction to update.
     */
    where: BybitTransactionWhereUniqueInput
  }

  /**
   * BybitTransaction updateMany
   */
  export type BybitTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BybitTransactions.
     */
    data: XOR<BybitTransactionUpdateManyMutationInput, BybitTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BybitTransactions to update
     */
    where?: BybitTransactionWhereInput
    /**
     * Limit how many BybitTransactions to update.
     */
    limit?: number
  }

  /**
   * BybitTransaction updateManyAndReturn
   */
  export type BybitTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * The data used to update BybitTransactions.
     */
    data: XOR<BybitTransactionUpdateManyMutationInput, BybitTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BybitTransactions to update
     */
    where?: BybitTransactionWhereInput
    /**
     * Limit how many BybitTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BybitTransaction upsert
   */
  export type BybitTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the BybitTransaction to update in case it exists.
     */
    where: BybitTransactionWhereUniqueInput
    /**
     * In case the BybitTransaction found by the `where` argument doesn't exist, create a new BybitTransaction with this data.
     */
    create: XOR<BybitTransactionCreateInput, BybitTransactionUncheckedCreateInput>
    /**
     * In case the BybitTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BybitTransactionUpdateInput, BybitTransactionUncheckedUpdateInput>
  }

  /**
   * BybitTransaction delete
   */
  export type BybitTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionInclude<ExtArgs> | null
    /**
     * Filter which BybitTransaction to delete.
     */
    where: BybitTransactionWhereUniqueInput
  }

  /**
   * BybitTransaction deleteMany
   */
  export type BybitTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitTransactions to delete
     */
    where?: BybitTransactionWhereInput
    /**
     * Limit how many BybitTransactions to delete.
     */
    limit?: number
  }

  /**
   * BybitTransaction.bybitMatch
   */
  export type BybitTransaction$bybitMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
    where?: BybitMatchWhereInput
    orderBy?: BybitMatchOrderByWithRelationInput | BybitMatchOrderByWithRelationInput[]
    cursor?: BybitMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BybitMatchScalarFieldEnum | BybitMatchScalarFieldEnum[]
  }

  /**
   * BybitTransaction without action
   */
  export type BybitTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Card
   */

  export type AggregateCard = {
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  export type CardAvgAggregateOutputType = {
    id: number | null
    externalId: number | null
    appPin: number | null
    cardPrice: number | null
  }

  export type CardSumAggregateOutputType = {
    id: number | null
    externalId: number | null
    appPin: number | null
    cardPrice: number | null
  }

  export type CardMinAggregateOutputType = {
    id: number | null
    externalId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    provider: string | null
    cardNumber: string | null
    bank: string | null
    phoneNumber: string | null
    appPin: number | null
    terminalPin: string | null
    comment: string | null
    picachu: string | null
    status: $Enums.CardStatus | null
    cardPrice: number | null
    isPaid: boolean | null
    letterCode: string | null
    actor: string | null
    inWork: boolean | null
    activePaymentMethod: string | null
  }

  export type CardMaxAggregateOutputType = {
    id: number | null
    externalId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    provider: string | null
    cardNumber: string | null
    bank: string | null
    phoneNumber: string | null
    appPin: number | null
    terminalPin: string | null
    comment: string | null
    picachu: string | null
    status: $Enums.CardStatus | null
    cardPrice: number | null
    isPaid: boolean | null
    letterCode: string | null
    actor: string | null
    inWork: boolean | null
    activePaymentMethod: string | null
  }

  export type CardCountAggregateOutputType = {
    id: number
    externalId: number
    createdAt: number
    updatedAt: number
    provider: number
    cardNumber: number
    bank: number
    phoneNumber: number
    appPin: number
    terminalPin: number
    comment: number
    picachu: number
    status: number
    cardPrice: number
    isPaid: number
    letterCode: number
    actor: number
    inWork: number
    activePaymentMethod: number
    _all: number
  }


  export type CardAvgAggregateInputType = {
    id?: true
    externalId?: true
    appPin?: true
    cardPrice?: true
  }

  export type CardSumAggregateInputType = {
    id?: true
    externalId?: true
    appPin?: true
    cardPrice?: true
  }

  export type CardMinAggregateInputType = {
    id?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    provider?: true
    cardNumber?: true
    bank?: true
    phoneNumber?: true
    appPin?: true
    terminalPin?: true
    comment?: true
    picachu?: true
    status?: true
    cardPrice?: true
    isPaid?: true
    letterCode?: true
    actor?: true
    inWork?: true
    activePaymentMethod?: true
  }

  export type CardMaxAggregateInputType = {
    id?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    provider?: true
    cardNumber?: true
    bank?: true
    phoneNumber?: true
    appPin?: true
    terminalPin?: true
    comment?: true
    picachu?: true
    status?: true
    cardPrice?: true
    isPaid?: true
    letterCode?: true
    actor?: true
    inWork?: true
    activePaymentMethod?: true
  }

  export type CardCountAggregateInputType = {
    id?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    provider?: true
    cardNumber?: true
    bank?: true
    phoneNumber?: true
    appPin?: true
    terminalPin?: true
    comment?: true
    picachu?: true
    status?: true
    cardPrice?: true
    isPaid?: true
    letterCode?: true
    actor?: true
    inWork?: true
    activePaymentMethod?: true
    _all?: true
  }

  export type CardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Card to aggregate.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cards
    **/
    _count?: true | CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardMaxAggregateInputType
  }

  export type GetCardAggregateType<T extends CardAggregateArgs> = {
        [P in keyof T & keyof AggregateCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCard[P]>
      : GetScalarType<T[P], AggregateCard[P]>
  }




  export type CardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardWhereInput
    orderBy?: CardOrderByWithAggregationInput | CardOrderByWithAggregationInput[]
    by: CardScalarFieldEnum[] | CardScalarFieldEnum
    having?: CardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardCountAggregateInputType | true
    _avg?: CardAvgAggregateInputType
    _sum?: CardSumAggregateInputType
    _min?: CardMinAggregateInputType
    _max?: CardMaxAggregateInputType
  }

  export type CardGroupByOutputType = {
    id: number
    externalId: number
    createdAt: Date
    updatedAt: Date
    provider: string
    cardNumber: string
    bank: string
    phoneNumber: string
    appPin: number
    terminalPin: string
    comment: string | null
    picachu: string | null
    status: $Enums.CardStatus
    cardPrice: number | null
    isPaid: boolean
    letterCode: string | null
    actor: string | null
    inWork: boolean
    activePaymentMethod: string | null
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  type GetCardGroupByPayload<T extends CardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardGroupByOutputType[P]>
            : GetScalarType<T[P], CardGroupByOutputType[P]>
        }
      >
    >


  export type CardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean
    cardNumber?: boolean
    bank?: boolean
    phoneNumber?: boolean
    appPin?: boolean
    terminalPin?: boolean
    comment?: boolean
    picachu?: boolean
    status?: boolean
    cardPrice?: boolean
    isPaid?: boolean
    letterCode?: boolean
    actor?: boolean
    inWork?: boolean
    activePaymentMethod?: boolean
    AuditLog?: boolean | Card$AuditLogArgs<ExtArgs>
    CardBalance?: boolean | Card$CardBalanceArgs<ExtArgs>
    CardPouring?: boolean | Card$CardPouringArgs<ExtArgs>
    _count?: boolean | CardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["card"]>

  export type CardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean
    cardNumber?: boolean
    bank?: boolean
    phoneNumber?: boolean
    appPin?: boolean
    terminalPin?: boolean
    comment?: boolean
    picachu?: boolean
    status?: boolean
    cardPrice?: boolean
    isPaid?: boolean
    letterCode?: boolean
    actor?: boolean
    inWork?: boolean
    activePaymentMethod?: boolean
  }, ExtArgs["result"]["card"]>

  export type CardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean
    cardNumber?: boolean
    bank?: boolean
    phoneNumber?: boolean
    appPin?: boolean
    terminalPin?: boolean
    comment?: boolean
    picachu?: boolean
    status?: boolean
    cardPrice?: boolean
    isPaid?: boolean
    letterCode?: boolean
    actor?: boolean
    inWork?: boolean
    activePaymentMethod?: boolean
  }, ExtArgs["result"]["card"]>

  export type CardSelectScalar = {
    id?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean
    cardNumber?: boolean
    bank?: boolean
    phoneNumber?: boolean
    appPin?: boolean
    terminalPin?: boolean
    comment?: boolean
    picachu?: boolean
    status?: boolean
    cardPrice?: boolean
    isPaid?: boolean
    letterCode?: boolean
    actor?: boolean
    inWork?: boolean
    activePaymentMethod?: boolean
  }

  export type CardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "createdAt" | "updatedAt" | "provider" | "cardNumber" | "bank" | "phoneNumber" | "appPin" | "terminalPin" | "comment" | "picachu" | "status" | "cardPrice" | "isPaid" | "letterCode" | "actor" | "inWork" | "activePaymentMethod", ExtArgs["result"]["card"]>
  export type CardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | Card$AuditLogArgs<ExtArgs>
    CardBalance?: boolean | Card$CardBalanceArgs<ExtArgs>
    CardPouring?: boolean | Card$CardPouringArgs<ExtArgs>
    _count?: boolean | CardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Card"
    objects: {
      AuditLog: Prisma.$AuditLogPayload<ExtArgs>[]
      CardBalance: Prisma.$CardBalancePayload<ExtArgs>[]
      CardPouring: Prisma.$CardPouringPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      externalId: number
      createdAt: Date
      updatedAt: Date
      provider: string
      cardNumber: string
      bank: string
      phoneNumber: string
      appPin: number
      terminalPin: string
      comment: string | null
      picachu: string | null
      status: $Enums.CardStatus
      cardPrice: number | null
      isPaid: boolean
      letterCode: string | null
      actor: string | null
      inWork: boolean
      activePaymentMethod: string | null
    }, ExtArgs["result"]["card"]>
    composites: {}
  }

  type CardGetPayload<S extends boolean | null | undefined | CardDefaultArgs> = $Result.GetResult<Prisma.$CardPayload, S>

  type CardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardCountAggregateInputType | true
    }

  export interface CardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Card'], meta: { name: 'Card' } }
    /**
     * Find zero or one Card that matches the filter.
     * @param {CardFindUniqueArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardFindUniqueArgs>(args: SelectSubset<T, CardFindUniqueArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Card that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardFindUniqueOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardFindUniqueOrThrowArgs>(args: SelectSubset<T, CardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardFindFirstArgs>(args?: SelectSubset<T, CardFindFirstArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Card that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardFindFirstOrThrowArgs>(args?: SelectSubset<T, CardFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cards
     * const cards = await prisma.card.findMany()
     * 
     * // Get first 10 Cards
     * const cards = await prisma.card.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardWithIdOnly = await prisma.card.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardFindManyArgs>(args?: SelectSubset<T, CardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Card.
     * @param {CardCreateArgs} args - Arguments to create a Card.
     * @example
     * // Create one Card
     * const Card = await prisma.card.create({
     *   data: {
     *     // ... data to create a Card
     *   }
     * })
     * 
     */
    create<T extends CardCreateArgs>(args: SelectSubset<T, CardCreateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cards.
     * @param {CardCreateManyArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const card = await prisma.card.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardCreateManyArgs>(args?: SelectSubset<T, CardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cards and returns the data saved in the database.
     * @param {CardCreateManyAndReturnArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const card = await prisma.card.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cards and only return the `id`
     * const cardWithIdOnly = await prisma.card.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CardCreateManyAndReturnArgs>(args?: SelectSubset<T, CardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Card.
     * @param {CardDeleteArgs} args - Arguments to delete one Card.
     * @example
     * // Delete one Card
     * const Card = await prisma.card.delete({
     *   where: {
     *     // ... filter to delete one Card
     *   }
     * })
     * 
     */
    delete<T extends CardDeleteArgs>(args: SelectSubset<T, CardDeleteArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Card.
     * @param {CardUpdateArgs} args - Arguments to update one Card.
     * @example
     * // Update one Card
     * const card = await prisma.card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardUpdateArgs>(args: SelectSubset<T, CardUpdateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cards.
     * @param {CardDeleteManyArgs} args - Arguments to filter Cards to delete.
     * @example
     * // Delete a few Cards
     * const { count } = await prisma.card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardDeleteManyArgs>(args?: SelectSubset<T, CardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardUpdateManyArgs>(args: SelectSubset<T, CardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards and returns the data updated in the database.
     * @param {CardUpdateManyAndReturnArgs} args - Arguments to update many Cards.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cards and only return the `id`
     * const cardWithIdOnly = await prisma.card.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CardUpdateManyAndReturnArgs>(args: SelectSubset<T, CardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Card.
     * @param {CardUpsertArgs} args - Arguments to update or create a Card.
     * @example
     * // Update or create a Card
     * const card = await prisma.card.upsert({
     *   create: {
     *     // ... data to create a Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Card we want to update
     *   }
     * })
     */
    upsert<T extends CardUpsertArgs>(args: SelectSubset<T, CardUpsertArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardCountArgs} args - Arguments to filter Cards to count.
     * @example
     * // Count the number of Cards
     * const count = await prisma.card.count({
     *   where: {
     *     // ... the filter for the Cards we want to count
     *   }
     * })
    **/
    count<T extends CardCountArgs>(
      args?: Subset<T, CardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAggregateArgs>(args: Subset<T, CardAggregateArgs>): Prisma.PrismaPromise<GetCardAggregateType<T>>

    /**
     * Group by Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardGroupByArgs['orderBy'] }
        : { orderBy?: CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Card model
   */
  readonly fields: CardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AuditLog<T extends Card$AuditLogArgs<ExtArgs> = {}>(args?: Subset<T, Card$AuditLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CardBalance<T extends Card$CardBalanceArgs<ExtArgs> = {}>(args?: Subset<T, Card$CardBalanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CardPouring<T extends Card$CardPouringArgs<ExtArgs> = {}>(args?: Subset<T, Card$CardPouringArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Card model
   */
  interface CardFieldRefs {
    readonly id: FieldRef<"Card", 'Int'>
    readonly externalId: FieldRef<"Card", 'Int'>
    readonly createdAt: FieldRef<"Card", 'DateTime'>
    readonly updatedAt: FieldRef<"Card", 'DateTime'>
    readonly provider: FieldRef<"Card", 'String'>
    readonly cardNumber: FieldRef<"Card", 'String'>
    readonly bank: FieldRef<"Card", 'String'>
    readonly phoneNumber: FieldRef<"Card", 'String'>
    readonly appPin: FieldRef<"Card", 'Int'>
    readonly terminalPin: FieldRef<"Card", 'String'>
    readonly comment: FieldRef<"Card", 'String'>
    readonly picachu: FieldRef<"Card", 'String'>
    readonly status: FieldRef<"Card", 'CardStatus'>
    readonly cardPrice: FieldRef<"Card", 'Float'>
    readonly isPaid: FieldRef<"Card", 'Boolean'>
    readonly letterCode: FieldRef<"Card", 'String'>
    readonly actor: FieldRef<"Card", 'String'>
    readonly inWork: FieldRef<"Card", 'Boolean'>
    readonly activePaymentMethod: FieldRef<"Card", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Card findUnique
   */
  export type CardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findUniqueOrThrow
   */
  export type CardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findFirst
   */
  export type CardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findFirstOrThrow
   */
  export type CardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findMany
   */
  export type CardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card create
   */
  export type CardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The data needed to create a Card.
     */
    data: XOR<CardCreateInput, CardUncheckedCreateInput>
  }

  /**
   * Card createMany
   */
  export type CardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cards.
     */
    data: CardCreateManyInput | CardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Card createManyAndReturn
   */
  export type CardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * The data used to create many Cards.
     */
    data: CardCreateManyInput | CardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Card update
   */
  export type CardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The data needed to update a Card.
     */
    data: XOR<CardUpdateInput, CardUncheckedUpdateInput>
    /**
     * Choose, which Card to update.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card updateMany
   */
  export type CardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cards.
     */
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyInput>
    /**
     * Filter which Cards to update
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to update.
     */
    limit?: number
  }

  /**
   * Card updateManyAndReturn
   */
  export type CardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * The data used to update Cards.
     */
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyInput>
    /**
     * Filter which Cards to update
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to update.
     */
    limit?: number
  }

  /**
   * Card upsert
   */
  export type CardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The filter to search for the Card to update in case it exists.
     */
    where: CardWhereUniqueInput
    /**
     * In case the Card found by the `where` argument doesn't exist, create a new Card with this data.
     */
    create: XOR<CardCreateInput, CardUncheckedCreateInput>
    /**
     * In case the Card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardUpdateInput, CardUncheckedUpdateInput>
  }

  /**
   * Card delete
   */
  export type CardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter which Card to delete.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card deleteMany
   */
  export type CardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cards to delete
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to delete.
     */
    limit?: number
  }

  /**
   * Card.AuditLog
   */
  export type Card$AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Card.CardBalance
   */
  export type Card$CardBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
    where?: CardBalanceWhereInput
    orderBy?: CardBalanceOrderByWithRelationInput | CardBalanceOrderByWithRelationInput[]
    cursor?: CardBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardBalanceScalarFieldEnum | CardBalanceScalarFieldEnum[]
  }

  /**
   * Card.CardPouring
   */
  export type Card$CardPouringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
    where?: CardPouringWhereInput
    orderBy?: CardPouringOrderByWithRelationInput | CardPouringOrderByWithRelationInput[]
    cursor?: CardPouringWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardPouringScalarFieldEnum | CardPouringScalarFieldEnum[]
  }

  /**
   * Card without action
   */
  export type CardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
  }


  /**
   * Model CardBalance
   */

  export type AggregateCardBalance = {
    _count: CardBalanceCountAggregateOutputType | null
    _avg: CardBalanceAvgAggregateOutputType | null
    _sum: CardBalanceSumAggregateOutputType | null
    _min: CardBalanceMinAggregateOutputType | null
    _max: CardBalanceMaxAggregateOutputType | null
  }

  export type CardBalanceAvgAggregateOutputType = {
    id: number | null
    cardId: number | null
    startBalance: number | null
    endBalance: number | null
  }

  export type CardBalanceSumAggregateOutputType = {
    id: number | null
    cardId: number | null
    startBalance: number | null
    endBalance: number | null
  }

  export type CardBalanceMinAggregateOutputType = {
    id: number | null
    cardId: number | null
    date: Date | null
    startBalance: number | null
    endBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
  }

  export type CardBalanceMaxAggregateOutputType = {
    id: number | null
    cardId: number | null
    date: Date | null
    startBalance: number | null
    endBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
  }

  export type CardBalanceCountAggregateOutputType = {
    id: number
    cardId: number
    date: number
    startBalance: number
    endBalance: number
    createdAt: number
    updatedAt: number
    comment: number
    _all: number
  }


  export type CardBalanceAvgAggregateInputType = {
    id?: true
    cardId?: true
    startBalance?: true
    endBalance?: true
  }

  export type CardBalanceSumAggregateInputType = {
    id?: true
    cardId?: true
    startBalance?: true
    endBalance?: true
  }

  export type CardBalanceMinAggregateInputType = {
    id?: true
    cardId?: true
    date?: true
    startBalance?: true
    endBalance?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
  }

  export type CardBalanceMaxAggregateInputType = {
    id?: true
    cardId?: true
    date?: true
    startBalance?: true
    endBalance?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
  }

  export type CardBalanceCountAggregateInputType = {
    id?: true
    cardId?: true
    date?: true
    startBalance?: true
    endBalance?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    _all?: true
  }

  export type CardBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardBalance to aggregate.
     */
    where?: CardBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardBalances to fetch.
     */
    orderBy?: CardBalanceOrderByWithRelationInput | CardBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardBalances
    **/
    _count?: true | CardBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardBalanceMaxAggregateInputType
  }

  export type GetCardBalanceAggregateType<T extends CardBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateCardBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardBalance[P]>
      : GetScalarType<T[P], AggregateCardBalance[P]>
  }




  export type CardBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardBalanceWhereInput
    orderBy?: CardBalanceOrderByWithAggregationInput | CardBalanceOrderByWithAggregationInput[]
    by: CardBalanceScalarFieldEnum[] | CardBalanceScalarFieldEnum
    having?: CardBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardBalanceCountAggregateInputType | true
    _avg?: CardBalanceAvgAggregateInputType
    _sum?: CardBalanceSumAggregateInputType
    _min?: CardBalanceMinAggregateInputType
    _max?: CardBalanceMaxAggregateInputType
  }

  export type CardBalanceGroupByOutputType = {
    id: number
    cardId: number
    date: Date
    startBalance: number
    endBalance: number
    createdAt: Date
    updatedAt: Date
    comment: string | null
    _count: CardBalanceCountAggregateOutputType | null
    _avg: CardBalanceAvgAggregateOutputType | null
    _sum: CardBalanceSumAggregateOutputType | null
    _min: CardBalanceMinAggregateOutputType | null
    _max: CardBalanceMaxAggregateOutputType | null
  }

  type GetCardBalanceGroupByPayload<T extends CardBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], CardBalanceGroupByOutputType[P]>
        }
      >
    >


  export type CardBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    date?: boolean
    startBalance?: boolean
    endBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    AuditLog?: boolean | CardBalance$AuditLogArgs<ExtArgs>
    Card?: boolean | CardDefaultArgs<ExtArgs>
    _count?: boolean | CardBalanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardBalance"]>

  export type CardBalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    date?: boolean
    startBalance?: boolean
    endBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    Card?: boolean | CardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardBalance"]>

  export type CardBalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    date?: boolean
    startBalance?: boolean
    endBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    Card?: boolean | CardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardBalance"]>

  export type CardBalanceSelectScalar = {
    id?: boolean
    cardId?: boolean
    date?: boolean
    startBalance?: boolean
    endBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
  }

  export type CardBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cardId" | "date" | "startBalance" | "endBalance" | "createdAt" | "updatedAt" | "comment", ExtArgs["result"]["cardBalance"]>
  export type CardBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | CardBalance$AuditLogArgs<ExtArgs>
    Card?: boolean | CardDefaultArgs<ExtArgs>
    _count?: boolean | CardBalanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CardBalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Card?: boolean | CardDefaultArgs<ExtArgs>
  }
  export type CardBalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Card?: boolean | CardDefaultArgs<ExtArgs>
  }

  export type $CardBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardBalance"
    objects: {
      AuditLog: Prisma.$AuditLogPayload<ExtArgs>[]
      Card: Prisma.$CardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cardId: number
      date: Date
      startBalance: number
      endBalance: number
      createdAt: Date
      updatedAt: Date
      comment: string | null
    }, ExtArgs["result"]["cardBalance"]>
    composites: {}
  }

  type CardBalanceGetPayload<S extends boolean | null | undefined | CardBalanceDefaultArgs> = $Result.GetResult<Prisma.$CardBalancePayload, S>

  type CardBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardBalanceCountAggregateInputType | true
    }

  export interface CardBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardBalance'], meta: { name: 'CardBalance' } }
    /**
     * Find zero or one CardBalance that matches the filter.
     * @param {CardBalanceFindUniqueArgs} args - Arguments to find a CardBalance
     * @example
     * // Get one CardBalance
     * const cardBalance = await prisma.cardBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardBalanceFindUniqueArgs>(args: SelectSubset<T, CardBalanceFindUniqueArgs<ExtArgs>>): Prisma__CardBalanceClient<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CardBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardBalanceFindUniqueOrThrowArgs} args - Arguments to find a CardBalance
     * @example
     * // Get one CardBalance
     * const cardBalance = await prisma.cardBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, CardBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardBalanceClient<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardBalanceFindFirstArgs} args - Arguments to find a CardBalance
     * @example
     * // Get one CardBalance
     * const cardBalance = await prisma.cardBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardBalanceFindFirstArgs>(args?: SelectSubset<T, CardBalanceFindFirstArgs<ExtArgs>>): Prisma__CardBalanceClient<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardBalanceFindFirstOrThrowArgs} args - Arguments to find a CardBalance
     * @example
     * // Get one CardBalance
     * const cardBalance = await prisma.cardBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, CardBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardBalanceClient<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CardBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardBalances
     * const cardBalances = await prisma.cardBalance.findMany()
     * 
     * // Get first 10 CardBalances
     * const cardBalances = await prisma.cardBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardBalanceWithIdOnly = await prisma.cardBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardBalanceFindManyArgs>(args?: SelectSubset<T, CardBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CardBalance.
     * @param {CardBalanceCreateArgs} args - Arguments to create a CardBalance.
     * @example
     * // Create one CardBalance
     * const CardBalance = await prisma.cardBalance.create({
     *   data: {
     *     // ... data to create a CardBalance
     *   }
     * })
     * 
     */
    create<T extends CardBalanceCreateArgs>(args: SelectSubset<T, CardBalanceCreateArgs<ExtArgs>>): Prisma__CardBalanceClient<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CardBalances.
     * @param {CardBalanceCreateManyArgs} args - Arguments to create many CardBalances.
     * @example
     * // Create many CardBalances
     * const cardBalance = await prisma.cardBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardBalanceCreateManyArgs>(args?: SelectSubset<T, CardBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CardBalances and returns the data saved in the database.
     * @param {CardBalanceCreateManyAndReturnArgs} args - Arguments to create many CardBalances.
     * @example
     * // Create many CardBalances
     * const cardBalance = await prisma.cardBalance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CardBalances and only return the `id`
     * const cardBalanceWithIdOnly = await prisma.cardBalance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CardBalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, CardBalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CardBalance.
     * @param {CardBalanceDeleteArgs} args - Arguments to delete one CardBalance.
     * @example
     * // Delete one CardBalance
     * const CardBalance = await prisma.cardBalance.delete({
     *   where: {
     *     // ... filter to delete one CardBalance
     *   }
     * })
     * 
     */
    delete<T extends CardBalanceDeleteArgs>(args: SelectSubset<T, CardBalanceDeleteArgs<ExtArgs>>): Prisma__CardBalanceClient<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CardBalance.
     * @param {CardBalanceUpdateArgs} args - Arguments to update one CardBalance.
     * @example
     * // Update one CardBalance
     * const cardBalance = await prisma.cardBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardBalanceUpdateArgs>(args: SelectSubset<T, CardBalanceUpdateArgs<ExtArgs>>): Prisma__CardBalanceClient<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CardBalances.
     * @param {CardBalanceDeleteManyArgs} args - Arguments to filter CardBalances to delete.
     * @example
     * // Delete a few CardBalances
     * const { count } = await prisma.cardBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardBalanceDeleteManyArgs>(args?: SelectSubset<T, CardBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardBalances
     * const cardBalance = await prisma.cardBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardBalanceUpdateManyArgs>(args: SelectSubset<T, CardBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardBalances and returns the data updated in the database.
     * @param {CardBalanceUpdateManyAndReturnArgs} args - Arguments to update many CardBalances.
     * @example
     * // Update many CardBalances
     * const cardBalance = await prisma.cardBalance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CardBalances and only return the `id`
     * const cardBalanceWithIdOnly = await prisma.cardBalance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CardBalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, CardBalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CardBalance.
     * @param {CardBalanceUpsertArgs} args - Arguments to update or create a CardBalance.
     * @example
     * // Update or create a CardBalance
     * const cardBalance = await prisma.cardBalance.upsert({
     *   create: {
     *     // ... data to create a CardBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardBalance we want to update
     *   }
     * })
     */
    upsert<T extends CardBalanceUpsertArgs>(args: SelectSubset<T, CardBalanceUpsertArgs<ExtArgs>>): Prisma__CardBalanceClient<$Result.GetResult<Prisma.$CardBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CardBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardBalanceCountArgs} args - Arguments to filter CardBalances to count.
     * @example
     * // Count the number of CardBalances
     * const count = await prisma.cardBalance.count({
     *   where: {
     *     // ... the filter for the CardBalances we want to count
     *   }
     * })
    **/
    count<T extends CardBalanceCountArgs>(
      args?: Subset<T, CardBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardBalanceAggregateArgs>(args: Subset<T, CardBalanceAggregateArgs>): Prisma.PrismaPromise<GetCardBalanceAggregateType<T>>

    /**
     * Group by CardBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardBalanceGroupByArgs['orderBy'] }
        : { orderBy?: CardBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardBalance model
   */
  readonly fields: CardBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AuditLog<T extends CardBalance$AuditLogArgs<ExtArgs> = {}>(args?: Subset<T, CardBalance$AuditLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardBalance model
   */
  interface CardBalanceFieldRefs {
    readonly id: FieldRef<"CardBalance", 'Int'>
    readonly cardId: FieldRef<"CardBalance", 'Int'>
    readonly date: FieldRef<"CardBalance", 'DateTime'>
    readonly startBalance: FieldRef<"CardBalance", 'Float'>
    readonly endBalance: FieldRef<"CardBalance", 'Float'>
    readonly createdAt: FieldRef<"CardBalance", 'DateTime'>
    readonly updatedAt: FieldRef<"CardBalance", 'DateTime'>
    readonly comment: FieldRef<"CardBalance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CardBalance findUnique
   */
  export type CardBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CardBalance to fetch.
     */
    where: CardBalanceWhereUniqueInput
  }

  /**
   * CardBalance findUniqueOrThrow
   */
  export type CardBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CardBalance to fetch.
     */
    where: CardBalanceWhereUniqueInput
  }

  /**
   * CardBalance findFirst
   */
  export type CardBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CardBalance to fetch.
     */
    where?: CardBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardBalances to fetch.
     */
    orderBy?: CardBalanceOrderByWithRelationInput | CardBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardBalances.
     */
    cursor?: CardBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardBalances.
     */
    distinct?: CardBalanceScalarFieldEnum | CardBalanceScalarFieldEnum[]
  }

  /**
   * CardBalance findFirstOrThrow
   */
  export type CardBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CardBalance to fetch.
     */
    where?: CardBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardBalances to fetch.
     */
    orderBy?: CardBalanceOrderByWithRelationInput | CardBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardBalances.
     */
    cursor?: CardBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardBalances.
     */
    distinct?: CardBalanceScalarFieldEnum | CardBalanceScalarFieldEnum[]
  }

  /**
   * CardBalance findMany
   */
  export type CardBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CardBalances to fetch.
     */
    where?: CardBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardBalances to fetch.
     */
    orderBy?: CardBalanceOrderByWithRelationInput | CardBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardBalances.
     */
    cursor?: CardBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardBalances.
     */
    skip?: number
    distinct?: CardBalanceScalarFieldEnum | CardBalanceScalarFieldEnum[]
  }

  /**
   * CardBalance create
   */
  export type CardBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a CardBalance.
     */
    data: XOR<CardBalanceCreateInput, CardBalanceUncheckedCreateInput>
  }

  /**
   * CardBalance createMany
   */
  export type CardBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardBalances.
     */
    data: CardBalanceCreateManyInput | CardBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CardBalance createManyAndReturn
   */
  export type CardBalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * The data used to create many CardBalances.
     */
    data: CardBalanceCreateManyInput | CardBalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardBalance update
   */
  export type CardBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a CardBalance.
     */
    data: XOR<CardBalanceUpdateInput, CardBalanceUncheckedUpdateInput>
    /**
     * Choose, which CardBalance to update.
     */
    where: CardBalanceWhereUniqueInput
  }

  /**
   * CardBalance updateMany
   */
  export type CardBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardBalances.
     */
    data: XOR<CardBalanceUpdateManyMutationInput, CardBalanceUncheckedUpdateManyInput>
    /**
     * Filter which CardBalances to update
     */
    where?: CardBalanceWhereInput
    /**
     * Limit how many CardBalances to update.
     */
    limit?: number
  }

  /**
   * CardBalance updateManyAndReturn
   */
  export type CardBalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * The data used to update CardBalances.
     */
    data: XOR<CardBalanceUpdateManyMutationInput, CardBalanceUncheckedUpdateManyInput>
    /**
     * Filter which CardBalances to update
     */
    where?: CardBalanceWhereInput
    /**
     * Limit how many CardBalances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardBalance upsert
   */
  export type CardBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the CardBalance to update in case it exists.
     */
    where: CardBalanceWhereUniqueInput
    /**
     * In case the CardBalance found by the `where` argument doesn't exist, create a new CardBalance with this data.
     */
    create: XOR<CardBalanceCreateInput, CardBalanceUncheckedCreateInput>
    /**
     * In case the CardBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardBalanceUpdateInput, CardBalanceUncheckedUpdateInput>
  }

  /**
   * CardBalance delete
   */
  export type CardBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
    /**
     * Filter which CardBalance to delete.
     */
    where: CardBalanceWhereUniqueInput
  }

  /**
   * CardBalance deleteMany
   */
  export type CardBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardBalances to delete
     */
    where?: CardBalanceWhereInput
    /**
     * Limit how many CardBalances to delete.
     */
    limit?: number
  }

  /**
   * CardBalance.AuditLog
   */
  export type CardBalance$AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * CardBalance without action
   */
  export type CardBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardBalance
     */
    select?: CardBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardBalance
     */
    omit?: CardBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardBalanceInclude<ExtArgs> | null
  }


  /**
   * Model CardPouring
   */

  export type AggregateCardPouring = {
    _count: CardPouringCountAggregateOutputType | null
    _avg: CardPouringAvgAggregateOutputType | null
    _sum: CardPouringSumAggregateOutputType | null
    _min: CardPouringMinAggregateOutputType | null
    _max: CardPouringMaxAggregateOutputType | null
  }

  export type CardPouringAvgAggregateOutputType = {
    id: number | null
    cardId: number | null
    initialAmount: number | null
    finalAmount: number | null
    pouringAmount: number | null
    withdrawalAmount: number | null
  }

  export type CardPouringSumAggregateOutputType = {
    id: number | null
    cardId: number | null
    initialAmount: number | null
    finalAmount: number | null
    pouringAmount: number | null
    withdrawalAmount: number | null
  }

  export type CardPouringMinAggregateOutputType = {
    id: number | null
    cardId: number | null
    pouringDate: Date | null
    initialAmount: number | null
    initialDate: Date | null
    finalAmount: number | null
    finalDate: Date | null
    pouringAmount: number | null
    withdrawalAmount: number | null
    withdrawalDate: Date | null
    collectorName: string | null
    status: $Enums.CardStatus | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardPouringMaxAggregateOutputType = {
    id: number | null
    cardId: number | null
    pouringDate: Date | null
    initialAmount: number | null
    initialDate: Date | null
    finalAmount: number | null
    finalDate: Date | null
    pouringAmount: number | null
    withdrawalAmount: number | null
    withdrawalDate: Date | null
    collectorName: string | null
    status: $Enums.CardStatus | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardPouringCountAggregateOutputType = {
    id: number
    cardId: number
    pouringDate: number
    initialAmount: number
    initialDate: number
    finalAmount: number
    finalDate: number
    pouringAmount: number
    withdrawalAmount: number
    withdrawalDate: number
    collectorName: number
    status: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CardPouringAvgAggregateInputType = {
    id?: true
    cardId?: true
    initialAmount?: true
    finalAmount?: true
    pouringAmount?: true
    withdrawalAmount?: true
  }

  export type CardPouringSumAggregateInputType = {
    id?: true
    cardId?: true
    initialAmount?: true
    finalAmount?: true
    pouringAmount?: true
    withdrawalAmount?: true
  }

  export type CardPouringMinAggregateInputType = {
    id?: true
    cardId?: true
    pouringDate?: true
    initialAmount?: true
    initialDate?: true
    finalAmount?: true
    finalDate?: true
    pouringAmount?: true
    withdrawalAmount?: true
    withdrawalDate?: true
    collectorName?: true
    status?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardPouringMaxAggregateInputType = {
    id?: true
    cardId?: true
    pouringDate?: true
    initialAmount?: true
    initialDate?: true
    finalAmount?: true
    finalDate?: true
    pouringAmount?: true
    withdrawalAmount?: true
    withdrawalDate?: true
    collectorName?: true
    status?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardPouringCountAggregateInputType = {
    id?: true
    cardId?: true
    pouringDate?: true
    initialAmount?: true
    initialDate?: true
    finalAmount?: true
    finalDate?: true
    pouringAmount?: true
    withdrawalAmount?: true
    withdrawalDate?: true
    collectorName?: true
    status?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CardPouringAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardPouring to aggregate.
     */
    where?: CardPouringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardPourings to fetch.
     */
    orderBy?: CardPouringOrderByWithRelationInput | CardPouringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardPouringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardPourings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardPourings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardPourings
    **/
    _count?: true | CardPouringCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardPouringAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardPouringSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardPouringMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardPouringMaxAggregateInputType
  }

  export type GetCardPouringAggregateType<T extends CardPouringAggregateArgs> = {
        [P in keyof T & keyof AggregateCardPouring]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardPouring[P]>
      : GetScalarType<T[P], AggregateCardPouring[P]>
  }




  export type CardPouringGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardPouringWhereInput
    orderBy?: CardPouringOrderByWithAggregationInput | CardPouringOrderByWithAggregationInput[]
    by: CardPouringScalarFieldEnum[] | CardPouringScalarFieldEnum
    having?: CardPouringScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardPouringCountAggregateInputType | true
    _avg?: CardPouringAvgAggregateInputType
    _sum?: CardPouringSumAggregateInputType
    _min?: CardPouringMinAggregateInputType
    _max?: CardPouringMaxAggregateInputType
  }

  export type CardPouringGroupByOutputType = {
    id: number
    cardId: number
    pouringDate: Date
    initialAmount: number
    initialDate: Date
    finalAmount: number | null
    finalDate: Date | null
    pouringAmount: number
    withdrawalAmount: number | null
    withdrawalDate: Date | null
    collectorName: string | null
    status: $Enums.CardStatus
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: CardPouringCountAggregateOutputType | null
    _avg: CardPouringAvgAggregateOutputType | null
    _sum: CardPouringSumAggregateOutputType | null
    _min: CardPouringMinAggregateOutputType | null
    _max: CardPouringMaxAggregateOutputType | null
  }

  type GetCardPouringGroupByPayload<T extends CardPouringGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardPouringGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardPouringGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardPouringGroupByOutputType[P]>
            : GetScalarType<T[P], CardPouringGroupByOutputType[P]>
        }
      >
    >


  export type CardPouringSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    pouringDate?: boolean
    initialAmount?: boolean
    initialDate?: boolean
    finalAmount?: boolean
    finalDate?: boolean
    pouringAmount?: boolean
    withdrawalAmount?: boolean
    withdrawalDate?: boolean
    collectorName?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    AuditLog?: boolean | CardPouring$AuditLogArgs<ExtArgs>
    Card?: boolean | CardDefaultArgs<ExtArgs>
    _count?: boolean | CardPouringCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardPouring"]>

  export type CardPouringSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    pouringDate?: boolean
    initialAmount?: boolean
    initialDate?: boolean
    finalAmount?: boolean
    finalDate?: boolean
    pouringAmount?: boolean
    withdrawalAmount?: boolean
    withdrawalDate?: boolean
    collectorName?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Card?: boolean | CardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardPouring"]>

  export type CardPouringSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cardId?: boolean
    pouringDate?: boolean
    initialAmount?: boolean
    initialDate?: boolean
    finalAmount?: boolean
    finalDate?: boolean
    pouringAmount?: boolean
    withdrawalAmount?: boolean
    withdrawalDate?: boolean
    collectorName?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Card?: boolean | CardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardPouring"]>

  export type CardPouringSelectScalar = {
    id?: boolean
    cardId?: boolean
    pouringDate?: boolean
    initialAmount?: boolean
    initialDate?: boolean
    finalAmount?: boolean
    finalDate?: boolean
    pouringAmount?: boolean
    withdrawalAmount?: boolean
    withdrawalDate?: boolean
    collectorName?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CardPouringOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cardId" | "pouringDate" | "initialAmount" | "initialDate" | "finalAmount" | "finalDate" | "pouringAmount" | "withdrawalAmount" | "withdrawalDate" | "collectorName" | "status" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["cardPouring"]>
  export type CardPouringInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | CardPouring$AuditLogArgs<ExtArgs>
    Card?: boolean | CardDefaultArgs<ExtArgs>
    _count?: boolean | CardPouringCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CardPouringIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Card?: boolean | CardDefaultArgs<ExtArgs>
  }
  export type CardPouringIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Card?: boolean | CardDefaultArgs<ExtArgs>
  }

  export type $CardPouringPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardPouring"
    objects: {
      AuditLog: Prisma.$AuditLogPayload<ExtArgs>[]
      Card: Prisma.$CardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cardId: number
      pouringDate: Date
      initialAmount: number
      initialDate: Date
      finalAmount: number | null
      finalDate: Date | null
      pouringAmount: number
      withdrawalAmount: number | null
      withdrawalDate: Date | null
      collectorName: string | null
      status: $Enums.CardStatus
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cardPouring"]>
    composites: {}
  }

  type CardPouringGetPayload<S extends boolean | null | undefined | CardPouringDefaultArgs> = $Result.GetResult<Prisma.$CardPouringPayload, S>

  type CardPouringCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardPouringFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardPouringCountAggregateInputType | true
    }

  export interface CardPouringDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardPouring'], meta: { name: 'CardPouring' } }
    /**
     * Find zero or one CardPouring that matches the filter.
     * @param {CardPouringFindUniqueArgs} args - Arguments to find a CardPouring
     * @example
     * // Get one CardPouring
     * const cardPouring = await prisma.cardPouring.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardPouringFindUniqueArgs>(args: SelectSubset<T, CardPouringFindUniqueArgs<ExtArgs>>): Prisma__CardPouringClient<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CardPouring that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardPouringFindUniqueOrThrowArgs} args - Arguments to find a CardPouring
     * @example
     * // Get one CardPouring
     * const cardPouring = await prisma.cardPouring.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardPouringFindUniqueOrThrowArgs>(args: SelectSubset<T, CardPouringFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardPouringClient<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardPouring that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardPouringFindFirstArgs} args - Arguments to find a CardPouring
     * @example
     * // Get one CardPouring
     * const cardPouring = await prisma.cardPouring.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardPouringFindFirstArgs>(args?: SelectSubset<T, CardPouringFindFirstArgs<ExtArgs>>): Prisma__CardPouringClient<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardPouring that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardPouringFindFirstOrThrowArgs} args - Arguments to find a CardPouring
     * @example
     * // Get one CardPouring
     * const cardPouring = await prisma.cardPouring.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardPouringFindFirstOrThrowArgs>(args?: SelectSubset<T, CardPouringFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardPouringClient<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CardPourings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardPouringFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardPourings
     * const cardPourings = await prisma.cardPouring.findMany()
     * 
     * // Get first 10 CardPourings
     * const cardPourings = await prisma.cardPouring.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardPouringWithIdOnly = await prisma.cardPouring.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardPouringFindManyArgs>(args?: SelectSubset<T, CardPouringFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CardPouring.
     * @param {CardPouringCreateArgs} args - Arguments to create a CardPouring.
     * @example
     * // Create one CardPouring
     * const CardPouring = await prisma.cardPouring.create({
     *   data: {
     *     // ... data to create a CardPouring
     *   }
     * })
     * 
     */
    create<T extends CardPouringCreateArgs>(args: SelectSubset<T, CardPouringCreateArgs<ExtArgs>>): Prisma__CardPouringClient<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CardPourings.
     * @param {CardPouringCreateManyArgs} args - Arguments to create many CardPourings.
     * @example
     * // Create many CardPourings
     * const cardPouring = await prisma.cardPouring.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardPouringCreateManyArgs>(args?: SelectSubset<T, CardPouringCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CardPourings and returns the data saved in the database.
     * @param {CardPouringCreateManyAndReturnArgs} args - Arguments to create many CardPourings.
     * @example
     * // Create many CardPourings
     * const cardPouring = await prisma.cardPouring.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CardPourings and only return the `id`
     * const cardPouringWithIdOnly = await prisma.cardPouring.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CardPouringCreateManyAndReturnArgs>(args?: SelectSubset<T, CardPouringCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CardPouring.
     * @param {CardPouringDeleteArgs} args - Arguments to delete one CardPouring.
     * @example
     * // Delete one CardPouring
     * const CardPouring = await prisma.cardPouring.delete({
     *   where: {
     *     // ... filter to delete one CardPouring
     *   }
     * })
     * 
     */
    delete<T extends CardPouringDeleteArgs>(args: SelectSubset<T, CardPouringDeleteArgs<ExtArgs>>): Prisma__CardPouringClient<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CardPouring.
     * @param {CardPouringUpdateArgs} args - Arguments to update one CardPouring.
     * @example
     * // Update one CardPouring
     * const cardPouring = await prisma.cardPouring.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardPouringUpdateArgs>(args: SelectSubset<T, CardPouringUpdateArgs<ExtArgs>>): Prisma__CardPouringClient<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CardPourings.
     * @param {CardPouringDeleteManyArgs} args - Arguments to filter CardPourings to delete.
     * @example
     * // Delete a few CardPourings
     * const { count } = await prisma.cardPouring.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardPouringDeleteManyArgs>(args?: SelectSubset<T, CardPouringDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardPourings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardPouringUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardPourings
     * const cardPouring = await prisma.cardPouring.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardPouringUpdateManyArgs>(args: SelectSubset<T, CardPouringUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardPourings and returns the data updated in the database.
     * @param {CardPouringUpdateManyAndReturnArgs} args - Arguments to update many CardPourings.
     * @example
     * // Update many CardPourings
     * const cardPouring = await prisma.cardPouring.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CardPourings and only return the `id`
     * const cardPouringWithIdOnly = await prisma.cardPouring.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CardPouringUpdateManyAndReturnArgs>(args: SelectSubset<T, CardPouringUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CardPouring.
     * @param {CardPouringUpsertArgs} args - Arguments to update or create a CardPouring.
     * @example
     * // Update or create a CardPouring
     * const cardPouring = await prisma.cardPouring.upsert({
     *   create: {
     *     // ... data to create a CardPouring
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardPouring we want to update
     *   }
     * })
     */
    upsert<T extends CardPouringUpsertArgs>(args: SelectSubset<T, CardPouringUpsertArgs<ExtArgs>>): Prisma__CardPouringClient<$Result.GetResult<Prisma.$CardPouringPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CardPourings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardPouringCountArgs} args - Arguments to filter CardPourings to count.
     * @example
     * // Count the number of CardPourings
     * const count = await prisma.cardPouring.count({
     *   where: {
     *     // ... the filter for the CardPourings we want to count
     *   }
     * })
    **/
    count<T extends CardPouringCountArgs>(
      args?: Subset<T, CardPouringCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardPouringCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardPouring.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardPouringAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardPouringAggregateArgs>(args: Subset<T, CardPouringAggregateArgs>): Prisma.PrismaPromise<GetCardPouringAggregateType<T>>

    /**
     * Group by CardPouring.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardPouringGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardPouringGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardPouringGroupByArgs['orderBy'] }
        : { orderBy?: CardPouringGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardPouringGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardPouringGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardPouring model
   */
  readonly fields: CardPouringFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardPouring.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardPouringClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AuditLog<T extends CardPouring$AuditLogArgs<ExtArgs> = {}>(args?: Subset<T, CardPouring$AuditLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardPouring model
   */
  interface CardPouringFieldRefs {
    readonly id: FieldRef<"CardPouring", 'Int'>
    readonly cardId: FieldRef<"CardPouring", 'Int'>
    readonly pouringDate: FieldRef<"CardPouring", 'DateTime'>
    readonly initialAmount: FieldRef<"CardPouring", 'Float'>
    readonly initialDate: FieldRef<"CardPouring", 'DateTime'>
    readonly finalAmount: FieldRef<"CardPouring", 'Float'>
    readonly finalDate: FieldRef<"CardPouring", 'DateTime'>
    readonly pouringAmount: FieldRef<"CardPouring", 'Float'>
    readonly withdrawalAmount: FieldRef<"CardPouring", 'Float'>
    readonly withdrawalDate: FieldRef<"CardPouring", 'DateTime'>
    readonly collectorName: FieldRef<"CardPouring", 'String'>
    readonly status: FieldRef<"CardPouring", 'CardStatus'>
    readonly comment: FieldRef<"CardPouring", 'String'>
    readonly createdAt: FieldRef<"CardPouring", 'DateTime'>
    readonly updatedAt: FieldRef<"CardPouring", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CardPouring findUnique
   */
  export type CardPouringFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
    /**
     * Filter, which CardPouring to fetch.
     */
    where: CardPouringWhereUniqueInput
  }

  /**
   * CardPouring findUniqueOrThrow
   */
  export type CardPouringFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
    /**
     * Filter, which CardPouring to fetch.
     */
    where: CardPouringWhereUniqueInput
  }

  /**
   * CardPouring findFirst
   */
  export type CardPouringFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
    /**
     * Filter, which CardPouring to fetch.
     */
    where?: CardPouringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardPourings to fetch.
     */
    orderBy?: CardPouringOrderByWithRelationInput | CardPouringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardPourings.
     */
    cursor?: CardPouringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardPourings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardPourings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardPourings.
     */
    distinct?: CardPouringScalarFieldEnum | CardPouringScalarFieldEnum[]
  }

  /**
   * CardPouring findFirstOrThrow
   */
  export type CardPouringFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
    /**
     * Filter, which CardPouring to fetch.
     */
    where?: CardPouringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardPourings to fetch.
     */
    orderBy?: CardPouringOrderByWithRelationInput | CardPouringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardPourings.
     */
    cursor?: CardPouringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardPourings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardPourings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardPourings.
     */
    distinct?: CardPouringScalarFieldEnum | CardPouringScalarFieldEnum[]
  }

  /**
   * CardPouring findMany
   */
  export type CardPouringFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
    /**
     * Filter, which CardPourings to fetch.
     */
    where?: CardPouringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardPourings to fetch.
     */
    orderBy?: CardPouringOrderByWithRelationInput | CardPouringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardPourings.
     */
    cursor?: CardPouringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardPourings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardPourings.
     */
    skip?: number
    distinct?: CardPouringScalarFieldEnum | CardPouringScalarFieldEnum[]
  }

  /**
   * CardPouring create
   */
  export type CardPouringCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
    /**
     * The data needed to create a CardPouring.
     */
    data: XOR<CardPouringCreateInput, CardPouringUncheckedCreateInput>
  }

  /**
   * CardPouring createMany
   */
  export type CardPouringCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardPourings.
     */
    data: CardPouringCreateManyInput | CardPouringCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CardPouring createManyAndReturn
   */
  export type CardPouringCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * The data used to create many CardPourings.
     */
    data: CardPouringCreateManyInput | CardPouringCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardPouring update
   */
  export type CardPouringUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
    /**
     * The data needed to update a CardPouring.
     */
    data: XOR<CardPouringUpdateInput, CardPouringUncheckedUpdateInput>
    /**
     * Choose, which CardPouring to update.
     */
    where: CardPouringWhereUniqueInput
  }

  /**
   * CardPouring updateMany
   */
  export type CardPouringUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardPourings.
     */
    data: XOR<CardPouringUpdateManyMutationInput, CardPouringUncheckedUpdateManyInput>
    /**
     * Filter which CardPourings to update
     */
    where?: CardPouringWhereInput
    /**
     * Limit how many CardPourings to update.
     */
    limit?: number
  }

  /**
   * CardPouring updateManyAndReturn
   */
  export type CardPouringUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * The data used to update CardPourings.
     */
    data: XOR<CardPouringUpdateManyMutationInput, CardPouringUncheckedUpdateManyInput>
    /**
     * Filter which CardPourings to update
     */
    where?: CardPouringWhereInput
    /**
     * Limit how many CardPourings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardPouring upsert
   */
  export type CardPouringUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
    /**
     * The filter to search for the CardPouring to update in case it exists.
     */
    where: CardPouringWhereUniqueInput
    /**
     * In case the CardPouring found by the `where` argument doesn't exist, create a new CardPouring with this data.
     */
    create: XOR<CardPouringCreateInput, CardPouringUncheckedCreateInput>
    /**
     * In case the CardPouring was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardPouringUpdateInput, CardPouringUncheckedUpdateInput>
  }

  /**
   * CardPouring delete
   */
  export type CardPouringDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
    /**
     * Filter which CardPouring to delete.
     */
    where: CardPouringWhereUniqueInput
  }

  /**
   * CardPouring deleteMany
   */
  export type CardPouringDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardPourings to delete
     */
    where?: CardPouringWhereInput
    /**
     * Limit how many CardPourings to delete.
     */
    limit?: number
  }

  /**
   * CardPouring.AuditLog
   */
  export type CardPouring$AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * CardPouring without action
   */
  export type CardPouringDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardPouring
     */
    select?: CardPouringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardPouring
     */
    omit?: CardPouringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardPouringInclude<ExtArgs> | null
  }


  /**
   * Model Cell
   */

  export type AggregateCell = {
    _count: CellCountAggregateOutputType | null
    _avg: CellAvgAggregateOutputType | null
    _sum: CellSumAggregateOutputType | null
    _min: CellMinAggregateOutputType | null
    _max: CellMaxAggregateOutputType | null
  }

  export type CellAvgAggregateOutputType = {
    id: number | null
    rowId: number | null
    columnId: number | null
  }

  export type CellSumAggregateOutputType = {
    id: number | null
    rowId: number | null
    columnId: number | null
  }

  export type CellMinAggregateOutputType = {
    id: number | null
    rowId: number | null
    columnId: number | null
    value: string | null
    displayValue: string | null
    calculatedValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CellMaxAggregateOutputType = {
    id: number | null
    rowId: number | null
    columnId: number | null
    value: string | null
    displayValue: string | null
    calculatedValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CellCountAggregateOutputType = {
    id: number
    rowId: number
    columnId: number
    value: number
    displayValue: number
    calculatedValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CellAvgAggregateInputType = {
    id?: true
    rowId?: true
    columnId?: true
  }

  export type CellSumAggregateInputType = {
    id?: true
    rowId?: true
    columnId?: true
  }

  export type CellMinAggregateInputType = {
    id?: true
    rowId?: true
    columnId?: true
    value?: true
    displayValue?: true
    calculatedValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CellMaxAggregateInputType = {
    id?: true
    rowId?: true
    columnId?: true
    value?: true
    displayValue?: true
    calculatedValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CellCountAggregateInputType = {
    id?: true
    rowId?: true
    columnId?: true
    value?: true
    displayValue?: true
    calculatedValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cell to aggregate.
     */
    where?: CellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cells to fetch.
     */
    orderBy?: CellOrderByWithRelationInput | CellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cells
    **/
    _count?: true | CellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CellMaxAggregateInputType
  }

  export type GetCellAggregateType<T extends CellAggregateArgs> = {
        [P in keyof T & keyof AggregateCell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCell[P]>
      : GetScalarType<T[P], AggregateCell[P]>
  }




  export type CellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CellWhereInput
    orderBy?: CellOrderByWithAggregationInput | CellOrderByWithAggregationInput[]
    by: CellScalarFieldEnum[] | CellScalarFieldEnum
    having?: CellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CellCountAggregateInputType | true
    _avg?: CellAvgAggregateInputType
    _sum?: CellSumAggregateInputType
    _min?: CellMinAggregateInputType
    _max?: CellMaxAggregateInputType
  }

  export type CellGroupByOutputType = {
    id: number
    rowId: number
    columnId: number
    value: string | null
    displayValue: string | null
    calculatedValue: string | null
    createdAt: Date
    updatedAt: Date
    _count: CellCountAggregateOutputType | null
    _avg: CellAvgAggregateOutputType | null
    _sum: CellSumAggregateOutputType | null
    _min: CellMinAggregateOutputType | null
    _max: CellMaxAggregateOutputType | null
  }

  type GetCellGroupByPayload<T extends CellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CellGroupByOutputType[P]>
            : GetScalarType<T[P], CellGroupByOutputType[P]>
        }
      >
    >


  export type CellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rowId?: boolean
    columnId?: boolean
    value?: boolean
    displayValue?: boolean
    calculatedValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Row?: boolean | RowDefaultArgs<ExtArgs>
    Comment?: boolean | Cell$CommentArgs<ExtArgs>
    _count?: boolean | CellCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cell"]>

  export type CellSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rowId?: boolean
    columnId?: boolean
    value?: boolean
    displayValue?: boolean
    calculatedValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Row?: boolean | RowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cell"]>

  export type CellSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rowId?: boolean
    columnId?: boolean
    value?: boolean
    displayValue?: boolean
    calculatedValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Row?: boolean | RowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cell"]>

  export type CellSelectScalar = {
    id?: boolean
    rowId?: boolean
    columnId?: boolean
    value?: boolean
    displayValue?: boolean
    calculatedValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CellOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rowId" | "columnId" | "value" | "displayValue" | "calculatedValue" | "createdAt" | "updatedAt", ExtArgs["result"]["cell"]>
  export type CellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Row?: boolean | RowDefaultArgs<ExtArgs>
    Comment?: boolean | Cell$CommentArgs<ExtArgs>
    _count?: boolean | CellCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CellIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Row?: boolean | RowDefaultArgs<ExtArgs>
  }
  export type CellIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Row?: boolean | RowDefaultArgs<ExtArgs>
  }

  export type $CellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cell"
    objects: {
      Column: Prisma.$ColumnPayload<ExtArgs>
      Row: Prisma.$RowPayload<ExtArgs>
      Comment: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rowId: number
      columnId: number
      value: string | null
      displayValue: string | null
      calculatedValue: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cell"]>
    composites: {}
  }

  type CellGetPayload<S extends boolean | null | undefined | CellDefaultArgs> = $Result.GetResult<Prisma.$CellPayload, S>

  type CellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CellFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CellCountAggregateInputType | true
    }

  export interface CellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cell'], meta: { name: 'Cell' } }
    /**
     * Find zero or one Cell that matches the filter.
     * @param {CellFindUniqueArgs} args - Arguments to find a Cell
     * @example
     * // Get one Cell
     * const cell = await prisma.cell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CellFindUniqueArgs>(args: SelectSubset<T, CellFindUniqueArgs<ExtArgs>>): Prisma__CellClient<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cell that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CellFindUniqueOrThrowArgs} args - Arguments to find a Cell
     * @example
     * // Get one Cell
     * const cell = await prisma.cell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CellFindUniqueOrThrowArgs>(args: SelectSubset<T, CellFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CellClient<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CellFindFirstArgs} args - Arguments to find a Cell
     * @example
     * // Get one Cell
     * const cell = await prisma.cell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CellFindFirstArgs>(args?: SelectSubset<T, CellFindFirstArgs<ExtArgs>>): Prisma__CellClient<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CellFindFirstOrThrowArgs} args - Arguments to find a Cell
     * @example
     * // Get one Cell
     * const cell = await prisma.cell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CellFindFirstOrThrowArgs>(args?: SelectSubset<T, CellFindFirstOrThrowArgs<ExtArgs>>): Prisma__CellClient<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CellFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cells
     * const cells = await prisma.cell.findMany()
     * 
     * // Get first 10 Cells
     * const cells = await prisma.cell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cellWithIdOnly = await prisma.cell.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CellFindManyArgs>(args?: SelectSubset<T, CellFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cell.
     * @param {CellCreateArgs} args - Arguments to create a Cell.
     * @example
     * // Create one Cell
     * const Cell = await prisma.cell.create({
     *   data: {
     *     // ... data to create a Cell
     *   }
     * })
     * 
     */
    create<T extends CellCreateArgs>(args: SelectSubset<T, CellCreateArgs<ExtArgs>>): Prisma__CellClient<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cells.
     * @param {CellCreateManyArgs} args - Arguments to create many Cells.
     * @example
     * // Create many Cells
     * const cell = await prisma.cell.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CellCreateManyArgs>(args?: SelectSubset<T, CellCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cells and returns the data saved in the database.
     * @param {CellCreateManyAndReturnArgs} args - Arguments to create many Cells.
     * @example
     * // Create many Cells
     * const cell = await prisma.cell.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cells and only return the `id`
     * const cellWithIdOnly = await prisma.cell.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CellCreateManyAndReturnArgs>(args?: SelectSubset<T, CellCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cell.
     * @param {CellDeleteArgs} args - Arguments to delete one Cell.
     * @example
     * // Delete one Cell
     * const Cell = await prisma.cell.delete({
     *   where: {
     *     // ... filter to delete one Cell
     *   }
     * })
     * 
     */
    delete<T extends CellDeleteArgs>(args: SelectSubset<T, CellDeleteArgs<ExtArgs>>): Prisma__CellClient<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cell.
     * @param {CellUpdateArgs} args - Arguments to update one Cell.
     * @example
     * // Update one Cell
     * const cell = await prisma.cell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CellUpdateArgs>(args: SelectSubset<T, CellUpdateArgs<ExtArgs>>): Prisma__CellClient<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cells.
     * @param {CellDeleteManyArgs} args - Arguments to filter Cells to delete.
     * @example
     * // Delete a few Cells
     * const { count } = await prisma.cell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CellDeleteManyArgs>(args?: SelectSubset<T, CellDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cells
     * const cell = await prisma.cell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CellUpdateManyArgs>(args: SelectSubset<T, CellUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cells and returns the data updated in the database.
     * @param {CellUpdateManyAndReturnArgs} args - Arguments to update many Cells.
     * @example
     * // Update many Cells
     * const cell = await prisma.cell.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cells and only return the `id`
     * const cellWithIdOnly = await prisma.cell.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CellUpdateManyAndReturnArgs>(args: SelectSubset<T, CellUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cell.
     * @param {CellUpsertArgs} args - Arguments to update or create a Cell.
     * @example
     * // Update or create a Cell
     * const cell = await prisma.cell.upsert({
     *   create: {
     *     // ... data to create a Cell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cell we want to update
     *   }
     * })
     */
    upsert<T extends CellUpsertArgs>(args: SelectSubset<T, CellUpsertArgs<ExtArgs>>): Prisma__CellClient<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CellCountArgs} args - Arguments to filter Cells to count.
     * @example
     * // Count the number of Cells
     * const count = await prisma.cell.count({
     *   where: {
     *     // ... the filter for the Cells we want to count
     *   }
     * })
    **/
    count<T extends CellCountArgs>(
      args?: Subset<T, CellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CellAggregateArgs>(args: Subset<T, CellAggregateArgs>): Prisma.PrismaPromise<GetCellAggregateType<T>>

    /**
     * Group by Cell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CellGroupByArgs['orderBy'] }
        : { orderBy?: CellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cell model
   */
  readonly fields: CellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Column<T extends ColumnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ColumnDefaultArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Row<T extends RowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RowDefaultArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Comment<T extends Cell$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Cell$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cell model
   */
  interface CellFieldRefs {
    readonly id: FieldRef<"Cell", 'Int'>
    readonly rowId: FieldRef<"Cell", 'Int'>
    readonly columnId: FieldRef<"Cell", 'Int'>
    readonly value: FieldRef<"Cell", 'String'>
    readonly displayValue: FieldRef<"Cell", 'String'>
    readonly calculatedValue: FieldRef<"Cell", 'String'>
    readonly createdAt: FieldRef<"Cell", 'DateTime'>
    readonly updatedAt: FieldRef<"Cell", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cell findUnique
   */
  export type CellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
    /**
     * Filter, which Cell to fetch.
     */
    where: CellWhereUniqueInput
  }

  /**
   * Cell findUniqueOrThrow
   */
  export type CellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
    /**
     * Filter, which Cell to fetch.
     */
    where: CellWhereUniqueInput
  }

  /**
   * Cell findFirst
   */
  export type CellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
    /**
     * Filter, which Cell to fetch.
     */
    where?: CellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cells to fetch.
     */
    orderBy?: CellOrderByWithRelationInput | CellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cells.
     */
    cursor?: CellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cells.
     */
    distinct?: CellScalarFieldEnum | CellScalarFieldEnum[]
  }

  /**
   * Cell findFirstOrThrow
   */
  export type CellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
    /**
     * Filter, which Cell to fetch.
     */
    where?: CellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cells to fetch.
     */
    orderBy?: CellOrderByWithRelationInput | CellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cells.
     */
    cursor?: CellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cells.
     */
    distinct?: CellScalarFieldEnum | CellScalarFieldEnum[]
  }

  /**
   * Cell findMany
   */
  export type CellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
    /**
     * Filter, which Cells to fetch.
     */
    where?: CellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cells to fetch.
     */
    orderBy?: CellOrderByWithRelationInput | CellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cells.
     */
    cursor?: CellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cells.
     */
    skip?: number
    distinct?: CellScalarFieldEnum | CellScalarFieldEnum[]
  }

  /**
   * Cell create
   */
  export type CellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
    /**
     * The data needed to create a Cell.
     */
    data: XOR<CellCreateInput, CellUncheckedCreateInput>
  }

  /**
   * Cell createMany
   */
  export type CellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cells.
     */
    data: CellCreateManyInput | CellCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cell createManyAndReturn
   */
  export type CellCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * The data used to create many Cells.
     */
    data: CellCreateManyInput | CellCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cell update
   */
  export type CellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
    /**
     * The data needed to update a Cell.
     */
    data: XOR<CellUpdateInput, CellUncheckedUpdateInput>
    /**
     * Choose, which Cell to update.
     */
    where: CellWhereUniqueInput
  }

  /**
   * Cell updateMany
   */
  export type CellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cells.
     */
    data: XOR<CellUpdateManyMutationInput, CellUncheckedUpdateManyInput>
    /**
     * Filter which Cells to update
     */
    where?: CellWhereInput
    /**
     * Limit how many Cells to update.
     */
    limit?: number
  }

  /**
   * Cell updateManyAndReturn
   */
  export type CellUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * The data used to update Cells.
     */
    data: XOR<CellUpdateManyMutationInput, CellUncheckedUpdateManyInput>
    /**
     * Filter which Cells to update
     */
    where?: CellWhereInput
    /**
     * Limit how many Cells to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cell upsert
   */
  export type CellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
    /**
     * The filter to search for the Cell to update in case it exists.
     */
    where: CellWhereUniqueInput
    /**
     * In case the Cell found by the `where` argument doesn't exist, create a new Cell with this data.
     */
    create: XOR<CellCreateInput, CellUncheckedCreateInput>
    /**
     * In case the Cell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CellUpdateInput, CellUncheckedUpdateInput>
  }

  /**
   * Cell delete
   */
  export type CellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
    /**
     * Filter which Cell to delete.
     */
    where: CellWhereUniqueInput
  }

  /**
   * Cell deleteMany
   */
  export type CellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cells to delete
     */
    where?: CellWhereInput
    /**
     * Limit how many Cells to delete.
     */
    limit?: number
  }

  /**
   * Cell.Comment
   */
  export type Cell$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Cell without action
   */
  export type CellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
  }


  /**
   * Model Column
   */

  export type AggregateColumn = {
    _count: ColumnCountAggregateOutputType | null
    _avg: ColumnAvgAggregateOutputType | null
    _sum: ColumnSumAggregateOutputType | null
    _min: ColumnMinAggregateOutputType | null
    _max: ColumnMaxAggregateOutputType | null
  }

  export type ColumnAvgAggregateOutputType = {
    id: number | null
    tableId: number | null
    width: number | null
    order: number | null
  }

  export type ColumnSumAggregateOutputType = {
    id: number | null
    tableId: number | null
    width: number | null
    order: number | null
  }

  export type ColumnMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.ColumnType | null
    tableId: number | null
    width: number | null
    isRequired: boolean | null
    isFilterable: boolean | null
    isSummable: boolean | null
    defaultValue: string | null
    format: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ColumnMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.ColumnType | null
    tableId: number | null
    width: number | null
    isRequired: boolean | null
    isFilterable: boolean | null
    isSummable: boolean | null
    defaultValue: string | null
    format: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ColumnCountAggregateOutputType = {
    id: number
    name: number
    type: number
    tableId: number
    width: number
    isRequired: number
    isFilterable: number
    isSummable: number
    defaultValue: number
    format: number
    order: number
    options: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ColumnAvgAggregateInputType = {
    id?: true
    tableId?: true
    width?: true
    order?: true
  }

  export type ColumnSumAggregateInputType = {
    id?: true
    tableId?: true
    width?: true
    order?: true
  }

  export type ColumnMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    tableId?: true
    width?: true
    isRequired?: true
    isFilterable?: true
    isSummable?: true
    defaultValue?: true
    format?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ColumnMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    tableId?: true
    width?: true
    isRequired?: true
    isFilterable?: true
    isSummable?: true
    defaultValue?: true
    format?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ColumnCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    tableId?: true
    width?: true
    isRequired?: true
    isFilterable?: true
    isSummable?: true
    defaultValue?: true
    format?: true
    order?: true
    options?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ColumnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Column to aggregate.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Columns
    **/
    _count?: true | ColumnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColumnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColumnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColumnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColumnMaxAggregateInputType
  }

  export type GetColumnAggregateType<T extends ColumnAggregateArgs> = {
        [P in keyof T & keyof AggregateColumn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColumn[P]>
      : GetScalarType<T[P], AggregateColumn[P]>
  }




  export type ColumnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColumnWhereInput
    orderBy?: ColumnOrderByWithAggregationInput | ColumnOrderByWithAggregationInput[]
    by: ColumnScalarFieldEnum[] | ColumnScalarFieldEnum
    having?: ColumnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColumnCountAggregateInputType | true
    _avg?: ColumnAvgAggregateInputType
    _sum?: ColumnSumAggregateInputType
    _min?: ColumnMinAggregateInputType
    _max?: ColumnMaxAggregateInputType
  }

  export type ColumnGroupByOutputType = {
    id: number
    name: string
    type: $Enums.ColumnType
    tableId: number
    width: number | null
    isRequired: boolean
    isFilterable: boolean
    isSummable: boolean
    defaultValue: string | null
    format: string | null
    order: number
    options: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ColumnCountAggregateOutputType | null
    _avg: ColumnAvgAggregateOutputType | null
    _sum: ColumnSumAggregateOutputType | null
    _min: ColumnMinAggregateOutputType | null
    _max: ColumnMaxAggregateOutputType | null
  }

  type GetColumnGroupByPayload<T extends ColumnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColumnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColumnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColumnGroupByOutputType[P]>
            : GetScalarType<T[P], ColumnGroupByOutputType[P]>
        }
      >
    >


  export type ColumnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    tableId?: boolean
    width?: boolean
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: boolean
    format?: boolean
    order?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Cell?: boolean | Column$CellArgs<ExtArgs>
    Table?: boolean | TableDefaultArgs<ExtArgs>
    Filter?: boolean | Column$FilterArgs<ExtArgs>
    _count?: boolean | ColumnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["column"]>

  export type ColumnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    tableId?: boolean
    width?: boolean
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: boolean
    format?: boolean
    order?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["column"]>

  export type ColumnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    tableId?: boolean
    width?: boolean
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: boolean
    format?: boolean
    order?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["column"]>

  export type ColumnSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    tableId?: boolean
    width?: boolean
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: boolean
    format?: boolean
    order?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ColumnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "tableId" | "width" | "isRequired" | "isFilterable" | "isSummable" | "defaultValue" | "format" | "order" | "options" | "createdAt" | "updatedAt", ExtArgs["result"]["column"]>
  export type ColumnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cell?: boolean | Column$CellArgs<ExtArgs>
    Table?: boolean | TableDefaultArgs<ExtArgs>
    Filter?: boolean | Column$FilterArgs<ExtArgs>
    _count?: boolean | ColumnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ColumnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }
  export type ColumnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }

  export type $ColumnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Column"
    objects: {
      Cell: Prisma.$CellPayload<ExtArgs>[]
      Table: Prisma.$TablePayload<ExtArgs>
      Filter: Prisma.$FilterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: $Enums.ColumnType
      tableId: number
      width: number | null
      isRequired: boolean
      isFilterable: boolean
      isSummable: boolean
      defaultValue: string | null
      format: string | null
      order: number
      options: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["column"]>
    composites: {}
  }

  type ColumnGetPayload<S extends boolean | null | undefined | ColumnDefaultArgs> = $Result.GetResult<Prisma.$ColumnPayload, S>

  type ColumnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ColumnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ColumnCountAggregateInputType | true
    }

  export interface ColumnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Column'], meta: { name: 'Column' } }
    /**
     * Find zero or one Column that matches the filter.
     * @param {ColumnFindUniqueArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ColumnFindUniqueArgs>(args: SelectSubset<T, ColumnFindUniqueArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Column that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ColumnFindUniqueOrThrowArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ColumnFindUniqueOrThrowArgs>(args: SelectSubset<T, ColumnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Column that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnFindFirstArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ColumnFindFirstArgs>(args?: SelectSubset<T, ColumnFindFirstArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Column that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnFindFirstOrThrowArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ColumnFindFirstOrThrowArgs>(args?: SelectSubset<T, ColumnFindFirstOrThrowArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Columns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Columns
     * const columns = await prisma.column.findMany()
     * 
     * // Get first 10 Columns
     * const columns = await prisma.column.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const columnWithIdOnly = await prisma.column.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ColumnFindManyArgs>(args?: SelectSubset<T, ColumnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Column.
     * @param {ColumnCreateArgs} args - Arguments to create a Column.
     * @example
     * // Create one Column
     * const Column = await prisma.column.create({
     *   data: {
     *     // ... data to create a Column
     *   }
     * })
     * 
     */
    create<T extends ColumnCreateArgs>(args: SelectSubset<T, ColumnCreateArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Columns.
     * @param {ColumnCreateManyArgs} args - Arguments to create many Columns.
     * @example
     * // Create many Columns
     * const column = await prisma.column.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ColumnCreateManyArgs>(args?: SelectSubset<T, ColumnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Columns and returns the data saved in the database.
     * @param {ColumnCreateManyAndReturnArgs} args - Arguments to create many Columns.
     * @example
     * // Create many Columns
     * const column = await prisma.column.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Columns and only return the `id`
     * const columnWithIdOnly = await prisma.column.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ColumnCreateManyAndReturnArgs>(args?: SelectSubset<T, ColumnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Column.
     * @param {ColumnDeleteArgs} args - Arguments to delete one Column.
     * @example
     * // Delete one Column
     * const Column = await prisma.column.delete({
     *   where: {
     *     // ... filter to delete one Column
     *   }
     * })
     * 
     */
    delete<T extends ColumnDeleteArgs>(args: SelectSubset<T, ColumnDeleteArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Column.
     * @param {ColumnUpdateArgs} args - Arguments to update one Column.
     * @example
     * // Update one Column
     * const column = await prisma.column.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ColumnUpdateArgs>(args: SelectSubset<T, ColumnUpdateArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Columns.
     * @param {ColumnDeleteManyArgs} args - Arguments to filter Columns to delete.
     * @example
     * // Delete a few Columns
     * const { count } = await prisma.column.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ColumnDeleteManyArgs>(args?: SelectSubset<T, ColumnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Columns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Columns
     * const column = await prisma.column.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ColumnUpdateManyArgs>(args: SelectSubset<T, ColumnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Columns and returns the data updated in the database.
     * @param {ColumnUpdateManyAndReturnArgs} args - Arguments to update many Columns.
     * @example
     * // Update many Columns
     * const column = await prisma.column.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Columns and only return the `id`
     * const columnWithIdOnly = await prisma.column.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ColumnUpdateManyAndReturnArgs>(args: SelectSubset<T, ColumnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Column.
     * @param {ColumnUpsertArgs} args - Arguments to update or create a Column.
     * @example
     * // Update or create a Column
     * const column = await prisma.column.upsert({
     *   create: {
     *     // ... data to create a Column
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Column we want to update
     *   }
     * })
     */
    upsert<T extends ColumnUpsertArgs>(args: SelectSubset<T, ColumnUpsertArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Columns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnCountArgs} args - Arguments to filter Columns to count.
     * @example
     * // Count the number of Columns
     * const count = await prisma.column.count({
     *   where: {
     *     // ... the filter for the Columns we want to count
     *   }
     * })
    **/
    count<T extends ColumnCountArgs>(
      args?: Subset<T, ColumnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColumnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Column.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColumnAggregateArgs>(args: Subset<T, ColumnAggregateArgs>): Prisma.PrismaPromise<GetColumnAggregateType<T>>

    /**
     * Group by Column.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ColumnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColumnGroupByArgs['orderBy'] }
        : { orderBy?: ColumnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ColumnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColumnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Column model
   */
  readonly fields: ColumnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Column.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColumnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Cell<T extends Column$CellArgs<ExtArgs> = {}>(args?: Subset<T, Column$CellArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Table<T extends TableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TableDefaultArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Filter<T extends Column$FilterArgs<ExtArgs> = {}>(args?: Subset<T, Column$FilterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Column model
   */
  interface ColumnFieldRefs {
    readonly id: FieldRef<"Column", 'Int'>
    readonly name: FieldRef<"Column", 'String'>
    readonly type: FieldRef<"Column", 'ColumnType'>
    readonly tableId: FieldRef<"Column", 'Int'>
    readonly width: FieldRef<"Column", 'Int'>
    readonly isRequired: FieldRef<"Column", 'Boolean'>
    readonly isFilterable: FieldRef<"Column", 'Boolean'>
    readonly isSummable: FieldRef<"Column", 'Boolean'>
    readonly defaultValue: FieldRef<"Column", 'String'>
    readonly format: FieldRef<"Column", 'String'>
    readonly order: FieldRef<"Column", 'Int'>
    readonly options: FieldRef<"Column", 'Json'>
    readonly createdAt: FieldRef<"Column", 'DateTime'>
    readonly updatedAt: FieldRef<"Column", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Column findUnique
   */
  export type ColumnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column findUniqueOrThrow
   */
  export type ColumnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column findFirst
   */
  export type ColumnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Columns.
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Columns.
     */
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Column findFirstOrThrow
   */
  export type ColumnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Columns.
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Columns.
     */
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Column findMany
   */
  export type ColumnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Columns to fetch.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Columns.
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Column create
   */
  export type ColumnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * The data needed to create a Column.
     */
    data: XOR<ColumnCreateInput, ColumnUncheckedCreateInput>
  }

  /**
   * Column createMany
   */
  export type ColumnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Columns.
     */
    data: ColumnCreateManyInput | ColumnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Column createManyAndReturn
   */
  export type ColumnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * The data used to create many Columns.
     */
    data: ColumnCreateManyInput | ColumnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Column update
   */
  export type ColumnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * The data needed to update a Column.
     */
    data: XOR<ColumnUpdateInput, ColumnUncheckedUpdateInput>
    /**
     * Choose, which Column to update.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column updateMany
   */
  export type ColumnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Columns.
     */
    data: XOR<ColumnUpdateManyMutationInput, ColumnUncheckedUpdateManyInput>
    /**
     * Filter which Columns to update
     */
    where?: ColumnWhereInput
    /**
     * Limit how many Columns to update.
     */
    limit?: number
  }

  /**
   * Column updateManyAndReturn
   */
  export type ColumnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * The data used to update Columns.
     */
    data: XOR<ColumnUpdateManyMutationInput, ColumnUncheckedUpdateManyInput>
    /**
     * Filter which Columns to update
     */
    where?: ColumnWhereInput
    /**
     * Limit how many Columns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Column upsert
   */
  export type ColumnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * The filter to search for the Column to update in case it exists.
     */
    where: ColumnWhereUniqueInput
    /**
     * In case the Column found by the `where` argument doesn't exist, create a new Column with this data.
     */
    create: XOR<ColumnCreateInput, ColumnUncheckedCreateInput>
    /**
     * In case the Column was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColumnUpdateInput, ColumnUncheckedUpdateInput>
  }

  /**
   * Column delete
   */
  export type ColumnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter which Column to delete.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column deleteMany
   */
  export type ColumnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Columns to delete
     */
    where?: ColumnWhereInput
    /**
     * Limit how many Columns to delete.
     */
    limit?: number
  }

  /**
   * Column.Cell
   */
  export type Column$CellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
    where?: CellWhereInput
    orderBy?: CellOrderByWithRelationInput | CellOrderByWithRelationInput[]
    cursor?: CellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CellScalarFieldEnum | CellScalarFieldEnum[]
  }

  /**
   * Column.Filter
   */
  export type Column$FilterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    where?: FilterWhereInput
    orderBy?: FilterOrderByWithRelationInput | FilterOrderByWithRelationInput[]
    cursor?: FilterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilterScalarFieldEnum | FilterScalarFieldEnum[]
  }

  /**
   * Column without action
   */
  export type ColumnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    cellId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    cellId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    cellId: number | null
    text: string | null
    author: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    cellId: number | null
    text: string | null
    author: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    cellId: number
    text: number
    author: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    cellId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    cellId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    cellId?: true
    text?: true
    author?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    cellId?: true
    text?: true
    author?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    cellId?: true
    text?: true
    author?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    cellId: number
    text: string
    author: string | null
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cellId?: boolean
    text?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Cell?: boolean | CellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cellId?: boolean
    text?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Cell?: boolean | CellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cellId?: boolean
    text?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Cell?: boolean | CellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    cellId?: boolean
    text?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cellId" | "text" | "author" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cell?: boolean | CellDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cell?: boolean | CellDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cell?: boolean | CellDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      Cell: Prisma.$CellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cellId: number
      text: string
      author: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Cell<T extends CellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CellDefaultArgs<ExtArgs>>): Prisma__CellClient<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly cellId: FieldRef<"Comment", 'Int'>
    readonly text: FieldRef<"Comment", 'String'>
    readonly author: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Filter
   */

  export type AggregateFilter = {
    _count: FilterCountAggregateOutputType | null
    _avg: FilterAvgAggregateOutputType | null
    _sum: FilterSumAggregateOutputType | null
    _min: FilterMinAggregateOutputType | null
    _max: FilterMaxAggregateOutputType | null
  }

  export type FilterAvgAggregateOutputType = {
    id: number | null
    tableId: number | null
    columnId: number | null
  }

  export type FilterSumAggregateOutputType = {
    id: number | null
    tableId: number | null
    columnId: number | null
  }

  export type FilterMinAggregateOutputType = {
    id: number | null
    name: string | null
    tableId: number | null
    columnId: number | null
    operator: $Enums.FilterOperator | null
    value: string | null
    secondValue: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FilterMaxAggregateOutputType = {
    id: number | null
    name: string | null
    tableId: number | null
    columnId: number | null
    operator: $Enums.FilterOperator | null
    value: string | null
    secondValue: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FilterCountAggregateOutputType = {
    id: number
    name: number
    tableId: number
    columnId: number
    operator: number
    value: number
    secondValue: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FilterAvgAggregateInputType = {
    id?: true
    tableId?: true
    columnId?: true
  }

  export type FilterSumAggregateInputType = {
    id?: true
    tableId?: true
    columnId?: true
  }

  export type FilterMinAggregateInputType = {
    id?: true
    name?: true
    tableId?: true
    columnId?: true
    operator?: true
    value?: true
    secondValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FilterMaxAggregateInputType = {
    id?: true
    name?: true
    tableId?: true
    columnId?: true
    operator?: true
    value?: true
    secondValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FilterCountAggregateInputType = {
    id?: true
    name?: true
    tableId?: true
    columnId?: true
    operator?: true
    value?: true
    secondValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FilterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Filter to aggregate.
     */
    where?: FilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filters to fetch.
     */
    orderBy?: FilterOrderByWithRelationInput | FilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Filters
    **/
    _count?: true | FilterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilterMaxAggregateInputType
  }

  export type GetFilterAggregateType<T extends FilterAggregateArgs> = {
        [P in keyof T & keyof AggregateFilter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilter[P]>
      : GetScalarType<T[P], AggregateFilter[P]>
  }




  export type FilterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilterWhereInput
    orderBy?: FilterOrderByWithAggregationInput | FilterOrderByWithAggregationInput[]
    by: FilterScalarFieldEnum[] | FilterScalarFieldEnum
    having?: FilterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilterCountAggregateInputType | true
    _avg?: FilterAvgAggregateInputType
    _sum?: FilterSumAggregateInputType
    _min?: FilterMinAggregateInputType
    _max?: FilterMaxAggregateInputType
  }

  export type FilterGroupByOutputType = {
    id: number
    name: string
    tableId: number
    columnId: number
    operator: $Enums.FilterOperator
    value: string | null
    secondValue: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: FilterCountAggregateOutputType | null
    _avg: FilterAvgAggregateOutputType | null
    _sum: FilterSumAggregateOutputType | null
    _min: FilterMinAggregateOutputType | null
    _max: FilterMaxAggregateOutputType | null
  }

  type GetFilterGroupByPayload<T extends FilterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilterGroupByOutputType[P]>
            : GetScalarType<T[P], FilterGroupByOutputType[P]>
        }
      >
    >


  export type FilterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tableId?: boolean
    columnId?: boolean
    operator?: boolean
    value?: boolean
    secondValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filter"]>

  export type FilterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tableId?: boolean
    columnId?: boolean
    operator?: boolean
    value?: boolean
    secondValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filter"]>

  export type FilterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tableId?: boolean
    columnId?: boolean
    operator?: boolean
    value?: boolean
    secondValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filter"]>

  export type FilterSelectScalar = {
    id?: boolean
    name?: boolean
    tableId?: boolean
    columnId?: boolean
    operator?: boolean
    value?: boolean
    secondValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FilterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "tableId" | "columnId" | "operator" | "value" | "secondValue" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["filter"]>
  export type FilterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }
  export type FilterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }
  export type FilterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Column?: boolean | ColumnDefaultArgs<ExtArgs>
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }

  export type $FilterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Filter"
    objects: {
      Column: Prisma.$ColumnPayload<ExtArgs>
      Table: Prisma.$TablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      tableId: number
      columnId: number
      operator: $Enums.FilterOperator
      value: string | null
      secondValue: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["filter"]>
    composites: {}
  }

  type FilterGetPayload<S extends boolean | null | undefined | FilterDefaultArgs> = $Result.GetResult<Prisma.$FilterPayload, S>

  type FilterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FilterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FilterCountAggregateInputType | true
    }

  export interface FilterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Filter'], meta: { name: 'Filter' } }
    /**
     * Find zero or one Filter that matches the filter.
     * @param {FilterFindUniqueArgs} args - Arguments to find a Filter
     * @example
     * // Get one Filter
     * const filter = await prisma.filter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilterFindUniqueArgs>(args: SelectSubset<T, FilterFindUniqueArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Filter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FilterFindUniqueOrThrowArgs} args - Arguments to find a Filter
     * @example
     * // Get one Filter
     * const filter = await prisma.filter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilterFindUniqueOrThrowArgs>(args: SelectSubset<T, FilterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Filter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterFindFirstArgs} args - Arguments to find a Filter
     * @example
     * // Get one Filter
     * const filter = await prisma.filter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilterFindFirstArgs>(args?: SelectSubset<T, FilterFindFirstArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Filter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterFindFirstOrThrowArgs} args - Arguments to find a Filter
     * @example
     * // Get one Filter
     * const filter = await prisma.filter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilterFindFirstOrThrowArgs>(args?: SelectSubset<T, FilterFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Filters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Filters
     * const filters = await prisma.filter.findMany()
     * 
     * // Get first 10 Filters
     * const filters = await prisma.filter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filterWithIdOnly = await prisma.filter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilterFindManyArgs>(args?: SelectSubset<T, FilterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Filter.
     * @param {FilterCreateArgs} args - Arguments to create a Filter.
     * @example
     * // Create one Filter
     * const Filter = await prisma.filter.create({
     *   data: {
     *     // ... data to create a Filter
     *   }
     * })
     * 
     */
    create<T extends FilterCreateArgs>(args: SelectSubset<T, FilterCreateArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Filters.
     * @param {FilterCreateManyArgs} args - Arguments to create many Filters.
     * @example
     * // Create many Filters
     * const filter = await prisma.filter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilterCreateManyArgs>(args?: SelectSubset<T, FilterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Filters and returns the data saved in the database.
     * @param {FilterCreateManyAndReturnArgs} args - Arguments to create many Filters.
     * @example
     * // Create many Filters
     * const filter = await prisma.filter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Filters and only return the `id`
     * const filterWithIdOnly = await prisma.filter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FilterCreateManyAndReturnArgs>(args?: SelectSubset<T, FilterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Filter.
     * @param {FilterDeleteArgs} args - Arguments to delete one Filter.
     * @example
     * // Delete one Filter
     * const Filter = await prisma.filter.delete({
     *   where: {
     *     // ... filter to delete one Filter
     *   }
     * })
     * 
     */
    delete<T extends FilterDeleteArgs>(args: SelectSubset<T, FilterDeleteArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Filter.
     * @param {FilterUpdateArgs} args - Arguments to update one Filter.
     * @example
     * // Update one Filter
     * const filter = await prisma.filter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilterUpdateArgs>(args: SelectSubset<T, FilterUpdateArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Filters.
     * @param {FilterDeleteManyArgs} args - Arguments to filter Filters to delete.
     * @example
     * // Delete a few Filters
     * const { count } = await prisma.filter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilterDeleteManyArgs>(args?: SelectSubset<T, FilterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Filters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Filters
     * const filter = await prisma.filter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilterUpdateManyArgs>(args: SelectSubset<T, FilterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Filters and returns the data updated in the database.
     * @param {FilterUpdateManyAndReturnArgs} args - Arguments to update many Filters.
     * @example
     * // Update many Filters
     * const filter = await prisma.filter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Filters and only return the `id`
     * const filterWithIdOnly = await prisma.filter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FilterUpdateManyAndReturnArgs>(args: SelectSubset<T, FilterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Filter.
     * @param {FilterUpsertArgs} args - Arguments to update or create a Filter.
     * @example
     * // Update or create a Filter
     * const filter = await prisma.filter.upsert({
     *   create: {
     *     // ... data to create a Filter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Filter we want to update
     *   }
     * })
     */
    upsert<T extends FilterUpsertArgs>(args: SelectSubset<T, FilterUpsertArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Filters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterCountArgs} args - Arguments to filter Filters to count.
     * @example
     * // Count the number of Filters
     * const count = await prisma.filter.count({
     *   where: {
     *     // ... the filter for the Filters we want to count
     *   }
     * })
    **/
    count<T extends FilterCountArgs>(
      args?: Subset<T, FilterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilterAggregateArgs>(args: Subset<T, FilterAggregateArgs>): Prisma.PrismaPromise<GetFilterAggregateType<T>>

    /**
     * Group by Filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilterGroupByArgs['orderBy'] }
        : { orderBy?: FilterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Filter model
   */
  readonly fields: FilterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Filter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Column<T extends ColumnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ColumnDefaultArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Table<T extends TableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TableDefaultArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Filter model
   */
  interface FilterFieldRefs {
    readonly id: FieldRef<"Filter", 'Int'>
    readonly name: FieldRef<"Filter", 'String'>
    readonly tableId: FieldRef<"Filter", 'Int'>
    readonly columnId: FieldRef<"Filter", 'Int'>
    readonly operator: FieldRef<"Filter", 'FilterOperator'>
    readonly value: FieldRef<"Filter", 'String'>
    readonly secondValue: FieldRef<"Filter", 'String'>
    readonly isActive: FieldRef<"Filter", 'Boolean'>
    readonly createdAt: FieldRef<"Filter", 'DateTime'>
    readonly updatedAt: FieldRef<"Filter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Filter findUnique
   */
  export type FilterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter, which Filter to fetch.
     */
    where: FilterWhereUniqueInput
  }

  /**
   * Filter findUniqueOrThrow
   */
  export type FilterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter, which Filter to fetch.
     */
    where: FilterWhereUniqueInput
  }

  /**
   * Filter findFirst
   */
  export type FilterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter, which Filter to fetch.
     */
    where?: FilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filters to fetch.
     */
    orderBy?: FilterOrderByWithRelationInput | FilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Filters.
     */
    cursor?: FilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Filters.
     */
    distinct?: FilterScalarFieldEnum | FilterScalarFieldEnum[]
  }

  /**
   * Filter findFirstOrThrow
   */
  export type FilterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter, which Filter to fetch.
     */
    where?: FilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filters to fetch.
     */
    orderBy?: FilterOrderByWithRelationInput | FilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Filters.
     */
    cursor?: FilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Filters.
     */
    distinct?: FilterScalarFieldEnum | FilterScalarFieldEnum[]
  }

  /**
   * Filter findMany
   */
  export type FilterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter, which Filters to fetch.
     */
    where?: FilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filters to fetch.
     */
    orderBy?: FilterOrderByWithRelationInput | FilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Filters.
     */
    cursor?: FilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filters.
     */
    skip?: number
    distinct?: FilterScalarFieldEnum | FilterScalarFieldEnum[]
  }

  /**
   * Filter create
   */
  export type FilterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * The data needed to create a Filter.
     */
    data: XOR<FilterCreateInput, FilterUncheckedCreateInput>
  }

  /**
   * Filter createMany
   */
  export type FilterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Filters.
     */
    data: FilterCreateManyInput | FilterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Filter createManyAndReturn
   */
  export type FilterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * The data used to create many Filters.
     */
    data: FilterCreateManyInput | FilterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Filter update
   */
  export type FilterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * The data needed to update a Filter.
     */
    data: XOR<FilterUpdateInput, FilterUncheckedUpdateInput>
    /**
     * Choose, which Filter to update.
     */
    where: FilterWhereUniqueInput
  }

  /**
   * Filter updateMany
   */
  export type FilterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Filters.
     */
    data: XOR<FilterUpdateManyMutationInput, FilterUncheckedUpdateManyInput>
    /**
     * Filter which Filters to update
     */
    where?: FilterWhereInput
    /**
     * Limit how many Filters to update.
     */
    limit?: number
  }

  /**
   * Filter updateManyAndReturn
   */
  export type FilterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * The data used to update Filters.
     */
    data: XOR<FilterUpdateManyMutationInput, FilterUncheckedUpdateManyInput>
    /**
     * Filter which Filters to update
     */
    where?: FilterWhereInput
    /**
     * Limit how many Filters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Filter upsert
   */
  export type FilterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * The filter to search for the Filter to update in case it exists.
     */
    where: FilterWhereUniqueInput
    /**
     * In case the Filter found by the `where` argument doesn't exist, create a new Filter with this data.
     */
    create: XOR<FilterCreateInput, FilterUncheckedCreateInput>
    /**
     * In case the Filter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilterUpdateInput, FilterUncheckedUpdateInput>
  }

  /**
   * Filter delete
   */
  export type FilterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter which Filter to delete.
     */
    where: FilterWhereUniqueInput
  }

  /**
   * Filter deleteMany
   */
  export type FilterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Filters to delete
     */
    where?: FilterWhereInput
    /**
     * Limit how many Filters to delete.
     */
    limit?: number
  }

  /**
   * Filter without action
   */
  export type FilterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
  }


  /**
   * Model FinRow
   */

  export type AggregateFinRow = {
    _count: FinRowCountAggregateOutputType | null
    _avg: FinRowAvgAggregateOutputType | null
    _sum: FinRowSumAggregateOutputType | null
    _min: FinRowMinAggregateOutputType | null
    _max: FinRowMaxAggregateOutputType | null
  }

  export type FinRowAvgAggregateOutputType = {
    id: number | null
    startBalance: number | null
    endBalance: number | null
    employeeId: number | null
    usdtAmount: number | null
    exchangeRate: number | null
  }

  export type FinRowSumAggregateOutputType = {
    id: number | null
    startBalance: number | null
    endBalance: number | null
    employeeId: number | null
    usdtAmount: number | null
    exchangeRate: number | null
  }

  export type FinRowMinAggregateOutputType = {
    id: number | null
    date: Date | null
    time: string | null
    shift: string | null
    startBalance: number | null
    endBalance: number | null
    employeeId: number | null
    usdtAmount: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
    section: $Enums.SalarySection | null
    exchangeRate: number | null
  }

  export type FinRowMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    time: string | null
    shift: string | null
    startBalance: number | null
    endBalance: number | null
    employeeId: number | null
    usdtAmount: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
    section: $Enums.SalarySection | null
    exchangeRate: number | null
  }

  export type FinRowCountAggregateOutputType = {
    id: number
    date: number
    time: number
    shift: number
    startBalance: number
    endBalance: number
    employeeId: number
    usdtAmount: number
    comment: number
    createdAt: number
    updatedAt: number
    currency: number
    section: number
    exchangeRate: number
    _all: number
  }


  export type FinRowAvgAggregateInputType = {
    id?: true
    startBalance?: true
    endBalance?: true
    employeeId?: true
    usdtAmount?: true
    exchangeRate?: true
  }

  export type FinRowSumAggregateInputType = {
    id?: true
    startBalance?: true
    endBalance?: true
    employeeId?: true
    usdtAmount?: true
    exchangeRate?: true
  }

  export type FinRowMinAggregateInputType = {
    id?: true
    date?: true
    time?: true
    shift?: true
    startBalance?: true
    endBalance?: true
    employeeId?: true
    usdtAmount?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    section?: true
    exchangeRate?: true
  }

  export type FinRowMaxAggregateInputType = {
    id?: true
    date?: true
    time?: true
    shift?: true
    startBalance?: true
    endBalance?: true
    employeeId?: true
    usdtAmount?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    section?: true
    exchangeRate?: true
  }

  export type FinRowCountAggregateInputType = {
    id?: true
    date?: true
    time?: true
    shift?: true
    startBalance?: true
    endBalance?: true
    employeeId?: true
    usdtAmount?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    section?: true
    exchangeRate?: true
    _all?: true
  }

  export type FinRowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinRow to aggregate.
     */
    where?: FinRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinRows to fetch.
     */
    orderBy?: FinRowOrderByWithRelationInput | FinRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinRows
    **/
    _count?: true | FinRowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinRowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinRowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinRowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinRowMaxAggregateInputType
  }

  export type GetFinRowAggregateType<T extends FinRowAggregateArgs> = {
        [P in keyof T & keyof AggregateFinRow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinRow[P]>
      : GetScalarType<T[P], AggregateFinRow[P]>
  }




  export type FinRowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinRowWhereInput
    orderBy?: FinRowOrderByWithAggregationInput | FinRowOrderByWithAggregationInput[]
    by: FinRowScalarFieldEnum[] | FinRowScalarFieldEnum
    having?: FinRowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinRowCountAggregateInputType | true
    _avg?: FinRowAvgAggregateInputType
    _sum?: FinRowSumAggregateInputType
    _min?: FinRowMinAggregateInputType
    _max?: FinRowMaxAggregateInputType
  }

  export type FinRowGroupByOutputType = {
    id: number
    date: Date
    time: string
    shift: string
    startBalance: number
    endBalance: number
    employeeId: number | null
    usdtAmount: number
    comment: string | null
    createdAt: Date
    updatedAt: Date
    currency: string
    section: $Enums.SalarySection
    exchangeRate: number | null
    _count: FinRowCountAggregateOutputType | null
    _avg: FinRowAvgAggregateOutputType | null
    _sum: FinRowSumAggregateOutputType | null
    _min: FinRowMinAggregateOutputType | null
    _max: FinRowMaxAggregateOutputType | null
  }

  type GetFinRowGroupByPayload<T extends FinRowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinRowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinRowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinRowGroupByOutputType[P]>
            : GetScalarType<T[P], FinRowGroupByOutputType[P]>
        }
      >
    >


  export type FinRowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    shift?: boolean
    startBalance?: boolean
    endBalance?: boolean
    employeeId?: boolean
    usdtAmount?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    section?: boolean
    exchangeRate?: boolean
    Salary?: boolean | FinRow$SalaryArgs<ExtArgs>
    FinRowExpense?: boolean | FinRow$FinRowExpenseArgs<ExtArgs>
    _count?: boolean | FinRowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finRow"]>

  export type FinRowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    shift?: boolean
    startBalance?: boolean
    endBalance?: boolean
    employeeId?: boolean
    usdtAmount?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    section?: boolean
    exchangeRate?: boolean
    Salary?: boolean | FinRow$SalaryArgs<ExtArgs>
  }, ExtArgs["result"]["finRow"]>

  export type FinRowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    shift?: boolean
    startBalance?: boolean
    endBalance?: boolean
    employeeId?: boolean
    usdtAmount?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    section?: boolean
    exchangeRate?: boolean
    Salary?: boolean | FinRow$SalaryArgs<ExtArgs>
  }, ExtArgs["result"]["finRow"]>

  export type FinRowSelectScalar = {
    id?: boolean
    date?: boolean
    time?: boolean
    shift?: boolean
    startBalance?: boolean
    endBalance?: boolean
    employeeId?: boolean
    usdtAmount?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    section?: boolean
    exchangeRate?: boolean
  }

  export type FinRowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "time" | "shift" | "startBalance" | "endBalance" | "employeeId" | "usdtAmount" | "comment" | "createdAt" | "updatedAt" | "currency" | "section" | "exchangeRate", ExtArgs["result"]["finRow"]>
  export type FinRowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | FinRow$SalaryArgs<ExtArgs>
    FinRowExpense?: boolean | FinRow$FinRowExpenseArgs<ExtArgs>
    _count?: boolean | FinRowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FinRowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | FinRow$SalaryArgs<ExtArgs>
  }
  export type FinRowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | FinRow$SalaryArgs<ExtArgs>
  }

  export type $FinRowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinRow"
    objects: {
      Salary: Prisma.$SalaryPayload<ExtArgs> | null
      FinRowExpense: Prisma.$FinRowExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      time: string
      shift: string
      startBalance: number
      endBalance: number
      employeeId: number | null
      usdtAmount: number
      comment: string | null
      createdAt: Date
      updatedAt: Date
      currency: string
      section: $Enums.SalarySection
      exchangeRate: number | null
    }, ExtArgs["result"]["finRow"]>
    composites: {}
  }

  type FinRowGetPayload<S extends boolean | null | undefined | FinRowDefaultArgs> = $Result.GetResult<Prisma.$FinRowPayload, S>

  type FinRowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinRowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinRowCountAggregateInputType | true
    }

  export interface FinRowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinRow'], meta: { name: 'FinRow' } }
    /**
     * Find zero or one FinRow that matches the filter.
     * @param {FinRowFindUniqueArgs} args - Arguments to find a FinRow
     * @example
     * // Get one FinRow
     * const finRow = await prisma.finRow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinRowFindUniqueArgs>(args: SelectSubset<T, FinRowFindUniqueArgs<ExtArgs>>): Prisma__FinRowClient<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinRow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinRowFindUniqueOrThrowArgs} args - Arguments to find a FinRow
     * @example
     * // Get one FinRow
     * const finRow = await prisma.finRow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinRowFindUniqueOrThrowArgs>(args: SelectSubset<T, FinRowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinRowClient<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinRow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowFindFirstArgs} args - Arguments to find a FinRow
     * @example
     * // Get one FinRow
     * const finRow = await prisma.finRow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinRowFindFirstArgs>(args?: SelectSubset<T, FinRowFindFirstArgs<ExtArgs>>): Prisma__FinRowClient<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinRow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowFindFirstOrThrowArgs} args - Arguments to find a FinRow
     * @example
     * // Get one FinRow
     * const finRow = await prisma.finRow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinRowFindFirstOrThrowArgs>(args?: SelectSubset<T, FinRowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinRowClient<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinRows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinRows
     * const finRows = await prisma.finRow.findMany()
     * 
     * // Get first 10 FinRows
     * const finRows = await prisma.finRow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const finRowWithIdOnly = await prisma.finRow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinRowFindManyArgs>(args?: SelectSubset<T, FinRowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinRow.
     * @param {FinRowCreateArgs} args - Arguments to create a FinRow.
     * @example
     * // Create one FinRow
     * const FinRow = await prisma.finRow.create({
     *   data: {
     *     // ... data to create a FinRow
     *   }
     * })
     * 
     */
    create<T extends FinRowCreateArgs>(args: SelectSubset<T, FinRowCreateArgs<ExtArgs>>): Prisma__FinRowClient<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinRows.
     * @param {FinRowCreateManyArgs} args - Arguments to create many FinRows.
     * @example
     * // Create many FinRows
     * const finRow = await prisma.finRow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinRowCreateManyArgs>(args?: SelectSubset<T, FinRowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinRows and returns the data saved in the database.
     * @param {FinRowCreateManyAndReturnArgs} args - Arguments to create many FinRows.
     * @example
     * // Create many FinRows
     * const finRow = await prisma.finRow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinRows and only return the `id`
     * const finRowWithIdOnly = await prisma.finRow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinRowCreateManyAndReturnArgs>(args?: SelectSubset<T, FinRowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinRow.
     * @param {FinRowDeleteArgs} args - Arguments to delete one FinRow.
     * @example
     * // Delete one FinRow
     * const FinRow = await prisma.finRow.delete({
     *   where: {
     *     // ... filter to delete one FinRow
     *   }
     * })
     * 
     */
    delete<T extends FinRowDeleteArgs>(args: SelectSubset<T, FinRowDeleteArgs<ExtArgs>>): Prisma__FinRowClient<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinRow.
     * @param {FinRowUpdateArgs} args - Arguments to update one FinRow.
     * @example
     * // Update one FinRow
     * const finRow = await prisma.finRow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinRowUpdateArgs>(args: SelectSubset<T, FinRowUpdateArgs<ExtArgs>>): Prisma__FinRowClient<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinRows.
     * @param {FinRowDeleteManyArgs} args - Arguments to filter FinRows to delete.
     * @example
     * // Delete a few FinRows
     * const { count } = await prisma.finRow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinRowDeleteManyArgs>(args?: SelectSubset<T, FinRowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinRows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinRows
     * const finRow = await prisma.finRow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinRowUpdateManyArgs>(args: SelectSubset<T, FinRowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinRows and returns the data updated in the database.
     * @param {FinRowUpdateManyAndReturnArgs} args - Arguments to update many FinRows.
     * @example
     * // Update many FinRows
     * const finRow = await prisma.finRow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinRows and only return the `id`
     * const finRowWithIdOnly = await prisma.finRow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinRowUpdateManyAndReturnArgs>(args: SelectSubset<T, FinRowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinRow.
     * @param {FinRowUpsertArgs} args - Arguments to update or create a FinRow.
     * @example
     * // Update or create a FinRow
     * const finRow = await prisma.finRow.upsert({
     *   create: {
     *     // ... data to create a FinRow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinRow we want to update
     *   }
     * })
     */
    upsert<T extends FinRowUpsertArgs>(args: SelectSubset<T, FinRowUpsertArgs<ExtArgs>>): Prisma__FinRowClient<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinRows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowCountArgs} args - Arguments to filter FinRows to count.
     * @example
     * // Count the number of FinRows
     * const count = await prisma.finRow.count({
     *   where: {
     *     // ... the filter for the FinRows we want to count
     *   }
     * })
    **/
    count<T extends FinRowCountArgs>(
      args?: Subset<T, FinRowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinRowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinRow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinRowAggregateArgs>(args: Subset<T, FinRowAggregateArgs>): Prisma.PrismaPromise<GetFinRowAggregateType<T>>

    /**
     * Group by FinRow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinRowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinRowGroupByArgs['orderBy'] }
        : { orderBy?: FinRowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinRowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinRowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinRow model
   */
  readonly fields: FinRowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinRow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinRowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Salary<T extends FinRow$SalaryArgs<ExtArgs> = {}>(args?: Subset<T, FinRow$SalaryArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    FinRowExpense<T extends FinRow$FinRowExpenseArgs<ExtArgs> = {}>(args?: Subset<T, FinRow$FinRowExpenseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinRow model
   */
  interface FinRowFieldRefs {
    readonly id: FieldRef<"FinRow", 'Int'>
    readonly date: FieldRef<"FinRow", 'DateTime'>
    readonly time: FieldRef<"FinRow", 'String'>
    readonly shift: FieldRef<"FinRow", 'String'>
    readonly startBalance: FieldRef<"FinRow", 'Float'>
    readonly endBalance: FieldRef<"FinRow", 'Float'>
    readonly employeeId: FieldRef<"FinRow", 'Int'>
    readonly usdtAmount: FieldRef<"FinRow", 'Float'>
    readonly comment: FieldRef<"FinRow", 'String'>
    readonly createdAt: FieldRef<"FinRow", 'DateTime'>
    readonly updatedAt: FieldRef<"FinRow", 'DateTime'>
    readonly currency: FieldRef<"FinRow", 'String'>
    readonly section: FieldRef<"FinRow", 'SalarySection'>
    readonly exchangeRate: FieldRef<"FinRow", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * FinRow findUnique
   */
  export type FinRowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
    /**
     * Filter, which FinRow to fetch.
     */
    where: FinRowWhereUniqueInput
  }

  /**
   * FinRow findUniqueOrThrow
   */
  export type FinRowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
    /**
     * Filter, which FinRow to fetch.
     */
    where: FinRowWhereUniqueInput
  }

  /**
   * FinRow findFirst
   */
  export type FinRowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
    /**
     * Filter, which FinRow to fetch.
     */
    where?: FinRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinRows to fetch.
     */
    orderBy?: FinRowOrderByWithRelationInput | FinRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinRows.
     */
    cursor?: FinRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinRows.
     */
    distinct?: FinRowScalarFieldEnum | FinRowScalarFieldEnum[]
  }

  /**
   * FinRow findFirstOrThrow
   */
  export type FinRowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
    /**
     * Filter, which FinRow to fetch.
     */
    where?: FinRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinRows to fetch.
     */
    orderBy?: FinRowOrderByWithRelationInput | FinRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinRows.
     */
    cursor?: FinRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinRows.
     */
    distinct?: FinRowScalarFieldEnum | FinRowScalarFieldEnum[]
  }

  /**
   * FinRow findMany
   */
  export type FinRowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
    /**
     * Filter, which FinRows to fetch.
     */
    where?: FinRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinRows to fetch.
     */
    orderBy?: FinRowOrderByWithRelationInput | FinRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinRows.
     */
    cursor?: FinRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinRows.
     */
    skip?: number
    distinct?: FinRowScalarFieldEnum | FinRowScalarFieldEnum[]
  }

  /**
   * FinRow create
   */
  export type FinRowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
    /**
     * The data needed to create a FinRow.
     */
    data: XOR<FinRowCreateInput, FinRowUncheckedCreateInput>
  }

  /**
   * FinRow createMany
   */
  export type FinRowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinRows.
     */
    data: FinRowCreateManyInput | FinRowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinRow createManyAndReturn
   */
  export type FinRowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * The data used to create many FinRows.
     */
    data: FinRowCreateManyInput | FinRowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinRow update
   */
  export type FinRowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
    /**
     * The data needed to update a FinRow.
     */
    data: XOR<FinRowUpdateInput, FinRowUncheckedUpdateInput>
    /**
     * Choose, which FinRow to update.
     */
    where: FinRowWhereUniqueInput
  }

  /**
   * FinRow updateMany
   */
  export type FinRowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinRows.
     */
    data: XOR<FinRowUpdateManyMutationInput, FinRowUncheckedUpdateManyInput>
    /**
     * Filter which FinRows to update
     */
    where?: FinRowWhereInput
    /**
     * Limit how many FinRows to update.
     */
    limit?: number
  }

  /**
   * FinRow updateManyAndReturn
   */
  export type FinRowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * The data used to update FinRows.
     */
    data: XOR<FinRowUpdateManyMutationInput, FinRowUncheckedUpdateManyInput>
    /**
     * Filter which FinRows to update
     */
    where?: FinRowWhereInput
    /**
     * Limit how many FinRows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinRow upsert
   */
  export type FinRowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
    /**
     * The filter to search for the FinRow to update in case it exists.
     */
    where: FinRowWhereUniqueInput
    /**
     * In case the FinRow found by the `where` argument doesn't exist, create a new FinRow with this data.
     */
    create: XOR<FinRowCreateInput, FinRowUncheckedCreateInput>
    /**
     * In case the FinRow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinRowUpdateInput, FinRowUncheckedUpdateInput>
  }

  /**
   * FinRow delete
   */
  export type FinRowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
    /**
     * Filter which FinRow to delete.
     */
    where: FinRowWhereUniqueInput
  }

  /**
   * FinRow deleteMany
   */
  export type FinRowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinRows to delete
     */
    where?: FinRowWhereInput
    /**
     * Limit how many FinRows to delete.
     */
    limit?: number
  }

  /**
   * FinRow.Salary
   */
  export type FinRow$SalaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    where?: SalaryWhereInput
  }

  /**
   * FinRow.FinRowExpense
   */
  export type FinRow$FinRowExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseInclude<ExtArgs> | null
    where?: FinRowExpenseWhereInput
    orderBy?: FinRowExpenseOrderByWithRelationInput | FinRowExpenseOrderByWithRelationInput[]
    cursor?: FinRowExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinRowExpenseScalarFieldEnum | FinRowExpenseScalarFieldEnum[]
  }

  /**
   * FinRow without action
   */
  export type FinRowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
  }


  /**
   * Model FinRowExpense
   */

  export type AggregateFinRowExpense = {
    _count: FinRowExpenseCountAggregateOutputType | null
    _avg: FinRowExpenseAvgAggregateOutputType | null
    _sum: FinRowExpenseSumAggregateOutputType | null
    _min: FinRowExpenseMinAggregateOutputType | null
    _max: FinRowExpenseMaxAggregateOutputType | null
  }

  export type FinRowExpenseAvgAggregateOutputType = {
    id: number | null
    finRowId: number | null
    amount: number | null
  }

  export type FinRowExpenseSumAggregateOutputType = {
    id: number | null
    finRowId: number | null
    amount: number | null
  }

  export type FinRowExpenseMinAggregateOutputType = {
    id: number | null
    finRowId: number | null
    expenseType: string | null
    amount: number | null
    date: Date | null
    time: string | null
    period: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
    section: $Enums.SalarySection | null
  }

  export type FinRowExpenseMaxAggregateOutputType = {
    id: number | null
    finRowId: number | null
    expenseType: string | null
    amount: number | null
    date: Date | null
    time: string | null
    period: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
    section: $Enums.SalarySection | null
  }

  export type FinRowExpenseCountAggregateOutputType = {
    id: number
    finRowId: number
    expenseType: number
    amount: number
    date: number
    time: number
    period: number
    description: number
    createdAt: number
    updatedAt: number
    currency: number
    section: number
    _all: number
  }


  export type FinRowExpenseAvgAggregateInputType = {
    id?: true
    finRowId?: true
    amount?: true
  }

  export type FinRowExpenseSumAggregateInputType = {
    id?: true
    finRowId?: true
    amount?: true
  }

  export type FinRowExpenseMinAggregateInputType = {
    id?: true
    finRowId?: true
    expenseType?: true
    amount?: true
    date?: true
    time?: true
    period?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    section?: true
  }

  export type FinRowExpenseMaxAggregateInputType = {
    id?: true
    finRowId?: true
    expenseType?: true
    amount?: true
    date?: true
    time?: true
    period?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    section?: true
  }

  export type FinRowExpenseCountAggregateInputType = {
    id?: true
    finRowId?: true
    expenseType?: true
    amount?: true
    date?: true
    time?: true
    period?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    section?: true
    _all?: true
  }

  export type FinRowExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinRowExpense to aggregate.
     */
    where?: FinRowExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinRowExpenses to fetch.
     */
    orderBy?: FinRowExpenseOrderByWithRelationInput | FinRowExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinRowExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinRowExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinRowExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinRowExpenses
    **/
    _count?: true | FinRowExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinRowExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinRowExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinRowExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinRowExpenseMaxAggregateInputType
  }

  export type GetFinRowExpenseAggregateType<T extends FinRowExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateFinRowExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinRowExpense[P]>
      : GetScalarType<T[P], AggregateFinRowExpense[P]>
  }




  export type FinRowExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinRowExpenseWhereInput
    orderBy?: FinRowExpenseOrderByWithAggregationInput | FinRowExpenseOrderByWithAggregationInput[]
    by: FinRowExpenseScalarFieldEnum[] | FinRowExpenseScalarFieldEnum
    having?: FinRowExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinRowExpenseCountAggregateInputType | true
    _avg?: FinRowExpenseAvgAggregateInputType
    _sum?: FinRowExpenseSumAggregateInputType
    _min?: FinRowExpenseMinAggregateInputType
    _max?: FinRowExpenseMaxAggregateInputType
  }

  export type FinRowExpenseGroupByOutputType = {
    id: number
    finRowId: number | null
    expenseType: string
    amount: number
    date: Date
    time: string
    period: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    currency: string
    section: $Enums.SalarySection
    _count: FinRowExpenseCountAggregateOutputType | null
    _avg: FinRowExpenseAvgAggregateOutputType | null
    _sum: FinRowExpenseSumAggregateOutputType | null
    _min: FinRowExpenseMinAggregateOutputType | null
    _max: FinRowExpenseMaxAggregateOutputType | null
  }

  type GetFinRowExpenseGroupByPayload<T extends FinRowExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinRowExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinRowExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinRowExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], FinRowExpenseGroupByOutputType[P]>
        }
      >
    >


  export type FinRowExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    finRowId?: boolean
    expenseType?: boolean
    amount?: boolean
    date?: boolean
    time?: boolean
    period?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    section?: boolean
    FinRow?: boolean | FinRowExpense$FinRowArgs<ExtArgs>
  }, ExtArgs["result"]["finRowExpense"]>

  export type FinRowExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    finRowId?: boolean
    expenseType?: boolean
    amount?: boolean
    date?: boolean
    time?: boolean
    period?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    section?: boolean
    FinRow?: boolean | FinRowExpense$FinRowArgs<ExtArgs>
  }, ExtArgs["result"]["finRowExpense"]>

  export type FinRowExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    finRowId?: boolean
    expenseType?: boolean
    amount?: boolean
    date?: boolean
    time?: boolean
    period?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    section?: boolean
    FinRow?: boolean | FinRowExpense$FinRowArgs<ExtArgs>
  }, ExtArgs["result"]["finRowExpense"]>

  export type FinRowExpenseSelectScalar = {
    id?: boolean
    finRowId?: boolean
    expenseType?: boolean
    amount?: boolean
    date?: boolean
    time?: boolean
    period?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    section?: boolean
  }

  export type FinRowExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "finRowId" | "expenseType" | "amount" | "date" | "time" | "period" | "description" | "createdAt" | "updatedAt" | "currency" | "section", ExtArgs["result"]["finRowExpense"]>
  export type FinRowExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FinRow?: boolean | FinRowExpense$FinRowArgs<ExtArgs>
  }
  export type FinRowExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FinRow?: boolean | FinRowExpense$FinRowArgs<ExtArgs>
  }
  export type FinRowExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FinRow?: boolean | FinRowExpense$FinRowArgs<ExtArgs>
  }

  export type $FinRowExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinRowExpense"
    objects: {
      FinRow: Prisma.$FinRowPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      finRowId: number | null
      expenseType: string
      amount: number
      date: Date
      time: string
      period: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      currency: string
      section: $Enums.SalarySection
    }, ExtArgs["result"]["finRowExpense"]>
    composites: {}
  }

  type FinRowExpenseGetPayload<S extends boolean | null | undefined | FinRowExpenseDefaultArgs> = $Result.GetResult<Prisma.$FinRowExpensePayload, S>

  type FinRowExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinRowExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinRowExpenseCountAggregateInputType | true
    }

  export interface FinRowExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinRowExpense'], meta: { name: 'FinRowExpense' } }
    /**
     * Find zero or one FinRowExpense that matches the filter.
     * @param {FinRowExpenseFindUniqueArgs} args - Arguments to find a FinRowExpense
     * @example
     * // Get one FinRowExpense
     * const finRowExpense = await prisma.finRowExpense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinRowExpenseFindUniqueArgs>(args: SelectSubset<T, FinRowExpenseFindUniqueArgs<ExtArgs>>): Prisma__FinRowExpenseClient<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinRowExpense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinRowExpenseFindUniqueOrThrowArgs} args - Arguments to find a FinRowExpense
     * @example
     * // Get one FinRowExpense
     * const finRowExpense = await prisma.finRowExpense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinRowExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, FinRowExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinRowExpenseClient<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinRowExpense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowExpenseFindFirstArgs} args - Arguments to find a FinRowExpense
     * @example
     * // Get one FinRowExpense
     * const finRowExpense = await prisma.finRowExpense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinRowExpenseFindFirstArgs>(args?: SelectSubset<T, FinRowExpenseFindFirstArgs<ExtArgs>>): Prisma__FinRowExpenseClient<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinRowExpense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowExpenseFindFirstOrThrowArgs} args - Arguments to find a FinRowExpense
     * @example
     * // Get one FinRowExpense
     * const finRowExpense = await prisma.finRowExpense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinRowExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, FinRowExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinRowExpenseClient<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinRowExpenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinRowExpenses
     * const finRowExpenses = await prisma.finRowExpense.findMany()
     * 
     * // Get first 10 FinRowExpenses
     * const finRowExpenses = await prisma.finRowExpense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const finRowExpenseWithIdOnly = await prisma.finRowExpense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinRowExpenseFindManyArgs>(args?: SelectSubset<T, FinRowExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinRowExpense.
     * @param {FinRowExpenseCreateArgs} args - Arguments to create a FinRowExpense.
     * @example
     * // Create one FinRowExpense
     * const FinRowExpense = await prisma.finRowExpense.create({
     *   data: {
     *     // ... data to create a FinRowExpense
     *   }
     * })
     * 
     */
    create<T extends FinRowExpenseCreateArgs>(args: SelectSubset<T, FinRowExpenseCreateArgs<ExtArgs>>): Prisma__FinRowExpenseClient<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinRowExpenses.
     * @param {FinRowExpenseCreateManyArgs} args - Arguments to create many FinRowExpenses.
     * @example
     * // Create many FinRowExpenses
     * const finRowExpense = await prisma.finRowExpense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinRowExpenseCreateManyArgs>(args?: SelectSubset<T, FinRowExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinRowExpenses and returns the data saved in the database.
     * @param {FinRowExpenseCreateManyAndReturnArgs} args - Arguments to create many FinRowExpenses.
     * @example
     * // Create many FinRowExpenses
     * const finRowExpense = await prisma.finRowExpense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinRowExpenses and only return the `id`
     * const finRowExpenseWithIdOnly = await prisma.finRowExpense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinRowExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, FinRowExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinRowExpense.
     * @param {FinRowExpenseDeleteArgs} args - Arguments to delete one FinRowExpense.
     * @example
     * // Delete one FinRowExpense
     * const FinRowExpense = await prisma.finRowExpense.delete({
     *   where: {
     *     // ... filter to delete one FinRowExpense
     *   }
     * })
     * 
     */
    delete<T extends FinRowExpenseDeleteArgs>(args: SelectSubset<T, FinRowExpenseDeleteArgs<ExtArgs>>): Prisma__FinRowExpenseClient<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinRowExpense.
     * @param {FinRowExpenseUpdateArgs} args - Arguments to update one FinRowExpense.
     * @example
     * // Update one FinRowExpense
     * const finRowExpense = await prisma.finRowExpense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinRowExpenseUpdateArgs>(args: SelectSubset<T, FinRowExpenseUpdateArgs<ExtArgs>>): Prisma__FinRowExpenseClient<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinRowExpenses.
     * @param {FinRowExpenseDeleteManyArgs} args - Arguments to filter FinRowExpenses to delete.
     * @example
     * // Delete a few FinRowExpenses
     * const { count } = await prisma.finRowExpense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinRowExpenseDeleteManyArgs>(args?: SelectSubset<T, FinRowExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinRowExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinRowExpenses
     * const finRowExpense = await prisma.finRowExpense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinRowExpenseUpdateManyArgs>(args: SelectSubset<T, FinRowExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinRowExpenses and returns the data updated in the database.
     * @param {FinRowExpenseUpdateManyAndReturnArgs} args - Arguments to update many FinRowExpenses.
     * @example
     * // Update many FinRowExpenses
     * const finRowExpense = await prisma.finRowExpense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinRowExpenses and only return the `id`
     * const finRowExpenseWithIdOnly = await prisma.finRowExpense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinRowExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, FinRowExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinRowExpense.
     * @param {FinRowExpenseUpsertArgs} args - Arguments to update or create a FinRowExpense.
     * @example
     * // Update or create a FinRowExpense
     * const finRowExpense = await prisma.finRowExpense.upsert({
     *   create: {
     *     // ... data to create a FinRowExpense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinRowExpense we want to update
     *   }
     * })
     */
    upsert<T extends FinRowExpenseUpsertArgs>(args: SelectSubset<T, FinRowExpenseUpsertArgs<ExtArgs>>): Prisma__FinRowExpenseClient<$Result.GetResult<Prisma.$FinRowExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinRowExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowExpenseCountArgs} args - Arguments to filter FinRowExpenses to count.
     * @example
     * // Count the number of FinRowExpenses
     * const count = await prisma.finRowExpense.count({
     *   where: {
     *     // ... the filter for the FinRowExpenses we want to count
     *   }
     * })
    **/
    count<T extends FinRowExpenseCountArgs>(
      args?: Subset<T, FinRowExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinRowExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinRowExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinRowExpenseAggregateArgs>(args: Subset<T, FinRowExpenseAggregateArgs>): Prisma.PrismaPromise<GetFinRowExpenseAggregateType<T>>

    /**
     * Group by FinRowExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinRowExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinRowExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinRowExpenseGroupByArgs['orderBy'] }
        : { orderBy?: FinRowExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinRowExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinRowExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinRowExpense model
   */
  readonly fields: FinRowExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinRowExpense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinRowExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FinRow<T extends FinRowExpense$FinRowArgs<ExtArgs> = {}>(args?: Subset<T, FinRowExpense$FinRowArgs<ExtArgs>>): Prisma__FinRowClient<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinRowExpense model
   */
  interface FinRowExpenseFieldRefs {
    readonly id: FieldRef<"FinRowExpense", 'Int'>
    readonly finRowId: FieldRef<"FinRowExpense", 'Int'>
    readonly expenseType: FieldRef<"FinRowExpense", 'String'>
    readonly amount: FieldRef<"FinRowExpense", 'Float'>
    readonly date: FieldRef<"FinRowExpense", 'DateTime'>
    readonly time: FieldRef<"FinRowExpense", 'String'>
    readonly period: FieldRef<"FinRowExpense", 'String'>
    readonly description: FieldRef<"FinRowExpense", 'String'>
    readonly createdAt: FieldRef<"FinRowExpense", 'DateTime'>
    readonly updatedAt: FieldRef<"FinRowExpense", 'DateTime'>
    readonly currency: FieldRef<"FinRowExpense", 'String'>
    readonly section: FieldRef<"FinRowExpense", 'SalarySection'>
  }
    

  // Custom InputTypes
  /**
   * FinRowExpense findUnique
   */
  export type FinRowExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FinRowExpense to fetch.
     */
    where: FinRowExpenseWhereUniqueInput
  }

  /**
   * FinRowExpense findUniqueOrThrow
   */
  export type FinRowExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FinRowExpense to fetch.
     */
    where: FinRowExpenseWhereUniqueInput
  }

  /**
   * FinRowExpense findFirst
   */
  export type FinRowExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FinRowExpense to fetch.
     */
    where?: FinRowExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinRowExpenses to fetch.
     */
    orderBy?: FinRowExpenseOrderByWithRelationInput | FinRowExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinRowExpenses.
     */
    cursor?: FinRowExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinRowExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinRowExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinRowExpenses.
     */
    distinct?: FinRowExpenseScalarFieldEnum | FinRowExpenseScalarFieldEnum[]
  }

  /**
   * FinRowExpense findFirstOrThrow
   */
  export type FinRowExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FinRowExpense to fetch.
     */
    where?: FinRowExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinRowExpenses to fetch.
     */
    orderBy?: FinRowExpenseOrderByWithRelationInput | FinRowExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinRowExpenses.
     */
    cursor?: FinRowExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinRowExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinRowExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinRowExpenses.
     */
    distinct?: FinRowExpenseScalarFieldEnum | FinRowExpenseScalarFieldEnum[]
  }

  /**
   * FinRowExpense findMany
   */
  export type FinRowExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FinRowExpenses to fetch.
     */
    where?: FinRowExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinRowExpenses to fetch.
     */
    orderBy?: FinRowExpenseOrderByWithRelationInput | FinRowExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinRowExpenses.
     */
    cursor?: FinRowExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinRowExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinRowExpenses.
     */
    skip?: number
    distinct?: FinRowExpenseScalarFieldEnum | FinRowExpenseScalarFieldEnum[]
  }

  /**
   * FinRowExpense create
   */
  export type FinRowExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a FinRowExpense.
     */
    data: XOR<FinRowExpenseCreateInput, FinRowExpenseUncheckedCreateInput>
  }

  /**
   * FinRowExpense createMany
   */
  export type FinRowExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinRowExpenses.
     */
    data: FinRowExpenseCreateManyInput | FinRowExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinRowExpense createManyAndReturn
   */
  export type FinRowExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many FinRowExpenses.
     */
    data: FinRowExpenseCreateManyInput | FinRowExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinRowExpense update
   */
  export type FinRowExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a FinRowExpense.
     */
    data: XOR<FinRowExpenseUpdateInput, FinRowExpenseUncheckedUpdateInput>
    /**
     * Choose, which FinRowExpense to update.
     */
    where: FinRowExpenseWhereUniqueInput
  }

  /**
   * FinRowExpense updateMany
   */
  export type FinRowExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinRowExpenses.
     */
    data: XOR<FinRowExpenseUpdateManyMutationInput, FinRowExpenseUncheckedUpdateManyInput>
    /**
     * Filter which FinRowExpenses to update
     */
    where?: FinRowExpenseWhereInput
    /**
     * Limit how many FinRowExpenses to update.
     */
    limit?: number
  }

  /**
   * FinRowExpense updateManyAndReturn
   */
  export type FinRowExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * The data used to update FinRowExpenses.
     */
    data: XOR<FinRowExpenseUpdateManyMutationInput, FinRowExpenseUncheckedUpdateManyInput>
    /**
     * Filter which FinRowExpenses to update
     */
    where?: FinRowExpenseWhereInput
    /**
     * Limit how many FinRowExpenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinRowExpense upsert
   */
  export type FinRowExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the FinRowExpense to update in case it exists.
     */
    where: FinRowExpenseWhereUniqueInput
    /**
     * In case the FinRowExpense found by the `where` argument doesn't exist, create a new FinRowExpense with this data.
     */
    create: XOR<FinRowExpenseCreateInput, FinRowExpenseUncheckedCreateInput>
    /**
     * In case the FinRowExpense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinRowExpenseUpdateInput, FinRowExpenseUncheckedUpdateInput>
  }

  /**
   * FinRowExpense delete
   */
  export type FinRowExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseInclude<ExtArgs> | null
    /**
     * Filter which FinRowExpense to delete.
     */
    where: FinRowExpenseWhereUniqueInput
  }

  /**
   * FinRowExpense deleteMany
   */
  export type FinRowExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinRowExpenses to delete
     */
    where?: FinRowExpenseWhereInput
    /**
     * Limit how many FinRowExpenses to delete.
     */
    limit?: number
  }

  /**
   * FinRowExpense.FinRow
   */
  export type FinRowExpense$FinRowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
    where?: FinRowWhereInput
  }

  /**
   * FinRowExpense without action
   */
  export type FinRowExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRowExpense
     */
    select?: FinRowExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRowExpense
     */
    omit?: FinRowExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowExpenseInclude<ExtArgs> | null
  }


  /**
   * Model IdexCabinet
   */

  export type AggregateIdexCabinet = {
    _count: IdexCabinetCountAggregateOutputType | null
    _avg: IdexCabinetAvgAggregateOutputType | null
    _sum: IdexCabinetSumAggregateOutputType | null
    _min: IdexCabinetMinAggregateOutputType | null
    _max: IdexCabinetMaxAggregateOutputType | null
  }

  export type IdexCabinetAvgAggregateOutputType = {
    id: number | null
    idexId: number | null
  }

  export type IdexCabinetSumAggregateOutputType = {
    id: number | null
    idexId: number | null
  }

  export type IdexCabinetMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    idexId: number | null
    login: string | null
    password: string | null
  }

  export type IdexCabinetMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    idexId: number | null
    login: string | null
    password: string | null
  }

  export type IdexCabinetCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    idexId: number
    login: number
    password: number
    _all: number
  }


  export type IdexCabinetAvgAggregateInputType = {
    id?: true
    idexId?: true
  }

  export type IdexCabinetSumAggregateInputType = {
    id?: true
    idexId?: true
  }

  export type IdexCabinetMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    idexId?: true
    login?: true
    password?: true
  }

  export type IdexCabinetMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    idexId?: true
    login?: true
    password?: true
  }

  export type IdexCabinetCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    idexId?: true
    login?: true
    password?: true
    _all?: true
  }

  export type IdexCabinetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdexCabinet to aggregate.
     */
    where?: IdexCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexCabinets to fetch.
     */
    orderBy?: IdexCabinetOrderByWithRelationInput | IdexCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdexCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IdexCabinets
    **/
    _count?: true | IdexCabinetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IdexCabinetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IdexCabinetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdexCabinetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdexCabinetMaxAggregateInputType
  }

  export type GetIdexCabinetAggregateType<T extends IdexCabinetAggregateArgs> = {
        [P in keyof T & keyof AggregateIdexCabinet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdexCabinet[P]>
      : GetScalarType<T[P], AggregateIdexCabinet[P]>
  }




  export type IdexCabinetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdexCabinetWhereInput
    orderBy?: IdexCabinetOrderByWithAggregationInput | IdexCabinetOrderByWithAggregationInput[]
    by: IdexCabinetScalarFieldEnum[] | IdexCabinetScalarFieldEnum
    having?: IdexCabinetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdexCabinetCountAggregateInputType | true
    _avg?: IdexCabinetAvgAggregateInputType
    _sum?: IdexCabinetSumAggregateInputType
    _min?: IdexCabinetMinAggregateInputType
    _max?: IdexCabinetMaxAggregateInputType
  }

  export type IdexCabinetGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    idexId: number
    login: string
    password: string
    _count: IdexCabinetCountAggregateOutputType | null
    _avg: IdexCabinetAvgAggregateOutputType | null
    _sum: IdexCabinetSumAggregateOutputType | null
    _min: IdexCabinetMinAggregateOutputType | null
    _max: IdexCabinetMaxAggregateOutputType | null
  }

  type GetIdexCabinetGroupByPayload<T extends IdexCabinetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdexCabinetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdexCabinetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdexCabinetGroupByOutputType[P]>
            : GetScalarType<T[P], IdexCabinetGroupByOutputType[P]>
        }
      >
    >


  export type IdexCabinetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idexId?: boolean
    login?: boolean
    password?: boolean
    IdexSyncOrder?: boolean | IdexCabinet$IdexSyncOrderArgs<ExtArgs>
    IdexTransaction?: boolean | IdexCabinet$IdexTransactionArgs<ExtArgs>
    WorkSessionIdexCabinet?: boolean | IdexCabinet$WorkSessionIdexCabinetArgs<ExtArgs>
    _count?: boolean | IdexCabinetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["idexCabinet"]>

  export type IdexCabinetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idexId?: boolean
    login?: boolean
    password?: boolean
  }, ExtArgs["result"]["idexCabinet"]>

  export type IdexCabinetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idexId?: boolean
    login?: boolean
    password?: boolean
  }, ExtArgs["result"]["idexCabinet"]>

  export type IdexCabinetSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idexId?: boolean
    login?: boolean
    password?: boolean
  }

  export type IdexCabinetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "idexId" | "login" | "password", ExtArgs["result"]["idexCabinet"]>
  export type IdexCabinetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexSyncOrder?: boolean | IdexCabinet$IdexSyncOrderArgs<ExtArgs>
    IdexTransaction?: boolean | IdexCabinet$IdexTransactionArgs<ExtArgs>
    WorkSessionIdexCabinet?: boolean | IdexCabinet$WorkSessionIdexCabinetArgs<ExtArgs>
    _count?: boolean | IdexCabinetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IdexCabinetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type IdexCabinetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IdexCabinetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IdexCabinet"
    objects: {
      IdexSyncOrder: Prisma.$IdexSyncOrderPayload<ExtArgs>[]
      IdexTransaction: Prisma.$IdexTransactionPayload<ExtArgs>[]
      WorkSessionIdexCabinet: Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      idexId: number
      login: string
      password: string
    }, ExtArgs["result"]["idexCabinet"]>
    composites: {}
  }

  type IdexCabinetGetPayload<S extends boolean | null | undefined | IdexCabinetDefaultArgs> = $Result.GetResult<Prisma.$IdexCabinetPayload, S>

  type IdexCabinetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdexCabinetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdexCabinetCountAggregateInputType | true
    }

  export interface IdexCabinetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IdexCabinet'], meta: { name: 'IdexCabinet' } }
    /**
     * Find zero or one IdexCabinet that matches the filter.
     * @param {IdexCabinetFindUniqueArgs} args - Arguments to find a IdexCabinet
     * @example
     * // Get one IdexCabinet
     * const idexCabinet = await prisma.idexCabinet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdexCabinetFindUniqueArgs>(args: SelectSubset<T, IdexCabinetFindUniqueArgs<ExtArgs>>): Prisma__IdexCabinetClient<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IdexCabinet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdexCabinetFindUniqueOrThrowArgs} args - Arguments to find a IdexCabinet
     * @example
     * // Get one IdexCabinet
     * const idexCabinet = await prisma.idexCabinet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdexCabinetFindUniqueOrThrowArgs>(args: SelectSubset<T, IdexCabinetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdexCabinetClient<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdexCabinet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexCabinetFindFirstArgs} args - Arguments to find a IdexCabinet
     * @example
     * // Get one IdexCabinet
     * const idexCabinet = await prisma.idexCabinet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdexCabinetFindFirstArgs>(args?: SelectSubset<T, IdexCabinetFindFirstArgs<ExtArgs>>): Prisma__IdexCabinetClient<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdexCabinet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexCabinetFindFirstOrThrowArgs} args - Arguments to find a IdexCabinet
     * @example
     * // Get one IdexCabinet
     * const idexCabinet = await prisma.idexCabinet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdexCabinetFindFirstOrThrowArgs>(args?: SelectSubset<T, IdexCabinetFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdexCabinetClient<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IdexCabinets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexCabinetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IdexCabinets
     * const idexCabinets = await prisma.idexCabinet.findMany()
     * 
     * // Get first 10 IdexCabinets
     * const idexCabinets = await prisma.idexCabinet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const idexCabinetWithIdOnly = await prisma.idexCabinet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdexCabinetFindManyArgs>(args?: SelectSubset<T, IdexCabinetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IdexCabinet.
     * @param {IdexCabinetCreateArgs} args - Arguments to create a IdexCabinet.
     * @example
     * // Create one IdexCabinet
     * const IdexCabinet = await prisma.idexCabinet.create({
     *   data: {
     *     // ... data to create a IdexCabinet
     *   }
     * })
     * 
     */
    create<T extends IdexCabinetCreateArgs>(args: SelectSubset<T, IdexCabinetCreateArgs<ExtArgs>>): Prisma__IdexCabinetClient<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IdexCabinets.
     * @param {IdexCabinetCreateManyArgs} args - Arguments to create many IdexCabinets.
     * @example
     * // Create many IdexCabinets
     * const idexCabinet = await prisma.idexCabinet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdexCabinetCreateManyArgs>(args?: SelectSubset<T, IdexCabinetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IdexCabinets and returns the data saved in the database.
     * @param {IdexCabinetCreateManyAndReturnArgs} args - Arguments to create many IdexCabinets.
     * @example
     * // Create many IdexCabinets
     * const idexCabinet = await prisma.idexCabinet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IdexCabinets and only return the `id`
     * const idexCabinetWithIdOnly = await prisma.idexCabinet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdexCabinetCreateManyAndReturnArgs>(args?: SelectSubset<T, IdexCabinetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IdexCabinet.
     * @param {IdexCabinetDeleteArgs} args - Arguments to delete one IdexCabinet.
     * @example
     * // Delete one IdexCabinet
     * const IdexCabinet = await prisma.idexCabinet.delete({
     *   where: {
     *     // ... filter to delete one IdexCabinet
     *   }
     * })
     * 
     */
    delete<T extends IdexCabinetDeleteArgs>(args: SelectSubset<T, IdexCabinetDeleteArgs<ExtArgs>>): Prisma__IdexCabinetClient<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IdexCabinet.
     * @param {IdexCabinetUpdateArgs} args - Arguments to update one IdexCabinet.
     * @example
     * // Update one IdexCabinet
     * const idexCabinet = await prisma.idexCabinet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdexCabinetUpdateArgs>(args: SelectSubset<T, IdexCabinetUpdateArgs<ExtArgs>>): Prisma__IdexCabinetClient<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IdexCabinets.
     * @param {IdexCabinetDeleteManyArgs} args - Arguments to filter IdexCabinets to delete.
     * @example
     * // Delete a few IdexCabinets
     * const { count } = await prisma.idexCabinet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdexCabinetDeleteManyArgs>(args?: SelectSubset<T, IdexCabinetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdexCabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexCabinetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IdexCabinets
     * const idexCabinet = await prisma.idexCabinet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdexCabinetUpdateManyArgs>(args: SelectSubset<T, IdexCabinetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdexCabinets and returns the data updated in the database.
     * @param {IdexCabinetUpdateManyAndReturnArgs} args - Arguments to update many IdexCabinets.
     * @example
     * // Update many IdexCabinets
     * const idexCabinet = await prisma.idexCabinet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IdexCabinets and only return the `id`
     * const idexCabinetWithIdOnly = await prisma.idexCabinet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdexCabinetUpdateManyAndReturnArgs>(args: SelectSubset<T, IdexCabinetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IdexCabinet.
     * @param {IdexCabinetUpsertArgs} args - Arguments to update or create a IdexCabinet.
     * @example
     * // Update or create a IdexCabinet
     * const idexCabinet = await prisma.idexCabinet.upsert({
     *   create: {
     *     // ... data to create a IdexCabinet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IdexCabinet we want to update
     *   }
     * })
     */
    upsert<T extends IdexCabinetUpsertArgs>(args: SelectSubset<T, IdexCabinetUpsertArgs<ExtArgs>>): Prisma__IdexCabinetClient<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IdexCabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexCabinetCountArgs} args - Arguments to filter IdexCabinets to count.
     * @example
     * // Count the number of IdexCabinets
     * const count = await prisma.idexCabinet.count({
     *   where: {
     *     // ... the filter for the IdexCabinets we want to count
     *   }
     * })
    **/
    count<T extends IdexCabinetCountArgs>(
      args?: Subset<T, IdexCabinetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdexCabinetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IdexCabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexCabinetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdexCabinetAggregateArgs>(args: Subset<T, IdexCabinetAggregateArgs>): Prisma.PrismaPromise<GetIdexCabinetAggregateType<T>>

    /**
     * Group by IdexCabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexCabinetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdexCabinetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdexCabinetGroupByArgs['orderBy'] }
        : { orderBy?: IdexCabinetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdexCabinetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdexCabinetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IdexCabinet model
   */
  readonly fields: IdexCabinetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IdexCabinet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdexCabinetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    IdexSyncOrder<T extends IdexCabinet$IdexSyncOrderArgs<ExtArgs> = {}>(args?: Subset<T, IdexCabinet$IdexSyncOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    IdexTransaction<T extends IdexCabinet$IdexTransactionArgs<ExtArgs> = {}>(args?: Subset<T, IdexCabinet$IdexTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WorkSessionIdexCabinet<T extends IdexCabinet$WorkSessionIdexCabinetArgs<ExtArgs> = {}>(args?: Subset<T, IdexCabinet$WorkSessionIdexCabinetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IdexCabinet model
   */
  interface IdexCabinetFieldRefs {
    readonly id: FieldRef<"IdexCabinet", 'Int'>
    readonly createdAt: FieldRef<"IdexCabinet", 'DateTime'>
    readonly updatedAt: FieldRef<"IdexCabinet", 'DateTime'>
    readonly idexId: FieldRef<"IdexCabinet", 'Int'>
    readonly login: FieldRef<"IdexCabinet", 'String'>
    readonly password: FieldRef<"IdexCabinet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IdexCabinet findUnique
   */
  export type IdexCabinetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexCabinetInclude<ExtArgs> | null
    /**
     * Filter, which IdexCabinet to fetch.
     */
    where: IdexCabinetWhereUniqueInput
  }

  /**
   * IdexCabinet findUniqueOrThrow
   */
  export type IdexCabinetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexCabinetInclude<ExtArgs> | null
    /**
     * Filter, which IdexCabinet to fetch.
     */
    where: IdexCabinetWhereUniqueInput
  }

  /**
   * IdexCabinet findFirst
   */
  export type IdexCabinetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexCabinetInclude<ExtArgs> | null
    /**
     * Filter, which IdexCabinet to fetch.
     */
    where?: IdexCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexCabinets to fetch.
     */
    orderBy?: IdexCabinetOrderByWithRelationInput | IdexCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdexCabinets.
     */
    cursor?: IdexCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdexCabinets.
     */
    distinct?: IdexCabinetScalarFieldEnum | IdexCabinetScalarFieldEnum[]
  }

  /**
   * IdexCabinet findFirstOrThrow
   */
  export type IdexCabinetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexCabinetInclude<ExtArgs> | null
    /**
     * Filter, which IdexCabinet to fetch.
     */
    where?: IdexCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexCabinets to fetch.
     */
    orderBy?: IdexCabinetOrderByWithRelationInput | IdexCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdexCabinets.
     */
    cursor?: IdexCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdexCabinets.
     */
    distinct?: IdexCabinetScalarFieldEnum | IdexCabinetScalarFieldEnum[]
  }

  /**
   * IdexCabinet findMany
   */
  export type IdexCabinetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexCabinetInclude<ExtArgs> | null
    /**
     * Filter, which IdexCabinets to fetch.
     */
    where?: IdexCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexCabinets to fetch.
     */
    orderBy?: IdexCabinetOrderByWithRelationInput | IdexCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IdexCabinets.
     */
    cursor?: IdexCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexCabinets.
     */
    skip?: number
    distinct?: IdexCabinetScalarFieldEnum | IdexCabinetScalarFieldEnum[]
  }

  /**
   * IdexCabinet create
   */
  export type IdexCabinetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexCabinetInclude<ExtArgs> | null
    /**
     * The data needed to create a IdexCabinet.
     */
    data: XOR<IdexCabinetCreateInput, IdexCabinetUncheckedCreateInput>
  }

  /**
   * IdexCabinet createMany
   */
  export type IdexCabinetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IdexCabinets.
     */
    data: IdexCabinetCreateManyInput | IdexCabinetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IdexCabinet createManyAndReturn
   */
  export type IdexCabinetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * The data used to create many IdexCabinets.
     */
    data: IdexCabinetCreateManyInput | IdexCabinetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IdexCabinet update
   */
  export type IdexCabinetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexCabinetInclude<ExtArgs> | null
    /**
     * The data needed to update a IdexCabinet.
     */
    data: XOR<IdexCabinetUpdateInput, IdexCabinetUncheckedUpdateInput>
    /**
     * Choose, which IdexCabinet to update.
     */
    where: IdexCabinetWhereUniqueInput
  }

  /**
   * IdexCabinet updateMany
   */
  export type IdexCabinetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IdexCabinets.
     */
    data: XOR<IdexCabinetUpdateManyMutationInput, IdexCabinetUncheckedUpdateManyInput>
    /**
     * Filter which IdexCabinets to update
     */
    where?: IdexCabinetWhereInput
    /**
     * Limit how many IdexCabinets to update.
     */
    limit?: number
  }

  /**
   * IdexCabinet updateManyAndReturn
   */
  export type IdexCabinetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * The data used to update IdexCabinets.
     */
    data: XOR<IdexCabinetUpdateManyMutationInput, IdexCabinetUncheckedUpdateManyInput>
    /**
     * Filter which IdexCabinets to update
     */
    where?: IdexCabinetWhereInput
    /**
     * Limit how many IdexCabinets to update.
     */
    limit?: number
  }

  /**
   * IdexCabinet upsert
   */
  export type IdexCabinetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexCabinetInclude<ExtArgs> | null
    /**
     * The filter to search for the IdexCabinet to update in case it exists.
     */
    where: IdexCabinetWhereUniqueInput
    /**
     * In case the IdexCabinet found by the `where` argument doesn't exist, create a new IdexCabinet with this data.
     */
    create: XOR<IdexCabinetCreateInput, IdexCabinetUncheckedCreateInput>
    /**
     * In case the IdexCabinet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdexCabinetUpdateInput, IdexCabinetUncheckedUpdateInput>
  }

  /**
   * IdexCabinet delete
   */
  export type IdexCabinetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexCabinetInclude<ExtArgs> | null
    /**
     * Filter which IdexCabinet to delete.
     */
    where: IdexCabinetWhereUniqueInput
  }

  /**
   * IdexCabinet deleteMany
   */
  export type IdexCabinetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdexCabinets to delete
     */
    where?: IdexCabinetWhereInput
    /**
     * Limit how many IdexCabinets to delete.
     */
    limit?: number
  }

  /**
   * IdexCabinet.IdexSyncOrder
   */
  export type IdexCabinet$IdexSyncOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderInclude<ExtArgs> | null
    where?: IdexSyncOrderWhereInput
    orderBy?: IdexSyncOrderOrderByWithRelationInput | IdexSyncOrderOrderByWithRelationInput[]
    cursor?: IdexSyncOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdexSyncOrderScalarFieldEnum | IdexSyncOrderScalarFieldEnum[]
  }

  /**
   * IdexCabinet.IdexTransaction
   */
  export type IdexCabinet$IdexTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionInclude<ExtArgs> | null
    where?: IdexTransactionWhereInput
    orderBy?: IdexTransactionOrderByWithRelationInput | IdexTransactionOrderByWithRelationInput[]
    cursor?: IdexTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdexTransactionScalarFieldEnum | IdexTransactionScalarFieldEnum[]
  }

  /**
   * IdexCabinet.WorkSessionIdexCabinet
   */
  export type IdexCabinet$WorkSessionIdexCabinetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
    where?: WorkSessionIdexCabinetWhereInput
    orderBy?: WorkSessionIdexCabinetOrderByWithRelationInput | WorkSessionIdexCabinetOrderByWithRelationInput[]
    cursor?: WorkSessionIdexCabinetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkSessionIdexCabinetScalarFieldEnum | WorkSessionIdexCabinetScalarFieldEnum[]
  }

  /**
   * IdexCabinet without action
   */
  export type IdexCabinetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexCabinetInclude<ExtArgs> | null
  }


  /**
   * Model IdexSyncOrder
   */

  export type AggregateIdexSyncOrder = {
    _count: IdexSyncOrderCountAggregateOutputType | null
    _avg: IdexSyncOrderAvgAggregateOutputType | null
    _sum: IdexSyncOrderSumAggregateOutputType | null
    _min: IdexSyncOrderMinAggregateOutputType | null
    _max: IdexSyncOrderMaxAggregateOutputType | null
  }

  export type IdexSyncOrderAvgAggregateOutputType = {
    id: number | null
    cabinetId: number | null
    pages: number | null
  }

  export type IdexSyncOrderSumAggregateOutputType = {
    id: number | null
    cabinetId: number | null
    pages: number[]
  }

  export type IdexSyncOrderMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cabinetId: number | null
    status: $Enums.IdexSyncOrderStatus | null
    startSyncAt: Date | null
    endSyncAt: Date | null
  }

  export type IdexSyncOrderMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cabinetId: number | null
    status: $Enums.IdexSyncOrderStatus | null
    startSyncAt: Date | null
    endSyncAt: Date | null
  }

  export type IdexSyncOrderCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    cabinetId: number
    processed: number
    status: number
    startSyncAt: number
    endSyncAt: number
    pages: number
    _all: number
  }


  export type IdexSyncOrderAvgAggregateInputType = {
    id?: true
    cabinetId?: true
    pages?: true
  }

  export type IdexSyncOrderSumAggregateInputType = {
    id?: true
    cabinetId?: true
    pages?: true
  }

  export type IdexSyncOrderMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    cabinetId?: true
    status?: true
    startSyncAt?: true
    endSyncAt?: true
  }

  export type IdexSyncOrderMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    cabinetId?: true
    status?: true
    startSyncAt?: true
    endSyncAt?: true
  }

  export type IdexSyncOrderCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    cabinetId?: true
    processed?: true
    status?: true
    startSyncAt?: true
    endSyncAt?: true
    pages?: true
    _all?: true
  }

  export type IdexSyncOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdexSyncOrder to aggregate.
     */
    where?: IdexSyncOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexSyncOrders to fetch.
     */
    orderBy?: IdexSyncOrderOrderByWithRelationInput | IdexSyncOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdexSyncOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexSyncOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexSyncOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IdexSyncOrders
    **/
    _count?: true | IdexSyncOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IdexSyncOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IdexSyncOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdexSyncOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdexSyncOrderMaxAggregateInputType
  }

  export type GetIdexSyncOrderAggregateType<T extends IdexSyncOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateIdexSyncOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdexSyncOrder[P]>
      : GetScalarType<T[P], AggregateIdexSyncOrder[P]>
  }




  export type IdexSyncOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdexSyncOrderWhereInput
    orderBy?: IdexSyncOrderOrderByWithAggregationInput | IdexSyncOrderOrderByWithAggregationInput[]
    by: IdexSyncOrderScalarFieldEnum[] | IdexSyncOrderScalarFieldEnum
    having?: IdexSyncOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdexSyncOrderCountAggregateInputType | true
    _avg?: IdexSyncOrderAvgAggregateInputType
    _sum?: IdexSyncOrderSumAggregateInputType
    _min?: IdexSyncOrderMinAggregateInputType
    _max?: IdexSyncOrderMaxAggregateInputType
  }

  export type IdexSyncOrderGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    cabinetId: number | null
    processed: JsonValue | null
    status: $Enums.IdexSyncOrderStatus
    startSyncAt: Date | null
    endSyncAt: Date | null
    pages: number[]
    _count: IdexSyncOrderCountAggregateOutputType | null
    _avg: IdexSyncOrderAvgAggregateOutputType | null
    _sum: IdexSyncOrderSumAggregateOutputType | null
    _min: IdexSyncOrderMinAggregateOutputType | null
    _max: IdexSyncOrderMaxAggregateOutputType | null
  }

  type GetIdexSyncOrderGroupByPayload<T extends IdexSyncOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdexSyncOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdexSyncOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdexSyncOrderGroupByOutputType[P]>
            : GetScalarType<T[P], IdexSyncOrderGroupByOutputType[P]>
        }
      >
    >


  export type IdexSyncOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cabinetId?: boolean
    processed?: boolean
    status?: boolean
    startSyncAt?: boolean
    endSyncAt?: boolean
    pages?: boolean
    IdexCabinet?: boolean | IdexSyncOrder$IdexCabinetArgs<ExtArgs>
  }, ExtArgs["result"]["idexSyncOrder"]>

  export type IdexSyncOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cabinetId?: boolean
    processed?: boolean
    status?: boolean
    startSyncAt?: boolean
    endSyncAt?: boolean
    pages?: boolean
    IdexCabinet?: boolean | IdexSyncOrder$IdexCabinetArgs<ExtArgs>
  }, ExtArgs["result"]["idexSyncOrder"]>

  export type IdexSyncOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cabinetId?: boolean
    processed?: boolean
    status?: boolean
    startSyncAt?: boolean
    endSyncAt?: boolean
    pages?: boolean
    IdexCabinet?: boolean | IdexSyncOrder$IdexCabinetArgs<ExtArgs>
  }, ExtArgs["result"]["idexSyncOrder"]>

  export type IdexSyncOrderSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cabinetId?: boolean
    processed?: boolean
    status?: boolean
    startSyncAt?: boolean
    endSyncAt?: boolean
    pages?: boolean
  }

  export type IdexSyncOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "cabinetId" | "processed" | "status" | "startSyncAt" | "endSyncAt" | "pages", ExtArgs["result"]["idexSyncOrder"]>
  export type IdexSyncOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexCabinet?: boolean | IdexSyncOrder$IdexCabinetArgs<ExtArgs>
  }
  export type IdexSyncOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexCabinet?: boolean | IdexSyncOrder$IdexCabinetArgs<ExtArgs>
  }
  export type IdexSyncOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexCabinet?: boolean | IdexSyncOrder$IdexCabinetArgs<ExtArgs>
  }

  export type $IdexSyncOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IdexSyncOrder"
    objects: {
      IdexCabinet: Prisma.$IdexCabinetPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      cabinetId: number | null
      processed: Prisma.JsonValue | null
      status: $Enums.IdexSyncOrderStatus
      startSyncAt: Date | null
      endSyncAt: Date | null
      pages: number[]
    }, ExtArgs["result"]["idexSyncOrder"]>
    composites: {}
  }

  type IdexSyncOrderGetPayload<S extends boolean | null | undefined | IdexSyncOrderDefaultArgs> = $Result.GetResult<Prisma.$IdexSyncOrderPayload, S>

  type IdexSyncOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdexSyncOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdexSyncOrderCountAggregateInputType | true
    }

  export interface IdexSyncOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IdexSyncOrder'], meta: { name: 'IdexSyncOrder' } }
    /**
     * Find zero or one IdexSyncOrder that matches the filter.
     * @param {IdexSyncOrderFindUniqueArgs} args - Arguments to find a IdexSyncOrder
     * @example
     * // Get one IdexSyncOrder
     * const idexSyncOrder = await prisma.idexSyncOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdexSyncOrderFindUniqueArgs>(args: SelectSubset<T, IdexSyncOrderFindUniqueArgs<ExtArgs>>): Prisma__IdexSyncOrderClient<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IdexSyncOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdexSyncOrderFindUniqueOrThrowArgs} args - Arguments to find a IdexSyncOrder
     * @example
     * // Get one IdexSyncOrder
     * const idexSyncOrder = await prisma.idexSyncOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdexSyncOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, IdexSyncOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdexSyncOrderClient<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdexSyncOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexSyncOrderFindFirstArgs} args - Arguments to find a IdexSyncOrder
     * @example
     * // Get one IdexSyncOrder
     * const idexSyncOrder = await prisma.idexSyncOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdexSyncOrderFindFirstArgs>(args?: SelectSubset<T, IdexSyncOrderFindFirstArgs<ExtArgs>>): Prisma__IdexSyncOrderClient<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdexSyncOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexSyncOrderFindFirstOrThrowArgs} args - Arguments to find a IdexSyncOrder
     * @example
     * // Get one IdexSyncOrder
     * const idexSyncOrder = await prisma.idexSyncOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdexSyncOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, IdexSyncOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdexSyncOrderClient<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IdexSyncOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexSyncOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IdexSyncOrders
     * const idexSyncOrders = await prisma.idexSyncOrder.findMany()
     * 
     * // Get first 10 IdexSyncOrders
     * const idexSyncOrders = await prisma.idexSyncOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const idexSyncOrderWithIdOnly = await prisma.idexSyncOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdexSyncOrderFindManyArgs>(args?: SelectSubset<T, IdexSyncOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IdexSyncOrder.
     * @param {IdexSyncOrderCreateArgs} args - Arguments to create a IdexSyncOrder.
     * @example
     * // Create one IdexSyncOrder
     * const IdexSyncOrder = await prisma.idexSyncOrder.create({
     *   data: {
     *     // ... data to create a IdexSyncOrder
     *   }
     * })
     * 
     */
    create<T extends IdexSyncOrderCreateArgs>(args: SelectSubset<T, IdexSyncOrderCreateArgs<ExtArgs>>): Prisma__IdexSyncOrderClient<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IdexSyncOrders.
     * @param {IdexSyncOrderCreateManyArgs} args - Arguments to create many IdexSyncOrders.
     * @example
     * // Create many IdexSyncOrders
     * const idexSyncOrder = await prisma.idexSyncOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdexSyncOrderCreateManyArgs>(args?: SelectSubset<T, IdexSyncOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IdexSyncOrders and returns the data saved in the database.
     * @param {IdexSyncOrderCreateManyAndReturnArgs} args - Arguments to create many IdexSyncOrders.
     * @example
     * // Create many IdexSyncOrders
     * const idexSyncOrder = await prisma.idexSyncOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IdexSyncOrders and only return the `id`
     * const idexSyncOrderWithIdOnly = await prisma.idexSyncOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdexSyncOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, IdexSyncOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IdexSyncOrder.
     * @param {IdexSyncOrderDeleteArgs} args - Arguments to delete one IdexSyncOrder.
     * @example
     * // Delete one IdexSyncOrder
     * const IdexSyncOrder = await prisma.idexSyncOrder.delete({
     *   where: {
     *     // ... filter to delete one IdexSyncOrder
     *   }
     * })
     * 
     */
    delete<T extends IdexSyncOrderDeleteArgs>(args: SelectSubset<T, IdexSyncOrderDeleteArgs<ExtArgs>>): Prisma__IdexSyncOrderClient<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IdexSyncOrder.
     * @param {IdexSyncOrderUpdateArgs} args - Arguments to update one IdexSyncOrder.
     * @example
     * // Update one IdexSyncOrder
     * const idexSyncOrder = await prisma.idexSyncOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdexSyncOrderUpdateArgs>(args: SelectSubset<T, IdexSyncOrderUpdateArgs<ExtArgs>>): Prisma__IdexSyncOrderClient<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IdexSyncOrders.
     * @param {IdexSyncOrderDeleteManyArgs} args - Arguments to filter IdexSyncOrders to delete.
     * @example
     * // Delete a few IdexSyncOrders
     * const { count } = await prisma.idexSyncOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdexSyncOrderDeleteManyArgs>(args?: SelectSubset<T, IdexSyncOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdexSyncOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexSyncOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IdexSyncOrders
     * const idexSyncOrder = await prisma.idexSyncOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdexSyncOrderUpdateManyArgs>(args: SelectSubset<T, IdexSyncOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdexSyncOrders and returns the data updated in the database.
     * @param {IdexSyncOrderUpdateManyAndReturnArgs} args - Arguments to update many IdexSyncOrders.
     * @example
     * // Update many IdexSyncOrders
     * const idexSyncOrder = await prisma.idexSyncOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IdexSyncOrders and only return the `id`
     * const idexSyncOrderWithIdOnly = await prisma.idexSyncOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdexSyncOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, IdexSyncOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IdexSyncOrder.
     * @param {IdexSyncOrderUpsertArgs} args - Arguments to update or create a IdexSyncOrder.
     * @example
     * // Update or create a IdexSyncOrder
     * const idexSyncOrder = await prisma.idexSyncOrder.upsert({
     *   create: {
     *     // ... data to create a IdexSyncOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IdexSyncOrder we want to update
     *   }
     * })
     */
    upsert<T extends IdexSyncOrderUpsertArgs>(args: SelectSubset<T, IdexSyncOrderUpsertArgs<ExtArgs>>): Prisma__IdexSyncOrderClient<$Result.GetResult<Prisma.$IdexSyncOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IdexSyncOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexSyncOrderCountArgs} args - Arguments to filter IdexSyncOrders to count.
     * @example
     * // Count the number of IdexSyncOrders
     * const count = await prisma.idexSyncOrder.count({
     *   where: {
     *     // ... the filter for the IdexSyncOrders we want to count
     *   }
     * })
    **/
    count<T extends IdexSyncOrderCountArgs>(
      args?: Subset<T, IdexSyncOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdexSyncOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IdexSyncOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexSyncOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdexSyncOrderAggregateArgs>(args: Subset<T, IdexSyncOrderAggregateArgs>): Prisma.PrismaPromise<GetIdexSyncOrderAggregateType<T>>

    /**
     * Group by IdexSyncOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexSyncOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdexSyncOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdexSyncOrderGroupByArgs['orderBy'] }
        : { orderBy?: IdexSyncOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdexSyncOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdexSyncOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IdexSyncOrder model
   */
  readonly fields: IdexSyncOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IdexSyncOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdexSyncOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    IdexCabinet<T extends IdexSyncOrder$IdexCabinetArgs<ExtArgs> = {}>(args?: Subset<T, IdexSyncOrder$IdexCabinetArgs<ExtArgs>>): Prisma__IdexCabinetClient<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IdexSyncOrder model
   */
  interface IdexSyncOrderFieldRefs {
    readonly id: FieldRef<"IdexSyncOrder", 'Int'>
    readonly createdAt: FieldRef<"IdexSyncOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"IdexSyncOrder", 'DateTime'>
    readonly cabinetId: FieldRef<"IdexSyncOrder", 'Int'>
    readonly processed: FieldRef<"IdexSyncOrder", 'Json'>
    readonly status: FieldRef<"IdexSyncOrder", 'IdexSyncOrderStatus'>
    readonly startSyncAt: FieldRef<"IdexSyncOrder", 'DateTime'>
    readonly endSyncAt: FieldRef<"IdexSyncOrder", 'DateTime'>
    readonly pages: FieldRef<"IdexSyncOrder", 'Int[]'>
  }
    

  // Custom InputTypes
  /**
   * IdexSyncOrder findUnique
   */
  export type IdexSyncOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderInclude<ExtArgs> | null
    /**
     * Filter, which IdexSyncOrder to fetch.
     */
    where: IdexSyncOrderWhereUniqueInput
  }

  /**
   * IdexSyncOrder findUniqueOrThrow
   */
  export type IdexSyncOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderInclude<ExtArgs> | null
    /**
     * Filter, which IdexSyncOrder to fetch.
     */
    where: IdexSyncOrderWhereUniqueInput
  }

  /**
   * IdexSyncOrder findFirst
   */
  export type IdexSyncOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderInclude<ExtArgs> | null
    /**
     * Filter, which IdexSyncOrder to fetch.
     */
    where?: IdexSyncOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexSyncOrders to fetch.
     */
    orderBy?: IdexSyncOrderOrderByWithRelationInput | IdexSyncOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdexSyncOrders.
     */
    cursor?: IdexSyncOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexSyncOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexSyncOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdexSyncOrders.
     */
    distinct?: IdexSyncOrderScalarFieldEnum | IdexSyncOrderScalarFieldEnum[]
  }

  /**
   * IdexSyncOrder findFirstOrThrow
   */
  export type IdexSyncOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderInclude<ExtArgs> | null
    /**
     * Filter, which IdexSyncOrder to fetch.
     */
    where?: IdexSyncOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexSyncOrders to fetch.
     */
    orderBy?: IdexSyncOrderOrderByWithRelationInput | IdexSyncOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdexSyncOrders.
     */
    cursor?: IdexSyncOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexSyncOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexSyncOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdexSyncOrders.
     */
    distinct?: IdexSyncOrderScalarFieldEnum | IdexSyncOrderScalarFieldEnum[]
  }

  /**
   * IdexSyncOrder findMany
   */
  export type IdexSyncOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderInclude<ExtArgs> | null
    /**
     * Filter, which IdexSyncOrders to fetch.
     */
    where?: IdexSyncOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexSyncOrders to fetch.
     */
    orderBy?: IdexSyncOrderOrderByWithRelationInput | IdexSyncOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IdexSyncOrders.
     */
    cursor?: IdexSyncOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexSyncOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexSyncOrders.
     */
    skip?: number
    distinct?: IdexSyncOrderScalarFieldEnum | IdexSyncOrderScalarFieldEnum[]
  }

  /**
   * IdexSyncOrder create
   */
  export type IdexSyncOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a IdexSyncOrder.
     */
    data: XOR<IdexSyncOrderCreateInput, IdexSyncOrderUncheckedCreateInput>
  }

  /**
   * IdexSyncOrder createMany
   */
  export type IdexSyncOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IdexSyncOrders.
     */
    data: IdexSyncOrderCreateManyInput | IdexSyncOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IdexSyncOrder createManyAndReturn
   */
  export type IdexSyncOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * The data used to create many IdexSyncOrders.
     */
    data: IdexSyncOrderCreateManyInput | IdexSyncOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IdexSyncOrder update
   */
  export type IdexSyncOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a IdexSyncOrder.
     */
    data: XOR<IdexSyncOrderUpdateInput, IdexSyncOrderUncheckedUpdateInput>
    /**
     * Choose, which IdexSyncOrder to update.
     */
    where: IdexSyncOrderWhereUniqueInput
  }

  /**
   * IdexSyncOrder updateMany
   */
  export type IdexSyncOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IdexSyncOrders.
     */
    data: XOR<IdexSyncOrderUpdateManyMutationInput, IdexSyncOrderUncheckedUpdateManyInput>
    /**
     * Filter which IdexSyncOrders to update
     */
    where?: IdexSyncOrderWhereInput
    /**
     * Limit how many IdexSyncOrders to update.
     */
    limit?: number
  }

  /**
   * IdexSyncOrder updateManyAndReturn
   */
  export type IdexSyncOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * The data used to update IdexSyncOrders.
     */
    data: XOR<IdexSyncOrderUpdateManyMutationInput, IdexSyncOrderUncheckedUpdateManyInput>
    /**
     * Filter which IdexSyncOrders to update
     */
    where?: IdexSyncOrderWhereInput
    /**
     * Limit how many IdexSyncOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IdexSyncOrder upsert
   */
  export type IdexSyncOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the IdexSyncOrder to update in case it exists.
     */
    where: IdexSyncOrderWhereUniqueInput
    /**
     * In case the IdexSyncOrder found by the `where` argument doesn't exist, create a new IdexSyncOrder with this data.
     */
    create: XOR<IdexSyncOrderCreateInput, IdexSyncOrderUncheckedCreateInput>
    /**
     * In case the IdexSyncOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdexSyncOrderUpdateInput, IdexSyncOrderUncheckedUpdateInput>
  }

  /**
   * IdexSyncOrder delete
   */
  export type IdexSyncOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderInclude<ExtArgs> | null
    /**
     * Filter which IdexSyncOrder to delete.
     */
    where: IdexSyncOrderWhereUniqueInput
  }

  /**
   * IdexSyncOrder deleteMany
   */
  export type IdexSyncOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdexSyncOrders to delete
     */
    where?: IdexSyncOrderWhereInput
    /**
     * Limit how many IdexSyncOrders to delete.
     */
    limit?: number
  }

  /**
   * IdexSyncOrder.IdexCabinet
   */
  export type IdexSyncOrder$IdexCabinetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexCabinet
     */
    select?: IdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexCabinet
     */
    omit?: IdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexCabinetInclude<ExtArgs> | null
    where?: IdexCabinetWhereInput
  }

  /**
   * IdexSyncOrder without action
   */
  export type IdexSyncOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexSyncOrder
     */
    select?: IdexSyncOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexSyncOrder
     */
    omit?: IdexSyncOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexSyncOrderInclude<ExtArgs> | null
  }


  /**
   * Model IdexTransaction
   */

  export type AggregateIdexTransaction = {
    _count: IdexTransactionCountAggregateOutputType | null
    _avg: IdexTransactionAvgAggregateOutputType | null
    _sum: IdexTransactionSumAggregateOutputType | null
    _min: IdexTransactionMinAggregateOutputType | null
    _max: IdexTransactionMaxAggregateOutputType | null
  }

  export type IdexTransactionAvgAggregateOutputType = {
    id: number | null
    externalId: number | null
    paymentMethodId: number | null
    status: number | null
    cabinetId: number | null
  }

  export type IdexTransactionSumAggregateOutputType = {
    id: number | null
    externalId: bigint | null
    paymentMethodId: bigint | null
    status: number | null
    cabinetId: number | null
  }

  export type IdexTransactionMinAggregateOutputType = {
    id: number | null
    externalId: bigint | null
    paymentMethodId: bigint | null
    wallet: string | null
    status: number | null
    approvedAt: string | null
    expiredAt: string | null
    createdAtExternal: string | null
    updatedAtExternal: string | null
    cabinetId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdexTransactionMaxAggregateOutputType = {
    id: number | null
    externalId: bigint | null
    paymentMethodId: bigint | null
    wallet: string | null
    status: number | null
    approvedAt: string | null
    expiredAt: string | null
    createdAtExternal: string | null
    updatedAtExternal: string | null
    cabinetId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdexTransactionCountAggregateOutputType = {
    id: number
    externalId: number
    paymentMethodId: number
    wallet: number
    amount: number
    total: number
    status: number
    approvedAt: number
    expiredAt: number
    createdAtExternal: number
    updatedAtExternal: number
    extraData: number
    cabinetId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IdexTransactionAvgAggregateInputType = {
    id?: true
    externalId?: true
    paymentMethodId?: true
    status?: true
    cabinetId?: true
  }

  export type IdexTransactionSumAggregateInputType = {
    id?: true
    externalId?: true
    paymentMethodId?: true
    status?: true
    cabinetId?: true
  }

  export type IdexTransactionMinAggregateInputType = {
    id?: true
    externalId?: true
    paymentMethodId?: true
    wallet?: true
    status?: true
    approvedAt?: true
    expiredAt?: true
    createdAtExternal?: true
    updatedAtExternal?: true
    cabinetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdexTransactionMaxAggregateInputType = {
    id?: true
    externalId?: true
    paymentMethodId?: true
    wallet?: true
    status?: true
    approvedAt?: true
    expiredAt?: true
    createdAtExternal?: true
    updatedAtExternal?: true
    cabinetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdexTransactionCountAggregateInputType = {
    id?: true
    externalId?: true
    paymentMethodId?: true
    wallet?: true
    amount?: true
    total?: true
    status?: true
    approvedAt?: true
    expiredAt?: true
    createdAtExternal?: true
    updatedAtExternal?: true
    extraData?: true
    cabinetId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IdexTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdexTransaction to aggregate.
     */
    where?: IdexTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexTransactions to fetch.
     */
    orderBy?: IdexTransactionOrderByWithRelationInput | IdexTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdexTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IdexTransactions
    **/
    _count?: true | IdexTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IdexTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IdexTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdexTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdexTransactionMaxAggregateInputType
  }

  export type GetIdexTransactionAggregateType<T extends IdexTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateIdexTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdexTransaction[P]>
      : GetScalarType<T[P], AggregateIdexTransaction[P]>
  }




  export type IdexTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdexTransactionWhereInput
    orderBy?: IdexTransactionOrderByWithAggregationInput | IdexTransactionOrderByWithAggregationInput[]
    by: IdexTransactionScalarFieldEnum[] | IdexTransactionScalarFieldEnum
    having?: IdexTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdexTransactionCountAggregateInputType | true
    _avg?: IdexTransactionAvgAggregateInputType
    _sum?: IdexTransactionSumAggregateInputType
    _min?: IdexTransactionMinAggregateInputType
    _max?: IdexTransactionMaxAggregateInputType
  }

  export type IdexTransactionGroupByOutputType = {
    id: number
    externalId: bigint
    paymentMethodId: bigint
    wallet: string
    amount: JsonValue
    total: JsonValue
    status: number
    approvedAt: string | null
    expiredAt: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonValue
    cabinetId: number
    createdAt: Date
    updatedAt: Date
    _count: IdexTransactionCountAggregateOutputType | null
    _avg: IdexTransactionAvgAggregateOutputType | null
    _sum: IdexTransactionSumAggregateOutputType | null
    _min: IdexTransactionMinAggregateOutputType | null
    _max: IdexTransactionMaxAggregateOutputType | null
  }

  type GetIdexTransactionGroupByPayload<T extends IdexTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdexTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdexTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdexTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], IdexTransactionGroupByOutputType[P]>
        }
      >
    >


  export type IdexTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    paymentMethodId?: boolean
    wallet?: boolean
    amount?: boolean
    total?: boolean
    status?: boolean
    approvedAt?: boolean
    expiredAt?: boolean
    createdAtExternal?: boolean
    updatedAtExternal?: boolean
    extraData?: boolean
    cabinetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    BybitClipMatch?: boolean | IdexTransaction$BybitClipMatchArgs<ExtArgs>
    BybitMatch?: boolean | IdexTransaction$BybitMatchArgs<ExtArgs>
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
    Match?: boolean | IdexTransaction$MatchArgs<ExtArgs>
    _count?: boolean | IdexTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["idexTransaction"]>

  export type IdexTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    paymentMethodId?: boolean
    wallet?: boolean
    amount?: boolean
    total?: boolean
    status?: boolean
    approvedAt?: boolean
    expiredAt?: boolean
    createdAtExternal?: boolean
    updatedAtExternal?: boolean
    extraData?: boolean
    cabinetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["idexTransaction"]>

  export type IdexTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    paymentMethodId?: boolean
    wallet?: boolean
    amount?: boolean
    total?: boolean
    status?: boolean
    approvedAt?: boolean
    expiredAt?: boolean
    createdAtExternal?: boolean
    updatedAtExternal?: boolean
    extraData?: boolean
    cabinetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["idexTransaction"]>

  export type IdexTransactionSelectScalar = {
    id?: boolean
    externalId?: boolean
    paymentMethodId?: boolean
    wallet?: boolean
    amount?: boolean
    total?: boolean
    status?: boolean
    approvedAt?: boolean
    expiredAt?: boolean
    createdAtExternal?: boolean
    updatedAtExternal?: boolean
    extraData?: boolean
    cabinetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IdexTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "paymentMethodId" | "wallet" | "amount" | "total" | "status" | "approvedAt" | "expiredAt" | "createdAtExternal" | "updatedAtExternal" | "extraData" | "cabinetId" | "createdAt" | "updatedAt", ExtArgs["result"]["idexTransaction"]>
  export type IdexTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitClipMatch?: boolean | IdexTransaction$BybitClipMatchArgs<ExtArgs>
    BybitMatch?: boolean | IdexTransaction$BybitMatchArgs<ExtArgs>
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
    Match?: boolean | IdexTransaction$MatchArgs<ExtArgs>
    _count?: boolean | IdexTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IdexTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
  }
  export type IdexTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
  }

  export type $IdexTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IdexTransaction"
    objects: {
      BybitClipMatch: Prisma.$BybitClipMatchPayload<ExtArgs>[]
      BybitMatch: Prisma.$BybitMatchPayload<ExtArgs>[]
      IdexCabinet: Prisma.$IdexCabinetPayload<ExtArgs>
      Match: Prisma.$MatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      externalId: bigint
      paymentMethodId: bigint
      wallet: string
      amount: Prisma.JsonValue
      total: Prisma.JsonValue
      status: number
      approvedAt: string | null
      expiredAt: string | null
      createdAtExternal: string
      updatedAtExternal: string
      extraData: Prisma.JsonValue
      cabinetId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["idexTransaction"]>
    composites: {}
  }

  type IdexTransactionGetPayload<S extends boolean | null | undefined | IdexTransactionDefaultArgs> = $Result.GetResult<Prisma.$IdexTransactionPayload, S>

  type IdexTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdexTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdexTransactionCountAggregateInputType | true
    }

  export interface IdexTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IdexTransaction'], meta: { name: 'IdexTransaction' } }
    /**
     * Find zero or one IdexTransaction that matches the filter.
     * @param {IdexTransactionFindUniqueArgs} args - Arguments to find a IdexTransaction
     * @example
     * // Get one IdexTransaction
     * const idexTransaction = await prisma.idexTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdexTransactionFindUniqueArgs>(args: SelectSubset<T, IdexTransactionFindUniqueArgs<ExtArgs>>): Prisma__IdexTransactionClient<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IdexTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdexTransactionFindUniqueOrThrowArgs} args - Arguments to find a IdexTransaction
     * @example
     * // Get one IdexTransaction
     * const idexTransaction = await prisma.idexTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdexTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, IdexTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdexTransactionClient<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdexTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexTransactionFindFirstArgs} args - Arguments to find a IdexTransaction
     * @example
     * // Get one IdexTransaction
     * const idexTransaction = await prisma.idexTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdexTransactionFindFirstArgs>(args?: SelectSubset<T, IdexTransactionFindFirstArgs<ExtArgs>>): Prisma__IdexTransactionClient<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdexTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexTransactionFindFirstOrThrowArgs} args - Arguments to find a IdexTransaction
     * @example
     * // Get one IdexTransaction
     * const idexTransaction = await prisma.idexTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdexTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, IdexTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdexTransactionClient<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IdexTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IdexTransactions
     * const idexTransactions = await prisma.idexTransaction.findMany()
     * 
     * // Get first 10 IdexTransactions
     * const idexTransactions = await prisma.idexTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const idexTransactionWithIdOnly = await prisma.idexTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdexTransactionFindManyArgs>(args?: SelectSubset<T, IdexTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IdexTransaction.
     * @param {IdexTransactionCreateArgs} args - Arguments to create a IdexTransaction.
     * @example
     * // Create one IdexTransaction
     * const IdexTransaction = await prisma.idexTransaction.create({
     *   data: {
     *     // ... data to create a IdexTransaction
     *   }
     * })
     * 
     */
    create<T extends IdexTransactionCreateArgs>(args: SelectSubset<T, IdexTransactionCreateArgs<ExtArgs>>): Prisma__IdexTransactionClient<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IdexTransactions.
     * @param {IdexTransactionCreateManyArgs} args - Arguments to create many IdexTransactions.
     * @example
     * // Create many IdexTransactions
     * const idexTransaction = await prisma.idexTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdexTransactionCreateManyArgs>(args?: SelectSubset<T, IdexTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IdexTransactions and returns the data saved in the database.
     * @param {IdexTransactionCreateManyAndReturnArgs} args - Arguments to create many IdexTransactions.
     * @example
     * // Create many IdexTransactions
     * const idexTransaction = await prisma.idexTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IdexTransactions and only return the `id`
     * const idexTransactionWithIdOnly = await prisma.idexTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdexTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, IdexTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IdexTransaction.
     * @param {IdexTransactionDeleteArgs} args - Arguments to delete one IdexTransaction.
     * @example
     * // Delete one IdexTransaction
     * const IdexTransaction = await prisma.idexTransaction.delete({
     *   where: {
     *     // ... filter to delete one IdexTransaction
     *   }
     * })
     * 
     */
    delete<T extends IdexTransactionDeleteArgs>(args: SelectSubset<T, IdexTransactionDeleteArgs<ExtArgs>>): Prisma__IdexTransactionClient<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IdexTransaction.
     * @param {IdexTransactionUpdateArgs} args - Arguments to update one IdexTransaction.
     * @example
     * // Update one IdexTransaction
     * const idexTransaction = await prisma.idexTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdexTransactionUpdateArgs>(args: SelectSubset<T, IdexTransactionUpdateArgs<ExtArgs>>): Prisma__IdexTransactionClient<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IdexTransactions.
     * @param {IdexTransactionDeleteManyArgs} args - Arguments to filter IdexTransactions to delete.
     * @example
     * // Delete a few IdexTransactions
     * const { count } = await prisma.idexTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdexTransactionDeleteManyArgs>(args?: SelectSubset<T, IdexTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdexTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IdexTransactions
     * const idexTransaction = await prisma.idexTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdexTransactionUpdateManyArgs>(args: SelectSubset<T, IdexTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdexTransactions and returns the data updated in the database.
     * @param {IdexTransactionUpdateManyAndReturnArgs} args - Arguments to update many IdexTransactions.
     * @example
     * // Update many IdexTransactions
     * const idexTransaction = await prisma.idexTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IdexTransactions and only return the `id`
     * const idexTransactionWithIdOnly = await prisma.idexTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdexTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, IdexTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IdexTransaction.
     * @param {IdexTransactionUpsertArgs} args - Arguments to update or create a IdexTransaction.
     * @example
     * // Update or create a IdexTransaction
     * const idexTransaction = await prisma.idexTransaction.upsert({
     *   create: {
     *     // ... data to create a IdexTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IdexTransaction we want to update
     *   }
     * })
     */
    upsert<T extends IdexTransactionUpsertArgs>(args: SelectSubset<T, IdexTransactionUpsertArgs<ExtArgs>>): Prisma__IdexTransactionClient<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IdexTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexTransactionCountArgs} args - Arguments to filter IdexTransactions to count.
     * @example
     * // Count the number of IdexTransactions
     * const count = await prisma.idexTransaction.count({
     *   where: {
     *     // ... the filter for the IdexTransactions we want to count
     *   }
     * })
    **/
    count<T extends IdexTransactionCountArgs>(
      args?: Subset<T, IdexTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdexTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IdexTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdexTransactionAggregateArgs>(args: Subset<T, IdexTransactionAggregateArgs>): Prisma.PrismaPromise<GetIdexTransactionAggregateType<T>>

    /**
     * Group by IdexTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdexTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdexTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdexTransactionGroupByArgs['orderBy'] }
        : { orderBy?: IdexTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdexTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdexTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IdexTransaction model
   */
  readonly fields: IdexTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IdexTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdexTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BybitClipMatch<T extends IdexTransaction$BybitClipMatchArgs<ExtArgs> = {}>(args?: Subset<T, IdexTransaction$BybitClipMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BybitMatch<T extends IdexTransaction$BybitMatchArgs<ExtArgs> = {}>(args?: Subset<T, IdexTransaction$BybitMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    IdexCabinet<T extends IdexCabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IdexCabinetDefaultArgs<ExtArgs>>): Prisma__IdexCabinetClient<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Match<T extends IdexTransaction$MatchArgs<ExtArgs> = {}>(args?: Subset<T, IdexTransaction$MatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IdexTransaction model
   */
  interface IdexTransactionFieldRefs {
    readonly id: FieldRef<"IdexTransaction", 'Int'>
    readonly externalId: FieldRef<"IdexTransaction", 'BigInt'>
    readonly paymentMethodId: FieldRef<"IdexTransaction", 'BigInt'>
    readonly wallet: FieldRef<"IdexTransaction", 'String'>
    readonly amount: FieldRef<"IdexTransaction", 'Json'>
    readonly total: FieldRef<"IdexTransaction", 'Json'>
    readonly status: FieldRef<"IdexTransaction", 'Int'>
    readonly approvedAt: FieldRef<"IdexTransaction", 'String'>
    readonly expiredAt: FieldRef<"IdexTransaction", 'String'>
    readonly createdAtExternal: FieldRef<"IdexTransaction", 'String'>
    readonly updatedAtExternal: FieldRef<"IdexTransaction", 'String'>
    readonly extraData: FieldRef<"IdexTransaction", 'Json'>
    readonly cabinetId: FieldRef<"IdexTransaction", 'Int'>
    readonly createdAt: FieldRef<"IdexTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"IdexTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IdexTransaction findUnique
   */
  export type IdexTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionInclude<ExtArgs> | null
    /**
     * Filter, which IdexTransaction to fetch.
     */
    where: IdexTransactionWhereUniqueInput
  }

  /**
   * IdexTransaction findUniqueOrThrow
   */
  export type IdexTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionInclude<ExtArgs> | null
    /**
     * Filter, which IdexTransaction to fetch.
     */
    where: IdexTransactionWhereUniqueInput
  }

  /**
   * IdexTransaction findFirst
   */
  export type IdexTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionInclude<ExtArgs> | null
    /**
     * Filter, which IdexTransaction to fetch.
     */
    where?: IdexTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexTransactions to fetch.
     */
    orderBy?: IdexTransactionOrderByWithRelationInput | IdexTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdexTransactions.
     */
    cursor?: IdexTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdexTransactions.
     */
    distinct?: IdexTransactionScalarFieldEnum | IdexTransactionScalarFieldEnum[]
  }

  /**
   * IdexTransaction findFirstOrThrow
   */
  export type IdexTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionInclude<ExtArgs> | null
    /**
     * Filter, which IdexTransaction to fetch.
     */
    where?: IdexTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexTransactions to fetch.
     */
    orderBy?: IdexTransactionOrderByWithRelationInput | IdexTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdexTransactions.
     */
    cursor?: IdexTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdexTransactions.
     */
    distinct?: IdexTransactionScalarFieldEnum | IdexTransactionScalarFieldEnum[]
  }

  /**
   * IdexTransaction findMany
   */
  export type IdexTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionInclude<ExtArgs> | null
    /**
     * Filter, which IdexTransactions to fetch.
     */
    where?: IdexTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdexTransactions to fetch.
     */
    orderBy?: IdexTransactionOrderByWithRelationInput | IdexTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IdexTransactions.
     */
    cursor?: IdexTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdexTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdexTransactions.
     */
    skip?: number
    distinct?: IdexTransactionScalarFieldEnum | IdexTransactionScalarFieldEnum[]
  }

  /**
   * IdexTransaction create
   */
  export type IdexTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a IdexTransaction.
     */
    data: XOR<IdexTransactionCreateInput, IdexTransactionUncheckedCreateInput>
  }

  /**
   * IdexTransaction createMany
   */
  export type IdexTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IdexTransactions.
     */
    data: IdexTransactionCreateManyInput | IdexTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IdexTransaction createManyAndReturn
   */
  export type IdexTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many IdexTransactions.
     */
    data: IdexTransactionCreateManyInput | IdexTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IdexTransaction update
   */
  export type IdexTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a IdexTransaction.
     */
    data: XOR<IdexTransactionUpdateInput, IdexTransactionUncheckedUpdateInput>
    /**
     * Choose, which IdexTransaction to update.
     */
    where: IdexTransactionWhereUniqueInput
  }

  /**
   * IdexTransaction updateMany
   */
  export type IdexTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IdexTransactions.
     */
    data: XOR<IdexTransactionUpdateManyMutationInput, IdexTransactionUncheckedUpdateManyInput>
    /**
     * Filter which IdexTransactions to update
     */
    where?: IdexTransactionWhereInput
    /**
     * Limit how many IdexTransactions to update.
     */
    limit?: number
  }

  /**
   * IdexTransaction updateManyAndReturn
   */
  export type IdexTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * The data used to update IdexTransactions.
     */
    data: XOR<IdexTransactionUpdateManyMutationInput, IdexTransactionUncheckedUpdateManyInput>
    /**
     * Filter which IdexTransactions to update
     */
    where?: IdexTransactionWhereInput
    /**
     * Limit how many IdexTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IdexTransaction upsert
   */
  export type IdexTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the IdexTransaction to update in case it exists.
     */
    where: IdexTransactionWhereUniqueInput
    /**
     * In case the IdexTransaction found by the `where` argument doesn't exist, create a new IdexTransaction with this data.
     */
    create: XOR<IdexTransactionCreateInput, IdexTransactionUncheckedCreateInput>
    /**
     * In case the IdexTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdexTransactionUpdateInput, IdexTransactionUncheckedUpdateInput>
  }

  /**
   * IdexTransaction delete
   */
  export type IdexTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionInclude<ExtArgs> | null
    /**
     * Filter which IdexTransaction to delete.
     */
    where: IdexTransactionWhereUniqueInput
  }

  /**
   * IdexTransaction deleteMany
   */
  export type IdexTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdexTransactions to delete
     */
    where?: IdexTransactionWhereInput
    /**
     * Limit how many IdexTransactions to delete.
     */
    limit?: number
  }

  /**
   * IdexTransaction.BybitClipMatch
   */
  export type IdexTransaction$BybitClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    where?: BybitClipMatchWhereInput
    orderBy?: BybitClipMatchOrderByWithRelationInput | BybitClipMatchOrderByWithRelationInput[]
    cursor?: BybitClipMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BybitClipMatchScalarFieldEnum | BybitClipMatchScalarFieldEnum[]
  }

  /**
   * IdexTransaction.BybitMatch
   */
  export type IdexTransaction$BybitMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitMatch
     */
    select?: BybitMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitMatch
     */
    omit?: BybitMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitMatchInclude<ExtArgs> | null
    where?: BybitMatchWhereInput
    orderBy?: BybitMatchOrderByWithRelationInput | BybitMatchOrderByWithRelationInput[]
    cursor?: BybitMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BybitMatchScalarFieldEnum | BybitMatchScalarFieldEnum[]
  }

  /**
   * IdexTransaction.Match
   */
  export type IdexTransaction$MatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * IdexTransaction without action
   */
  export type IdexTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdexTransaction
     */
    select?: IdexTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdexTransaction
     */
    omit?: IdexTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdexTransactionInclude<ExtArgs> | null
  }


  /**
   * Model ImportExport
   */

  export type AggregateImportExport = {
    _count: ImportExportCountAggregateOutputType | null
    _avg: ImportExportAvgAggregateOutputType | null
    _sum: ImportExportSumAggregateOutputType | null
    _min: ImportExportMinAggregateOutputType | null
    _max: ImportExportMaxAggregateOutputType | null
  }

  export type ImportExportAvgAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type ImportExportSumAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type ImportExportMinAggregateOutputType = {
    id: number | null
    tableId: number | null
    name: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImportExportMaxAggregateOutputType = {
    id: number | null
    tableId: number | null
    name: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImportExportCountAggregateOutputType = {
    id: number
    tableId: number
    name: number
    type: number
    mappings: number
    options: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImportExportAvgAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type ImportExportSumAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type ImportExportMinAggregateInputType = {
    id?: true
    tableId?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImportExportMaxAggregateInputType = {
    id?: true
    tableId?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImportExportCountAggregateInputType = {
    id?: true
    tableId?: true
    name?: true
    type?: true
    mappings?: true
    options?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImportExportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportExport to aggregate.
     */
    where?: ImportExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportExports to fetch.
     */
    orderBy?: ImportExportOrderByWithRelationInput | ImportExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportExports
    **/
    _count?: true | ImportExportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportExportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportExportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportExportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportExportMaxAggregateInputType
  }

  export type GetImportExportAggregateType<T extends ImportExportAggregateArgs> = {
        [P in keyof T & keyof AggregateImportExport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportExport[P]>
      : GetScalarType<T[P], AggregateImportExport[P]>
  }




  export type ImportExportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportExportWhereInput
    orderBy?: ImportExportOrderByWithAggregationInput | ImportExportOrderByWithAggregationInput[]
    by: ImportExportScalarFieldEnum[] | ImportExportScalarFieldEnum
    having?: ImportExportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportExportCountAggregateInputType | true
    _avg?: ImportExportAvgAggregateInputType
    _sum?: ImportExportSumAggregateInputType
    _min?: ImportExportMinAggregateInputType
    _max?: ImportExportMaxAggregateInputType
  }

  export type ImportExportGroupByOutputType = {
    id: number
    tableId: number
    name: string
    type: string
    mappings: JsonValue
    options: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ImportExportCountAggregateOutputType | null
    _avg: ImportExportAvgAggregateOutputType | null
    _sum: ImportExportSumAggregateOutputType | null
    _min: ImportExportMinAggregateOutputType | null
    _max: ImportExportMaxAggregateOutputType | null
  }

  type GetImportExportGroupByPayload<T extends ImportExportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportExportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportExportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportExportGroupByOutputType[P]>
            : GetScalarType<T[P], ImportExportGroupByOutputType[P]>
        }
      >
    >


  export type ImportExportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    name?: boolean
    type?: boolean
    mappings?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["importExport"]>

  export type ImportExportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    name?: boolean
    type?: boolean
    mappings?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["importExport"]>

  export type ImportExportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    name?: boolean
    type?: boolean
    mappings?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["importExport"]>

  export type ImportExportSelectScalar = {
    id?: boolean
    tableId?: boolean
    name?: boolean
    type?: boolean
    mappings?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImportExportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableId" | "name" | "type" | "mappings" | "options" | "createdAt" | "updatedAt", ExtArgs["result"]["importExport"]>

  export type $ImportExportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportExport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tableId: number
      name: string
      type: string
      mappings: Prisma.JsonValue
      options: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["importExport"]>
    composites: {}
  }

  type ImportExportGetPayload<S extends boolean | null | undefined | ImportExportDefaultArgs> = $Result.GetResult<Prisma.$ImportExportPayload, S>

  type ImportExportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImportExportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImportExportCountAggregateInputType | true
    }

  export interface ImportExportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportExport'], meta: { name: 'ImportExport' } }
    /**
     * Find zero or one ImportExport that matches the filter.
     * @param {ImportExportFindUniqueArgs} args - Arguments to find a ImportExport
     * @example
     * // Get one ImportExport
     * const importExport = await prisma.importExport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportExportFindUniqueArgs>(args: SelectSubset<T, ImportExportFindUniqueArgs<ExtArgs>>): Prisma__ImportExportClient<$Result.GetResult<Prisma.$ImportExportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImportExport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImportExportFindUniqueOrThrowArgs} args - Arguments to find a ImportExport
     * @example
     * // Get one ImportExport
     * const importExport = await prisma.importExport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportExportFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportExportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportExportClient<$Result.GetResult<Prisma.$ImportExportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportExport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportExportFindFirstArgs} args - Arguments to find a ImportExport
     * @example
     * // Get one ImportExport
     * const importExport = await prisma.importExport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportExportFindFirstArgs>(args?: SelectSubset<T, ImportExportFindFirstArgs<ExtArgs>>): Prisma__ImportExportClient<$Result.GetResult<Prisma.$ImportExportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportExport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportExportFindFirstOrThrowArgs} args - Arguments to find a ImportExport
     * @example
     * // Get one ImportExport
     * const importExport = await prisma.importExport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportExportFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportExportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportExportClient<$Result.GetResult<Prisma.$ImportExportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImportExports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportExportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportExports
     * const importExports = await prisma.importExport.findMany()
     * 
     * // Get first 10 ImportExports
     * const importExports = await prisma.importExport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importExportWithIdOnly = await prisma.importExport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportExportFindManyArgs>(args?: SelectSubset<T, ImportExportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportExportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImportExport.
     * @param {ImportExportCreateArgs} args - Arguments to create a ImportExport.
     * @example
     * // Create one ImportExport
     * const ImportExport = await prisma.importExport.create({
     *   data: {
     *     // ... data to create a ImportExport
     *   }
     * })
     * 
     */
    create<T extends ImportExportCreateArgs>(args: SelectSubset<T, ImportExportCreateArgs<ExtArgs>>): Prisma__ImportExportClient<$Result.GetResult<Prisma.$ImportExportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImportExports.
     * @param {ImportExportCreateManyArgs} args - Arguments to create many ImportExports.
     * @example
     * // Create many ImportExports
     * const importExport = await prisma.importExport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportExportCreateManyArgs>(args?: SelectSubset<T, ImportExportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportExports and returns the data saved in the database.
     * @param {ImportExportCreateManyAndReturnArgs} args - Arguments to create many ImportExports.
     * @example
     * // Create many ImportExports
     * const importExport = await prisma.importExport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportExports and only return the `id`
     * const importExportWithIdOnly = await prisma.importExport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportExportCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportExportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportExportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImportExport.
     * @param {ImportExportDeleteArgs} args - Arguments to delete one ImportExport.
     * @example
     * // Delete one ImportExport
     * const ImportExport = await prisma.importExport.delete({
     *   where: {
     *     // ... filter to delete one ImportExport
     *   }
     * })
     * 
     */
    delete<T extends ImportExportDeleteArgs>(args: SelectSubset<T, ImportExportDeleteArgs<ExtArgs>>): Prisma__ImportExportClient<$Result.GetResult<Prisma.$ImportExportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImportExport.
     * @param {ImportExportUpdateArgs} args - Arguments to update one ImportExport.
     * @example
     * // Update one ImportExport
     * const importExport = await prisma.importExport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportExportUpdateArgs>(args: SelectSubset<T, ImportExportUpdateArgs<ExtArgs>>): Prisma__ImportExportClient<$Result.GetResult<Prisma.$ImportExportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImportExports.
     * @param {ImportExportDeleteManyArgs} args - Arguments to filter ImportExports to delete.
     * @example
     * // Delete a few ImportExports
     * const { count } = await prisma.importExport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportExportDeleteManyArgs>(args?: SelectSubset<T, ImportExportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportExportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportExports
     * const importExport = await prisma.importExport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportExportUpdateManyArgs>(args: SelectSubset<T, ImportExportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportExports and returns the data updated in the database.
     * @param {ImportExportUpdateManyAndReturnArgs} args - Arguments to update many ImportExports.
     * @example
     * // Update many ImportExports
     * const importExport = await prisma.importExport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImportExports and only return the `id`
     * const importExportWithIdOnly = await prisma.importExport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImportExportUpdateManyAndReturnArgs>(args: SelectSubset<T, ImportExportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportExportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImportExport.
     * @param {ImportExportUpsertArgs} args - Arguments to update or create a ImportExport.
     * @example
     * // Update or create a ImportExport
     * const importExport = await prisma.importExport.upsert({
     *   create: {
     *     // ... data to create a ImportExport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportExport we want to update
     *   }
     * })
     */
    upsert<T extends ImportExportUpsertArgs>(args: SelectSubset<T, ImportExportUpsertArgs<ExtArgs>>): Prisma__ImportExportClient<$Result.GetResult<Prisma.$ImportExportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImportExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportExportCountArgs} args - Arguments to filter ImportExports to count.
     * @example
     * // Count the number of ImportExports
     * const count = await prisma.importExport.count({
     *   where: {
     *     // ... the filter for the ImportExports we want to count
     *   }
     * })
    **/
    count<T extends ImportExportCountArgs>(
      args?: Subset<T, ImportExportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportExportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportExportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportExportAggregateArgs>(args: Subset<T, ImportExportAggregateArgs>): Prisma.PrismaPromise<GetImportExportAggregateType<T>>

    /**
     * Group by ImportExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportExportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportExportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportExportGroupByArgs['orderBy'] }
        : { orderBy?: ImportExportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportExportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportExportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportExport model
   */
  readonly fields: ImportExportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportExport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportExportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportExport model
   */
  interface ImportExportFieldRefs {
    readonly id: FieldRef<"ImportExport", 'Int'>
    readonly tableId: FieldRef<"ImportExport", 'Int'>
    readonly name: FieldRef<"ImportExport", 'String'>
    readonly type: FieldRef<"ImportExport", 'String'>
    readonly mappings: FieldRef<"ImportExport", 'Json'>
    readonly options: FieldRef<"ImportExport", 'Json'>
    readonly createdAt: FieldRef<"ImportExport", 'DateTime'>
    readonly updatedAt: FieldRef<"ImportExport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportExport findUnique
   */
  export type ImportExportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
    /**
     * Filter, which ImportExport to fetch.
     */
    where: ImportExportWhereUniqueInput
  }

  /**
   * ImportExport findUniqueOrThrow
   */
  export type ImportExportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
    /**
     * Filter, which ImportExport to fetch.
     */
    where: ImportExportWhereUniqueInput
  }

  /**
   * ImportExport findFirst
   */
  export type ImportExportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
    /**
     * Filter, which ImportExport to fetch.
     */
    where?: ImportExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportExports to fetch.
     */
    orderBy?: ImportExportOrderByWithRelationInput | ImportExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportExports.
     */
    cursor?: ImportExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportExports.
     */
    distinct?: ImportExportScalarFieldEnum | ImportExportScalarFieldEnum[]
  }

  /**
   * ImportExport findFirstOrThrow
   */
  export type ImportExportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
    /**
     * Filter, which ImportExport to fetch.
     */
    where?: ImportExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportExports to fetch.
     */
    orderBy?: ImportExportOrderByWithRelationInput | ImportExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportExports.
     */
    cursor?: ImportExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportExports.
     */
    distinct?: ImportExportScalarFieldEnum | ImportExportScalarFieldEnum[]
  }

  /**
   * ImportExport findMany
   */
  export type ImportExportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
    /**
     * Filter, which ImportExports to fetch.
     */
    where?: ImportExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportExports to fetch.
     */
    orderBy?: ImportExportOrderByWithRelationInput | ImportExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportExports.
     */
    cursor?: ImportExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportExports.
     */
    skip?: number
    distinct?: ImportExportScalarFieldEnum | ImportExportScalarFieldEnum[]
  }

  /**
   * ImportExport create
   */
  export type ImportExportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
    /**
     * The data needed to create a ImportExport.
     */
    data: XOR<ImportExportCreateInput, ImportExportUncheckedCreateInput>
  }

  /**
   * ImportExport createMany
   */
  export type ImportExportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportExports.
     */
    data: ImportExportCreateManyInput | ImportExportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportExport createManyAndReturn
   */
  export type ImportExportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
    /**
     * The data used to create many ImportExports.
     */
    data: ImportExportCreateManyInput | ImportExportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportExport update
   */
  export type ImportExportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
    /**
     * The data needed to update a ImportExport.
     */
    data: XOR<ImportExportUpdateInput, ImportExportUncheckedUpdateInput>
    /**
     * Choose, which ImportExport to update.
     */
    where: ImportExportWhereUniqueInput
  }

  /**
   * ImportExport updateMany
   */
  export type ImportExportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportExports.
     */
    data: XOR<ImportExportUpdateManyMutationInput, ImportExportUncheckedUpdateManyInput>
    /**
     * Filter which ImportExports to update
     */
    where?: ImportExportWhereInput
    /**
     * Limit how many ImportExports to update.
     */
    limit?: number
  }

  /**
   * ImportExport updateManyAndReturn
   */
  export type ImportExportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
    /**
     * The data used to update ImportExports.
     */
    data: XOR<ImportExportUpdateManyMutationInput, ImportExportUncheckedUpdateManyInput>
    /**
     * Filter which ImportExports to update
     */
    where?: ImportExportWhereInput
    /**
     * Limit how many ImportExports to update.
     */
    limit?: number
  }

  /**
   * ImportExport upsert
   */
  export type ImportExportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
    /**
     * The filter to search for the ImportExport to update in case it exists.
     */
    where: ImportExportWhereUniqueInput
    /**
     * In case the ImportExport found by the `where` argument doesn't exist, create a new ImportExport with this data.
     */
    create: XOR<ImportExportCreateInput, ImportExportUncheckedCreateInput>
    /**
     * In case the ImportExport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportExportUpdateInput, ImportExportUncheckedUpdateInput>
  }

  /**
   * ImportExport delete
   */
  export type ImportExportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
    /**
     * Filter which ImportExport to delete.
     */
    where: ImportExportWhereUniqueInput
  }

  /**
   * ImportExport deleteMany
   */
  export type ImportExportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportExports to delete
     */
    where?: ImportExportWhereInput
    /**
     * Limit how many ImportExports to delete.
     */
    limit?: number
  }

  /**
   * ImportExport without action
   */
  export type ImportExportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportExport
     */
    select?: ImportExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportExport
     */
    omit?: ImportExportOmit<ExtArgs> | null
  }


  /**
   * Model Match
   */

  export type AggregateMatch = {
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  export type MatchAvgAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    transactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
  }

  export type MatchSumAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    transactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
  }

  export type MatchMinAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    transactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchMaxAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    transactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchCountAggregateOutputType = {
    id: number
    idexTransactionId: number
    transactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchAvgAggregateInputType = {
    id?: true
    idexTransactionId?: true
    transactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
  }

  export type MatchSumAggregateInputType = {
    id?: true
    idexTransactionId?: true
    transactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
  }

  export type MatchMinAggregateInputType = {
    id?: true
    idexTransactionId?: true
    transactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchMaxAggregateInputType = {
    id?: true
    idexTransactionId?: true
    transactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchCountAggregateInputType = {
    id?: true
    idexTransactionId?: true
    transactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Match to aggregate.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matches
    **/
    _count?: true | MatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMaxAggregateInputType
  }

  export type GetMatchAggregateType<T extends MatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatch[P]>
      : GetScalarType<T[P], AggregateMatch[P]>
  }




  export type MatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithAggregationInput | MatchOrderByWithAggregationInput[]
    by: MatchScalarFieldEnum[] | MatchScalarFieldEnum
    having?: MatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchCountAggregateInputType | true
    _avg?: MatchAvgAggregateInputType
    _sum?: MatchSumAggregateInputType
    _min?: MatchMinAggregateInputType
    _max?: MatchMaxAggregateInputType
  }

  export type MatchGroupByOutputType = {
    id: number
    idexTransactionId: number
    transactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt: Date
    updatedAt: Date
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  type GetMatchGroupByPayload<T extends MatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchGroupByOutputType[P]>
            : GetScalarType<T[P], MatchGroupByOutputType[P]>
        }
      >
    >


  export type MatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idexTransactionId?: boolean
    transactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idexTransactionId?: boolean
    transactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idexTransactionId?: boolean
    transactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectScalar = {
    id?: boolean
    idexTransactionId?: boolean
    transactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idexTransactionId" | "transactionId" | "timeDifference" | "grossExpense" | "grossIncome" | "grossProfit" | "profitPercentage" | "createdAt" | "updatedAt", ExtArgs["result"]["match"]>
  export type MatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type MatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type MatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $MatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Match"
    objects: {
      IdexTransaction: Prisma.$IdexTransactionPayload<ExtArgs>
      Transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idexTransactionId: number
      transactionId: number
      timeDifference: number
      grossExpense: number
      grossIncome: number
      grossProfit: number
      profitPercentage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["match"]>
    composites: {}
  }

  type MatchGetPayload<S extends boolean | null | undefined | MatchDefaultArgs> = $Result.GetResult<Prisma.$MatchPayload, S>

  type MatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchCountAggregateInputType | true
    }

  export interface MatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Match'], meta: { name: 'Match' } }
    /**
     * Find zero or one Match that matches the filter.
     * @param {MatchFindUniqueArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchFindUniqueArgs>(args: SelectSubset<T, MatchFindUniqueArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Match that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchFindUniqueOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchFindFirstArgs>(args?: SelectSubset<T, MatchFindFirstArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.match.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.match.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchWithIdOnly = await prisma.match.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchFindManyArgs>(args?: SelectSubset<T, MatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Match.
     * @param {MatchCreateArgs} args - Arguments to create a Match.
     * @example
     * // Create one Match
     * const Match = await prisma.match.create({
     *   data: {
     *     // ... data to create a Match
     *   }
     * })
     * 
     */
    create<T extends MatchCreateArgs>(args: SelectSubset<T, MatchCreateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Matches.
     * @param {MatchCreateManyArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchCreateManyArgs>(args?: SelectSubset<T, MatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Matches and returns the data saved in the database.
     * @param {MatchCreateManyAndReturnArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Match.
     * @param {MatchDeleteArgs} args - Arguments to delete one Match.
     * @example
     * // Delete one Match
     * const Match = await prisma.match.delete({
     *   where: {
     *     // ... filter to delete one Match
     *   }
     * })
     * 
     */
    delete<T extends MatchDeleteArgs>(args: SelectSubset<T, MatchDeleteArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Match.
     * @param {MatchUpdateArgs} args - Arguments to update one Match.
     * @example
     * // Update one Match
     * const match = await prisma.match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchUpdateArgs>(args: SelectSubset<T, MatchUpdateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Matches.
     * @param {MatchDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchDeleteManyArgs>(args?: SelectSubset<T, MatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchUpdateManyArgs>(args: SelectSubset<T, MatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches and returns the data updated in the database.
     * @param {MatchUpdateManyAndReturnArgs} args - Arguments to update many Matches.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Match.
     * @param {MatchUpsertArgs} args - Arguments to update or create a Match.
     * @example
     * // Update or create a Match
     * const match = await prisma.match.upsert({
     *   create: {
     *     // ... data to create a Match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Match we want to update
     *   }
     * })
     */
    upsert<T extends MatchUpsertArgs>(args: SelectSubset<T, MatchUpsertArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.match.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends MatchCountArgs>(
      args?: Subset<T, MatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchAggregateArgs>(args: Subset<T, MatchAggregateArgs>): Prisma.PrismaPromise<GetMatchAggregateType<T>>

    /**
     * Group by Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchGroupByArgs['orderBy'] }
        : { orderBy?: MatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Match model
   */
  readonly fields: MatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    IdexTransaction<T extends IdexTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IdexTransactionDefaultArgs<ExtArgs>>): Prisma__IdexTransactionClient<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Match model
   */
  interface MatchFieldRefs {
    readonly id: FieldRef<"Match", 'Int'>
    readonly idexTransactionId: FieldRef<"Match", 'Int'>
    readonly transactionId: FieldRef<"Match", 'Int'>
    readonly timeDifference: FieldRef<"Match", 'Int'>
    readonly grossExpense: FieldRef<"Match", 'Float'>
    readonly grossIncome: FieldRef<"Match", 'Float'>
    readonly grossProfit: FieldRef<"Match", 'Float'>
    readonly profitPercentage: FieldRef<"Match", 'Float'>
    readonly createdAt: FieldRef<"Match", 'DateTime'>
    readonly updatedAt: FieldRef<"Match", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Match findUnique
   */
  export type MatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findUniqueOrThrow
   */
  export type MatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findFirst
   */
  export type MatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findFirstOrThrow
   */
  export type MatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findMany
   */
  export type MatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match create
   */
  export type MatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Match.
     */
    data: XOR<MatchCreateInput, MatchUncheckedCreateInput>
  }

  /**
   * Match createMany
   */
  export type MatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Match createManyAndReturn
   */
  export type MatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match update
   */
  export type MatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Match.
     */
    data: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
    /**
     * Choose, which Match to update.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match updateMany
   */
  export type MatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
  }

  /**
   * Match updateManyAndReturn
   */
  export type MatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match upsert
   */
  export type MatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Match to update in case it exists.
     */
    where: MatchWhereUniqueInput
    /**
     * In case the Match found by the `where` argument doesn't exist, create a new Match with this data.
     */
    create: XOR<MatchCreateInput, MatchUncheckedCreateInput>
    /**
     * In case the Match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
  }

  /**
   * Match delete
   */
  export type MatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter which Match to delete.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match deleteMany
   */
  export type MatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to delete
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to delete.
     */
    limit?: number
  }

  /**
   * Match without action
   */
  export type MatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSettings
   */

  export type AggregateNotificationSettings = {
    _count: NotificationSettingsCountAggregateOutputType | null
    _avg: NotificationSettingsAvgAggregateOutputType | null
    _sum: NotificationSettingsSumAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  export type NotificationSettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type NotificationSettingsSumAggregateOutputType = {
    id: number | null
  }

  export type NotificationSettingsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingsCountAggregateOutputType = {
    id: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationSettingsAvgAggregateInputType = {
    id?: true
  }

  export type NotificationSettingsSumAggregateInputType = {
    id?: true
  }

  export type NotificationSettingsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingsCountAggregateInputType = {
    id?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to aggregate.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSettings
    **/
    _count?: true | NotificationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type GetNotificationSettingsAggregateType<T extends NotificationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSettings[P]>
      : GetScalarType<T[P], AggregateNotificationSettings[P]>
  }




  export type NotificationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithAggregationInput | NotificationSettingsOrderByWithAggregationInput[]
    by: NotificationSettingsScalarFieldEnum[] | NotificationSettingsScalarFieldEnum
    having?: NotificationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSettingsCountAggregateInputType | true
    _avg?: NotificationSettingsAvgAggregateInputType
    _sum?: NotificationSettingsSumAggregateInputType
    _min?: NotificationSettingsMinAggregateInputType
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type NotificationSettingsGroupByOutputType = {
    id: number
    settings: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: NotificationSettingsCountAggregateOutputType | null
    _avg: NotificationSettingsAvgAggregateOutputType | null
    _sum: NotificationSettingsSumAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  type GetNotificationSettingsGroupByPayload<T extends NotificationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectScalar = {
    id?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "settings" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationSettings"]>

  export type $NotificationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      settings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationSettings"]>
    composites: {}
  }

  type NotificationSettingsGetPayload<S extends boolean | null | undefined | NotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingsPayload, S>

  type NotificationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationSettingsCountAggregateInputType | true
    }

  export interface NotificationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSettings'], meta: { name: 'NotificationSettings' } }
    /**
     * Find zero or one NotificationSettings that matches the filter.
     * @param {NotificationSettingsFindUniqueArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSettingsFindUniqueArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSettingsFindFirstArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany()
     * 
     * // Get first 10 NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSettingsFindManyArgs>(args?: SelectSubset<T, NotificationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationSettings.
     * @param {NotificationSettingsCreateArgs} args - Arguments to create a NotificationSettings.
     * @example
     * // Create one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.create({
     *   data: {
     *     // ... data to create a NotificationSettings
     *   }
     * })
     * 
     */
    create<T extends NotificationSettingsCreateArgs>(args: SelectSubset<T, NotificationSettingsCreateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationSettings.
     * @param {NotificationSettingsCreateManyArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSettingsCreateManyArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSettings and returns the data saved in the database.
     * @param {NotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationSettings.
     * @param {NotificationSettingsDeleteArgs} args - Arguments to delete one NotificationSettings.
     * @example
     * // Delete one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.delete({
     *   where: {
     *     // ... filter to delete one NotificationSettings
     *   }
     * })
     * 
     */
    delete<T extends NotificationSettingsDeleteArgs>(args: SelectSubset<T, NotificationSettingsDeleteArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationSettings.
     * @param {NotificationSettingsUpdateArgs} args - Arguments to update one NotificationSettings.
     * @example
     * // Update one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSettingsUpdateArgs>(args: SelectSubset<T, NotificationSettingsUpdateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationSettings.
     * @param {NotificationSettingsDeleteManyArgs} args - Arguments to filter NotificationSettings to delete.
     * @example
     * // Delete a few NotificationSettings
     * const { count } = await prisma.notificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSettingsDeleteManyArgs>(args?: SelectSubset<T, NotificationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSettingsUpdateManyArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings and returns the data updated in the database.
     * @param {NotificationSettingsUpdateManyAndReturnArgs} args - Arguments to update many NotificationSettings.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationSettings.
     * @param {NotificationSettingsUpsertArgs} args - Arguments to update or create a NotificationSettings.
     * @example
     * // Update or create a NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.upsert({
     *   create: {
     *     // ... data to create a NotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSettingsUpsertArgs>(args: SelectSubset<T, NotificationSettingsUpsertArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsCountArgs} args - Arguments to filter NotificationSettings to count.
     * @example
     * // Count the number of NotificationSettings
     * const count = await prisma.notificationSettings.count({
     *   where: {
     *     // ... the filter for the NotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends NotificationSettingsCountArgs>(
      args?: Subset<T, NotificationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSettingsAggregateArgs>(args: Subset<T, NotificationSettingsAggregateArgs>): Prisma.PrismaPromise<GetNotificationSettingsAggregateType<T>>

    /**
     * Group by NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSettings model
   */
  readonly fields: NotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSettings model
   */
  interface NotificationSettingsFieldRefs {
    readonly id: FieldRef<"NotificationSettings", 'Int'>
    readonly settings: FieldRef<"NotificationSettings", 'Json'>
    readonly createdAt: FieldRef<"NotificationSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSettings findUnique
   */
  export type NotificationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findUniqueOrThrow
   */
  export type NotificationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findFirst
   */
  export type NotificationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findFirstOrThrow
   */
  export type NotificationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findMany
   */
  export type NotificationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings create
   */
  export type NotificationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a NotificationSettings.
     */
    data: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
  }

  /**
   * NotificationSettings createMany
   */
  export type NotificationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings createManyAndReturn
   */
  export type NotificationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings update
   */
  export type NotificationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
    /**
     * Choose, which NotificationSettings to update.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings updateMany
   */
  export type NotificationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
  }

  /**
   * NotificationSettings updateManyAndReturn
   */
  export type NotificationSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
  }

  /**
   * NotificationSettings upsert
   */
  export type NotificationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the NotificationSettings to update in case it exists.
     */
    where: NotificationSettingsWhereUniqueInput
    /**
     * In case the NotificationSettings found by the `where` argument doesn't exist, create a new NotificationSettings with this data.
     */
    create: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
    /**
     * In case the NotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
  }

  /**
   * NotificationSettings delete
   */
  export type NotificationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Filter which NotificationSettings to delete.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings deleteMany
   */
  export type NotificationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to delete
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to delete.
     */
    limit?: number
  }

  /**
   * NotificationSettings without action
   */
  export type NotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
  }


  /**
   * Model Password
   */

  export type AggregatePassword = {
    _count: PasswordCountAggregateOutputType | null
    _avg: PasswordAvgAggregateOutputType | null
    _sum: PasswordSumAggregateOutputType | null
    _min: PasswordMinAggregateOutputType | null
    _max: PasswordMaxAggregateOutputType | null
  }

  export type PasswordAvgAggregateOutputType = {
    id: number | null
  }

  export type PasswordSumAggregateOutputType = {
    id: number | null
  }

  export type PasswordMinAggregateOutputType = {
    id: number | null
    name: string | null
    login: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
    type: $Enums.PasswordType | null
  }

  export type PasswordMaxAggregateOutputType = {
    id: number | null
    name: string | null
    login: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
    type: $Enums.PasswordType | null
  }

  export type PasswordCountAggregateOutputType = {
    id: number
    name: number
    login: number
    password: number
    createdAt: number
    updatedAt: number
    comment: number
    type: number
    _all: number
  }


  export type PasswordAvgAggregateInputType = {
    id?: true
  }

  export type PasswordSumAggregateInputType = {
    id?: true
  }

  export type PasswordMinAggregateInputType = {
    id?: true
    name?: true
    login?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    type?: true
  }

  export type PasswordMaxAggregateInputType = {
    id?: true
    name?: true
    login?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    type?: true
  }

  export type PasswordCountAggregateInputType = {
    id?: true
    name?: true
    login?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    type?: true
    _all?: true
  }

  export type PasswordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Password to aggregate.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passwords
    **/
    _count?: true | PasswordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordMaxAggregateInputType
  }

  export type GetPasswordAggregateType<T extends PasswordAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword[P]>
      : GetScalarType<T[P], AggregatePassword[P]>
  }




  export type PasswordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordWhereInput
    orderBy?: PasswordOrderByWithAggregationInput | PasswordOrderByWithAggregationInput[]
    by: PasswordScalarFieldEnum[] | PasswordScalarFieldEnum
    having?: PasswordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordCountAggregateInputType | true
    _avg?: PasswordAvgAggregateInputType
    _sum?: PasswordSumAggregateInputType
    _min?: PasswordMinAggregateInputType
    _max?: PasswordMaxAggregateInputType
  }

  export type PasswordGroupByOutputType = {
    id: number
    name: string
    login: string | null
    password: string
    createdAt: Date
    updatedAt: Date
    comment: string | null
    type: $Enums.PasswordType | null
    _count: PasswordCountAggregateOutputType | null
    _avg: PasswordAvgAggregateOutputType | null
    _sum: PasswordSumAggregateOutputType | null
    _min: PasswordMinAggregateOutputType | null
    _max: PasswordMaxAggregateOutputType | null
  }

  type GetPasswordGroupByPayload<T extends PasswordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordGroupByOutputType[P]>
        }
      >
    >


  export type PasswordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    login?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    type?: boolean
  }, ExtArgs["result"]["password"]>

  export type PasswordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    login?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    type?: boolean
  }, ExtArgs["result"]["password"]>

  export type PasswordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    login?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    type?: boolean
  }, ExtArgs["result"]["password"]>

  export type PasswordSelectScalar = {
    id?: boolean
    name?: boolean
    login?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    type?: boolean
  }

  export type PasswordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "login" | "password" | "createdAt" | "updatedAt" | "comment" | "type", ExtArgs["result"]["password"]>

  export type $PasswordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Password"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      login: string | null
      password: string
      createdAt: Date
      updatedAt: Date
      comment: string | null
      type: $Enums.PasswordType | null
    }, ExtArgs["result"]["password"]>
    composites: {}
  }

  type PasswordGetPayload<S extends boolean | null | undefined | PasswordDefaultArgs> = $Result.GetResult<Prisma.$PasswordPayload, S>

  type PasswordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordCountAggregateInputType | true
    }

  export interface PasswordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Password'], meta: { name: 'Password' } }
    /**
     * Find zero or one Password that matches the filter.
     * @param {PasswordFindUniqueArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordFindUniqueArgs>(args: SelectSubset<T, PasswordFindUniqueArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordFindUniqueOrThrowArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordFindFirstArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordFindFirstArgs>(args?: SelectSubset<T, PasswordFindFirstArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordFindFirstOrThrowArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passwords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passwords
     * const passwords = await prisma.password.findMany()
     * 
     * // Get first 10 Passwords
     * const passwords = await prisma.password.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordWithIdOnly = await prisma.password.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordFindManyArgs>(args?: SelectSubset<T, PasswordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password.
     * @param {PasswordCreateArgs} args - Arguments to create a Password.
     * @example
     * // Create one Password
     * const Password = await prisma.password.create({
     *   data: {
     *     // ... data to create a Password
     *   }
     * })
     * 
     */
    create<T extends PasswordCreateArgs>(args: SelectSubset<T, PasswordCreateArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passwords.
     * @param {PasswordCreateManyArgs} args - Arguments to create many Passwords.
     * @example
     * // Create many Passwords
     * const password = await prisma.password.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordCreateManyArgs>(args?: SelectSubset<T, PasswordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Passwords and returns the data saved in the database.
     * @param {PasswordCreateManyAndReturnArgs} args - Arguments to create many Passwords.
     * @example
     * // Create many Passwords
     * const password = await prisma.password.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Passwords and only return the `id`
     * const passwordWithIdOnly = await prisma.password.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Password.
     * @param {PasswordDeleteArgs} args - Arguments to delete one Password.
     * @example
     * // Delete one Password
     * const Password = await prisma.password.delete({
     *   where: {
     *     // ... filter to delete one Password
     *   }
     * })
     * 
     */
    delete<T extends PasswordDeleteArgs>(args: SelectSubset<T, PasswordDeleteArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password.
     * @param {PasswordUpdateArgs} args - Arguments to update one Password.
     * @example
     * // Update one Password
     * const password = await prisma.password.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordUpdateArgs>(args: SelectSubset<T, PasswordUpdateArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passwords.
     * @param {PasswordDeleteManyArgs} args - Arguments to filter Passwords to delete.
     * @example
     * // Delete a few Passwords
     * const { count } = await prisma.password.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordDeleteManyArgs>(args?: SelectSubset<T, PasswordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passwords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passwords
     * const password = await prisma.password.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordUpdateManyArgs>(args: SelectSubset<T, PasswordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passwords and returns the data updated in the database.
     * @param {PasswordUpdateManyAndReturnArgs} args - Arguments to update many Passwords.
     * @example
     * // Update many Passwords
     * const password = await prisma.password.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Passwords and only return the `id`
     * const passwordWithIdOnly = await prisma.password.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Password.
     * @param {PasswordUpsertArgs} args - Arguments to update or create a Password.
     * @example
     * // Update or create a Password
     * const password = await prisma.password.upsert({
     *   create: {
     *     // ... data to create a Password
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password we want to update
     *   }
     * })
     */
    upsert<T extends PasswordUpsertArgs>(args: SelectSubset<T, PasswordUpsertArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passwords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordCountArgs} args - Arguments to filter Passwords to count.
     * @example
     * // Count the number of Passwords
     * const count = await prisma.password.count({
     *   where: {
     *     // ... the filter for the Passwords we want to count
     *   }
     * })
    **/
    count<T extends PasswordCountArgs>(
      args?: Subset<T, PasswordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordAggregateArgs>(args: Subset<T, PasswordAggregateArgs>): Prisma.PrismaPromise<GetPasswordAggregateType<T>>

    /**
     * Group by Password.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordGroupByArgs['orderBy'] }
        : { orderBy?: PasswordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Password model
   */
  readonly fields: PasswordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Password.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Password model
   */
  interface PasswordFieldRefs {
    readonly id: FieldRef<"Password", 'Int'>
    readonly name: FieldRef<"Password", 'String'>
    readonly login: FieldRef<"Password", 'String'>
    readonly password: FieldRef<"Password", 'String'>
    readonly createdAt: FieldRef<"Password", 'DateTime'>
    readonly updatedAt: FieldRef<"Password", 'DateTime'>
    readonly comment: FieldRef<"Password", 'String'>
    readonly type: FieldRef<"Password", 'PasswordType'>
  }
    

  // Custom InputTypes
  /**
   * Password findUnique
   */
  export type PasswordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password findUniqueOrThrow
   */
  export type PasswordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password findFirst
   */
  export type PasswordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passwords.
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passwords.
     */
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * Password findFirstOrThrow
   */
  export type PasswordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passwords.
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passwords.
     */
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * Password findMany
   */
  export type PasswordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Filter, which Passwords to fetch.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passwords.
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * Password create
   */
  export type PasswordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * The data needed to create a Password.
     */
    data: XOR<PasswordCreateInput, PasswordUncheckedCreateInput>
  }

  /**
   * Password createMany
   */
  export type PasswordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passwords.
     */
    data: PasswordCreateManyInput | PasswordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Password createManyAndReturn
   */
  export type PasswordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * The data used to create many Passwords.
     */
    data: PasswordCreateManyInput | PasswordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Password update
   */
  export type PasswordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * The data needed to update a Password.
     */
    data: XOR<PasswordUpdateInput, PasswordUncheckedUpdateInput>
    /**
     * Choose, which Password to update.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password updateMany
   */
  export type PasswordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passwords.
     */
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyInput>
    /**
     * Filter which Passwords to update
     */
    where?: PasswordWhereInput
    /**
     * Limit how many Passwords to update.
     */
    limit?: number
  }

  /**
   * Password updateManyAndReturn
   */
  export type PasswordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * The data used to update Passwords.
     */
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyInput>
    /**
     * Filter which Passwords to update
     */
    where?: PasswordWhereInput
    /**
     * Limit how many Passwords to update.
     */
    limit?: number
  }

  /**
   * Password upsert
   */
  export type PasswordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * The filter to search for the Password to update in case it exists.
     */
    where: PasswordWhereUniqueInput
    /**
     * In case the Password found by the `where` argument doesn't exist, create a new Password with this data.
     */
    create: XOR<PasswordCreateInput, PasswordUncheckedCreateInput>
    /**
     * In case the Password was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordUpdateInput, PasswordUncheckedUpdateInput>
  }

  /**
   * Password delete
   */
  export type PasswordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Filter which Password to delete.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password deleteMany
   */
  export type PasswordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passwords to delete
     */
    where?: PasswordWhereInput
    /**
     * Limit how many Passwords to delete.
     */
    limit?: number
  }

  /**
   * Password without action
   */
  export type PasswordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
  }


  /**
   * Model ReportNotification
   */

  export type AggregateReportNotification = {
    _count: ReportNotificationCountAggregateOutputType | null
    _avg: ReportNotificationAvgAggregateOutputType | null
    _sum: ReportNotificationSumAggregateOutputType | null
    _min: ReportNotificationMinAggregateOutputType | null
    _max: ReportNotificationMaxAggregateOutputType | null
  }

  export type ReportNotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ReportNotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ReportNotificationMinAggregateOutputType = {
    id: number | null
    notificationTime: Date | null
    reportReceived: boolean | null
    reportTime: Date | null
    adminNotified: boolean | null
    adminNotifyTime: Date | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportNotificationMaxAggregateOutputType = {
    id: number | null
    notificationTime: Date | null
    reportReceived: boolean | null
    reportTime: Date | null
    adminNotified: boolean | null
    adminNotifyTime: Date | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportNotificationCountAggregateOutputType = {
    id: number
    notificationTime: number
    reportReceived: number
    reportTime: number
    adminNotified: number
    adminNotifyTime: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportNotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ReportNotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ReportNotificationMinAggregateInputType = {
    id?: true
    notificationTime?: true
    reportReceived?: true
    reportTime?: true
    adminNotified?: true
    adminNotifyTime?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportNotificationMaxAggregateInputType = {
    id?: true
    notificationTime?: true
    reportReceived?: true
    reportTime?: true
    adminNotified?: true
    adminNotifyTime?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportNotificationCountAggregateInputType = {
    id?: true
    notificationTime?: true
    reportReceived?: true
    reportTime?: true
    adminNotified?: true
    adminNotifyTime?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportNotification to aggregate.
     */
    where?: ReportNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportNotifications to fetch.
     */
    orderBy?: ReportNotificationOrderByWithRelationInput | ReportNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportNotifications
    **/
    _count?: true | ReportNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportNotificationMaxAggregateInputType
  }

  export type GetReportNotificationAggregateType<T extends ReportNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateReportNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportNotification[P]>
      : GetScalarType<T[P], AggregateReportNotification[P]>
  }




  export type ReportNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportNotificationWhereInput
    orderBy?: ReportNotificationOrderByWithAggregationInput | ReportNotificationOrderByWithAggregationInput[]
    by: ReportNotificationScalarFieldEnum[] | ReportNotificationScalarFieldEnum
    having?: ReportNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportNotificationCountAggregateInputType | true
    _avg?: ReportNotificationAvgAggregateInputType
    _sum?: ReportNotificationSumAggregateInputType
    _min?: ReportNotificationMinAggregateInputType
    _max?: ReportNotificationMaxAggregateInputType
  }

  export type ReportNotificationGroupByOutputType = {
    id: number
    notificationTime: Date
    reportReceived: boolean
    reportTime: Date | null
    adminNotified: boolean
    adminNotifyTime: Date | null
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: ReportNotificationCountAggregateOutputType | null
    _avg: ReportNotificationAvgAggregateOutputType | null
    _sum: ReportNotificationSumAggregateOutputType | null
    _min: ReportNotificationMinAggregateOutputType | null
    _max: ReportNotificationMaxAggregateOutputType | null
  }

  type GetReportNotificationGroupByPayload<T extends ReportNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], ReportNotificationGroupByOutputType[P]>
        }
      >
    >


  export type ReportNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationTime?: boolean
    reportReceived?: boolean
    reportTime?: boolean
    adminNotified?: boolean
    adminNotifyTime?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportNotification"]>

  export type ReportNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationTime?: boolean
    reportReceived?: boolean
    reportTime?: boolean
    adminNotified?: boolean
    adminNotifyTime?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportNotification"]>

  export type ReportNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationTime?: boolean
    reportReceived?: boolean
    reportTime?: boolean
    adminNotified?: boolean
    adminNotifyTime?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportNotification"]>

  export type ReportNotificationSelectScalar = {
    id?: boolean
    notificationTime?: boolean
    reportReceived?: boolean
    reportTime?: boolean
    adminNotified?: boolean
    adminNotifyTime?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notificationTime" | "reportReceived" | "reportTime" | "adminNotified" | "adminNotifyTime" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["reportNotification"]>
  export type ReportNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportNotification"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      notificationTime: Date
      reportReceived: boolean
      reportTime: Date | null
      adminNotified: boolean
      adminNotifyTime: Date | null
      userId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportNotification"]>
    composites: {}
  }

  type ReportNotificationGetPayload<S extends boolean | null | undefined | ReportNotificationDefaultArgs> = $Result.GetResult<Prisma.$ReportNotificationPayload, S>

  type ReportNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportNotificationCountAggregateInputType | true
    }

  export interface ReportNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportNotification'], meta: { name: 'ReportNotification' } }
    /**
     * Find zero or one ReportNotification that matches the filter.
     * @param {ReportNotificationFindUniqueArgs} args - Arguments to find a ReportNotification
     * @example
     * // Get one ReportNotification
     * const reportNotification = await prisma.reportNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportNotificationFindUniqueArgs>(args: SelectSubset<T, ReportNotificationFindUniqueArgs<ExtArgs>>): Prisma__ReportNotificationClient<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportNotificationFindUniqueOrThrowArgs} args - Arguments to find a ReportNotification
     * @example
     * // Get one ReportNotification
     * const reportNotification = await prisma.reportNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportNotificationClient<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportNotificationFindFirstArgs} args - Arguments to find a ReportNotification
     * @example
     * // Get one ReportNotification
     * const reportNotification = await prisma.reportNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportNotificationFindFirstArgs>(args?: SelectSubset<T, ReportNotificationFindFirstArgs<ExtArgs>>): Prisma__ReportNotificationClient<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportNotificationFindFirstOrThrowArgs} args - Arguments to find a ReportNotification
     * @example
     * // Get one ReportNotification
     * const reportNotification = await prisma.reportNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportNotificationClient<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportNotifications
     * const reportNotifications = await prisma.reportNotification.findMany()
     * 
     * // Get first 10 ReportNotifications
     * const reportNotifications = await prisma.reportNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportNotificationWithIdOnly = await prisma.reportNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportNotificationFindManyArgs>(args?: SelectSubset<T, ReportNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportNotification.
     * @param {ReportNotificationCreateArgs} args - Arguments to create a ReportNotification.
     * @example
     * // Create one ReportNotification
     * const ReportNotification = await prisma.reportNotification.create({
     *   data: {
     *     // ... data to create a ReportNotification
     *   }
     * })
     * 
     */
    create<T extends ReportNotificationCreateArgs>(args: SelectSubset<T, ReportNotificationCreateArgs<ExtArgs>>): Prisma__ReportNotificationClient<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportNotifications.
     * @param {ReportNotificationCreateManyArgs} args - Arguments to create many ReportNotifications.
     * @example
     * // Create many ReportNotifications
     * const reportNotification = await prisma.reportNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportNotificationCreateManyArgs>(args?: SelectSubset<T, ReportNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportNotifications and returns the data saved in the database.
     * @param {ReportNotificationCreateManyAndReturnArgs} args - Arguments to create many ReportNotifications.
     * @example
     * // Create many ReportNotifications
     * const reportNotification = await prisma.reportNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportNotifications and only return the `id`
     * const reportNotificationWithIdOnly = await prisma.reportNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportNotification.
     * @param {ReportNotificationDeleteArgs} args - Arguments to delete one ReportNotification.
     * @example
     * // Delete one ReportNotification
     * const ReportNotification = await prisma.reportNotification.delete({
     *   where: {
     *     // ... filter to delete one ReportNotification
     *   }
     * })
     * 
     */
    delete<T extends ReportNotificationDeleteArgs>(args: SelectSubset<T, ReportNotificationDeleteArgs<ExtArgs>>): Prisma__ReportNotificationClient<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportNotification.
     * @param {ReportNotificationUpdateArgs} args - Arguments to update one ReportNotification.
     * @example
     * // Update one ReportNotification
     * const reportNotification = await prisma.reportNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportNotificationUpdateArgs>(args: SelectSubset<T, ReportNotificationUpdateArgs<ExtArgs>>): Prisma__ReportNotificationClient<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportNotifications.
     * @param {ReportNotificationDeleteManyArgs} args - Arguments to filter ReportNotifications to delete.
     * @example
     * // Delete a few ReportNotifications
     * const { count } = await prisma.reportNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportNotificationDeleteManyArgs>(args?: SelectSubset<T, ReportNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportNotifications
     * const reportNotification = await prisma.reportNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportNotificationUpdateManyArgs>(args: SelectSubset<T, ReportNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportNotifications and returns the data updated in the database.
     * @param {ReportNotificationUpdateManyAndReturnArgs} args - Arguments to update many ReportNotifications.
     * @example
     * // Update many ReportNotifications
     * const reportNotification = await prisma.reportNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportNotifications and only return the `id`
     * const reportNotificationWithIdOnly = await prisma.reportNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportNotification.
     * @param {ReportNotificationUpsertArgs} args - Arguments to update or create a ReportNotification.
     * @example
     * // Update or create a ReportNotification
     * const reportNotification = await prisma.reportNotification.upsert({
     *   create: {
     *     // ... data to create a ReportNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportNotification we want to update
     *   }
     * })
     */
    upsert<T extends ReportNotificationUpsertArgs>(args: SelectSubset<T, ReportNotificationUpsertArgs<ExtArgs>>): Prisma__ReportNotificationClient<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportNotificationCountArgs} args - Arguments to filter ReportNotifications to count.
     * @example
     * // Count the number of ReportNotifications
     * const count = await prisma.reportNotification.count({
     *   where: {
     *     // ... the filter for the ReportNotifications we want to count
     *   }
     * })
    **/
    count<T extends ReportNotificationCountArgs>(
      args?: Subset<T, ReportNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportNotificationAggregateArgs>(args: Subset<T, ReportNotificationAggregateArgs>): Prisma.PrismaPromise<GetReportNotificationAggregateType<T>>

    /**
     * Group by ReportNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportNotificationGroupByArgs['orderBy'] }
        : { orderBy?: ReportNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportNotification model
   */
  readonly fields: ReportNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportNotification model
   */
  interface ReportNotificationFieldRefs {
    readonly id: FieldRef<"ReportNotification", 'Int'>
    readonly notificationTime: FieldRef<"ReportNotification", 'DateTime'>
    readonly reportReceived: FieldRef<"ReportNotification", 'Boolean'>
    readonly reportTime: FieldRef<"ReportNotification", 'DateTime'>
    readonly adminNotified: FieldRef<"ReportNotification", 'Boolean'>
    readonly adminNotifyTime: FieldRef<"ReportNotification", 'DateTime'>
    readonly userId: FieldRef<"ReportNotification", 'Int'>
    readonly createdAt: FieldRef<"ReportNotification", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportNotification findUnique
   */
  export type ReportNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ReportNotification to fetch.
     */
    where: ReportNotificationWhereUniqueInput
  }

  /**
   * ReportNotification findUniqueOrThrow
   */
  export type ReportNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ReportNotification to fetch.
     */
    where: ReportNotificationWhereUniqueInput
  }

  /**
   * ReportNotification findFirst
   */
  export type ReportNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ReportNotification to fetch.
     */
    where?: ReportNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportNotifications to fetch.
     */
    orderBy?: ReportNotificationOrderByWithRelationInput | ReportNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportNotifications.
     */
    cursor?: ReportNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportNotifications.
     */
    distinct?: ReportNotificationScalarFieldEnum | ReportNotificationScalarFieldEnum[]
  }

  /**
   * ReportNotification findFirstOrThrow
   */
  export type ReportNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ReportNotification to fetch.
     */
    where?: ReportNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportNotifications to fetch.
     */
    orderBy?: ReportNotificationOrderByWithRelationInput | ReportNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportNotifications.
     */
    cursor?: ReportNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportNotifications.
     */
    distinct?: ReportNotificationScalarFieldEnum | ReportNotificationScalarFieldEnum[]
  }

  /**
   * ReportNotification findMany
   */
  export type ReportNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ReportNotifications to fetch.
     */
    where?: ReportNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportNotifications to fetch.
     */
    orderBy?: ReportNotificationOrderByWithRelationInput | ReportNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportNotifications.
     */
    cursor?: ReportNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportNotifications.
     */
    skip?: number
    distinct?: ReportNotificationScalarFieldEnum | ReportNotificationScalarFieldEnum[]
  }

  /**
   * ReportNotification create
   */
  export type ReportNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportNotification.
     */
    data: XOR<ReportNotificationCreateInput, ReportNotificationUncheckedCreateInput>
  }

  /**
   * ReportNotification createMany
   */
  export type ReportNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportNotifications.
     */
    data: ReportNotificationCreateManyInput | ReportNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportNotification createManyAndReturn
   */
  export type ReportNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many ReportNotifications.
     */
    data: ReportNotificationCreateManyInput | ReportNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportNotification update
   */
  export type ReportNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportNotification.
     */
    data: XOR<ReportNotificationUpdateInput, ReportNotificationUncheckedUpdateInput>
    /**
     * Choose, which ReportNotification to update.
     */
    where: ReportNotificationWhereUniqueInput
  }

  /**
   * ReportNotification updateMany
   */
  export type ReportNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportNotifications.
     */
    data: XOR<ReportNotificationUpdateManyMutationInput, ReportNotificationUncheckedUpdateManyInput>
    /**
     * Filter which ReportNotifications to update
     */
    where?: ReportNotificationWhereInput
    /**
     * Limit how many ReportNotifications to update.
     */
    limit?: number
  }

  /**
   * ReportNotification updateManyAndReturn
   */
  export type ReportNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * The data used to update ReportNotifications.
     */
    data: XOR<ReportNotificationUpdateManyMutationInput, ReportNotificationUncheckedUpdateManyInput>
    /**
     * Filter which ReportNotifications to update
     */
    where?: ReportNotificationWhereInput
    /**
     * Limit how many ReportNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportNotification upsert
   */
  export type ReportNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportNotification to update in case it exists.
     */
    where: ReportNotificationWhereUniqueInput
    /**
     * In case the ReportNotification found by the `where` argument doesn't exist, create a new ReportNotification with this data.
     */
    create: XOR<ReportNotificationCreateInput, ReportNotificationUncheckedCreateInput>
    /**
     * In case the ReportNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportNotificationUpdateInput, ReportNotificationUncheckedUpdateInput>
  }

  /**
   * ReportNotification delete
   */
  export type ReportNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationInclude<ExtArgs> | null
    /**
     * Filter which ReportNotification to delete.
     */
    where: ReportNotificationWhereUniqueInput
  }

  /**
   * ReportNotification deleteMany
   */
  export type ReportNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportNotifications to delete
     */
    where?: ReportNotificationWhereInput
    /**
     * Limit how many ReportNotifications to delete.
     */
    limit?: number
  }

  /**
   * ReportNotification without action
   */
  export type ReportNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationInclude<ExtArgs> | null
  }


  /**
   * Model Row
   */

  export type AggregateRow = {
    _count: RowCountAggregateOutputType | null
    _avg: RowAvgAggregateOutputType | null
    _sum: RowSumAggregateOutputType | null
    _min: RowMinAggregateOutputType | null
    _max: RowMaxAggregateOutputType | null
  }

  export type RowAvgAggregateOutputType = {
    id: number | null
    tableId: number | null
    order: number | null
  }

  export type RowSumAggregateOutputType = {
    id: number | null
    tableId: number | null
    order: number | null
  }

  export type RowMinAggregateOutputType = {
    id: number | null
    tableId: number | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RowMaxAggregateOutputType = {
    id: number | null
    tableId: number | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RowCountAggregateOutputType = {
    id: number
    tableId: number
    order: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RowAvgAggregateInputType = {
    id?: true
    tableId?: true
    order?: true
  }

  export type RowSumAggregateInputType = {
    id?: true
    tableId?: true
    order?: true
  }

  export type RowMinAggregateInputType = {
    id?: true
    tableId?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RowMaxAggregateInputType = {
    id?: true
    tableId?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RowCountAggregateInputType = {
    id?: true
    tableId?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Row to aggregate.
     */
    where?: RowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rows to fetch.
     */
    orderBy?: RowOrderByWithRelationInput | RowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rows
    **/
    _count?: true | RowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RowMaxAggregateInputType
  }

  export type GetRowAggregateType<T extends RowAggregateArgs> = {
        [P in keyof T & keyof AggregateRow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRow[P]>
      : GetScalarType<T[P], AggregateRow[P]>
  }




  export type RowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RowWhereInput
    orderBy?: RowOrderByWithAggregationInput | RowOrderByWithAggregationInput[]
    by: RowScalarFieldEnum[] | RowScalarFieldEnum
    having?: RowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RowCountAggregateInputType | true
    _avg?: RowAvgAggregateInputType
    _sum?: RowSumAggregateInputType
    _min?: RowMinAggregateInputType
    _max?: RowMaxAggregateInputType
  }

  export type RowGroupByOutputType = {
    id: number
    tableId: number
    order: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RowCountAggregateOutputType | null
    _avg: RowAvgAggregateOutputType | null
    _sum: RowSumAggregateOutputType | null
    _min: RowMinAggregateOutputType | null
    _max: RowMaxAggregateOutputType | null
  }

  type GetRowGroupByPayload<T extends RowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RowGroupByOutputType[P]>
            : GetScalarType<T[P], RowGroupByOutputType[P]>
        }
      >
    >


  export type RowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Cell?: boolean | Row$CellArgs<ExtArgs>
    Table?: boolean | TableDefaultArgs<ExtArgs>
    _count?: boolean | RowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["row"]>

  export type RowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["row"]>

  export type RowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["row"]>

  export type RowSelectScalar = {
    id?: boolean
    tableId?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableId" | "order" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["row"]>
  export type RowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cell?: boolean | Row$CellArgs<ExtArgs>
    Table?: boolean | TableDefaultArgs<ExtArgs>
    _count?: boolean | RowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }
  export type RowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Table?: boolean | TableDefaultArgs<ExtArgs>
  }

  export type $RowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Row"
    objects: {
      Cell: Prisma.$CellPayload<ExtArgs>[]
      Table: Prisma.$TablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tableId: number
      order: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["row"]>
    composites: {}
  }

  type RowGetPayload<S extends boolean | null | undefined | RowDefaultArgs> = $Result.GetResult<Prisma.$RowPayload, S>

  type RowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RowCountAggregateInputType | true
    }

  export interface RowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Row'], meta: { name: 'Row' } }
    /**
     * Find zero or one Row that matches the filter.
     * @param {RowFindUniqueArgs} args - Arguments to find a Row
     * @example
     * // Get one Row
     * const row = await prisma.row.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RowFindUniqueArgs>(args: SelectSubset<T, RowFindUniqueArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Row that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RowFindUniqueOrThrowArgs} args - Arguments to find a Row
     * @example
     * // Get one Row
     * const row = await prisma.row.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RowFindUniqueOrThrowArgs>(args: SelectSubset<T, RowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Row that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowFindFirstArgs} args - Arguments to find a Row
     * @example
     * // Get one Row
     * const row = await prisma.row.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RowFindFirstArgs>(args?: SelectSubset<T, RowFindFirstArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Row that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowFindFirstOrThrowArgs} args - Arguments to find a Row
     * @example
     * // Get one Row
     * const row = await prisma.row.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RowFindFirstOrThrowArgs>(args?: SelectSubset<T, RowFindFirstOrThrowArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rows
     * const rows = await prisma.row.findMany()
     * 
     * // Get first 10 Rows
     * const rows = await prisma.row.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rowWithIdOnly = await prisma.row.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RowFindManyArgs>(args?: SelectSubset<T, RowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Row.
     * @param {RowCreateArgs} args - Arguments to create a Row.
     * @example
     * // Create one Row
     * const Row = await prisma.row.create({
     *   data: {
     *     // ... data to create a Row
     *   }
     * })
     * 
     */
    create<T extends RowCreateArgs>(args: SelectSubset<T, RowCreateArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rows.
     * @param {RowCreateManyArgs} args - Arguments to create many Rows.
     * @example
     * // Create many Rows
     * const row = await prisma.row.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RowCreateManyArgs>(args?: SelectSubset<T, RowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rows and returns the data saved in the database.
     * @param {RowCreateManyAndReturnArgs} args - Arguments to create many Rows.
     * @example
     * // Create many Rows
     * const row = await prisma.row.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rows and only return the `id`
     * const rowWithIdOnly = await prisma.row.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RowCreateManyAndReturnArgs>(args?: SelectSubset<T, RowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Row.
     * @param {RowDeleteArgs} args - Arguments to delete one Row.
     * @example
     * // Delete one Row
     * const Row = await prisma.row.delete({
     *   where: {
     *     // ... filter to delete one Row
     *   }
     * })
     * 
     */
    delete<T extends RowDeleteArgs>(args: SelectSubset<T, RowDeleteArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Row.
     * @param {RowUpdateArgs} args - Arguments to update one Row.
     * @example
     * // Update one Row
     * const row = await prisma.row.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RowUpdateArgs>(args: SelectSubset<T, RowUpdateArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rows.
     * @param {RowDeleteManyArgs} args - Arguments to filter Rows to delete.
     * @example
     * // Delete a few Rows
     * const { count } = await prisma.row.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RowDeleteManyArgs>(args?: SelectSubset<T, RowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rows
     * const row = await prisma.row.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RowUpdateManyArgs>(args: SelectSubset<T, RowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rows and returns the data updated in the database.
     * @param {RowUpdateManyAndReturnArgs} args - Arguments to update many Rows.
     * @example
     * // Update many Rows
     * const row = await prisma.row.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rows and only return the `id`
     * const rowWithIdOnly = await prisma.row.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RowUpdateManyAndReturnArgs>(args: SelectSubset<T, RowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Row.
     * @param {RowUpsertArgs} args - Arguments to update or create a Row.
     * @example
     * // Update or create a Row
     * const row = await prisma.row.upsert({
     *   create: {
     *     // ... data to create a Row
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Row we want to update
     *   }
     * })
     */
    upsert<T extends RowUpsertArgs>(args: SelectSubset<T, RowUpsertArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowCountArgs} args - Arguments to filter Rows to count.
     * @example
     * // Count the number of Rows
     * const count = await prisma.row.count({
     *   where: {
     *     // ... the filter for the Rows we want to count
     *   }
     * })
    **/
    count<T extends RowCountArgs>(
      args?: Subset<T, RowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Row.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RowAggregateArgs>(args: Subset<T, RowAggregateArgs>): Prisma.PrismaPromise<GetRowAggregateType<T>>

    /**
     * Group by Row.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RowGroupByArgs['orderBy'] }
        : { orderBy?: RowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Row model
   */
  readonly fields: RowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Row.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Cell<T extends Row$CellArgs<ExtArgs> = {}>(args?: Subset<T, Row$CellArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Table<T extends TableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TableDefaultArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Row model
   */
  interface RowFieldRefs {
    readonly id: FieldRef<"Row", 'Int'>
    readonly tableId: FieldRef<"Row", 'Int'>
    readonly order: FieldRef<"Row", 'Int'>
    readonly isActive: FieldRef<"Row", 'Boolean'>
    readonly createdAt: FieldRef<"Row", 'DateTime'>
    readonly updatedAt: FieldRef<"Row", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Row findUnique
   */
  export type RowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter, which Row to fetch.
     */
    where: RowWhereUniqueInput
  }

  /**
   * Row findUniqueOrThrow
   */
  export type RowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter, which Row to fetch.
     */
    where: RowWhereUniqueInput
  }

  /**
   * Row findFirst
   */
  export type RowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter, which Row to fetch.
     */
    where?: RowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rows to fetch.
     */
    orderBy?: RowOrderByWithRelationInput | RowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rows.
     */
    cursor?: RowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rows.
     */
    distinct?: RowScalarFieldEnum | RowScalarFieldEnum[]
  }

  /**
   * Row findFirstOrThrow
   */
  export type RowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter, which Row to fetch.
     */
    where?: RowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rows to fetch.
     */
    orderBy?: RowOrderByWithRelationInput | RowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rows.
     */
    cursor?: RowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rows.
     */
    distinct?: RowScalarFieldEnum | RowScalarFieldEnum[]
  }

  /**
   * Row findMany
   */
  export type RowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter, which Rows to fetch.
     */
    where?: RowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rows to fetch.
     */
    orderBy?: RowOrderByWithRelationInput | RowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rows.
     */
    cursor?: RowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rows.
     */
    skip?: number
    distinct?: RowScalarFieldEnum | RowScalarFieldEnum[]
  }

  /**
   * Row create
   */
  export type RowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * The data needed to create a Row.
     */
    data: XOR<RowCreateInput, RowUncheckedCreateInput>
  }

  /**
   * Row createMany
   */
  export type RowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rows.
     */
    data: RowCreateManyInput | RowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Row createManyAndReturn
   */
  export type RowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * The data used to create many Rows.
     */
    data: RowCreateManyInput | RowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Row update
   */
  export type RowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * The data needed to update a Row.
     */
    data: XOR<RowUpdateInput, RowUncheckedUpdateInput>
    /**
     * Choose, which Row to update.
     */
    where: RowWhereUniqueInput
  }

  /**
   * Row updateMany
   */
  export type RowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rows.
     */
    data: XOR<RowUpdateManyMutationInput, RowUncheckedUpdateManyInput>
    /**
     * Filter which Rows to update
     */
    where?: RowWhereInput
    /**
     * Limit how many Rows to update.
     */
    limit?: number
  }

  /**
   * Row updateManyAndReturn
   */
  export type RowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * The data used to update Rows.
     */
    data: XOR<RowUpdateManyMutationInput, RowUncheckedUpdateManyInput>
    /**
     * Filter which Rows to update
     */
    where?: RowWhereInput
    /**
     * Limit how many Rows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Row upsert
   */
  export type RowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * The filter to search for the Row to update in case it exists.
     */
    where: RowWhereUniqueInput
    /**
     * In case the Row found by the `where` argument doesn't exist, create a new Row with this data.
     */
    create: XOR<RowCreateInput, RowUncheckedCreateInput>
    /**
     * In case the Row was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RowUpdateInput, RowUncheckedUpdateInput>
  }

  /**
   * Row delete
   */
  export type RowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter which Row to delete.
     */
    where: RowWhereUniqueInput
  }

  /**
   * Row deleteMany
   */
  export type RowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rows to delete
     */
    where?: RowWhereInput
    /**
     * Limit how many Rows to delete.
     */
    limit?: number
  }

  /**
   * Row.Cell
   */
  export type Row$CellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cell
     */
    select?: CellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cell
     */
    omit?: CellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CellInclude<ExtArgs> | null
    where?: CellWhereInput
    orderBy?: CellOrderByWithRelationInput | CellOrderByWithRelationInput[]
    cursor?: CellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CellScalarFieldEnum | CellScalarFieldEnum[]
  }

  /**
   * Row without action
   */
  export type RowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
  }


  /**
   * Model Salary
   */

  export type AggregateSalary = {
    _count: SalaryCountAggregateOutputType | null
    _avg: SalaryAvgAggregateOutputType | null
    _sum: SalarySumAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  export type SalaryAvgAggregateOutputType = {
    id: number | null
    payday: number | null
    paydayMonth: number | null
    fixedSalary: number | null
    payday2: number | null
    payday3: number | null
  }

  export type SalarySumAggregateOutputType = {
    id: number | null
    payday: number | null
    paydayMonth: number | null
    fixedSalary: number | null
    payday2: number | null
    payday3: number | null
  }

  export type SalaryMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    position: string | null
    startDate: Date | null
    payday: number | null
    paydayMonth: number | null
    fixedSalary: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
    periodic: $Enums.PeriodType | null
    payday2: number | null
    payday3: number | null
    section: $Enums.SalarySection | null
  }

  export type SalaryMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    position: string | null
    startDate: Date | null
    payday: number | null
    paydayMonth: number | null
    fixedSalary: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
    periodic: $Enums.PeriodType | null
    payday2: number | null
    payday3: number | null
    section: $Enums.SalarySection | null
  }

  export type SalaryCountAggregateOutputType = {
    id: number
    fullName: number
    position: number
    startDate: number
    payday: number
    paydayMonth: number
    fixedSalary: number
    isActive: number
    createdAt: number
    updatedAt: number
    comment: number
    periodic: number
    payday2: number
    payday3: number
    section: number
    _all: number
  }


  export type SalaryAvgAggregateInputType = {
    id?: true
    payday?: true
    paydayMonth?: true
    fixedSalary?: true
    payday2?: true
    payday3?: true
  }

  export type SalarySumAggregateInputType = {
    id?: true
    payday?: true
    paydayMonth?: true
    fixedSalary?: true
    payday2?: true
    payday3?: true
  }

  export type SalaryMinAggregateInputType = {
    id?: true
    fullName?: true
    position?: true
    startDate?: true
    payday?: true
    paydayMonth?: true
    fixedSalary?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    periodic?: true
    payday2?: true
    payday3?: true
    section?: true
  }

  export type SalaryMaxAggregateInputType = {
    id?: true
    fullName?: true
    position?: true
    startDate?: true
    payday?: true
    paydayMonth?: true
    fixedSalary?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    periodic?: true
    payday2?: true
    payday3?: true
    section?: true
  }

  export type SalaryCountAggregateInputType = {
    id?: true
    fullName?: true
    position?: true
    startDate?: true
    payday?: true
    paydayMonth?: true
    fixedSalary?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    periodic?: true
    payday2?: true
    payday3?: true
    section?: true
    _all?: true
  }

  export type SalaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salary to aggregate.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salaries
    **/
    _count?: true | SalaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryMaxAggregateInputType
  }

  export type GetSalaryAggregateType<T extends SalaryAggregateArgs> = {
        [P in keyof T & keyof AggregateSalary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalary[P]>
      : GetScalarType<T[P], AggregateSalary[P]>
  }




  export type SalaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryWhereInput
    orderBy?: SalaryOrderByWithAggregationInput | SalaryOrderByWithAggregationInput[]
    by: SalaryScalarFieldEnum[] | SalaryScalarFieldEnum
    having?: SalaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryCountAggregateInputType | true
    _avg?: SalaryAvgAggregateInputType
    _sum?: SalarySumAggregateInputType
    _min?: SalaryMinAggregateInputType
    _max?: SalaryMaxAggregateInputType
  }

  export type SalaryGroupByOutputType = {
    id: number
    fullName: string
    position: string
    startDate: Date
    payday: number
    paydayMonth: number | null
    fixedSalary: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    comment: string | null
    periodic: $Enums.PeriodType
    payday2: number | null
    payday3: number | null
    section: $Enums.SalarySection
    _count: SalaryCountAggregateOutputType | null
    _avg: SalaryAvgAggregateOutputType | null
    _sum: SalarySumAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  type GetSalaryGroupByPayload<T extends SalaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryGroupByOutputType[P]>
        }
      >
    >


  export type SalarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    position?: boolean
    startDate?: boolean
    payday?: boolean
    paydayMonth?: boolean
    fixedSalary?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    periodic?: boolean
    payday2?: boolean
    payday3?: boolean
    section?: boolean
    FinRow?: boolean | Salary$FinRowArgs<ExtArgs>
    SalaryDebt?: boolean | Salary$SalaryDebtArgs<ExtArgs>
    SalaryEarning?: boolean | Salary$SalaryEarningArgs<ExtArgs>
    SalaryPayment?: boolean | Salary$SalaryPaymentArgs<ExtArgs>
    ShiftReport?: boolean | Salary$ShiftReportArgs<ExtArgs>
    _count?: boolean | SalaryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salary"]>

  export type SalarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    position?: boolean
    startDate?: boolean
    payday?: boolean
    paydayMonth?: boolean
    fixedSalary?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    periodic?: boolean
    payday2?: boolean
    payday3?: boolean
    section?: boolean
  }, ExtArgs["result"]["salary"]>

  export type SalarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    position?: boolean
    startDate?: boolean
    payday?: boolean
    paydayMonth?: boolean
    fixedSalary?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    periodic?: boolean
    payday2?: boolean
    payday3?: boolean
    section?: boolean
  }, ExtArgs["result"]["salary"]>

  export type SalarySelectScalar = {
    id?: boolean
    fullName?: boolean
    position?: boolean
    startDate?: boolean
    payday?: boolean
    paydayMonth?: boolean
    fixedSalary?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    periodic?: boolean
    payday2?: boolean
    payday3?: boolean
    section?: boolean
  }

  export type SalaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "position" | "startDate" | "payday" | "paydayMonth" | "fixedSalary" | "isActive" | "createdAt" | "updatedAt" | "comment" | "periodic" | "payday2" | "payday3" | "section", ExtArgs["result"]["salary"]>
  export type SalaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FinRow?: boolean | Salary$FinRowArgs<ExtArgs>
    SalaryDebt?: boolean | Salary$SalaryDebtArgs<ExtArgs>
    SalaryEarning?: boolean | Salary$SalaryEarningArgs<ExtArgs>
    SalaryPayment?: boolean | Salary$SalaryPaymentArgs<ExtArgs>
    ShiftReport?: boolean | Salary$ShiftReportArgs<ExtArgs>
    _count?: boolean | SalaryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SalaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SalaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Salary"
    objects: {
      FinRow: Prisma.$FinRowPayload<ExtArgs>[]
      SalaryDebt: Prisma.$SalaryDebtPayload<ExtArgs>[]
      SalaryEarning: Prisma.$SalaryEarningPayload<ExtArgs>[]
      SalaryPayment: Prisma.$SalaryPaymentPayload<ExtArgs>[]
      ShiftReport: Prisma.$ShiftReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      position: string
      startDate: Date
      payday: number
      paydayMonth: number | null
      fixedSalary: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      comment: string | null
      periodic: $Enums.PeriodType
      payday2: number | null
      payday3: number | null
      section: $Enums.SalarySection
    }, ExtArgs["result"]["salary"]>
    composites: {}
  }

  type SalaryGetPayload<S extends boolean | null | undefined | SalaryDefaultArgs> = $Result.GetResult<Prisma.$SalaryPayload, S>

  type SalaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryCountAggregateInputType | true
    }

  export interface SalaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Salary'], meta: { name: 'Salary' } }
    /**
     * Find zero or one Salary that matches the filter.
     * @param {SalaryFindUniqueArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryFindUniqueArgs>(args: SelectSubset<T, SalaryFindUniqueArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Salary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryFindUniqueOrThrowArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindFirstArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryFindFirstArgs>(args?: SelectSubset<T, SalaryFindFirstArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindFirstOrThrowArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Salaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salaries
     * const salaries = await prisma.salary.findMany()
     * 
     * // Get first 10 Salaries
     * const salaries = await prisma.salary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryWithIdOnly = await prisma.salary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryFindManyArgs>(args?: SelectSubset<T, SalaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Salary.
     * @param {SalaryCreateArgs} args - Arguments to create a Salary.
     * @example
     * // Create one Salary
     * const Salary = await prisma.salary.create({
     *   data: {
     *     // ... data to create a Salary
     *   }
     * })
     * 
     */
    create<T extends SalaryCreateArgs>(args: SelectSubset<T, SalaryCreateArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Salaries.
     * @param {SalaryCreateManyArgs} args - Arguments to create many Salaries.
     * @example
     * // Create many Salaries
     * const salary = await prisma.salary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryCreateManyArgs>(args?: SelectSubset<T, SalaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Salaries and returns the data saved in the database.
     * @param {SalaryCreateManyAndReturnArgs} args - Arguments to create many Salaries.
     * @example
     * // Create many Salaries
     * const salary = await prisma.salary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Salaries and only return the `id`
     * const salaryWithIdOnly = await prisma.salary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Salary.
     * @param {SalaryDeleteArgs} args - Arguments to delete one Salary.
     * @example
     * // Delete one Salary
     * const Salary = await prisma.salary.delete({
     *   where: {
     *     // ... filter to delete one Salary
     *   }
     * })
     * 
     */
    delete<T extends SalaryDeleteArgs>(args: SelectSubset<T, SalaryDeleteArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Salary.
     * @param {SalaryUpdateArgs} args - Arguments to update one Salary.
     * @example
     * // Update one Salary
     * const salary = await prisma.salary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryUpdateArgs>(args: SelectSubset<T, SalaryUpdateArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Salaries.
     * @param {SalaryDeleteManyArgs} args - Arguments to filter Salaries to delete.
     * @example
     * // Delete a few Salaries
     * const { count } = await prisma.salary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryDeleteManyArgs>(args?: SelectSubset<T, SalaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salaries
     * const salary = await prisma.salary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryUpdateManyArgs>(args: SelectSubset<T, SalaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salaries and returns the data updated in the database.
     * @param {SalaryUpdateManyAndReturnArgs} args - Arguments to update many Salaries.
     * @example
     * // Update many Salaries
     * const salary = await prisma.salary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Salaries and only return the `id`
     * const salaryWithIdOnly = await prisma.salary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Salary.
     * @param {SalaryUpsertArgs} args - Arguments to update or create a Salary.
     * @example
     * // Update or create a Salary
     * const salary = await prisma.salary.upsert({
     *   create: {
     *     // ... data to create a Salary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salary we want to update
     *   }
     * })
     */
    upsert<T extends SalaryUpsertArgs>(args: SelectSubset<T, SalaryUpsertArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryCountArgs} args - Arguments to filter Salaries to count.
     * @example
     * // Count the number of Salaries
     * const count = await prisma.salary.count({
     *   where: {
     *     // ... the filter for the Salaries we want to count
     *   }
     * })
    **/
    count<T extends SalaryCountArgs>(
      args?: Subset<T, SalaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryAggregateArgs>(args: Subset<T, SalaryAggregateArgs>): Prisma.PrismaPromise<GetSalaryAggregateType<T>>

    /**
     * Group by Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryGroupByArgs['orderBy'] }
        : { orderBy?: SalaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Salary model
   */
  readonly fields: SalaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FinRow<T extends Salary$FinRowArgs<ExtArgs> = {}>(args?: Subset<T, Salary$FinRowArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinRowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalaryDebt<T extends Salary$SalaryDebtArgs<ExtArgs> = {}>(args?: Subset<T, Salary$SalaryDebtArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalaryEarning<T extends Salary$SalaryEarningArgs<ExtArgs> = {}>(args?: Subset<T, Salary$SalaryEarningArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalaryPayment<T extends Salary$SalaryPaymentArgs<ExtArgs> = {}>(args?: Subset<T, Salary$SalaryPaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ShiftReport<T extends Salary$ShiftReportArgs<ExtArgs> = {}>(args?: Subset<T, Salary$ShiftReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Salary model
   */
  interface SalaryFieldRefs {
    readonly id: FieldRef<"Salary", 'Int'>
    readonly fullName: FieldRef<"Salary", 'String'>
    readonly position: FieldRef<"Salary", 'String'>
    readonly startDate: FieldRef<"Salary", 'DateTime'>
    readonly payday: FieldRef<"Salary", 'Int'>
    readonly paydayMonth: FieldRef<"Salary", 'Int'>
    readonly fixedSalary: FieldRef<"Salary", 'Float'>
    readonly isActive: FieldRef<"Salary", 'Boolean'>
    readonly createdAt: FieldRef<"Salary", 'DateTime'>
    readonly updatedAt: FieldRef<"Salary", 'DateTime'>
    readonly comment: FieldRef<"Salary", 'String'>
    readonly periodic: FieldRef<"Salary", 'PeriodType'>
    readonly payday2: FieldRef<"Salary", 'Int'>
    readonly payday3: FieldRef<"Salary", 'Int'>
    readonly section: FieldRef<"Salary", 'SalarySection'>
  }
    

  // Custom InputTypes
  /**
   * Salary findUnique
   */
  export type SalaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary findUniqueOrThrow
   */
  export type SalaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary findFirst
   */
  export type SalaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salaries.
     */
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary findFirstOrThrow
   */
  export type SalaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salaries.
     */
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary findMany
   */
  export type SalaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salaries to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary create
   */
  export type SalaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The data needed to create a Salary.
     */
    data: XOR<SalaryCreateInput, SalaryUncheckedCreateInput>
  }

  /**
   * Salary createMany
   */
  export type SalaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Salaries.
     */
    data: SalaryCreateManyInput | SalaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Salary createManyAndReturn
   */
  export type SalaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * The data used to create many Salaries.
     */
    data: SalaryCreateManyInput | SalaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Salary update
   */
  export type SalaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The data needed to update a Salary.
     */
    data: XOR<SalaryUpdateInput, SalaryUncheckedUpdateInput>
    /**
     * Choose, which Salary to update.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary updateMany
   */
  export type SalaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Salaries.
     */
    data: XOR<SalaryUpdateManyMutationInput, SalaryUncheckedUpdateManyInput>
    /**
     * Filter which Salaries to update
     */
    where?: SalaryWhereInput
    /**
     * Limit how many Salaries to update.
     */
    limit?: number
  }

  /**
   * Salary updateManyAndReturn
   */
  export type SalaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * The data used to update Salaries.
     */
    data: XOR<SalaryUpdateManyMutationInput, SalaryUncheckedUpdateManyInput>
    /**
     * Filter which Salaries to update
     */
    where?: SalaryWhereInput
    /**
     * Limit how many Salaries to update.
     */
    limit?: number
  }

  /**
   * Salary upsert
   */
  export type SalaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The filter to search for the Salary to update in case it exists.
     */
    where: SalaryWhereUniqueInput
    /**
     * In case the Salary found by the `where` argument doesn't exist, create a new Salary with this data.
     */
    create: XOR<SalaryCreateInput, SalaryUncheckedCreateInput>
    /**
     * In case the Salary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryUpdateInput, SalaryUncheckedUpdateInput>
  }

  /**
   * Salary delete
   */
  export type SalaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter which Salary to delete.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary deleteMany
   */
  export type SalaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salaries to delete
     */
    where?: SalaryWhereInput
    /**
     * Limit how many Salaries to delete.
     */
    limit?: number
  }

  /**
   * Salary.FinRow
   */
  export type Salary$FinRowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinRow
     */
    select?: FinRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinRow
     */
    omit?: FinRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinRowInclude<ExtArgs> | null
    where?: FinRowWhereInput
    orderBy?: FinRowOrderByWithRelationInput | FinRowOrderByWithRelationInput[]
    cursor?: FinRowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinRowScalarFieldEnum | FinRowScalarFieldEnum[]
  }

  /**
   * Salary.SalaryDebt
   */
  export type Salary$SalaryDebtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtInclude<ExtArgs> | null
    where?: SalaryDebtWhereInput
    orderBy?: SalaryDebtOrderByWithRelationInput | SalaryDebtOrderByWithRelationInput[]
    cursor?: SalaryDebtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryDebtScalarFieldEnum | SalaryDebtScalarFieldEnum[]
  }

  /**
   * Salary.SalaryEarning
   */
  export type Salary$SalaryEarningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningInclude<ExtArgs> | null
    where?: SalaryEarningWhereInput
    orderBy?: SalaryEarningOrderByWithRelationInput | SalaryEarningOrderByWithRelationInput[]
    cursor?: SalaryEarningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryEarningScalarFieldEnum | SalaryEarningScalarFieldEnum[]
  }

  /**
   * Salary.SalaryPayment
   */
  export type Salary$SalaryPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    where?: SalaryPaymentWhereInput
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    cursor?: SalaryPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * Salary.ShiftReport
   */
  export type Salary$ShiftReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
    where?: ShiftReportWhereInput
    orderBy?: ShiftReportOrderByWithRelationInput | ShiftReportOrderByWithRelationInput[]
    cursor?: ShiftReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftReportScalarFieldEnum | ShiftReportScalarFieldEnum[]
  }

  /**
   * Salary without action
   */
  export type SalaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
  }


  /**
   * Model SalaryDebt
   */

  export type AggregateSalaryDebt = {
    _count: SalaryDebtCountAggregateOutputType | null
    _avg: SalaryDebtAvgAggregateOutputType | null
    _sum: SalaryDebtSumAggregateOutputType | null
    _min: SalaryDebtMinAggregateOutputType | null
    _max: SalaryDebtMaxAggregateOutputType | null
  }

  export type SalaryDebtAvgAggregateOutputType = {
    id: number | null
    salaryId: number | null
    amount: number | null
  }

  export type SalaryDebtSumAggregateOutputType = {
    id: number | null
    salaryId: number | null
    amount: number | null
  }

  export type SalaryDebtMinAggregateOutputType = {
    id: number | null
    salaryId: number | null
    amount: number | null
    debtDate: Date | null
    description: string | null
    isPaid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryDebtMaxAggregateOutputType = {
    id: number | null
    salaryId: number | null
    amount: number | null
    debtDate: Date | null
    description: string | null
    isPaid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryDebtCountAggregateOutputType = {
    id: number
    salaryId: number
    amount: number
    debtDate: number
    description: number
    isPaid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalaryDebtAvgAggregateInputType = {
    id?: true
    salaryId?: true
    amount?: true
  }

  export type SalaryDebtSumAggregateInputType = {
    id?: true
    salaryId?: true
    amount?: true
  }

  export type SalaryDebtMinAggregateInputType = {
    id?: true
    salaryId?: true
    amount?: true
    debtDate?: true
    description?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryDebtMaxAggregateInputType = {
    id?: true
    salaryId?: true
    amount?: true
    debtDate?: true
    description?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryDebtCountAggregateInputType = {
    id?: true
    salaryId?: true
    amount?: true
    debtDate?: true
    description?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalaryDebtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryDebt to aggregate.
     */
    where?: SalaryDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryDebts to fetch.
     */
    orderBy?: SalaryDebtOrderByWithRelationInput | SalaryDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryDebts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryDebts
    **/
    _count?: true | SalaryDebtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryDebtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryDebtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryDebtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryDebtMaxAggregateInputType
  }

  export type GetSalaryDebtAggregateType<T extends SalaryDebtAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryDebt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryDebt[P]>
      : GetScalarType<T[P], AggregateSalaryDebt[P]>
  }




  export type SalaryDebtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryDebtWhereInput
    orderBy?: SalaryDebtOrderByWithAggregationInput | SalaryDebtOrderByWithAggregationInput[]
    by: SalaryDebtScalarFieldEnum[] | SalaryDebtScalarFieldEnum
    having?: SalaryDebtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryDebtCountAggregateInputType | true
    _avg?: SalaryDebtAvgAggregateInputType
    _sum?: SalaryDebtSumAggregateInputType
    _min?: SalaryDebtMinAggregateInputType
    _max?: SalaryDebtMaxAggregateInputType
  }

  export type SalaryDebtGroupByOutputType = {
    id: number
    salaryId: number
    amount: number
    debtDate: Date
    description: string | null
    isPaid: boolean
    createdAt: Date
    updatedAt: Date
    _count: SalaryDebtCountAggregateOutputType | null
    _avg: SalaryDebtAvgAggregateOutputType | null
    _sum: SalaryDebtSumAggregateOutputType | null
    _min: SalaryDebtMinAggregateOutputType | null
    _max: SalaryDebtMaxAggregateOutputType | null
  }

  type GetSalaryDebtGroupByPayload<T extends SalaryDebtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryDebtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryDebtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryDebtGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryDebtGroupByOutputType[P]>
        }
      >
    >


  export type SalaryDebtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salaryId?: boolean
    amount?: boolean
    debtDate?: boolean
    description?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryDebt"]>

  export type SalaryDebtSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salaryId?: boolean
    amount?: boolean
    debtDate?: boolean
    description?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryDebt"]>

  export type SalaryDebtSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salaryId?: boolean
    amount?: boolean
    debtDate?: boolean
    description?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryDebt"]>

  export type SalaryDebtSelectScalar = {
    id?: boolean
    salaryId?: boolean
    amount?: boolean
    debtDate?: boolean
    description?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalaryDebtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "salaryId" | "amount" | "debtDate" | "description" | "isPaid" | "createdAt" | "updatedAt", ExtArgs["result"]["salaryDebt"]>
  export type SalaryDebtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }
  export type SalaryDebtIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }
  export type SalaryDebtIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }

  export type $SalaryDebtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryDebt"
    objects: {
      Salary: Prisma.$SalaryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      salaryId: number
      amount: number
      debtDate: Date
      description: string | null
      isPaid: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salaryDebt"]>
    composites: {}
  }

  type SalaryDebtGetPayload<S extends boolean | null | undefined | SalaryDebtDefaultArgs> = $Result.GetResult<Prisma.$SalaryDebtPayload, S>

  type SalaryDebtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryDebtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryDebtCountAggregateInputType | true
    }

  export interface SalaryDebtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryDebt'], meta: { name: 'SalaryDebt' } }
    /**
     * Find zero or one SalaryDebt that matches the filter.
     * @param {SalaryDebtFindUniqueArgs} args - Arguments to find a SalaryDebt
     * @example
     * // Get one SalaryDebt
     * const salaryDebt = await prisma.salaryDebt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryDebtFindUniqueArgs>(args: SelectSubset<T, SalaryDebtFindUniqueArgs<ExtArgs>>): Prisma__SalaryDebtClient<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalaryDebt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryDebtFindUniqueOrThrowArgs} args - Arguments to find a SalaryDebt
     * @example
     * // Get one SalaryDebt
     * const salaryDebt = await prisma.salaryDebt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryDebtFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryDebtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryDebtClient<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryDebt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDebtFindFirstArgs} args - Arguments to find a SalaryDebt
     * @example
     * // Get one SalaryDebt
     * const salaryDebt = await prisma.salaryDebt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryDebtFindFirstArgs>(args?: SelectSubset<T, SalaryDebtFindFirstArgs<ExtArgs>>): Prisma__SalaryDebtClient<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryDebt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDebtFindFirstOrThrowArgs} args - Arguments to find a SalaryDebt
     * @example
     * // Get one SalaryDebt
     * const salaryDebt = await prisma.salaryDebt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryDebtFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryDebtFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryDebtClient<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalaryDebts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDebtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryDebts
     * const salaryDebts = await prisma.salaryDebt.findMany()
     * 
     * // Get first 10 SalaryDebts
     * const salaryDebts = await prisma.salaryDebt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryDebtWithIdOnly = await prisma.salaryDebt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryDebtFindManyArgs>(args?: SelectSubset<T, SalaryDebtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalaryDebt.
     * @param {SalaryDebtCreateArgs} args - Arguments to create a SalaryDebt.
     * @example
     * // Create one SalaryDebt
     * const SalaryDebt = await prisma.salaryDebt.create({
     *   data: {
     *     // ... data to create a SalaryDebt
     *   }
     * })
     * 
     */
    create<T extends SalaryDebtCreateArgs>(args: SelectSubset<T, SalaryDebtCreateArgs<ExtArgs>>): Prisma__SalaryDebtClient<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalaryDebts.
     * @param {SalaryDebtCreateManyArgs} args - Arguments to create many SalaryDebts.
     * @example
     * // Create many SalaryDebts
     * const salaryDebt = await prisma.salaryDebt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryDebtCreateManyArgs>(args?: SelectSubset<T, SalaryDebtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryDebts and returns the data saved in the database.
     * @param {SalaryDebtCreateManyAndReturnArgs} args - Arguments to create many SalaryDebts.
     * @example
     * // Create many SalaryDebts
     * const salaryDebt = await prisma.salaryDebt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryDebts and only return the `id`
     * const salaryDebtWithIdOnly = await prisma.salaryDebt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryDebtCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryDebtCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalaryDebt.
     * @param {SalaryDebtDeleteArgs} args - Arguments to delete one SalaryDebt.
     * @example
     * // Delete one SalaryDebt
     * const SalaryDebt = await prisma.salaryDebt.delete({
     *   where: {
     *     // ... filter to delete one SalaryDebt
     *   }
     * })
     * 
     */
    delete<T extends SalaryDebtDeleteArgs>(args: SelectSubset<T, SalaryDebtDeleteArgs<ExtArgs>>): Prisma__SalaryDebtClient<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalaryDebt.
     * @param {SalaryDebtUpdateArgs} args - Arguments to update one SalaryDebt.
     * @example
     * // Update one SalaryDebt
     * const salaryDebt = await prisma.salaryDebt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryDebtUpdateArgs>(args: SelectSubset<T, SalaryDebtUpdateArgs<ExtArgs>>): Prisma__SalaryDebtClient<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalaryDebts.
     * @param {SalaryDebtDeleteManyArgs} args - Arguments to filter SalaryDebts to delete.
     * @example
     * // Delete a few SalaryDebts
     * const { count } = await prisma.salaryDebt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryDebtDeleteManyArgs>(args?: SelectSubset<T, SalaryDebtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryDebts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDebtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryDebts
     * const salaryDebt = await prisma.salaryDebt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryDebtUpdateManyArgs>(args: SelectSubset<T, SalaryDebtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryDebts and returns the data updated in the database.
     * @param {SalaryDebtUpdateManyAndReturnArgs} args - Arguments to update many SalaryDebts.
     * @example
     * // Update many SalaryDebts
     * const salaryDebt = await prisma.salaryDebt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalaryDebts and only return the `id`
     * const salaryDebtWithIdOnly = await prisma.salaryDebt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryDebtUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryDebtUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalaryDebt.
     * @param {SalaryDebtUpsertArgs} args - Arguments to update or create a SalaryDebt.
     * @example
     * // Update or create a SalaryDebt
     * const salaryDebt = await prisma.salaryDebt.upsert({
     *   create: {
     *     // ... data to create a SalaryDebt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryDebt we want to update
     *   }
     * })
     */
    upsert<T extends SalaryDebtUpsertArgs>(args: SelectSubset<T, SalaryDebtUpsertArgs<ExtArgs>>): Prisma__SalaryDebtClient<$Result.GetResult<Prisma.$SalaryDebtPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalaryDebts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDebtCountArgs} args - Arguments to filter SalaryDebts to count.
     * @example
     * // Count the number of SalaryDebts
     * const count = await prisma.salaryDebt.count({
     *   where: {
     *     // ... the filter for the SalaryDebts we want to count
     *   }
     * })
    **/
    count<T extends SalaryDebtCountArgs>(
      args?: Subset<T, SalaryDebtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryDebtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryDebt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDebtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryDebtAggregateArgs>(args: Subset<T, SalaryDebtAggregateArgs>): Prisma.PrismaPromise<GetSalaryDebtAggregateType<T>>

    /**
     * Group by SalaryDebt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDebtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryDebtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryDebtGroupByArgs['orderBy'] }
        : { orderBy?: SalaryDebtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryDebtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryDebtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryDebt model
   */
  readonly fields: SalaryDebtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryDebt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryDebtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Salary<T extends SalaryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalaryDefaultArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryDebt model
   */
  interface SalaryDebtFieldRefs {
    readonly id: FieldRef<"SalaryDebt", 'Int'>
    readonly salaryId: FieldRef<"SalaryDebt", 'Int'>
    readonly amount: FieldRef<"SalaryDebt", 'Float'>
    readonly debtDate: FieldRef<"SalaryDebt", 'DateTime'>
    readonly description: FieldRef<"SalaryDebt", 'String'>
    readonly isPaid: FieldRef<"SalaryDebt", 'Boolean'>
    readonly createdAt: FieldRef<"SalaryDebt", 'DateTime'>
    readonly updatedAt: FieldRef<"SalaryDebt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalaryDebt findUnique
   */
  export type SalaryDebtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtInclude<ExtArgs> | null
    /**
     * Filter, which SalaryDebt to fetch.
     */
    where: SalaryDebtWhereUniqueInput
  }

  /**
   * SalaryDebt findUniqueOrThrow
   */
  export type SalaryDebtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtInclude<ExtArgs> | null
    /**
     * Filter, which SalaryDebt to fetch.
     */
    where: SalaryDebtWhereUniqueInput
  }

  /**
   * SalaryDebt findFirst
   */
  export type SalaryDebtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtInclude<ExtArgs> | null
    /**
     * Filter, which SalaryDebt to fetch.
     */
    where?: SalaryDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryDebts to fetch.
     */
    orderBy?: SalaryDebtOrderByWithRelationInput | SalaryDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryDebts.
     */
    cursor?: SalaryDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryDebts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryDebts.
     */
    distinct?: SalaryDebtScalarFieldEnum | SalaryDebtScalarFieldEnum[]
  }

  /**
   * SalaryDebt findFirstOrThrow
   */
  export type SalaryDebtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtInclude<ExtArgs> | null
    /**
     * Filter, which SalaryDebt to fetch.
     */
    where?: SalaryDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryDebts to fetch.
     */
    orderBy?: SalaryDebtOrderByWithRelationInput | SalaryDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryDebts.
     */
    cursor?: SalaryDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryDebts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryDebts.
     */
    distinct?: SalaryDebtScalarFieldEnum | SalaryDebtScalarFieldEnum[]
  }

  /**
   * SalaryDebt findMany
   */
  export type SalaryDebtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtInclude<ExtArgs> | null
    /**
     * Filter, which SalaryDebts to fetch.
     */
    where?: SalaryDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryDebts to fetch.
     */
    orderBy?: SalaryDebtOrderByWithRelationInput | SalaryDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryDebts.
     */
    cursor?: SalaryDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryDebts.
     */
    skip?: number
    distinct?: SalaryDebtScalarFieldEnum | SalaryDebtScalarFieldEnum[]
  }

  /**
   * SalaryDebt create
   */
  export type SalaryDebtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryDebt.
     */
    data: XOR<SalaryDebtCreateInput, SalaryDebtUncheckedCreateInput>
  }

  /**
   * SalaryDebt createMany
   */
  export type SalaryDebtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryDebts.
     */
    data: SalaryDebtCreateManyInput | SalaryDebtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryDebt createManyAndReturn
   */
  export type SalaryDebtCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * The data used to create many SalaryDebts.
     */
    data: SalaryDebtCreateManyInput | SalaryDebtCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryDebt update
   */
  export type SalaryDebtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryDebt.
     */
    data: XOR<SalaryDebtUpdateInput, SalaryDebtUncheckedUpdateInput>
    /**
     * Choose, which SalaryDebt to update.
     */
    where: SalaryDebtWhereUniqueInput
  }

  /**
   * SalaryDebt updateMany
   */
  export type SalaryDebtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryDebts.
     */
    data: XOR<SalaryDebtUpdateManyMutationInput, SalaryDebtUncheckedUpdateManyInput>
    /**
     * Filter which SalaryDebts to update
     */
    where?: SalaryDebtWhereInput
    /**
     * Limit how many SalaryDebts to update.
     */
    limit?: number
  }

  /**
   * SalaryDebt updateManyAndReturn
   */
  export type SalaryDebtUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * The data used to update SalaryDebts.
     */
    data: XOR<SalaryDebtUpdateManyMutationInput, SalaryDebtUncheckedUpdateManyInput>
    /**
     * Filter which SalaryDebts to update
     */
    where?: SalaryDebtWhereInput
    /**
     * Limit how many SalaryDebts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryDebt upsert
   */
  export type SalaryDebtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryDebt to update in case it exists.
     */
    where: SalaryDebtWhereUniqueInput
    /**
     * In case the SalaryDebt found by the `where` argument doesn't exist, create a new SalaryDebt with this data.
     */
    create: XOR<SalaryDebtCreateInput, SalaryDebtUncheckedCreateInput>
    /**
     * In case the SalaryDebt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryDebtUpdateInput, SalaryDebtUncheckedUpdateInput>
  }

  /**
   * SalaryDebt delete
   */
  export type SalaryDebtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtInclude<ExtArgs> | null
    /**
     * Filter which SalaryDebt to delete.
     */
    where: SalaryDebtWhereUniqueInput
  }

  /**
   * SalaryDebt deleteMany
   */
  export type SalaryDebtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryDebts to delete
     */
    where?: SalaryDebtWhereInput
    /**
     * Limit how many SalaryDebts to delete.
     */
    limit?: number
  }

  /**
   * SalaryDebt without action
   */
  export type SalaryDebtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDebt
     */
    select?: SalaryDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryDebt
     */
    omit?: SalaryDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDebtInclude<ExtArgs> | null
  }


  /**
   * Model SalaryEarning
   */

  export type AggregateSalaryEarning = {
    _count: SalaryEarningCountAggregateOutputType | null
    _avg: SalaryEarningAvgAggregateOutputType | null
    _sum: SalaryEarningSumAggregateOutputType | null
    _min: SalaryEarningMinAggregateOutputType | null
    _max: SalaryEarningMaxAggregateOutputType | null
  }

  export type SalaryEarningAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    salaryId: number | null
  }

  export type SalaryEarningSumAggregateOutputType = {
    id: number | null
    amount: number | null
    salaryId: number | null
  }

  export type SalaryEarningMinAggregateOutputType = {
    id: number | null
    amount: number | null
    earningDate: Date | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    salaryId: number | null
  }

  export type SalaryEarningMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    earningDate: Date | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    salaryId: number | null
  }

  export type SalaryEarningCountAggregateOutputType = {
    id: number
    amount: number
    earningDate: number
    description: number
    createdAt: number
    updatedAt: number
    salaryId: number
    _all: number
  }


  export type SalaryEarningAvgAggregateInputType = {
    id?: true
    amount?: true
    salaryId?: true
  }

  export type SalaryEarningSumAggregateInputType = {
    id?: true
    amount?: true
    salaryId?: true
  }

  export type SalaryEarningMinAggregateInputType = {
    id?: true
    amount?: true
    earningDate?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    salaryId?: true
  }

  export type SalaryEarningMaxAggregateInputType = {
    id?: true
    amount?: true
    earningDate?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    salaryId?: true
  }

  export type SalaryEarningCountAggregateInputType = {
    id?: true
    amount?: true
    earningDate?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    salaryId?: true
    _all?: true
  }

  export type SalaryEarningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryEarning to aggregate.
     */
    where?: SalaryEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryEarnings to fetch.
     */
    orderBy?: SalaryEarningOrderByWithRelationInput | SalaryEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryEarnings
    **/
    _count?: true | SalaryEarningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryEarningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryEarningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryEarningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryEarningMaxAggregateInputType
  }

  export type GetSalaryEarningAggregateType<T extends SalaryEarningAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryEarning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryEarning[P]>
      : GetScalarType<T[P], AggregateSalaryEarning[P]>
  }




  export type SalaryEarningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryEarningWhereInput
    orderBy?: SalaryEarningOrderByWithAggregationInput | SalaryEarningOrderByWithAggregationInput[]
    by: SalaryEarningScalarFieldEnum[] | SalaryEarningScalarFieldEnum
    having?: SalaryEarningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryEarningCountAggregateInputType | true
    _avg?: SalaryEarningAvgAggregateInputType
    _sum?: SalaryEarningSumAggregateInputType
    _min?: SalaryEarningMinAggregateInputType
    _max?: SalaryEarningMaxAggregateInputType
  }

  export type SalaryEarningGroupByOutputType = {
    id: number
    amount: number
    earningDate: Date
    description: string | null
    createdAt: Date
    updatedAt: Date
    salaryId: number
    _count: SalaryEarningCountAggregateOutputType | null
    _avg: SalaryEarningAvgAggregateOutputType | null
    _sum: SalaryEarningSumAggregateOutputType | null
    _min: SalaryEarningMinAggregateOutputType | null
    _max: SalaryEarningMaxAggregateOutputType | null
  }

  type GetSalaryEarningGroupByPayload<T extends SalaryEarningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryEarningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryEarningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryEarningGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryEarningGroupByOutputType[P]>
        }
      >
    >


  export type SalaryEarningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    earningDate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salaryId?: boolean
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryEarning"]>

  export type SalaryEarningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    earningDate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salaryId?: boolean
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryEarning"]>

  export type SalaryEarningSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    earningDate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salaryId?: boolean
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryEarning"]>

  export type SalaryEarningSelectScalar = {
    id?: boolean
    amount?: boolean
    earningDate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salaryId?: boolean
  }

  export type SalaryEarningOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "earningDate" | "description" | "createdAt" | "updatedAt" | "salaryId", ExtArgs["result"]["salaryEarning"]>
  export type SalaryEarningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }
  export type SalaryEarningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }
  export type SalaryEarningIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }

  export type $SalaryEarningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryEarning"
    objects: {
      Salary: Prisma.$SalaryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number
      earningDate: Date
      description: string | null
      createdAt: Date
      updatedAt: Date
      salaryId: number
    }, ExtArgs["result"]["salaryEarning"]>
    composites: {}
  }

  type SalaryEarningGetPayload<S extends boolean | null | undefined | SalaryEarningDefaultArgs> = $Result.GetResult<Prisma.$SalaryEarningPayload, S>

  type SalaryEarningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryEarningFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryEarningCountAggregateInputType | true
    }

  export interface SalaryEarningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryEarning'], meta: { name: 'SalaryEarning' } }
    /**
     * Find zero or one SalaryEarning that matches the filter.
     * @param {SalaryEarningFindUniqueArgs} args - Arguments to find a SalaryEarning
     * @example
     * // Get one SalaryEarning
     * const salaryEarning = await prisma.salaryEarning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryEarningFindUniqueArgs>(args: SelectSubset<T, SalaryEarningFindUniqueArgs<ExtArgs>>): Prisma__SalaryEarningClient<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalaryEarning that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryEarningFindUniqueOrThrowArgs} args - Arguments to find a SalaryEarning
     * @example
     * // Get one SalaryEarning
     * const salaryEarning = await prisma.salaryEarning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryEarningFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryEarningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryEarningClient<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryEarning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryEarningFindFirstArgs} args - Arguments to find a SalaryEarning
     * @example
     * // Get one SalaryEarning
     * const salaryEarning = await prisma.salaryEarning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryEarningFindFirstArgs>(args?: SelectSubset<T, SalaryEarningFindFirstArgs<ExtArgs>>): Prisma__SalaryEarningClient<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryEarning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryEarningFindFirstOrThrowArgs} args - Arguments to find a SalaryEarning
     * @example
     * // Get one SalaryEarning
     * const salaryEarning = await prisma.salaryEarning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryEarningFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryEarningFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryEarningClient<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalaryEarnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryEarningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryEarnings
     * const salaryEarnings = await prisma.salaryEarning.findMany()
     * 
     * // Get first 10 SalaryEarnings
     * const salaryEarnings = await prisma.salaryEarning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryEarningWithIdOnly = await prisma.salaryEarning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryEarningFindManyArgs>(args?: SelectSubset<T, SalaryEarningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalaryEarning.
     * @param {SalaryEarningCreateArgs} args - Arguments to create a SalaryEarning.
     * @example
     * // Create one SalaryEarning
     * const SalaryEarning = await prisma.salaryEarning.create({
     *   data: {
     *     // ... data to create a SalaryEarning
     *   }
     * })
     * 
     */
    create<T extends SalaryEarningCreateArgs>(args: SelectSubset<T, SalaryEarningCreateArgs<ExtArgs>>): Prisma__SalaryEarningClient<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalaryEarnings.
     * @param {SalaryEarningCreateManyArgs} args - Arguments to create many SalaryEarnings.
     * @example
     * // Create many SalaryEarnings
     * const salaryEarning = await prisma.salaryEarning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryEarningCreateManyArgs>(args?: SelectSubset<T, SalaryEarningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryEarnings and returns the data saved in the database.
     * @param {SalaryEarningCreateManyAndReturnArgs} args - Arguments to create many SalaryEarnings.
     * @example
     * // Create many SalaryEarnings
     * const salaryEarning = await prisma.salaryEarning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryEarnings and only return the `id`
     * const salaryEarningWithIdOnly = await prisma.salaryEarning.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryEarningCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryEarningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalaryEarning.
     * @param {SalaryEarningDeleteArgs} args - Arguments to delete one SalaryEarning.
     * @example
     * // Delete one SalaryEarning
     * const SalaryEarning = await prisma.salaryEarning.delete({
     *   where: {
     *     // ... filter to delete one SalaryEarning
     *   }
     * })
     * 
     */
    delete<T extends SalaryEarningDeleteArgs>(args: SelectSubset<T, SalaryEarningDeleteArgs<ExtArgs>>): Prisma__SalaryEarningClient<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalaryEarning.
     * @param {SalaryEarningUpdateArgs} args - Arguments to update one SalaryEarning.
     * @example
     * // Update one SalaryEarning
     * const salaryEarning = await prisma.salaryEarning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryEarningUpdateArgs>(args: SelectSubset<T, SalaryEarningUpdateArgs<ExtArgs>>): Prisma__SalaryEarningClient<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalaryEarnings.
     * @param {SalaryEarningDeleteManyArgs} args - Arguments to filter SalaryEarnings to delete.
     * @example
     * // Delete a few SalaryEarnings
     * const { count } = await prisma.salaryEarning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryEarningDeleteManyArgs>(args?: SelectSubset<T, SalaryEarningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryEarnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryEarningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryEarnings
     * const salaryEarning = await prisma.salaryEarning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryEarningUpdateManyArgs>(args: SelectSubset<T, SalaryEarningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryEarnings and returns the data updated in the database.
     * @param {SalaryEarningUpdateManyAndReturnArgs} args - Arguments to update many SalaryEarnings.
     * @example
     * // Update many SalaryEarnings
     * const salaryEarning = await prisma.salaryEarning.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalaryEarnings and only return the `id`
     * const salaryEarningWithIdOnly = await prisma.salaryEarning.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryEarningUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryEarningUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalaryEarning.
     * @param {SalaryEarningUpsertArgs} args - Arguments to update or create a SalaryEarning.
     * @example
     * // Update or create a SalaryEarning
     * const salaryEarning = await prisma.salaryEarning.upsert({
     *   create: {
     *     // ... data to create a SalaryEarning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryEarning we want to update
     *   }
     * })
     */
    upsert<T extends SalaryEarningUpsertArgs>(args: SelectSubset<T, SalaryEarningUpsertArgs<ExtArgs>>): Prisma__SalaryEarningClient<$Result.GetResult<Prisma.$SalaryEarningPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalaryEarnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryEarningCountArgs} args - Arguments to filter SalaryEarnings to count.
     * @example
     * // Count the number of SalaryEarnings
     * const count = await prisma.salaryEarning.count({
     *   where: {
     *     // ... the filter for the SalaryEarnings we want to count
     *   }
     * })
    **/
    count<T extends SalaryEarningCountArgs>(
      args?: Subset<T, SalaryEarningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryEarningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryEarning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryEarningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryEarningAggregateArgs>(args: Subset<T, SalaryEarningAggregateArgs>): Prisma.PrismaPromise<GetSalaryEarningAggregateType<T>>

    /**
     * Group by SalaryEarning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryEarningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryEarningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryEarningGroupByArgs['orderBy'] }
        : { orderBy?: SalaryEarningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryEarningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryEarningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryEarning model
   */
  readonly fields: SalaryEarningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryEarning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryEarningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Salary<T extends SalaryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalaryDefaultArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryEarning model
   */
  interface SalaryEarningFieldRefs {
    readonly id: FieldRef<"SalaryEarning", 'Int'>
    readonly amount: FieldRef<"SalaryEarning", 'Float'>
    readonly earningDate: FieldRef<"SalaryEarning", 'DateTime'>
    readonly description: FieldRef<"SalaryEarning", 'String'>
    readonly createdAt: FieldRef<"SalaryEarning", 'DateTime'>
    readonly updatedAt: FieldRef<"SalaryEarning", 'DateTime'>
    readonly salaryId: FieldRef<"SalaryEarning", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SalaryEarning findUnique
   */
  export type SalaryEarningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningInclude<ExtArgs> | null
    /**
     * Filter, which SalaryEarning to fetch.
     */
    where: SalaryEarningWhereUniqueInput
  }

  /**
   * SalaryEarning findUniqueOrThrow
   */
  export type SalaryEarningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningInclude<ExtArgs> | null
    /**
     * Filter, which SalaryEarning to fetch.
     */
    where: SalaryEarningWhereUniqueInput
  }

  /**
   * SalaryEarning findFirst
   */
  export type SalaryEarningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningInclude<ExtArgs> | null
    /**
     * Filter, which SalaryEarning to fetch.
     */
    where?: SalaryEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryEarnings to fetch.
     */
    orderBy?: SalaryEarningOrderByWithRelationInput | SalaryEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryEarnings.
     */
    cursor?: SalaryEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryEarnings.
     */
    distinct?: SalaryEarningScalarFieldEnum | SalaryEarningScalarFieldEnum[]
  }

  /**
   * SalaryEarning findFirstOrThrow
   */
  export type SalaryEarningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningInclude<ExtArgs> | null
    /**
     * Filter, which SalaryEarning to fetch.
     */
    where?: SalaryEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryEarnings to fetch.
     */
    orderBy?: SalaryEarningOrderByWithRelationInput | SalaryEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryEarnings.
     */
    cursor?: SalaryEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryEarnings.
     */
    distinct?: SalaryEarningScalarFieldEnum | SalaryEarningScalarFieldEnum[]
  }

  /**
   * SalaryEarning findMany
   */
  export type SalaryEarningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningInclude<ExtArgs> | null
    /**
     * Filter, which SalaryEarnings to fetch.
     */
    where?: SalaryEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryEarnings to fetch.
     */
    orderBy?: SalaryEarningOrderByWithRelationInput | SalaryEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryEarnings.
     */
    cursor?: SalaryEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryEarnings.
     */
    skip?: number
    distinct?: SalaryEarningScalarFieldEnum | SalaryEarningScalarFieldEnum[]
  }

  /**
   * SalaryEarning create
   */
  export type SalaryEarningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryEarning.
     */
    data: XOR<SalaryEarningCreateInput, SalaryEarningUncheckedCreateInput>
  }

  /**
   * SalaryEarning createMany
   */
  export type SalaryEarningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryEarnings.
     */
    data: SalaryEarningCreateManyInput | SalaryEarningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryEarning createManyAndReturn
   */
  export type SalaryEarningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * The data used to create many SalaryEarnings.
     */
    data: SalaryEarningCreateManyInput | SalaryEarningCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryEarning update
   */
  export type SalaryEarningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryEarning.
     */
    data: XOR<SalaryEarningUpdateInput, SalaryEarningUncheckedUpdateInput>
    /**
     * Choose, which SalaryEarning to update.
     */
    where: SalaryEarningWhereUniqueInput
  }

  /**
   * SalaryEarning updateMany
   */
  export type SalaryEarningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryEarnings.
     */
    data: XOR<SalaryEarningUpdateManyMutationInput, SalaryEarningUncheckedUpdateManyInput>
    /**
     * Filter which SalaryEarnings to update
     */
    where?: SalaryEarningWhereInput
    /**
     * Limit how many SalaryEarnings to update.
     */
    limit?: number
  }

  /**
   * SalaryEarning updateManyAndReturn
   */
  export type SalaryEarningUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * The data used to update SalaryEarnings.
     */
    data: XOR<SalaryEarningUpdateManyMutationInput, SalaryEarningUncheckedUpdateManyInput>
    /**
     * Filter which SalaryEarnings to update
     */
    where?: SalaryEarningWhereInput
    /**
     * Limit how many SalaryEarnings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryEarning upsert
   */
  export type SalaryEarningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryEarning to update in case it exists.
     */
    where: SalaryEarningWhereUniqueInput
    /**
     * In case the SalaryEarning found by the `where` argument doesn't exist, create a new SalaryEarning with this data.
     */
    create: XOR<SalaryEarningCreateInput, SalaryEarningUncheckedCreateInput>
    /**
     * In case the SalaryEarning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryEarningUpdateInput, SalaryEarningUncheckedUpdateInput>
  }

  /**
   * SalaryEarning delete
   */
  export type SalaryEarningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningInclude<ExtArgs> | null
    /**
     * Filter which SalaryEarning to delete.
     */
    where: SalaryEarningWhereUniqueInput
  }

  /**
   * SalaryEarning deleteMany
   */
  export type SalaryEarningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryEarnings to delete
     */
    where?: SalaryEarningWhereInput
    /**
     * Limit how many SalaryEarnings to delete.
     */
    limit?: number
  }

  /**
   * SalaryEarning without action
   */
  export type SalaryEarningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryEarning
     */
    select?: SalaryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryEarning
     */
    omit?: SalaryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryEarningInclude<ExtArgs> | null
  }


  /**
   * Model SalaryPayment
   */

  export type AggregateSalaryPayment = {
    _count: SalaryPaymentCountAggregateOutputType | null
    _avg: SalaryPaymentAvgAggregateOutputType | null
    _sum: SalaryPaymentSumAggregateOutputType | null
    _min: SalaryPaymentMinAggregateOutputType | null
    _max: SalaryPaymentMaxAggregateOutputType | null
  }

  export type SalaryPaymentAvgAggregateOutputType = {
    id: number | null
    salaryId: number | null
    amount: number | null
  }

  export type SalaryPaymentSumAggregateOutputType = {
    id: number | null
    salaryId: number | null
    amount: number | null
  }

  export type SalaryPaymentMinAggregateOutputType = {
    id: number | null
    salaryId: number | null
    amount: number | null
    paymentDate: Date | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
  }

  export type SalaryPaymentMaxAggregateOutputType = {
    id: number | null
    salaryId: number | null
    amount: number | null
    paymentDate: Date | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
  }

  export type SalaryPaymentCountAggregateOutputType = {
    id: number
    salaryId: number
    amount: number
    paymentDate: number
    comment: number
    createdAt: number
    updatedAt: number
    currency: number
    _all: number
  }


  export type SalaryPaymentAvgAggregateInputType = {
    id?: true
    salaryId?: true
    amount?: true
  }

  export type SalaryPaymentSumAggregateInputType = {
    id?: true
    salaryId?: true
    amount?: true
  }

  export type SalaryPaymentMinAggregateInputType = {
    id?: true
    salaryId?: true
    amount?: true
    paymentDate?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
  }

  export type SalaryPaymentMaxAggregateInputType = {
    id?: true
    salaryId?: true
    amount?: true
    paymentDate?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
  }

  export type SalaryPaymentCountAggregateInputType = {
    id?: true
    salaryId?: true
    amount?: true
    paymentDate?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    _all?: true
  }

  export type SalaryPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayment to aggregate.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryPayments
    **/
    _count?: true | SalaryPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryPaymentMaxAggregateInputType
  }

  export type GetSalaryPaymentAggregateType<T extends SalaryPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryPayment[P]>
      : GetScalarType<T[P], AggregateSalaryPayment[P]>
  }




  export type SalaryPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentWhereInput
    orderBy?: SalaryPaymentOrderByWithAggregationInput | SalaryPaymentOrderByWithAggregationInput[]
    by: SalaryPaymentScalarFieldEnum[] | SalaryPaymentScalarFieldEnum
    having?: SalaryPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryPaymentCountAggregateInputType | true
    _avg?: SalaryPaymentAvgAggregateInputType
    _sum?: SalaryPaymentSumAggregateInputType
    _min?: SalaryPaymentMinAggregateInputType
    _max?: SalaryPaymentMaxAggregateInputType
  }

  export type SalaryPaymentGroupByOutputType = {
    id: number
    salaryId: number
    amount: number
    paymentDate: Date
    comment: string | null
    createdAt: Date
    updatedAt: Date
    currency: string
    _count: SalaryPaymentCountAggregateOutputType | null
    _avg: SalaryPaymentAvgAggregateOutputType | null
    _sum: SalaryPaymentSumAggregateOutputType | null
    _min: SalaryPaymentMinAggregateOutputType | null
    _max: SalaryPaymentMaxAggregateOutputType | null
  }

  type GetSalaryPaymentGroupByPayload<T extends SalaryPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryPaymentGroupByOutputType[P]>
        }
      >
    >


  export type SalaryPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salaryId?: boolean
    amount?: boolean
    paymentDate?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayment"]>

  export type SalaryPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salaryId?: boolean
    amount?: boolean
    paymentDate?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayment"]>

  export type SalaryPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salaryId?: boolean
    amount?: boolean
    paymentDate?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayment"]>

  export type SalaryPaymentSelectScalar = {
    id?: boolean
    salaryId?: boolean
    amount?: boolean
    paymentDate?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
  }

  export type SalaryPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "salaryId" | "amount" | "paymentDate" | "comment" | "createdAt" | "updatedAt" | "currency", ExtArgs["result"]["salaryPayment"]>
  export type SalaryPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }
  export type SalaryPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }
  export type SalaryPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | SalaryDefaultArgs<ExtArgs>
  }

  export type $SalaryPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryPayment"
    objects: {
      Salary: Prisma.$SalaryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      salaryId: number
      amount: number
      paymentDate: Date
      comment: string | null
      createdAt: Date
      updatedAt: Date
      currency: string
    }, ExtArgs["result"]["salaryPayment"]>
    composites: {}
  }

  type SalaryPaymentGetPayload<S extends boolean | null | undefined | SalaryPaymentDefaultArgs> = $Result.GetResult<Prisma.$SalaryPaymentPayload, S>

  type SalaryPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryPaymentCountAggregateInputType | true
    }

  export interface SalaryPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryPayment'], meta: { name: 'SalaryPayment' } }
    /**
     * Find zero or one SalaryPayment that matches the filter.
     * @param {SalaryPaymentFindUniqueArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryPaymentFindUniqueArgs>(args: SelectSubset<T, SalaryPaymentFindUniqueArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalaryPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryPaymentFindUniqueOrThrowArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindFirstArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryPaymentFindFirstArgs>(args?: SelectSubset<T, SalaryPaymentFindFirstArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindFirstOrThrowArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalaryPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryPayments
     * const salaryPayments = await prisma.salaryPayment.findMany()
     * 
     * // Get first 10 SalaryPayments
     * const salaryPayments = await prisma.salaryPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryPaymentWithIdOnly = await prisma.salaryPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryPaymentFindManyArgs>(args?: SelectSubset<T, SalaryPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalaryPayment.
     * @param {SalaryPaymentCreateArgs} args - Arguments to create a SalaryPayment.
     * @example
     * // Create one SalaryPayment
     * const SalaryPayment = await prisma.salaryPayment.create({
     *   data: {
     *     // ... data to create a SalaryPayment
     *   }
     * })
     * 
     */
    create<T extends SalaryPaymentCreateArgs>(args: SelectSubset<T, SalaryPaymentCreateArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalaryPayments.
     * @param {SalaryPaymentCreateManyArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryPaymentCreateManyArgs>(args?: SelectSubset<T, SalaryPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryPayments and returns the data saved in the database.
     * @param {SalaryPaymentCreateManyAndReturnArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryPayments and only return the `id`
     * const salaryPaymentWithIdOnly = await prisma.salaryPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalaryPayment.
     * @param {SalaryPaymentDeleteArgs} args - Arguments to delete one SalaryPayment.
     * @example
     * // Delete one SalaryPayment
     * const SalaryPayment = await prisma.salaryPayment.delete({
     *   where: {
     *     // ... filter to delete one SalaryPayment
     *   }
     * })
     * 
     */
    delete<T extends SalaryPaymentDeleteArgs>(args: SelectSubset<T, SalaryPaymentDeleteArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalaryPayment.
     * @param {SalaryPaymentUpdateArgs} args - Arguments to update one SalaryPayment.
     * @example
     * // Update one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryPaymentUpdateArgs>(args: SelectSubset<T, SalaryPaymentUpdateArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalaryPayments.
     * @param {SalaryPaymentDeleteManyArgs} args - Arguments to filter SalaryPayments to delete.
     * @example
     * // Delete a few SalaryPayments
     * const { count } = await prisma.salaryPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryPaymentDeleteManyArgs>(args?: SelectSubset<T, SalaryPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryPaymentUpdateManyArgs>(args: SelectSubset<T, SalaryPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryPayments and returns the data updated in the database.
     * @param {SalaryPaymentUpdateManyAndReturnArgs} args - Arguments to update many SalaryPayments.
     * @example
     * // Update many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalaryPayments and only return the `id`
     * const salaryPaymentWithIdOnly = await prisma.salaryPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalaryPayment.
     * @param {SalaryPaymentUpsertArgs} args - Arguments to update or create a SalaryPayment.
     * @example
     * // Update or create a SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.upsert({
     *   create: {
     *     // ... data to create a SalaryPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryPayment we want to update
     *   }
     * })
     */
    upsert<T extends SalaryPaymentUpsertArgs>(args: SelectSubset<T, SalaryPaymentUpsertArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentCountArgs} args - Arguments to filter SalaryPayments to count.
     * @example
     * // Count the number of SalaryPayments
     * const count = await prisma.salaryPayment.count({
     *   where: {
     *     // ... the filter for the SalaryPayments we want to count
     *   }
     * })
    **/
    count<T extends SalaryPaymentCountArgs>(
      args?: Subset<T, SalaryPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryPaymentAggregateArgs>(args: Subset<T, SalaryPaymentAggregateArgs>): Prisma.PrismaPromise<GetSalaryPaymentAggregateType<T>>

    /**
     * Group by SalaryPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryPaymentGroupByArgs['orderBy'] }
        : { orderBy?: SalaryPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryPayment model
   */
  readonly fields: SalaryPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Salary<T extends SalaryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalaryDefaultArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryPayment model
   */
  interface SalaryPaymentFieldRefs {
    readonly id: FieldRef<"SalaryPayment", 'Int'>
    readonly salaryId: FieldRef<"SalaryPayment", 'Int'>
    readonly amount: FieldRef<"SalaryPayment", 'Float'>
    readonly paymentDate: FieldRef<"SalaryPayment", 'DateTime'>
    readonly comment: FieldRef<"SalaryPayment", 'String'>
    readonly createdAt: FieldRef<"SalaryPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"SalaryPayment", 'DateTime'>
    readonly currency: FieldRef<"SalaryPayment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SalaryPayment findUnique
   */
  export type SalaryPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment findUniqueOrThrow
   */
  export type SalaryPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment findFirst
   */
  export type SalaryPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment findFirstOrThrow
   */
  export type SalaryPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment findMany
   */
  export type SalaryPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment create
   */
  export type SalaryPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryPayment.
     */
    data: XOR<SalaryPaymentCreateInput, SalaryPaymentUncheckedCreateInput>
  }

  /**
   * SalaryPayment createMany
   */
  export type SalaryPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentCreateManyInput | SalaryPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryPayment createManyAndReturn
   */
  export type SalaryPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentCreateManyInput | SalaryPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryPayment update
   */
  export type SalaryPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryPayment.
     */
    data: XOR<SalaryPaymentUpdateInput, SalaryPaymentUncheckedUpdateInput>
    /**
     * Choose, which SalaryPayment to update.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment updateMany
   */
  export type SalaryPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryPayments.
     */
    data: XOR<SalaryPaymentUpdateManyMutationInput, SalaryPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SalaryPayments to update
     */
    where?: SalaryPaymentWhereInput
    /**
     * Limit how many SalaryPayments to update.
     */
    limit?: number
  }

  /**
   * SalaryPayment updateManyAndReturn
   */
  export type SalaryPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * The data used to update SalaryPayments.
     */
    data: XOR<SalaryPaymentUpdateManyMutationInput, SalaryPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SalaryPayments to update
     */
    where?: SalaryPaymentWhereInput
    /**
     * Limit how many SalaryPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryPayment upsert
   */
  export type SalaryPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryPayment to update in case it exists.
     */
    where: SalaryPaymentWhereUniqueInput
    /**
     * In case the SalaryPayment found by the `where` argument doesn't exist, create a new SalaryPayment with this data.
     */
    create: XOR<SalaryPaymentCreateInput, SalaryPaymentUncheckedCreateInput>
    /**
     * In case the SalaryPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryPaymentUpdateInput, SalaryPaymentUncheckedUpdateInput>
  }

  /**
   * SalaryPayment delete
   */
  export type SalaryPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter which SalaryPayment to delete.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment deleteMany
   */
  export type SalaryPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayments to delete
     */
    where?: SalaryPaymentWhereInput
    /**
     * Limit how many SalaryPayments to delete.
     */
    limit?: number
  }

  /**
   * SalaryPayment without action
   */
  export type SalaryPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type SectionSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type SectionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    slug: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    slug: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    slug: number
    isActive: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectionAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type SectionSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type SectionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _avg?: SectionAvgAggregateInputType
    _sum?: SectionSumAggregateInputType
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    id: number
    name: string
    description: string | null
    slug: string
    isActive: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Table?: boolean | Section$TableArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["section"]>

  export type SectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["section"]>

  export type SectionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "slug" | "isActive" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["section"]>
  export type SectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Table?: boolean | Section$TableArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {
      Table: Prisma.$TablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      slug: string
      isActive: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionWithIdOnly = await prisma.section.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sections and returns the data saved in the database.
     * @param {SectionCreateManyAndReturnArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectionCreateManyAndReturnArgs>(args?: SelectSubset<T, SectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections and returns the data updated in the database.
     * @param {SectionUpdateManyAndReturnArgs} args - Arguments to update many Sections.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SectionUpdateManyAndReturnArgs>(args: SelectSubset<T, SectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Table<T extends Section$TableArgs<ExtArgs> = {}>(args?: Subset<T, Section$TableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */
  interface SectionFieldRefs {
    readonly id: FieldRef<"Section", 'Int'>
    readonly name: FieldRef<"Section", 'String'>
    readonly description: FieldRef<"Section", 'String'>
    readonly slug: FieldRef<"Section", 'String'>
    readonly isActive: FieldRef<"Section", 'Boolean'>
    readonly order: FieldRef<"Section", 'Int'>
    readonly createdAt: FieldRef<"Section", 'DateTime'>
    readonly updatedAt: FieldRef<"Section", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Section createManyAndReturn
   */
  export type SectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
  }

  /**
   * Section updateManyAndReturn
   */
  export type SectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to delete.
     */
    limit?: number
  }

  /**
   * Section.Table
   */
  export type Section$TableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
  }


  /**
   * Model ShiftReport
   */

  export type AggregateShiftReport = {
    _count: ShiftReportCountAggregateOutputType | null
    _avg: ShiftReportAvgAggregateOutputType | null
    _sum: ShiftReportSumAggregateOutputType | null
    _min: ShiftReportMinAggregateOutputType | null
    _max: ShiftReportMaxAggregateOutputType | null
  }

  export type ShiftReportAvgAggregateOutputType = {
    id: number | null
    startBalance: number | null
    endBalance: number | null
    employeeId: number | null
    usdtAmount: number | null
  }

  export type ShiftReportSumAggregateOutputType = {
    id: number | null
    startBalance: number | null
    endBalance: number | null
    employeeId: number | null
    usdtAmount: number | null
  }

  export type ShiftReportMinAggregateOutputType = {
    id: number | null
    date: Date | null
    time: string | null
    shift: string | null
    startBalance: number | null
    endBalance: number | null
    employeeId: number | null
    usdtAmount: number | null
    currency: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftReportMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    time: string | null
    shift: string | null
    startBalance: number | null
    endBalance: number | null
    employeeId: number | null
    usdtAmount: number | null
    currency: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftReportCountAggregateOutputType = {
    id: number
    date: number
    time: number
    shift: number
    startBalance: number
    endBalance: number
    employeeId: number
    usdtAmount: number
    currency: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftReportAvgAggregateInputType = {
    id?: true
    startBalance?: true
    endBalance?: true
    employeeId?: true
    usdtAmount?: true
  }

  export type ShiftReportSumAggregateInputType = {
    id?: true
    startBalance?: true
    endBalance?: true
    employeeId?: true
    usdtAmount?: true
  }

  export type ShiftReportMinAggregateInputType = {
    id?: true
    date?: true
    time?: true
    shift?: true
    startBalance?: true
    endBalance?: true
    employeeId?: true
    usdtAmount?: true
    currency?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftReportMaxAggregateInputType = {
    id?: true
    date?: true
    time?: true
    shift?: true
    startBalance?: true
    endBalance?: true
    employeeId?: true
    usdtAmount?: true
    currency?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftReportCountAggregateInputType = {
    id?: true
    date?: true
    time?: true
    shift?: true
    startBalance?: true
    endBalance?: true
    employeeId?: true
    usdtAmount?: true
    currency?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftReport to aggregate.
     */
    where?: ShiftReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftReports to fetch.
     */
    orderBy?: ShiftReportOrderByWithRelationInput | ShiftReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftReports
    **/
    _count?: true | ShiftReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftReportMaxAggregateInputType
  }

  export type GetShiftReportAggregateType<T extends ShiftReportAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftReport[P]>
      : GetScalarType<T[P], AggregateShiftReport[P]>
  }




  export type ShiftReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftReportWhereInput
    orderBy?: ShiftReportOrderByWithAggregationInput | ShiftReportOrderByWithAggregationInput[]
    by: ShiftReportScalarFieldEnum[] | ShiftReportScalarFieldEnum
    having?: ShiftReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftReportCountAggregateInputType | true
    _avg?: ShiftReportAvgAggregateInputType
    _sum?: ShiftReportSumAggregateInputType
    _min?: ShiftReportMinAggregateInputType
    _max?: ShiftReportMaxAggregateInputType
  }

  export type ShiftReportGroupByOutputType = {
    id: number
    date: Date
    time: string
    shift: string
    startBalance: number
    endBalance: number
    employeeId: number | null
    usdtAmount: number
    currency: string
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShiftReportCountAggregateOutputType | null
    _avg: ShiftReportAvgAggregateOutputType | null
    _sum: ShiftReportSumAggregateOutputType | null
    _min: ShiftReportMinAggregateOutputType | null
    _max: ShiftReportMaxAggregateOutputType | null
  }

  type GetShiftReportGroupByPayload<T extends ShiftReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftReportGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftReportGroupByOutputType[P]>
        }
      >
    >


  export type ShiftReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    shift?: boolean
    startBalance?: boolean
    endBalance?: boolean
    employeeId?: boolean
    usdtAmount?: boolean
    currency?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Salary?: boolean | ShiftReport$SalaryArgs<ExtArgs>
    ShiftReportExpense?: boolean | ShiftReport$ShiftReportExpenseArgs<ExtArgs>
    _count?: boolean | ShiftReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftReport"]>

  export type ShiftReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    shift?: boolean
    startBalance?: boolean
    endBalance?: boolean
    employeeId?: boolean
    usdtAmount?: boolean
    currency?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Salary?: boolean | ShiftReport$SalaryArgs<ExtArgs>
  }, ExtArgs["result"]["shiftReport"]>

  export type ShiftReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    shift?: boolean
    startBalance?: boolean
    endBalance?: boolean
    employeeId?: boolean
    usdtAmount?: boolean
    currency?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Salary?: boolean | ShiftReport$SalaryArgs<ExtArgs>
  }, ExtArgs["result"]["shiftReport"]>

  export type ShiftReportSelectScalar = {
    id?: boolean
    date?: boolean
    time?: boolean
    shift?: boolean
    startBalance?: boolean
    endBalance?: boolean
    employeeId?: boolean
    usdtAmount?: boolean
    currency?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "time" | "shift" | "startBalance" | "endBalance" | "employeeId" | "usdtAmount" | "currency" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["shiftReport"]>
  export type ShiftReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | ShiftReport$SalaryArgs<ExtArgs>
    ShiftReportExpense?: boolean | ShiftReport$ShiftReportExpenseArgs<ExtArgs>
    _count?: boolean | ShiftReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShiftReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | ShiftReport$SalaryArgs<ExtArgs>
  }
  export type ShiftReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Salary?: boolean | ShiftReport$SalaryArgs<ExtArgs>
  }

  export type $ShiftReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftReport"
    objects: {
      Salary: Prisma.$SalaryPayload<ExtArgs> | null
      ShiftReportExpense: Prisma.$ShiftReportExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      time: string
      shift: string
      startBalance: number
      endBalance: number
      employeeId: number | null
      usdtAmount: number
      currency: string
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shiftReport"]>
    composites: {}
  }

  type ShiftReportGetPayload<S extends boolean | null | undefined | ShiftReportDefaultArgs> = $Result.GetResult<Prisma.$ShiftReportPayload, S>

  type ShiftReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftReportCountAggregateInputType | true
    }

  export interface ShiftReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftReport'], meta: { name: 'ShiftReport' } }
    /**
     * Find zero or one ShiftReport that matches the filter.
     * @param {ShiftReportFindUniqueArgs} args - Arguments to find a ShiftReport
     * @example
     * // Get one ShiftReport
     * const shiftReport = await prisma.shiftReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftReportFindUniqueArgs>(args: SelectSubset<T, ShiftReportFindUniqueArgs<ExtArgs>>): Prisma__ShiftReportClient<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShiftReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftReportFindUniqueOrThrowArgs} args - Arguments to find a ShiftReport
     * @example
     * // Get one ShiftReport
     * const shiftReport = await prisma.shiftReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftReportClient<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportFindFirstArgs} args - Arguments to find a ShiftReport
     * @example
     * // Get one ShiftReport
     * const shiftReport = await prisma.shiftReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftReportFindFirstArgs>(args?: SelectSubset<T, ShiftReportFindFirstArgs<ExtArgs>>): Prisma__ShiftReportClient<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportFindFirstOrThrowArgs} args - Arguments to find a ShiftReport
     * @example
     * // Get one ShiftReport
     * const shiftReport = await prisma.shiftReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftReportClient<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShiftReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftReports
     * const shiftReports = await prisma.shiftReport.findMany()
     * 
     * // Get first 10 ShiftReports
     * const shiftReports = await prisma.shiftReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftReportWithIdOnly = await prisma.shiftReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftReportFindManyArgs>(args?: SelectSubset<T, ShiftReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShiftReport.
     * @param {ShiftReportCreateArgs} args - Arguments to create a ShiftReport.
     * @example
     * // Create one ShiftReport
     * const ShiftReport = await prisma.shiftReport.create({
     *   data: {
     *     // ... data to create a ShiftReport
     *   }
     * })
     * 
     */
    create<T extends ShiftReportCreateArgs>(args: SelectSubset<T, ShiftReportCreateArgs<ExtArgs>>): Prisma__ShiftReportClient<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShiftReports.
     * @param {ShiftReportCreateManyArgs} args - Arguments to create many ShiftReports.
     * @example
     * // Create many ShiftReports
     * const shiftReport = await prisma.shiftReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftReportCreateManyArgs>(args?: SelectSubset<T, ShiftReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShiftReports and returns the data saved in the database.
     * @param {ShiftReportCreateManyAndReturnArgs} args - Arguments to create many ShiftReports.
     * @example
     * // Create many ShiftReports
     * const shiftReport = await prisma.shiftReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShiftReports and only return the `id`
     * const shiftReportWithIdOnly = await prisma.shiftReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShiftReport.
     * @param {ShiftReportDeleteArgs} args - Arguments to delete one ShiftReport.
     * @example
     * // Delete one ShiftReport
     * const ShiftReport = await prisma.shiftReport.delete({
     *   where: {
     *     // ... filter to delete one ShiftReport
     *   }
     * })
     * 
     */
    delete<T extends ShiftReportDeleteArgs>(args: SelectSubset<T, ShiftReportDeleteArgs<ExtArgs>>): Prisma__ShiftReportClient<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShiftReport.
     * @param {ShiftReportUpdateArgs} args - Arguments to update one ShiftReport.
     * @example
     * // Update one ShiftReport
     * const shiftReport = await prisma.shiftReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftReportUpdateArgs>(args: SelectSubset<T, ShiftReportUpdateArgs<ExtArgs>>): Prisma__ShiftReportClient<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShiftReports.
     * @param {ShiftReportDeleteManyArgs} args - Arguments to filter ShiftReports to delete.
     * @example
     * // Delete a few ShiftReports
     * const { count } = await prisma.shiftReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftReportDeleteManyArgs>(args?: SelectSubset<T, ShiftReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftReports
     * const shiftReport = await prisma.shiftReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftReportUpdateManyArgs>(args: SelectSubset<T, ShiftReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftReports and returns the data updated in the database.
     * @param {ShiftReportUpdateManyAndReturnArgs} args - Arguments to update many ShiftReports.
     * @example
     * // Update many ShiftReports
     * const shiftReport = await prisma.shiftReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShiftReports and only return the `id`
     * const shiftReportWithIdOnly = await prisma.shiftReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShiftReport.
     * @param {ShiftReportUpsertArgs} args - Arguments to update or create a ShiftReport.
     * @example
     * // Update or create a ShiftReport
     * const shiftReport = await prisma.shiftReport.upsert({
     *   create: {
     *     // ... data to create a ShiftReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftReport we want to update
     *   }
     * })
     */
    upsert<T extends ShiftReportUpsertArgs>(args: SelectSubset<T, ShiftReportUpsertArgs<ExtArgs>>): Prisma__ShiftReportClient<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShiftReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportCountArgs} args - Arguments to filter ShiftReports to count.
     * @example
     * // Count the number of ShiftReports
     * const count = await prisma.shiftReport.count({
     *   where: {
     *     // ... the filter for the ShiftReports we want to count
     *   }
     * })
    **/
    count<T extends ShiftReportCountArgs>(
      args?: Subset<T, ShiftReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftReportAggregateArgs>(args: Subset<T, ShiftReportAggregateArgs>): Prisma.PrismaPromise<GetShiftReportAggregateType<T>>

    /**
     * Group by ShiftReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftReportGroupByArgs['orderBy'] }
        : { orderBy?: ShiftReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftReport model
   */
  readonly fields: ShiftReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Salary<T extends ShiftReport$SalaryArgs<ExtArgs> = {}>(args?: Subset<T, ShiftReport$SalaryArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ShiftReportExpense<T extends ShiftReport$ShiftReportExpenseArgs<ExtArgs> = {}>(args?: Subset<T, ShiftReport$ShiftReportExpenseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftReport model
   */
  interface ShiftReportFieldRefs {
    readonly id: FieldRef<"ShiftReport", 'Int'>
    readonly date: FieldRef<"ShiftReport", 'DateTime'>
    readonly time: FieldRef<"ShiftReport", 'String'>
    readonly shift: FieldRef<"ShiftReport", 'String'>
    readonly startBalance: FieldRef<"ShiftReport", 'Float'>
    readonly endBalance: FieldRef<"ShiftReport", 'Float'>
    readonly employeeId: FieldRef<"ShiftReport", 'Int'>
    readonly usdtAmount: FieldRef<"ShiftReport", 'Float'>
    readonly currency: FieldRef<"ShiftReport", 'String'>
    readonly comment: FieldRef<"ShiftReport", 'String'>
    readonly createdAt: FieldRef<"ShiftReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ShiftReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShiftReport findUnique
   */
  export type ShiftReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
    /**
     * Filter, which ShiftReport to fetch.
     */
    where: ShiftReportWhereUniqueInput
  }

  /**
   * ShiftReport findUniqueOrThrow
   */
  export type ShiftReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
    /**
     * Filter, which ShiftReport to fetch.
     */
    where: ShiftReportWhereUniqueInput
  }

  /**
   * ShiftReport findFirst
   */
  export type ShiftReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
    /**
     * Filter, which ShiftReport to fetch.
     */
    where?: ShiftReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftReports to fetch.
     */
    orderBy?: ShiftReportOrderByWithRelationInput | ShiftReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftReports.
     */
    cursor?: ShiftReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftReports.
     */
    distinct?: ShiftReportScalarFieldEnum | ShiftReportScalarFieldEnum[]
  }

  /**
   * ShiftReport findFirstOrThrow
   */
  export type ShiftReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
    /**
     * Filter, which ShiftReport to fetch.
     */
    where?: ShiftReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftReports to fetch.
     */
    orderBy?: ShiftReportOrderByWithRelationInput | ShiftReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftReports.
     */
    cursor?: ShiftReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftReports.
     */
    distinct?: ShiftReportScalarFieldEnum | ShiftReportScalarFieldEnum[]
  }

  /**
   * ShiftReport findMany
   */
  export type ShiftReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
    /**
     * Filter, which ShiftReports to fetch.
     */
    where?: ShiftReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftReports to fetch.
     */
    orderBy?: ShiftReportOrderByWithRelationInput | ShiftReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftReports.
     */
    cursor?: ShiftReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftReports.
     */
    skip?: number
    distinct?: ShiftReportScalarFieldEnum | ShiftReportScalarFieldEnum[]
  }

  /**
   * ShiftReport create
   */
  export type ShiftReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftReport.
     */
    data: XOR<ShiftReportCreateInput, ShiftReportUncheckedCreateInput>
  }

  /**
   * ShiftReport createMany
   */
  export type ShiftReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftReports.
     */
    data: ShiftReportCreateManyInput | ShiftReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShiftReport createManyAndReturn
   */
  export type ShiftReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * The data used to create many ShiftReports.
     */
    data: ShiftReportCreateManyInput | ShiftReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftReport update
   */
  export type ShiftReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftReport.
     */
    data: XOR<ShiftReportUpdateInput, ShiftReportUncheckedUpdateInput>
    /**
     * Choose, which ShiftReport to update.
     */
    where: ShiftReportWhereUniqueInput
  }

  /**
   * ShiftReport updateMany
   */
  export type ShiftReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftReports.
     */
    data: XOR<ShiftReportUpdateManyMutationInput, ShiftReportUncheckedUpdateManyInput>
    /**
     * Filter which ShiftReports to update
     */
    where?: ShiftReportWhereInput
    /**
     * Limit how many ShiftReports to update.
     */
    limit?: number
  }

  /**
   * ShiftReport updateManyAndReturn
   */
  export type ShiftReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * The data used to update ShiftReports.
     */
    data: XOR<ShiftReportUpdateManyMutationInput, ShiftReportUncheckedUpdateManyInput>
    /**
     * Filter which ShiftReports to update
     */
    where?: ShiftReportWhereInput
    /**
     * Limit how many ShiftReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftReport upsert
   */
  export type ShiftReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftReport to update in case it exists.
     */
    where: ShiftReportWhereUniqueInput
    /**
     * In case the ShiftReport found by the `where` argument doesn't exist, create a new ShiftReport with this data.
     */
    create: XOR<ShiftReportCreateInput, ShiftReportUncheckedCreateInput>
    /**
     * In case the ShiftReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftReportUpdateInput, ShiftReportUncheckedUpdateInput>
  }

  /**
   * ShiftReport delete
   */
  export type ShiftReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
    /**
     * Filter which ShiftReport to delete.
     */
    where: ShiftReportWhereUniqueInput
  }

  /**
   * ShiftReport deleteMany
   */
  export type ShiftReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftReports to delete
     */
    where?: ShiftReportWhereInput
    /**
     * Limit how many ShiftReports to delete.
     */
    limit?: number
  }

  /**
   * ShiftReport.Salary
   */
  export type ShiftReport$SalaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    where?: SalaryWhereInput
  }

  /**
   * ShiftReport.ShiftReportExpense
   */
  export type ShiftReport$ShiftReportExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseInclude<ExtArgs> | null
    where?: ShiftReportExpenseWhereInput
    orderBy?: ShiftReportExpenseOrderByWithRelationInput | ShiftReportExpenseOrderByWithRelationInput[]
    cursor?: ShiftReportExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftReportExpenseScalarFieldEnum | ShiftReportExpenseScalarFieldEnum[]
  }

  /**
   * ShiftReport without action
   */
  export type ShiftReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
  }


  /**
   * Model ShiftReportExpense
   */

  export type AggregateShiftReportExpense = {
    _count: ShiftReportExpenseCountAggregateOutputType | null
    _avg: ShiftReportExpenseAvgAggregateOutputType | null
    _sum: ShiftReportExpenseSumAggregateOutputType | null
    _min: ShiftReportExpenseMinAggregateOutputType | null
    _max: ShiftReportExpenseMaxAggregateOutputType | null
  }

  export type ShiftReportExpenseAvgAggregateOutputType = {
    id: number | null
    shiftReportId: number | null
    amount: number | null
  }

  export type ShiftReportExpenseSumAggregateOutputType = {
    id: number | null
    shiftReportId: number | null
    amount: number | null
  }

  export type ShiftReportExpenseMinAggregateOutputType = {
    id: number | null
    shiftReportId: number | null
    expenseType: string | null
    amount: number | null
    currency: string | null
    date: Date | null
    time: string | null
    period: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftReportExpenseMaxAggregateOutputType = {
    id: number | null
    shiftReportId: number | null
    expenseType: string | null
    amount: number | null
    currency: string | null
    date: Date | null
    time: string | null
    period: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftReportExpenseCountAggregateOutputType = {
    id: number
    shiftReportId: number
    expenseType: number
    amount: number
    currency: number
    date: number
    time: number
    period: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftReportExpenseAvgAggregateInputType = {
    id?: true
    shiftReportId?: true
    amount?: true
  }

  export type ShiftReportExpenseSumAggregateInputType = {
    id?: true
    shiftReportId?: true
    amount?: true
  }

  export type ShiftReportExpenseMinAggregateInputType = {
    id?: true
    shiftReportId?: true
    expenseType?: true
    amount?: true
    currency?: true
    date?: true
    time?: true
    period?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftReportExpenseMaxAggregateInputType = {
    id?: true
    shiftReportId?: true
    expenseType?: true
    amount?: true
    currency?: true
    date?: true
    time?: true
    period?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftReportExpenseCountAggregateInputType = {
    id?: true
    shiftReportId?: true
    expenseType?: true
    amount?: true
    currency?: true
    date?: true
    time?: true
    period?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftReportExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftReportExpense to aggregate.
     */
    where?: ShiftReportExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftReportExpenses to fetch.
     */
    orderBy?: ShiftReportExpenseOrderByWithRelationInput | ShiftReportExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftReportExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftReportExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftReportExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftReportExpenses
    **/
    _count?: true | ShiftReportExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftReportExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftReportExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftReportExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftReportExpenseMaxAggregateInputType
  }

  export type GetShiftReportExpenseAggregateType<T extends ShiftReportExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftReportExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftReportExpense[P]>
      : GetScalarType<T[P], AggregateShiftReportExpense[P]>
  }




  export type ShiftReportExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftReportExpenseWhereInput
    orderBy?: ShiftReportExpenseOrderByWithAggregationInput | ShiftReportExpenseOrderByWithAggregationInput[]
    by: ShiftReportExpenseScalarFieldEnum[] | ShiftReportExpenseScalarFieldEnum
    having?: ShiftReportExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftReportExpenseCountAggregateInputType | true
    _avg?: ShiftReportExpenseAvgAggregateInputType
    _sum?: ShiftReportExpenseSumAggregateInputType
    _min?: ShiftReportExpenseMinAggregateInputType
    _max?: ShiftReportExpenseMaxAggregateInputType
  }

  export type ShiftReportExpenseGroupByOutputType = {
    id: number
    shiftReportId: number | null
    expenseType: string
    amount: number
    currency: string
    date: Date
    time: string
    period: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShiftReportExpenseCountAggregateOutputType | null
    _avg: ShiftReportExpenseAvgAggregateOutputType | null
    _sum: ShiftReportExpenseSumAggregateOutputType | null
    _min: ShiftReportExpenseMinAggregateOutputType | null
    _max: ShiftReportExpenseMaxAggregateOutputType | null
  }

  type GetShiftReportExpenseGroupByPayload<T extends ShiftReportExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftReportExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftReportExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftReportExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftReportExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ShiftReportExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shiftReportId?: boolean
    expenseType?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    time?: boolean
    period?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ShiftReport?: boolean | ShiftReportExpense$ShiftReportArgs<ExtArgs>
  }, ExtArgs["result"]["shiftReportExpense"]>

  export type ShiftReportExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shiftReportId?: boolean
    expenseType?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    time?: boolean
    period?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ShiftReport?: boolean | ShiftReportExpense$ShiftReportArgs<ExtArgs>
  }, ExtArgs["result"]["shiftReportExpense"]>

  export type ShiftReportExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shiftReportId?: boolean
    expenseType?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    time?: boolean
    period?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ShiftReport?: boolean | ShiftReportExpense$ShiftReportArgs<ExtArgs>
  }, ExtArgs["result"]["shiftReportExpense"]>

  export type ShiftReportExpenseSelectScalar = {
    id?: boolean
    shiftReportId?: boolean
    expenseType?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    time?: boolean
    period?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftReportExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shiftReportId" | "expenseType" | "amount" | "currency" | "date" | "time" | "period" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["shiftReportExpense"]>
  export type ShiftReportExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShiftReport?: boolean | ShiftReportExpense$ShiftReportArgs<ExtArgs>
  }
  export type ShiftReportExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShiftReport?: boolean | ShiftReportExpense$ShiftReportArgs<ExtArgs>
  }
  export type ShiftReportExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShiftReport?: boolean | ShiftReportExpense$ShiftReportArgs<ExtArgs>
  }

  export type $ShiftReportExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftReportExpense"
    objects: {
      ShiftReport: Prisma.$ShiftReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shiftReportId: number | null
      expenseType: string
      amount: number
      currency: string
      date: Date
      time: string
      period: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shiftReportExpense"]>
    composites: {}
  }

  type ShiftReportExpenseGetPayload<S extends boolean | null | undefined | ShiftReportExpenseDefaultArgs> = $Result.GetResult<Prisma.$ShiftReportExpensePayload, S>

  type ShiftReportExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftReportExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftReportExpenseCountAggregateInputType | true
    }

  export interface ShiftReportExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftReportExpense'], meta: { name: 'ShiftReportExpense' } }
    /**
     * Find zero or one ShiftReportExpense that matches the filter.
     * @param {ShiftReportExpenseFindUniqueArgs} args - Arguments to find a ShiftReportExpense
     * @example
     * // Get one ShiftReportExpense
     * const shiftReportExpense = await prisma.shiftReportExpense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftReportExpenseFindUniqueArgs>(args: SelectSubset<T, ShiftReportExpenseFindUniqueArgs<ExtArgs>>): Prisma__ShiftReportExpenseClient<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShiftReportExpense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftReportExpenseFindUniqueOrThrowArgs} args - Arguments to find a ShiftReportExpense
     * @example
     * // Get one ShiftReportExpense
     * const shiftReportExpense = await prisma.shiftReportExpense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftReportExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftReportExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftReportExpenseClient<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftReportExpense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportExpenseFindFirstArgs} args - Arguments to find a ShiftReportExpense
     * @example
     * // Get one ShiftReportExpense
     * const shiftReportExpense = await prisma.shiftReportExpense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftReportExpenseFindFirstArgs>(args?: SelectSubset<T, ShiftReportExpenseFindFirstArgs<ExtArgs>>): Prisma__ShiftReportExpenseClient<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftReportExpense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportExpenseFindFirstOrThrowArgs} args - Arguments to find a ShiftReportExpense
     * @example
     * // Get one ShiftReportExpense
     * const shiftReportExpense = await prisma.shiftReportExpense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftReportExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftReportExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftReportExpenseClient<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShiftReportExpenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftReportExpenses
     * const shiftReportExpenses = await prisma.shiftReportExpense.findMany()
     * 
     * // Get first 10 ShiftReportExpenses
     * const shiftReportExpenses = await prisma.shiftReportExpense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftReportExpenseWithIdOnly = await prisma.shiftReportExpense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftReportExpenseFindManyArgs>(args?: SelectSubset<T, ShiftReportExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShiftReportExpense.
     * @param {ShiftReportExpenseCreateArgs} args - Arguments to create a ShiftReportExpense.
     * @example
     * // Create one ShiftReportExpense
     * const ShiftReportExpense = await prisma.shiftReportExpense.create({
     *   data: {
     *     // ... data to create a ShiftReportExpense
     *   }
     * })
     * 
     */
    create<T extends ShiftReportExpenseCreateArgs>(args: SelectSubset<T, ShiftReportExpenseCreateArgs<ExtArgs>>): Prisma__ShiftReportExpenseClient<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShiftReportExpenses.
     * @param {ShiftReportExpenseCreateManyArgs} args - Arguments to create many ShiftReportExpenses.
     * @example
     * // Create many ShiftReportExpenses
     * const shiftReportExpense = await prisma.shiftReportExpense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftReportExpenseCreateManyArgs>(args?: SelectSubset<T, ShiftReportExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShiftReportExpenses and returns the data saved in the database.
     * @param {ShiftReportExpenseCreateManyAndReturnArgs} args - Arguments to create many ShiftReportExpenses.
     * @example
     * // Create many ShiftReportExpenses
     * const shiftReportExpense = await prisma.shiftReportExpense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShiftReportExpenses and only return the `id`
     * const shiftReportExpenseWithIdOnly = await prisma.shiftReportExpense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftReportExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftReportExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShiftReportExpense.
     * @param {ShiftReportExpenseDeleteArgs} args - Arguments to delete one ShiftReportExpense.
     * @example
     * // Delete one ShiftReportExpense
     * const ShiftReportExpense = await prisma.shiftReportExpense.delete({
     *   where: {
     *     // ... filter to delete one ShiftReportExpense
     *   }
     * })
     * 
     */
    delete<T extends ShiftReportExpenseDeleteArgs>(args: SelectSubset<T, ShiftReportExpenseDeleteArgs<ExtArgs>>): Prisma__ShiftReportExpenseClient<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShiftReportExpense.
     * @param {ShiftReportExpenseUpdateArgs} args - Arguments to update one ShiftReportExpense.
     * @example
     * // Update one ShiftReportExpense
     * const shiftReportExpense = await prisma.shiftReportExpense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftReportExpenseUpdateArgs>(args: SelectSubset<T, ShiftReportExpenseUpdateArgs<ExtArgs>>): Prisma__ShiftReportExpenseClient<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShiftReportExpenses.
     * @param {ShiftReportExpenseDeleteManyArgs} args - Arguments to filter ShiftReportExpenses to delete.
     * @example
     * // Delete a few ShiftReportExpenses
     * const { count } = await prisma.shiftReportExpense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftReportExpenseDeleteManyArgs>(args?: SelectSubset<T, ShiftReportExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftReportExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftReportExpenses
     * const shiftReportExpense = await prisma.shiftReportExpense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftReportExpenseUpdateManyArgs>(args: SelectSubset<T, ShiftReportExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftReportExpenses and returns the data updated in the database.
     * @param {ShiftReportExpenseUpdateManyAndReturnArgs} args - Arguments to update many ShiftReportExpenses.
     * @example
     * // Update many ShiftReportExpenses
     * const shiftReportExpense = await prisma.shiftReportExpense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShiftReportExpenses and only return the `id`
     * const shiftReportExpenseWithIdOnly = await prisma.shiftReportExpense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftReportExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftReportExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShiftReportExpense.
     * @param {ShiftReportExpenseUpsertArgs} args - Arguments to update or create a ShiftReportExpense.
     * @example
     * // Update or create a ShiftReportExpense
     * const shiftReportExpense = await prisma.shiftReportExpense.upsert({
     *   create: {
     *     // ... data to create a ShiftReportExpense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftReportExpense we want to update
     *   }
     * })
     */
    upsert<T extends ShiftReportExpenseUpsertArgs>(args: SelectSubset<T, ShiftReportExpenseUpsertArgs<ExtArgs>>): Prisma__ShiftReportExpenseClient<$Result.GetResult<Prisma.$ShiftReportExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShiftReportExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportExpenseCountArgs} args - Arguments to filter ShiftReportExpenses to count.
     * @example
     * // Count the number of ShiftReportExpenses
     * const count = await prisma.shiftReportExpense.count({
     *   where: {
     *     // ... the filter for the ShiftReportExpenses we want to count
     *   }
     * })
    **/
    count<T extends ShiftReportExpenseCountArgs>(
      args?: Subset<T, ShiftReportExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftReportExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftReportExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftReportExpenseAggregateArgs>(args: Subset<T, ShiftReportExpenseAggregateArgs>): Prisma.PrismaPromise<GetShiftReportExpenseAggregateType<T>>

    /**
     * Group by ShiftReportExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftReportExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftReportExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftReportExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ShiftReportExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftReportExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftReportExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftReportExpense model
   */
  readonly fields: ShiftReportExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftReportExpense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftReportExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ShiftReport<T extends ShiftReportExpense$ShiftReportArgs<ExtArgs> = {}>(args?: Subset<T, ShiftReportExpense$ShiftReportArgs<ExtArgs>>): Prisma__ShiftReportClient<$Result.GetResult<Prisma.$ShiftReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftReportExpense model
   */
  interface ShiftReportExpenseFieldRefs {
    readonly id: FieldRef<"ShiftReportExpense", 'Int'>
    readonly shiftReportId: FieldRef<"ShiftReportExpense", 'Int'>
    readonly expenseType: FieldRef<"ShiftReportExpense", 'String'>
    readonly amount: FieldRef<"ShiftReportExpense", 'Float'>
    readonly currency: FieldRef<"ShiftReportExpense", 'String'>
    readonly date: FieldRef<"ShiftReportExpense", 'DateTime'>
    readonly time: FieldRef<"ShiftReportExpense", 'String'>
    readonly period: FieldRef<"ShiftReportExpense", 'String'>
    readonly description: FieldRef<"ShiftReportExpense", 'String'>
    readonly createdAt: FieldRef<"ShiftReportExpense", 'DateTime'>
    readonly updatedAt: FieldRef<"ShiftReportExpense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShiftReportExpense findUnique
   */
  export type ShiftReportExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseInclude<ExtArgs> | null
    /**
     * Filter, which ShiftReportExpense to fetch.
     */
    where: ShiftReportExpenseWhereUniqueInput
  }

  /**
   * ShiftReportExpense findUniqueOrThrow
   */
  export type ShiftReportExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseInclude<ExtArgs> | null
    /**
     * Filter, which ShiftReportExpense to fetch.
     */
    where: ShiftReportExpenseWhereUniqueInput
  }

  /**
   * ShiftReportExpense findFirst
   */
  export type ShiftReportExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseInclude<ExtArgs> | null
    /**
     * Filter, which ShiftReportExpense to fetch.
     */
    where?: ShiftReportExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftReportExpenses to fetch.
     */
    orderBy?: ShiftReportExpenseOrderByWithRelationInput | ShiftReportExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftReportExpenses.
     */
    cursor?: ShiftReportExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftReportExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftReportExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftReportExpenses.
     */
    distinct?: ShiftReportExpenseScalarFieldEnum | ShiftReportExpenseScalarFieldEnum[]
  }

  /**
   * ShiftReportExpense findFirstOrThrow
   */
  export type ShiftReportExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseInclude<ExtArgs> | null
    /**
     * Filter, which ShiftReportExpense to fetch.
     */
    where?: ShiftReportExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftReportExpenses to fetch.
     */
    orderBy?: ShiftReportExpenseOrderByWithRelationInput | ShiftReportExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftReportExpenses.
     */
    cursor?: ShiftReportExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftReportExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftReportExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftReportExpenses.
     */
    distinct?: ShiftReportExpenseScalarFieldEnum | ShiftReportExpenseScalarFieldEnum[]
  }

  /**
   * ShiftReportExpense findMany
   */
  export type ShiftReportExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseInclude<ExtArgs> | null
    /**
     * Filter, which ShiftReportExpenses to fetch.
     */
    where?: ShiftReportExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftReportExpenses to fetch.
     */
    orderBy?: ShiftReportExpenseOrderByWithRelationInput | ShiftReportExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftReportExpenses.
     */
    cursor?: ShiftReportExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftReportExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftReportExpenses.
     */
    skip?: number
    distinct?: ShiftReportExpenseScalarFieldEnum | ShiftReportExpenseScalarFieldEnum[]
  }

  /**
   * ShiftReportExpense create
   */
  export type ShiftReportExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftReportExpense.
     */
    data: XOR<ShiftReportExpenseCreateInput, ShiftReportExpenseUncheckedCreateInput>
  }

  /**
   * ShiftReportExpense createMany
   */
  export type ShiftReportExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftReportExpenses.
     */
    data: ShiftReportExpenseCreateManyInput | ShiftReportExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShiftReportExpense createManyAndReturn
   */
  export type ShiftReportExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many ShiftReportExpenses.
     */
    data: ShiftReportExpenseCreateManyInput | ShiftReportExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftReportExpense update
   */
  export type ShiftReportExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftReportExpense.
     */
    data: XOR<ShiftReportExpenseUpdateInput, ShiftReportExpenseUncheckedUpdateInput>
    /**
     * Choose, which ShiftReportExpense to update.
     */
    where: ShiftReportExpenseWhereUniqueInput
  }

  /**
   * ShiftReportExpense updateMany
   */
  export type ShiftReportExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftReportExpenses.
     */
    data: XOR<ShiftReportExpenseUpdateManyMutationInput, ShiftReportExpenseUncheckedUpdateManyInput>
    /**
     * Filter which ShiftReportExpenses to update
     */
    where?: ShiftReportExpenseWhereInput
    /**
     * Limit how many ShiftReportExpenses to update.
     */
    limit?: number
  }

  /**
   * ShiftReportExpense updateManyAndReturn
   */
  export type ShiftReportExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * The data used to update ShiftReportExpenses.
     */
    data: XOR<ShiftReportExpenseUpdateManyMutationInput, ShiftReportExpenseUncheckedUpdateManyInput>
    /**
     * Filter which ShiftReportExpenses to update
     */
    where?: ShiftReportExpenseWhereInput
    /**
     * Limit how many ShiftReportExpenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftReportExpense upsert
   */
  export type ShiftReportExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftReportExpense to update in case it exists.
     */
    where: ShiftReportExpenseWhereUniqueInput
    /**
     * In case the ShiftReportExpense found by the `where` argument doesn't exist, create a new ShiftReportExpense with this data.
     */
    create: XOR<ShiftReportExpenseCreateInput, ShiftReportExpenseUncheckedCreateInput>
    /**
     * In case the ShiftReportExpense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftReportExpenseUpdateInput, ShiftReportExpenseUncheckedUpdateInput>
  }

  /**
   * ShiftReportExpense delete
   */
  export type ShiftReportExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseInclude<ExtArgs> | null
    /**
     * Filter which ShiftReportExpense to delete.
     */
    where: ShiftReportExpenseWhereUniqueInput
  }

  /**
   * ShiftReportExpense deleteMany
   */
  export type ShiftReportExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftReportExpenses to delete
     */
    where?: ShiftReportExpenseWhereInput
    /**
     * Limit how many ShiftReportExpenses to delete.
     */
    limit?: number
  }

  /**
   * ShiftReportExpense.ShiftReport
   */
  export type ShiftReportExpense$ShiftReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReport
     */
    select?: ShiftReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReport
     */
    omit?: ShiftReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportInclude<ExtArgs> | null
    where?: ShiftReportWhereInput
  }

  /**
   * ShiftReportExpense without action
   */
  export type ShiftReportExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftReportExpense
     */
    select?: ShiftReportExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftReportExpense
     */
    omit?: ShiftReportExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftReportExpenseInclude<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsAvgAggregateOutputType = {
    id: number | null
    reportReminderInterval: number | null
    reportWaitTime: number | null
  }

  export type SystemSettingsSumAggregateOutputType = {
    id: number | null
    reportReminderInterval: number | null
    reportWaitTime: number | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: number | null
    reportReminderInterval: number | null
    reportWaitTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: number | null
    reportReminderInterval: number | null
    reportWaitTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    reportReminderInterval: number
    reportWaitTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingsAvgAggregateInputType = {
    id?: true
    reportReminderInterval?: true
    reportWaitTime?: true
  }

  export type SystemSettingsSumAggregateInputType = {
    id?: true
    reportReminderInterval?: true
    reportWaitTime?: true
  }

  export type SystemSettingsMinAggregateInputType = {
    id?: true
    reportReminderInterval?: true
    reportWaitTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    reportReminderInterval?: true
    reportWaitTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    reportReminderInterval?: true
    reportWaitTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _avg?: SystemSettingsAvgAggregateInputType
    _sum?: SystemSettingsSumAggregateInputType
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: number
    reportReminderInterval: number
    reportWaitTime: number
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportReminderInterval?: boolean
    reportWaitTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportReminderInterval?: boolean
    reportWaitTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportReminderInterval?: boolean
    reportWaitTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectScalar = {
    id?: boolean
    reportReminderInterval?: boolean
    reportWaitTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportReminderInterval" | "reportWaitTime" | "createdAt" | "updatedAt", ExtArgs["result"]["systemSettings"]>

  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reportReminderInterval: number
      reportWaitTime: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingsCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingsUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'Int'>
    readonly reportReminderInterval: FieldRef<"SystemSettings", 'Int'>
    readonly reportWaitTime: FieldRef<"SystemSettings", 'Int'>
    readonly createdAt: FieldRef<"SystemSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings createManyAndReturn
   */
  export type SystemSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings updateManyAndReturn
   */
  export type SystemSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
  }


  /**
   * Model Table
   */

  export type AggregateTable = {
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  export type TableAvgAggregateOutputType = {
    id: number | null
    sectionId: number | null
    pageSize: number | null
    order: number | null
  }

  export type TableSumAggregateOutputType = {
    id: number | null
    sectionId: number | null
    pageSize: number | null
    order: number | null
  }

  export type TableMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    sectionId: number | null
    isSearchable: boolean | null
    hasPagination: boolean | null
    pageSize: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    sectionId: number | null
    isSearchable: boolean | null
    hasPagination: boolean | null
    pageSize: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableCountAggregateOutputType = {
    id: number
    name: number
    description: number
    sectionId: number
    isSearchable: number
    hasPagination: number
    pageSize: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TableAvgAggregateInputType = {
    id?: true
    sectionId?: true
    pageSize?: true
    order?: true
  }

  export type TableSumAggregateInputType = {
    id?: true
    sectionId?: true
    pageSize?: true
    order?: true
  }

  export type TableMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sectionId?: true
    isSearchable?: true
    hasPagination?: true
    pageSize?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sectionId?: true
    isSearchable?: true
    hasPagination?: true
    pageSize?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sectionId?: true
    isSearchable?: true
    hasPagination?: true
    pageSize?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Table to aggregate.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tables
    **/
    _count?: true | TableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableMaxAggregateInputType
  }

  export type GetTableAggregateType<T extends TableAggregateArgs> = {
        [P in keyof T & keyof AggregateTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable[P]>
      : GetScalarType<T[P], AggregateTable[P]>
  }




  export type TableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
    orderBy?: TableOrderByWithAggregationInput | TableOrderByWithAggregationInput[]
    by: TableScalarFieldEnum[] | TableScalarFieldEnum
    having?: TableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableCountAggregateInputType | true
    _avg?: TableAvgAggregateInputType
    _sum?: TableSumAggregateInputType
    _min?: TableMinAggregateInputType
    _max?: TableMaxAggregateInputType
  }

  export type TableGroupByOutputType = {
    id: number
    name: string
    description: string | null
    sectionId: number
    isSearchable: boolean
    hasPagination: boolean
    pageSize: number
    order: number
    createdAt: Date
    updatedAt: Date
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  type GetTableGroupByPayload<T extends TableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableGroupByOutputType[P]>
            : GetScalarType<T[P], TableGroupByOutputType[P]>
        }
      >
    >


  export type TableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    sectionId?: boolean
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Column?: boolean | Table$ColumnArgs<ExtArgs>
    Filter?: boolean | Table$FilterArgs<ExtArgs>
    Row?: boolean | Table$RowArgs<ExtArgs>
    Section?: boolean | SectionDefaultArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    sectionId?: boolean
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    sectionId?: boolean
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    sectionId?: boolean
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "sectionId" | "isSearchable" | "hasPagination" | "pageSize" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["table"]>
  export type TableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Column?: boolean | Table$ColumnArgs<ExtArgs>
    Filter?: boolean | Table$FilterArgs<ExtArgs>
    Row?: boolean | Table$RowArgs<ExtArgs>
    Section?: boolean | SectionDefaultArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Section?: boolean | SectionDefaultArgs<ExtArgs>
  }
  export type TableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $TablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Table"
    objects: {
      Column: Prisma.$ColumnPayload<ExtArgs>[]
      Filter: Prisma.$FilterPayload<ExtArgs>[]
      Row: Prisma.$RowPayload<ExtArgs>[]
      Section: Prisma.$SectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      sectionId: number
      isSearchable: boolean
      hasPagination: boolean
      pageSize: number
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["table"]>
    composites: {}
  }

  type TableGetPayload<S extends boolean | null | undefined | TableDefaultArgs> = $Result.GetResult<Prisma.$TablePayload, S>

  type TableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TableCountAggregateInputType | true
    }

  export interface TableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Table'], meta: { name: 'Table' } }
    /**
     * Find zero or one Table that matches the filter.
     * @param {TableFindUniqueArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableFindUniqueArgs>(args: SelectSubset<T, TableFindUniqueArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Table that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TableFindUniqueOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableFindUniqueOrThrowArgs>(args: SelectSubset<T, TableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableFindFirstArgs>(args?: SelectSubset<T, TableFindFirstArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableFindFirstOrThrowArgs>(args?: SelectSubset<T, TableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.table.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.table.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableWithIdOnly = await prisma.table.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TableFindManyArgs>(args?: SelectSubset<T, TableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Table.
     * @param {TableCreateArgs} args - Arguments to create a Table.
     * @example
     * // Create one Table
     * const Table = await prisma.table.create({
     *   data: {
     *     // ... data to create a Table
     *   }
     * })
     * 
     */
    create<T extends TableCreateArgs>(args: SelectSubset<T, TableCreateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tables.
     * @param {TableCreateManyArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableCreateManyArgs>(args?: SelectSubset<T, TableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tables and returns the data saved in the database.
     * @param {TableCreateManyAndReturnArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tables and only return the `id`
     * const tableWithIdOnly = await prisma.table.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TableCreateManyAndReturnArgs>(args?: SelectSubset<T, TableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Table.
     * @param {TableDeleteArgs} args - Arguments to delete one Table.
     * @example
     * // Delete one Table
     * const Table = await prisma.table.delete({
     *   where: {
     *     // ... filter to delete one Table
     *   }
     * })
     * 
     */
    delete<T extends TableDeleteArgs>(args: SelectSubset<T, TableDeleteArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Table.
     * @param {TableUpdateArgs} args - Arguments to update one Table.
     * @example
     * // Update one Table
     * const table = await prisma.table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableUpdateArgs>(args: SelectSubset<T, TableUpdateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tables.
     * @param {TableDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableDeleteManyArgs>(args?: SelectSubset<T, TableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableUpdateManyArgs>(args: SelectSubset<T, TableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables and returns the data updated in the database.
     * @param {TableUpdateManyAndReturnArgs} args - Arguments to update many Tables.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tables and only return the `id`
     * const tableWithIdOnly = await prisma.table.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TableUpdateManyAndReturnArgs>(args: SelectSubset<T, TableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Table.
     * @param {TableUpsertArgs} args - Arguments to update or create a Table.
     * @example
     * // Update or create a Table
     * const table = await prisma.table.upsert({
     *   create: {
     *     // ... data to create a Table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table we want to update
     *   }
     * })
     */
    upsert<T extends TableUpsertArgs>(args: SelectSubset<T, TableUpsertArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableCountArgs} args - Arguments to filter Tables to count.
     * @example
     * // Count the number of Tables
     * const count = await prisma.table.count({
     *   where: {
     *     // ... the filter for the Tables we want to count
     *   }
     * })
    **/
    count<T extends TableCountArgs>(
      args?: Subset<T, TableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableAggregateArgs>(args: Subset<T, TableAggregateArgs>): Prisma.PrismaPromise<GetTableAggregateType<T>>

    /**
     * Group by Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableGroupByArgs['orderBy'] }
        : { orderBy?: TableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Table model
   */
  readonly fields: TableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Column<T extends Table$ColumnArgs<ExtArgs> = {}>(args?: Subset<T, Table$ColumnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Filter<T extends Table$FilterArgs<ExtArgs> = {}>(args?: Subset<T, Table$FilterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Row<T extends Table$RowArgs<ExtArgs> = {}>(args?: Subset<T, Table$RowArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Table model
   */
  interface TableFieldRefs {
    readonly id: FieldRef<"Table", 'Int'>
    readonly name: FieldRef<"Table", 'String'>
    readonly description: FieldRef<"Table", 'String'>
    readonly sectionId: FieldRef<"Table", 'Int'>
    readonly isSearchable: FieldRef<"Table", 'Boolean'>
    readonly hasPagination: FieldRef<"Table", 'Boolean'>
    readonly pageSize: FieldRef<"Table", 'Int'>
    readonly order: FieldRef<"Table", 'Int'>
    readonly createdAt: FieldRef<"Table", 'DateTime'>
    readonly updatedAt: FieldRef<"Table", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Table findUnique
   */
  export type TableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findUniqueOrThrow
   */
  export type TableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findFirst
   */
  export type TableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findFirstOrThrow
   */
  export type TableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findMany
   */
  export type TableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Tables to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table create
   */
  export type TableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to create a Table.
     */
    data: XOR<TableCreateInput, TableUncheckedCreateInput>
  }

  /**
   * Table createMany
   */
  export type TableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Table createManyAndReturn
   */
  export type TableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Table update
   */
  export type TableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to update a Table.
     */
    data: XOR<TableUpdateInput, TableUncheckedUpdateInput>
    /**
     * Choose, which Table to update.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table updateMany
   */
  export type TableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tables.
     */
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    /**
     * Filter which Tables to update
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to update.
     */
    limit?: number
  }

  /**
   * Table updateManyAndReturn
   */
  export type TableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * The data used to update Tables.
     */
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    /**
     * Filter which Tables to update
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Table upsert
   */
  export type TableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The filter to search for the Table to update in case it exists.
     */
    where: TableWhereUniqueInput
    /**
     * In case the Table found by the `where` argument doesn't exist, create a new Table with this data.
     */
    create: XOR<TableCreateInput, TableUncheckedCreateInput>
    /**
     * In case the Table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableUpdateInput, TableUncheckedUpdateInput>
  }

  /**
   * Table delete
   */
  export type TableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter which Table to delete.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table deleteMany
   */
  export type TableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tables to delete
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to delete.
     */
    limit?: number
  }

  /**
   * Table.Column
   */
  export type Table$ColumnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    where?: ColumnWhereInput
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    cursor?: ColumnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Table.Filter
   */
  export type Table$FilterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filter
     */
    omit?: FilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    where?: FilterWhereInput
    orderBy?: FilterOrderByWithRelationInput | FilterOrderByWithRelationInput[]
    cursor?: FilterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilterScalarFieldEnum | FilterScalarFieldEnum[]
  }

  /**
   * Table.Row
   */
  export type Table$RowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    where?: RowWhereInput
    orderBy?: RowOrderByWithRelationInput | RowOrderByWithRelationInput[]
    cursor?: RowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RowScalarFieldEnum | RowScalarFieldEnum[]
  }

  /**
   * Table without action
   */
  export type TableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
  }


  /**
   * Model TelegramAccount
   */

  export type AggregateTelegramAccount = {
    _count: TelegramAccountCountAggregateOutputType | null
    _avg: TelegramAccountAvgAggregateOutputType | null
    _sum: TelegramAccountSumAggregateOutputType | null
    _min: TelegramAccountMinAggregateOutputType | null
    _max: TelegramAccountMaxAggregateOutputType | null
  }

  export type TelegramAccountAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TelegramAccountSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TelegramAccountMinAggregateOutputType = {
    id: number | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramAccountMaxAggregateOutputType = {
    id: number | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramAccountCountAggregateOutputType = {
    id: number
    telegramId: number
    username: number
    firstName: number
    lastName: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TelegramAccountAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TelegramAccountSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TelegramAccountMinAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramAccountMaxAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramAccountCountAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TelegramAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramAccount to aggregate.
     */
    where?: TelegramAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramAccounts to fetch.
     */
    orderBy?: TelegramAccountOrderByWithRelationInput | TelegramAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelegramAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelegramAccounts
    **/
    _count?: true | TelegramAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TelegramAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TelegramAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelegramAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelegramAccountMaxAggregateInputType
  }

  export type GetTelegramAccountAggregateType<T extends TelegramAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateTelegramAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelegramAccount[P]>
      : GetScalarType<T[P], AggregateTelegramAccount[P]>
  }




  export type TelegramAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramAccountWhereInput
    orderBy?: TelegramAccountOrderByWithAggregationInput | TelegramAccountOrderByWithAggregationInput[]
    by: TelegramAccountScalarFieldEnum[] | TelegramAccountScalarFieldEnum
    having?: TelegramAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelegramAccountCountAggregateInputType | true
    _avg?: TelegramAccountAvgAggregateInputType
    _sum?: TelegramAccountSumAggregateInputType
    _min?: TelegramAccountMinAggregateInputType
    _max?: TelegramAccountMaxAggregateInputType
  }

  export type TelegramAccountGroupByOutputType = {
    id: number
    telegramId: string
    username: string | null
    firstName: string | null
    lastName: string | null
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: TelegramAccountCountAggregateOutputType | null
    _avg: TelegramAccountAvgAggregateOutputType | null
    _sum: TelegramAccountSumAggregateOutputType | null
    _min: TelegramAccountMinAggregateOutputType | null
    _max: TelegramAccountMaxAggregateOutputType | null
  }

  type GetTelegramAccountGroupByPayload<T extends TelegramAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelegramAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelegramAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelegramAccountGroupByOutputType[P]>
            : GetScalarType<T[P], TelegramAccountGroupByOutputType[P]>
        }
      >
    >


  export type TelegramAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramAccount"]>

  export type TelegramAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramAccount"]>

  export type TelegramAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramAccount"]>

  export type TelegramAccountSelectScalar = {
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TelegramAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "telegramId" | "username" | "firstName" | "lastName" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["telegramAccount"]>
  export type TelegramAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TelegramAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TelegramAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TelegramAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelegramAccount"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      telegramId: string
      username: string | null
      firstName: string | null
      lastName: string | null
      userId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["telegramAccount"]>
    composites: {}
  }

  type TelegramAccountGetPayload<S extends boolean | null | undefined | TelegramAccountDefaultArgs> = $Result.GetResult<Prisma.$TelegramAccountPayload, S>

  type TelegramAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TelegramAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TelegramAccountCountAggregateInputType | true
    }

  export interface TelegramAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelegramAccount'], meta: { name: 'TelegramAccount' } }
    /**
     * Find zero or one TelegramAccount that matches the filter.
     * @param {TelegramAccountFindUniqueArgs} args - Arguments to find a TelegramAccount
     * @example
     * // Get one TelegramAccount
     * const telegramAccount = await prisma.telegramAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TelegramAccountFindUniqueArgs>(args: SelectSubset<T, TelegramAccountFindUniqueArgs<ExtArgs>>): Prisma__TelegramAccountClient<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TelegramAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TelegramAccountFindUniqueOrThrowArgs} args - Arguments to find a TelegramAccount
     * @example
     * // Get one TelegramAccount
     * const telegramAccount = await prisma.telegramAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TelegramAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, TelegramAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TelegramAccountClient<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramAccountFindFirstArgs} args - Arguments to find a TelegramAccount
     * @example
     * // Get one TelegramAccount
     * const telegramAccount = await prisma.telegramAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TelegramAccountFindFirstArgs>(args?: SelectSubset<T, TelegramAccountFindFirstArgs<ExtArgs>>): Prisma__TelegramAccountClient<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramAccountFindFirstOrThrowArgs} args - Arguments to find a TelegramAccount
     * @example
     * // Get one TelegramAccount
     * const telegramAccount = await prisma.telegramAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TelegramAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, TelegramAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__TelegramAccountClient<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TelegramAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelegramAccounts
     * const telegramAccounts = await prisma.telegramAccount.findMany()
     * 
     * // Get first 10 TelegramAccounts
     * const telegramAccounts = await prisma.telegramAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telegramAccountWithIdOnly = await prisma.telegramAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TelegramAccountFindManyArgs>(args?: SelectSubset<T, TelegramAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TelegramAccount.
     * @param {TelegramAccountCreateArgs} args - Arguments to create a TelegramAccount.
     * @example
     * // Create one TelegramAccount
     * const TelegramAccount = await prisma.telegramAccount.create({
     *   data: {
     *     // ... data to create a TelegramAccount
     *   }
     * })
     * 
     */
    create<T extends TelegramAccountCreateArgs>(args: SelectSubset<T, TelegramAccountCreateArgs<ExtArgs>>): Prisma__TelegramAccountClient<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TelegramAccounts.
     * @param {TelegramAccountCreateManyArgs} args - Arguments to create many TelegramAccounts.
     * @example
     * // Create many TelegramAccounts
     * const telegramAccount = await prisma.telegramAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TelegramAccountCreateManyArgs>(args?: SelectSubset<T, TelegramAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TelegramAccounts and returns the data saved in the database.
     * @param {TelegramAccountCreateManyAndReturnArgs} args - Arguments to create many TelegramAccounts.
     * @example
     * // Create many TelegramAccounts
     * const telegramAccount = await prisma.telegramAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TelegramAccounts and only return the `id`
     * const telegramAccountWithIdOnly = await prisma.telegramAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TelegramAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, TelegramAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TelegramAccount.
     * @param {TelegramAccountDeleteArgs} args - Arguments to delete one TelegramAccount.
     * @example
     * // Delete one TelegramAccount
     * const TelegramAccount = await prisma.telegramAccount.delete({
     *   where: {
     *     // ... filter to delete one TelegramAccount
     *   }
     * })
     * 
     */
    delete<T extends TelegramAccountDeleteArgs>(args: SelectSubset<T, TelegramAccountDeleteArgs<ExtArgs>>): Prisma__TelegramAccountClient<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TelegramAccount.
     * @param {TelegramAccountUpdateArgs} args - Arguments to update one TelegramAccount.
     * @example
     * // Update one TelegramAccount
     * const telegramAccount = await prisma.telegramAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TelegramAccountUpdateArgs>(args: SelectSubset<T, TelegramAccountUpdateArgs<ExtArgs>>): Prisma__TelegramAccountClient<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TelegramAccounts.
     * @param {TelegramAccountDeleteManyArgs} args - Arguments to filter TelegramAccounts to delete.
     * @example
     * // Delete a few TelegramAccounts
     * const { count } = await prisma.telegramAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TelegramAccountDeleteManyArgs>(args?: SelectSubset<T, TelegramAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelegramAccounts
     * const telegramAccount = await prisma.telegramAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TelegramAccountUpdateManyArgs>(args: SelectSubset<T, TelegramAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramAccounts and returns the data updated in the database.
     * @param {TelegramAccountUpdateManyAndReturnArgs} args - Arguments to update many TelegramAccounts.
     * @example
     * // Update many TelegramAccounts
     * const telegramAccount = await prisma.telegramAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TelegramAccounts and only return the `id`
     * const telegramAccountWithIdOnly = await prisma.telegramAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TelegramAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, TelegramAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TelegramAccount.
     * @param {TelegramAccountUpsertArgs} args - Arguments to update or create a TelegramAccount.
     * @example
     * // Update or create a TelegramAccount
     * const telegramAccount = await prisma.telegramAccount.upsert({
     *   create: {
     *     // ... data to create a TelegramAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelegramAccount we want to update
     *   }
     * })
     */
    upsert<T extends TelegramAccountUpsertArgs>(args: SelectSubset<T, TelegramAccountUpsertArgs<ExtArgs>>): Prisma__TelegramAccountClient<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TelegramAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramAccountCountArgs} args - Arguments to filter TelegramAccounts to count.
     * @example
     * // Count the number of TelegramAccounts
     * const count = await prisma.telegramAccount.count({
     *   where: {
     *     // ... the filter for the TelegramAccounts we want to count
     *   }
     * })
    **/
    count<T extends TelegramAccountCountArgs>(
      args?: Subset<T, TelegramAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelegramAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelegramAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelegramAccountAggregateArgs>(args: Subset<T, TelegramAccountAggregateArgs>): Prisma.PrismaPromise<GetTelegramAccountAggregateType<T>>

    /**
     * Group by TelegramAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelegramAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelegramAccountGroupByArgs['orderBy'] }
        : { orderBy?: TelegramAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelegramAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelegramAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelegramAccount model
   */
  readonly fields: TelegramAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelegramAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelegramAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TelegramAccount model
   */
  interface TelegramAccountFieldRefs {
    readonly id: FieldRef<"TelegramAccount", 'Int'>
    readonly telegramId: FieldRef<"TelegramAccount", 'String'>
    readonly username: FieldRef<"TelegramAccount", 'String'>
    readonly firstName: FieldRef<"TelegramAccount", 'String'>
    readonly lastName: FieldRef<"TelegramAccount", 'String'>
    readonly userId: FieldRef<"TelegramAccount", 'Int'>
    readonly createdAt: FieldRef<"TelegramAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"TelegramAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TelegramAccount findUnique
   */
  export type TelegramAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountInclude<ExtArgs> | null
    /**
     * Filter, which TelegramAccount to fetch.
     */
    where: TelegramAccountWhereUniqueInput
  }

  /**
   * TelegramAccount findUniqueOrThrow
   */
  export type TelegramAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountInclude<ExtArgs> | null
    /**
     * Filter, which TelegramAccount to fetch.
     */
    where: TelegramAccountWhereUniqueInput
  }

  /**
   * TelegramAccount findFirst
   */
  export type TelegramAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountInclude<ExtArgs> | null
    /**
     * Filter, which TelegramAccount to fetch.
     */
    where?: TelegramAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramAccounts to fetch.
     */
    orderBy?: TelegramAccountOrderByWithRelationInput | TelegramAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramAccounts.
     */
    cursor?: TelegramAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramAccounts.
     */
    distinct?: TelegramAccountScalarFieldEnum | TelegramAccountScalarFieldEnum[]
  }

  /**
   * TelegramAccount findFirstOrThrow
   */
  export type TelegramAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountInclude<ExtArgs> | null
    /**
     * Filter, which TelegramAccount to fetch.
     */
    where?: TelegramAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramAccounts to fetch.
     */
    orderBy?: TelegramAccountOrderByWithRelationInput | TelegramAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramAccounts.
     */
    cursor?: TelegramAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramAccounts.
     */
    distinct?: TelegramAccountScalarFieldEnum | TelegramAccountScalarFieldEnum[]
  }

  /**
   * TelegramAccount findMany
   */
  export type TelegramAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountInclude<ExtArgs> | null
    /**
     * Filter, which TelegramAccounts to fetch.
     */
    where?: TelegramAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramAccounts to fetch.
     */
    orderBy?: TelegramAccountOrderByWithRelationInput | TelegramAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelegramAccounts.
     */
    cursor?: TelegramAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramAccounts.
     */
    skip?: number
    distinct?: TelegramAccountScalarFieldEnum | TelegramAccountScalarFieldEnum[]
  }

  /**
   * TelegramAccount create
   */
  export type TelegramAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a TelegramAccount.
     */
    data: XOR<TelegramAccountCreateInput, TelegramAccountUncheckedCreateInput>
  }

  /**
   * TelegramAccount createMany
   */
  export type TelegramAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelegramAccounts.
     */
    data: TelegramAccountCreateManyInput | TelegramAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TelegramAccount createManyAndReturn
   */
  export type TelegramAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * The data used to create many TelegramAccounts.
     */
    data: TelegramAccountCreateManyInput | TelegramAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramAccount update
   */
  export type TelegramAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a TelegramAccount.
     */
    data: XOR<TelegramAccountUpdateInput, TelegramAccountUncheckedUpdateInput>
    /**
     * Choose, which TelegramAccount to update.
     */
    where: TelegramAccountWhereUniqueInput
  }

  /**
   * TelegramAccount updateMany
   */
  export type TelegramAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelegramAccounts.
     */
    data: XOR<TelegramAccountUpdateManyMutationInput, TelegramAccountUncheckedUpdateManyInput>
    /**
     * Filter which TelegramAccounts to update
     */
    where?: TelegramAccountWhereInput
    /**
     * Limit how many TelegramAccounts to update.
     */
    limit?: number
  }

  /**
   * TelegramAccount updateManyAndReturn
   */
  export type TelegramAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * The data used to update TelegramAccounts.
     */
    data: XOR<TelegramAccountUpdateManyMutationInput, TelegramAccountUncheckedUpdateManyInput>
    /**
     * Filter which TelegramAccounts to update
     */
    where?: TelegramAccountWhereInput
    /**
     * Limit how many TelegramAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramAccount upsert
   */
  export type TelegramAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the TelegramAccount to update in case it exists.
     */
    where: TelegramAccountWhereUniqueInput
    /**
     * In case the TelegramAccount found by the `where` argument doesn't exist, create a new TelegramAccount with this data.
     */
    create: XOR<TelegramAccountCreateInput, TelegramAccountUncheckedCreateInput>
    /**
     * In case the TelegramAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelegramAccountUpdateInput, TelegramAccountUncheckedUpdateInput>
  }

  /**
   * TelegramAccount delete
   */
  export type TelegramAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountInclude<ExtArgs> | null
    /**
     * Filter which TelegramAccount to delete.
     */
    where: TelegramAccountWhereUniqueInput
  }

  /**
   * TelegramAccount deleteMany
   */
  export type TelegramAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramAccounts to delete
     */
    where?: TelegramAccountWhereInput
    /**
     * Limit how many TelegramAccounts to delete.
     */
    limit?: number
  }

  /**
   * TelegramAccount without action
   */
  export type TelegramAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    totalPrice: number | null
    unitPrice: number | null
    userId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    amount: number | null
    totalPrice: number | null
    unitPrice: number | null
    userId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    externalId: string | null
    orderNo: string | null
    dateTime: Date | null
    type: string | null
    asset: string | null
    amount: number | null
    totalPrice: number | null
    unitPrice: number | null
    counterparty: string | null
    status: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    externalId: string | null
    orderNo: string | null
    dateTime: Date | null
    type: string | null
    asset: string | null
    amount: number | null
    totalPrice: number | null
    unitPrice: number | null
    counterparty: string | null
    status: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    externalId: number
    orderNo: number
    dateTime: number
    type: number
    asset: number
    amount: number
    totalPrice: number
    unitPrice: number
    counterparty: number
    status: number
    originalData: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    amount?: true
    totalPrice?: true
    unitPrice?: true
    userId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    amount?: true
    totalPrice?: true
    unitPrice?: true
    userId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    externalId?: true
    orderNo?: true
    dateTime?: true
    type?: true
    asset?: true
    amount?: true
    totalPrice?: true
    unitPrice?: true
    counterparty?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    externalId?: true
    orderNo?: true
    dateTime?: true
    type?: true
    asset?: true
    amount?: true
    totalPrice?: true
    unitPrice?: true
    counterparty?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    externalId?: true
    orderNo?: true
    dateTime?: true
    type?: true
    asset?: true
    amount?: true
    totalPrice?: true
    unitPrice?: true
    counterparty?: true
    status?: true
    originalData?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    externalId: string | null
    orderNo: string | null
    dateTime: Date
    type: string
    asset: string
    amount: number
    totalPrice: number
    unitPrice: number
    counterparty: string | null
    status: string
    originalData: JsonValue | null
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    orderNo?: boolean
    dateTime?: boolean
    type?: boolean
    asset?: boolean
    amount?: boolean
    totalPrice?: boolean
    unitPrice?: boolean
    counterparty?: boolean
    status?: boolean
    originalData?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Match?: boolean | Transaction$MatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    orderNo?: boolean
    dateTime?: boolean
    type?: boolean
    asset?: boolean
    amount?: boolean
    totalPrice?: boolean
    unitPrice?: boolean
    counterparty?: boolean
    status?: boolean
    originalData?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    orderNo?: boolean
    dateTime?: boolean
    type?: boolean
    asset?: boolean
    amount?: boolean
    totalPrice?: boolean
    unitPrice?: boolean
    counterparty?: boolean
    status?: boolean
    originalData?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    externalId?: boolean
    orderNo?: boolean
    dateTime?: boolean
    type?: boolean
    asset?: boolean
    amount?: boolean
    totalPrice?: boolean
    unitPrice?: boolean
    counterparty?: boolean
    status?: boolean
    originalData?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "orderNo" | "dateTime" | "type" | "asset" | "amount" | "totalPrice" | "unitPrice" | "counterparty" | "status" | "originalData" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Match?: boolean | Transaction$MatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      Match: Prisma.$MatchPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      externalId: string | null
      orderNo: string | null
      dateTime: Date
      type: string
      asset: string
      amount: number
      totalPrice: number
      unitPrice: number
      counterparty: string | null
      status: string
      originalData: Prisma.JsonValue | null
      userId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Match<T extends Transaction$MatchArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$MatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly externalId: FieldRef<"Transaction", 'String'>
    readonly orderNo: FieldRef<"Transaction", 'String'>
    readonly dateTime: FieldRef<"Transaction", 'DateTime'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly asset: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly totalPrice: FieldRef<"Transaction", 'Float'>
    readonly unitPrice: FieldRef<"Transaction", 'Float'>
    readonly counterparty: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly originalData: FieldRef<"Transaction", 'Json'>
    readonly userId: FieldRef<"Transaction", 'Int'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.Match
   */
  export type Transaction$MatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    passCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastNotification: Date | null
    role: $Enums.UserRole | null
    bybitApiSecret: string | null
    bybitApiToken: string | null
    lastBybitSyncAt: Date | null
    lastBybitSyncStatus: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    passCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastNotification: Date | null
    role: $Enums.UserRole | null
    bybitApiSecret: string | null
    bybitApiToken: string | null
    lastBybitSyncAt: Date | null
    lastBybitSyncStatus: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    passCode: number
    isActive: number
    createdAt: number
    updatedAt: number
    lastNotification: number
    role: number
    bybitApiSecret: number
    bybitApiToken: number
    lastBybitSyncAt: number
    lastBybitSyncStatus: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    passCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastNotification?: true
    role?: true
    bybitApiSecret?: true
    bybitApiToken?: true
    lastBybitSyncAt?: true
    lastBybitSyncStatus?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    passCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastNotification?: true
    role?: true
    bybitApiSecret?: true
    bybitApiToken?: true
    lastBybitSyncAt?: true
    lastBybitSyncStatus?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    passCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastNotification?: true
    role?: true
    bybitApiSecret?: true
    bybitApiToken?: true
    lastBybitSyncAt?: true
    lastBybitSyncStatus?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    passCode: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    lastNotification: Date | null
    role: $Enums.UserRole
    bybitApiSecret: string | null
    bybitApiToken: string | null
    lastBybitSyncAt: Date | null
    lastBybitSyncStatus: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    passCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastNotification?: boolean
    role?: boolean
    bybitApiSecret?: boolean
    bybitApiToken?: boolean
    lastBybitSyncAt?: boolean
    lastBybitSyncStatus?: boolean
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    BybitClipMatch?: boolean | User$BybitClipMatchArgs<ExtArgs>
    BybitTransaction?: boolean | User$BybitTransactionArgs<ExtArgs>
    MatchBybitReport?: boolean | User$MatchBybitReportArgs<ExtArgs>
    MatchViresReport?: boolean | User$MatchViresReportArgs<ExtArgs>
    ReportNotification?: boolean | User$ReportNotificationArgs<ExtArgs>
    TelegramAccount?: boolean | User$TelegramAccountArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    ViresCabinet?: boolean | User$ViresCabinetArgs<ExtArgs>
    ViresClipMatch?: boolean | User$ViresClipMatchArgs<ExtArgs>
    WorkSession?: boolean | User$WorkSessionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    passCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastNotification?: boolean
    role?: boolean
    bybitApiSecret?: boolean
    bybitApiToken?: boolean
    lastBybitSyncAt?: boolean
    lastBybitSyncStatus?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    passCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastNotification?: boolean
    role?: boolean
    bybitApiSecret?: boolean
    bybitApiToken?: boolean
    lastBybitSyncAt?: boolean
    lastBybitSyncStatus?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    passCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastNotification?: boolean
    role?: boolean
    bybitApiSecret?: boolean
    bybitApiToken?: boolean
    lastBybitSyncAt?: boolean
    lastBybitSyncStatus?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "passCode" | "isActive" | "createdAt" | "updatedAt" | "lastNotification" | "role" | "bybitApiSecret" | "bybitApiToken" | "lastBybitSyncAt" | "lastBybitSyncStatus", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    BybitClipMatch?: boolean | User$BybitClipMatchArgs<ExtArgs>
    BybitTransaction?: boolean | User$BybitTransactionArgs<ExtArgs>
    MatchBybitReport?: boolean | User$MatchBybitReportArgs<ExtArgs>
    MatchViresReport?: boolean | User$MatchViresReportArgs<ExtArgs>
    ReportNotification?: boolean | User$ReportNotificationArgs<ExtArgs>
    TelegramAccount?: boolean | User$TelegramAccountArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    ViresCabinet?: boolean | User$ViresCabinetArgs<ExtArgs>
    ViresClipMatch?: boolean | User$ViresClipMatchArgs<ExtArgs>
    WorkSession?: boolean | User$WorkSessionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      AuditLog: Prisma.$AuditLogPayload<ExtArgs>[]
      BybitClipMatch: Prisma.$BybitClipMatchPayload<ExtArgs>[]
      BybitTransaction: Prisma.$BybitTransactionPayload<ExtArgs>[]
      MatchBybitReport: Prisma.$MatchBybitReportPayload<ExtArgs>[]
      MatchViresReport: Prisma.$MatchViresReportPayload<ExtArgs>[]
      ReportNotification: Prisma.$ReportNotificationPayload<ExtArgs>[]
      TelegramAccount: Prisma.$TelegramAccountPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
      ViresCabinet: Prisma.$ViresCabinetPayload<ExtArgs>[]
      ViresClipMatch: Prisma.$ViresClipMatchPayload<ExtArgs>[]
      WorkSession: Prisma.$WorkSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      passCode: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      lastNotification: Date | null
      role: $Enums.UserRole
      bybitApiSecret: string | null
      bybitApiToken: string | null
      lastBybitSyncAt: Date | null
      lastBybitSyncStatus: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AuditLog<T extends User$AuditLogArgs<ExtArgs> = {}>(args?: Subset<T, User$AuditLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BybitClipMatch<T extends User$BybitClipMatchArgs<ExtArgs> = {}>(args?: Subset<T, User$BybitClipMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BybitTransaction<T extends User$BybitTransactionArgs<ExtArgs> = {}>(args?: Subset<T, User$BybitTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MatchBybitReport<T extends User$MatchBybitReportArgs<ExtArgs> = {}>(args?: Subset<T, User$MatchBybitReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MatchViresReport<T extends User$MatchViresReportArgs<ExtArgs> = {}>(args?: Subset<T, User$MatchViresReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ReportNotification<T extends User$ReportNotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$ReportNotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TelegramAccount<T extends User$TelegramAccountArgs<ExtArgs> = {}>(args?: Subset<T, User$TelegramAccountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends User$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, User$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ViresCabinet<T extends User$ViresCabinetArgs<ExtArgs> = {}>(args?: Subset<T, User$ViresCabinetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ViresClipMatch<T extends User$ViresClipMatchArgs<ExtArgs> = {}>(args?: Subset<T, User$ViresClipMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WorkSession<T extends User$WorkSessionArgs<ExtArgs> = {}>(args?: Subset<T, User$WorkSessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly passCode: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastNotification: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly bybitApiSecret: FieldRef<"User", 'String'>
    readonly bybitApiToken: FieldRef<"User", 'String'>
    readonly lastBybitSyncAt: FieldRef<"User", 'DateTime'>
    readonly lastBybitSyncStatus: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.AuditLog
   */
  export type User$AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.BybitClipMatch
   */
  export type User$BybitClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    where?: BybitClipMatchWhereInput
    orderBy?: BybitClipMatchOrderByWithRelationInput | BybitClipMatchOrderByWithRelationInput[]
    cursor?: BybitClipMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BybitClipMatchScalarFieldEnum | BybitClipMatchScalarFieldEnum[]
  }

  /**
   * User.BybitTransaction
   */
  export type User$BybitTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransaction
     */
    select?: BybitTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransaction
     */
    omit?: BybitTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionInclude<ExtArgs> | null
    where?: BybitTransactionWhereInput
    orderBy?: BybitTransactionOrderByWithRelationInput | BybitTransactionOrderByWithRelationInput[]
    cursor?: BybitTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BybitTransactionScalarFieldEnum | BybitTransactionScalarFieldEnum[]
  }

  /**
   * User.MatchBybitReport
   */
  export type User$MatchBybitReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
    where?: MatchBybitReportWhereInput
    orderBy?: MatchBybitReportOrderByWithRelationInput | MatchBybitReportOrderByWithRelationInput[]
    cursor?: MatchBybitReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchBybitReportScalarFieldEnum | MatchBybitReportScalarFieldEnum[]
  }

  /**
   * User.MatchViresReport
   */
  export type User$MatchViresReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
    where?: MatchViresReportWhereInput
    orderBy?: MatchViresReportOrderByWithRelationInput | MatchViresReportOrderByWithRelationInput[]
    cursor?: MatchViresReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchViresReportScalarFieldEnum | MatchViresReportScalarFieldEnum[]
  }

  /**
   * User.ReportNotification
   */
  export type User$ReportNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportNotification
     */
    select?: ReportNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportNotification
     */
    omit?: ReportNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportNotificationInclude<ExtArgs> | null
    where?: ReportNotificationWhereInput
    orderBy?: ReportNotificationOrderByWithRelationInput | ReportNotificationOrderByWithRelationInput[]
    cursor?: ReportNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportNotificationScalarFieldEnum | ReportNotificationScalarFieldEnum[]
  }

  /**
   * User.TelegramAccount
   */
  export type User$TelegramAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramAccount
     */
    select?: TelegramAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramAccount
     */
    omit?: TelegramAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramAccountInclude<ExtArgs> | null
    where?: TelegramAccountWhereInput
    orderBy?: TelegramAccountOrderByWithRelationInput | TelegramAccountOrderByWithRelationInput[]
    cursor?: TelegramAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelegramAccountScalarFieldEnum | TelegramAccountScalarFieldEnum[]
  }

  /**
   * User.Transaction
   */
  export type User$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.ViresCabinet
   */
  export type User$ViresCabinetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetInclude<ExtArgs> | null
    where?: ViresCabinetWhereInput
    orderBy?: ViresCabinetOrderByWithRelationInput | ViresCabinetOrderByWithRelationInput[]
    cursor?: ViresCabinetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViresCabinetScalarFieldEnum | ViresCabinetScalarFieldEnum[]
  }

  /**
   * User.ViresClipMatch
   */
  export type User$ViresClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    where?: ViresClipMatchWhereInput
    orderBy?: ViresClipMatchOrderByWithRelationInput | ViresClipMatchOrderByWithRelationInput[]
    cursor?: ViresClipMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViresClipMatchScalarFieldEnum | ViresClipMatchScalarFieldEnum[]
  }

  /**
   * User.WorkSession
   */
  export type User$WorkSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionInclude<ExtArgs> | null
    where?: WorkSessionWhereInput
    orderBy?: WorkSessionOrderByWithRelationInput | WorkSessionOrderByWithRelationInput[]
    cursor?: WorkSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkSessionScalarFieldEnum | WorkSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model WorkSession
   */

  export type AggregateWorkSession = {
    _count: WorkSessionCountAggregateOutputType | null
    _avg: WorkSessionAvgAggregateOutputType | null
    _sum: WorkSessionSumAggregateOutputType | null
    _min: WorkSessionMinAggregateOutputType | null
    _max: WorkSessionMaxAggregateOutputType | null
  }

  export type WorkSessionAvgAggregateOutputType = {
    id: number | null
    duration: number | null
    userId: number | null
  }

  export type WorkSessionSumAggregateOutputType = {
    id: number | null
    duration: number | null
    userId: number | null
  }

  export type WorkSessionMinAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    autoCompleted: boolean | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
  }

  export type WorkSessionMaxAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    autoCompleted: boolean | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
  }

  export type WorkSessionCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    duration: number
    autoCompleted: number
    userId: number
    createdAt: number
    updatedAt: number
    comment: number
    _all: number
  }


  export type WorkSessionAvgAggregateInputType = {
    id?: true
    duration?: true
    userId?: true
  }

  export type WorkSessionSumAggregateInputType = {
    id?: true
    duration?: true
    userId?: true
  }

  export type WorkSessionMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    duration?: true
    autoCompleted?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
  }

  export type WorkSessionMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    duration?: true
    autoCompleted?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
  }

  export type WorkSessionCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    duration?: true
    autoCompleted?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    _all?: true
  }

  export type WorkSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkSession to aggregate.
     */
    where?: WorkSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSessions to fetch.
     */
    orderBy?: WorkSessionOrderByWithRelationInput | WorkSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkSessions
    **/
    _count?: true | WorkSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkSessionMaxAggregateInputType
  }

  export type GetWorkSessionAggregateType<T extends WorkSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkSession[P]>
      : GetScalarType<T[P], AggregateWorkSession[P]>
  }




  export type WorkSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkSessionWhereInput
    orderBy?: WorkSessionOrderByWithAggregationInput | WorkSessionOrderByWithAggregationInput[]
    by: WorkSessionScalarFieldEnum[] | WorkSessionScalarFieldEnum
    having?: WorkSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkSessionCountAggregateInputType | true
    _avg?: WorkSessionAvgAggregateInputType
    _sum?: WorkSessionSumAggregateInputType
    _min?: WorkSessionMinAggregateInputType
    _max?: WorkSessionMaxAggregateInputType
  }

  export type WorkSessionGroupByOutputType = {
    id: number
    startTime: Date
    endTime: Date | null
    duration: number | null
    autoCompleted: boolean
    userId: number
    createdAt: Date
    updatedAt: Date
    comment: string | null
    _count: WorkSessionCountAggregateOutputType | null
    _avg: WorkSessionAvgAggregateOutputType | null
    _sum: WorkSessionSumAggregateOutputType | null
    _min: WorkSessionMinAggregateOutputType | null
    _max: WorkSessionMaxAggregateOutputType | null
  }

  type GetWorkSessionGroupByPayload<T extends WorkSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkSessionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkSessionGroupByOutputType[P]>
        }
      >
    >


  export type WorkSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    autoCompleted?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    WorkSessionIdexCabinet?: boolean | WorkSession$WorkSessionIdexCabinetArgs<ExtArgs>
    _count?: boolean | WorkSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workSession"]>

  export type WorkSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    autoCompleted?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workSession"]>

  export type WorkSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    autoCompleted?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workSession"]>

  export type WorkSessionSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    autoCompleted?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
  }

  export type WorkSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startTime" | "endTime" | "duration" | "autoCompleted" | "userId" | "createdAt" | "updatedAt" | "comment", ExtArgs["result"]["workSession"]>
  export type WorkSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    WorkSessionIdexCabinet?: boolean | WorkSession$WorkSessionIdexCabinetArgs<ExtArgs>
    _count?: boolean | WorkSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkSession"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      WorkSessionIdexCabinet: Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      startTime: Date
      endTime: Date | null
      duration: number | null
      autoCompleted: boolean
      userId: number
      createdAt: Date
      updatedAt: Date
      comment: string | null
    }, ExtArgs["result"]["workSession"]>
    composites: {}
  }

  type WorkSessionGetPayload<S extends boolean | null | undefined | WorkSessionDefaultArgs> = $Result.GetResult<Prisma.$WorkSessionPayload, S>

  type WorkSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkSessionCountAggregateInputType | true
    }

  export interface WorkSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkSession'], meta: { name: 'WorkSession' } }
    /**
     * Find zero or one WorkSession that matches the filter.
     * @param {WorkSessionFindUniqueArgs} args - Arguments to find a WorkSession
     * @example
     * // Get one WorkSession
     * const workSession = await prisma.workSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkSessionFindUniqueArgs>(args: SelectSubset<T, WorkSessionFindUniqueArgs<ExtArgs>>): Prisma__WorkSessionClient<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkSessionFindUniqueOrThrowArgs} args - Arguments to find a WorkSession
     * @example
     * // Get one WorkSession
     * const workSession = await prisma.workSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkSessionClient<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionFindFirstArgs} args - Arguments to find a WorkSession
     * @example
     * // Get one WorkSession
     * const workSession = await prisma.workSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkSessionFindFirstArgs>(args?: SelectSubset<T, WorkSessionFindFirstArgs<ExtArgs>>): Prisma__WorkSessionClient<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionFindFirstOrThrowArgs} args - Arguments to find a WorkSession
     * @example
     * // Get one WorkSession
     * const workSession = await prisma.workSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkSessionClient<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkSessions
     * const workSessions = await prisma.workSession.findMany()
     * 
     * // Get first 10 WorkSessions
     * const workSessions = await prisma.workSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workSessionWithIdOnly = await prisma.workSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkSessionFindManyArgs>(args?: SelectSubset<T, WorkSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkSession.
     * @param {WorkSessionCreateArgs} args - Arguments to create a WorkSession.
     * @example
     * // Create one WorkSession
     * const WorkSession = await prisma.workSession.create({
     *   data: {
     *     // ... data to create a WorkSession
     *   }
     * })
     * 
     */
    create<T extends WorkSessionCreateArgs>(args: SelectSubset<T, WorkSessionCreateArgs<ExtArgs>>): Prisma__WorkSessionClient<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkSessions.
     * @param {WorkSessionCreateManyArgs} args - Arguments to create many WorkSessions.
     * @example
     * // Create many WorkSessions
     * const workSession = await prisma.workSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkSessionCreateManyArgs>(args?: SelectSubset<T, WorkSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkSessions and returns the data saved in the database.
     * @param {WorkSessionCreateManyAndReturnArgs} args - Arguments to create many WorkSessions.
     * @example
     * // Create many WorkSessions
     * const workSession = await prisma.workSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkSessions and only return the `id`
     * const workSessionWithIdOnly = await prisma.workSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkSession.
     * @param {WorkSessionDeleteArgs} args - Arguments to delete one WorkSession.
     * @example
     * // Delete one WorkSession
     * const WorkSession = await prisma.workSession.delete({
     *   where: {
     *     // ... filter to delete one WorkSession
     *   }
     * })
     * 
     */
    delete<T extends WorkSessionDeleteArgs>(args: SelectSubset<T, WorkSessionDeleteArgs<ExtArgs>>): Prisma__WorkSessionClient<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkSession.
     * @param {WorkSessionUpdateArgs} args - Arguments to update one WorkSession.
     * @example
     * // Update one WorkSession
     * const workSession = await prisma.workSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkSessionUpdateArgs>(args: SelectSubset<T, WorkSessionUpdateArgs<ExtArgs>>): Prisma__WorkSessionClient<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkSessions.
     * @param {WorkSessionDeleteManyArgs} args - Arguments to filter WorkSessions to delete.
     * @example
     * // Delete a few WorkSessions
     * const { count } = await prisma.workSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkSessionDeleteManyArgs>(args?: SelectSubset<T, WorkSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkSessions
     * const workSession = await prisma.workSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkSessionUpdateManyArgs>(args: SelectSubset<T, WorkSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkSessions and returns the data updated in the database.
     * @param {WorkSessionUpdateManyAndReturnArgs} args - Arguments to update many WorkSessions.
     * @example
     * // Update many WorkSessions
     * const workSession = await prisma.workSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkSessions and only return the `id`
     * const workSessionWithIdOnly = await prisma.workSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkSession.
     * @param {WorkSessionUpsertArgs} args - Arguments to update or create a WorkSession.
     * @example
     * // Update or create a WorkSession
     * const workSession = await prisma.workSession.upsert({
     *   create: {
     *     // ... data to create a WorkSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkSession we want to update
     *   }
     * })
     */
    upsert<T extends WorkSessionUpsertArgs>(args: SelectSubset<T, WorkSessionUpsertArgs<ExtArgs>>): Prisma__WorkSessionClient<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionCountArgs} args - Arguments to filter WorkSessions to count.
     * @example
     * // Count the number of WorkSessions
     * const count = await prisma.workSession.count({
     *   where: {
     *     // ... the filter for the WorkSessions we want to count
     *   }
     * })
    **/
    count<T extends WorkSessionCountArgs>(
      args?: Subset<T, WorkSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkSessionAggregateArgs>(args: Subset<T, WorkSessionAggregateArgs>): Prisma.PrismaPromise<GetWorkSessionAggregateType<T>>

    /**
     * Group by WorkSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkSessionGroupByArgs['orderBy'] }
        : { orderBy?: WorkSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkSession model
   */
  readonly fields: WorkSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    WorkSessionIdexCabinet<T extends WorkSession$WorkSessionIdexCabinetArgs<ExtArgs> = {}>(args?: Subset<T, WorkSession$WorkSessionIdexCabinetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkSession model
   */
  interface WorkSessionFieldRefs {
    readonly id: FieldRef<"WorkSession", 'Int'>
    readonly startTime: FieldRef<"WorkSession", 'DateTime'>
    readonly endTime: FieldRef<"WorkSession", 'DateTime'>
    readonly duration: FieldRef<"WorkSession", 'Int'>
    readonly autoCompleted: FieldRef<"WorkSession", 'Boolean'>
    readonly userId: FieldRef<"WorkSession", 'Int'>
    readonly createdAt: FieldRef<"WorkSession", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkSession", 'DateTime'>
    readonly comment: FieldRef<"WorkSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkSession findUnique
   */
  export type WorkSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkSession to fetch.
     */
    where: WorkSessionWhereUniqueInput
  }

  /**
   * WorkSession findUniqueOrThrow
   */
  export type WorkSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkSession to fetch.
     */
    where: WorkSessionWhereUniqueInput
  }

  /**
   * WorkSession findFirst
   */
  export type WorkSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkSession to fetch.
     */
    where?: WorkSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSessions to fetch.
     */
    orderBy?: WorkSessionOrderByWithRelationInput | WorkSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkSessions.
     */
    cursor?: WorkSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkSessions.
     */
    distinct?: WorkSessionScalarFieldEnum | WorkSessionScalarFieldEnum[]
  }

  /**
   * WorkSession findFirstOrThrow
   */
  export type WorkSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkSession to fetch.
     */
    where?: WorkSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSessions to fetch.
     */
    orderBy?: WorkSessionOrderByWithRelationInput | WorkSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkSessions.
     */
    cursor?: WorkSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkSessions.
     */
    distinct?: WorkSessionScalarFieldEnum | WorkSessionScalarFieldEnum[]
  }

  /**
   * WorkSession findMany
   */
  export type WorkSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkSessions to fetch.
     */
    where?: WorkSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSessions to fetch.
     */
    orderBy?: WorkSessionOrderByWithRelationInput | WorkSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkSessions.
     */
    cursor?: WorkSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSessions.
     */
    skip?: number
    distinct?: WorkSessionScalarFieldEnum | WorkSessionScalarFieldEnum[]
  }

  /**
   * WorkSession create
   */
  export type WorkSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkSession.
     */
    data: XOR<WorkSessionCreateInput, WorkSessionUncheckedCreateInput>
  }

  /**
   * WorkSession createMany
   */
  export type WorkSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkSessions.
     */
    data: WorkSessionCreateManyInput | WorkSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkSession createManyAndReturn
   */
  export type WorkSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * The data used to create many WorkSessions.
     */
    data: WorkSessionCreateManyInput | WorkSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkSession update
   */
  export type WorkSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkSession.
     */
    data: XOR<WorkSessionUpdateInput, WorkSessionUncheckedUpdateInput>
    /**
     * Choose, which WorkSession to update.
     */
    where: WorkSessionWhereUniqueInput
  }

  /**
   * WorkSession updateMany
   */
  export type WorkSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkSessions.
     */
    data: XOR<WorkSessionUpdateManyMutationInput, WorkSessionUncheckedUpdateManyInput>
    /**
     * Filter which WorkSessions to update
     */
    where?: WorkSessionWhereInput
    /**
     * Limit how many WorkSessions to update.
     */
    limit?: number
  }

  /**
   * WorkSession updateManyAndReturn
   */
  export type WorkSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * The data used to update WorkSessions.
     */
    data: XOR<WorkSessionUpdateManyMutationInput, WorkSessionUncheckedUpdateManyInput>
    /**
     * Filter which WorkSessions to update
     */
    where?: WorkSessionWhereInput
    /**
     * Limit how many WorkSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkSession upsert
   */
  export type WorkSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkSession to update in case it exists.
     */
    where: WorkSessionWhereUniqueInput
    /**
     * In case the WorkSession found by the `where` argument doesn't exist, create a new WorkSession with this data.
     */
    create: XOR<WorkSessionCreateInput, WorkSessionUncheckedCreateInput>
    /**
     * In case the WorkSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkSessionUpdateInput, WorkSessionUncheckedUpdateInput>
  }

  /**
   * WorkSession delete
   */
  export type WorkSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionInclude<ExtArgs> | null
    /**
     * Filter which WorkSession to delete.
     */
    where: WorkSessionWhereUniqueInput
  }

  /**
   * WorkSession deleteMany
   */
  export type WorkSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkSessions to delete
     */
    where?: WorkSessionWhereInput
    /**
     * Limit how many WorkSessions to delete.
     */
    limit?: number
  }

  /**
   * WorkSession.WorkSessionIdexCabinet
   */
  export type WorkSession$WorkSessionIdexCabinetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
    where?: WorkSessionIdexCabinetWhereInput
    orderBy?: WorkSessionIdexCabinetOrderByWithRelationInput | WorkSessionIdexCabinetOrderByWithRelationInput[]
    cursor?: WorkSessionIdexCabinetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkSessionIdexCabinetScalarFieldEnum | WorkSessionIdexCabinetScalarFieldEnum[]
  }

  /**
   * WorkSession without action
   */
  export type WorkSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSession
     */
    select?: WorkSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSession
     */
    omit?: WorkSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionInclude<ExtArgs> | null
  }


  /**
   * Model WorkSessionIdexCabinet
   */

  export type AggregateWorkSessionIdexCabinet = {
    _count: WorkSessionIdexCabinetCountAggregateOutputType | null
    _avg: WorkSessionIdexCabinetAvgAggregateOutputType | null
    _sum: WorkSessionIdexCabinetSumAggregateOutputType | null
    _min: WorkSessionIdexCabinetMinAggregateOutputType | null
    _max: WorkSessionIdexCabinetMaxAggregateOutputType | null
  }

  export type WorkSessionIdexCabinetAvgAggregateOutputType = {
    workSessionId: number | null
    idexCabinetId: number | null
  }

  export type WorkSessionIdexCabinetSumAggregateOutputType = {
    workSessionId: number | null
    idexCabinetId: number | null
  }

  export type WorkSessionIdexCabinetMinAggregateOutputType = {
    workSessionId: number | null
    idexCabinetId: number | null
    assignedAt: Date | null
  }

  export type WorkSessionIdexCabinetMaxAggregateOutputType = {
    workSessionId: number | null
    idexCabinetId: number | null
    assignedAt: Date | null
  }

  export type WorkSessionIdexCabinetCountAggregateOutputType = {
    workSessionId: number
    idexCabinetId: number
    assignedAt: number
    _all: number
  }


  export type WorkSessionIdexCabinetAvgAggregateInputType = {
    workSessionId?: true
    idexCabinetId?: true
  }

  export type WorkSessionIdexCabinetSumAggregateInputType = {
    workSessionId?: true
    idexCabinetId?: true
  }

  export type WorkSessionIdexCabinetMinAggregateInputType = {
    workSessionId?: true
    idexCabinetId?: true
    assignedAt?: true
  }

  export type WorkSessionIdexCabinetMaxAggregateInputType = {
    workSessionId?: true
    idexCabinetId?: true
    assignedAt?: true
  }

  export type WorkSessionIdexCabinetCountAggregateInputType = {
    workSessionId?: true
    idexCabinetId?: true
    assignedAt?: true
    _all?: true
  }

  export type WorkSessionIdexCabinetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkSessionIdexCabinet to aggregate.
     */
    where?: WorkSessionIdexCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSessionIdexCabinets to fetch.
     */
    orderBy?: WorkSessionIdexCabinetOrderByWithRelationInput | WorkSessionIdexCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkSessionIdexCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSessionIdexCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSessionIdexCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkSessionIdexCabinets
    **/
    _count?: true | WorkSessionIdexCabinetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkSessionIdexCabinetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkSessionIdexCabinetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkSessionIdexCabinetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkSessionIdexCabinetMaxAggregateInputType
  }

  export type GetWorkSessionIdexCabinetAggregateType<T extends WorkSessionIdexCabinetAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkSessionIdexCabinet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkSessionIdexCabinet[P]>
      : GetScalarType<T[P], AggregateWorkSessionIdexCabinet[P]>
  }




  export type WorkSessionIdexCabinetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkSessionIdexCabinetWhereInput
    orderBy?: WorkSessionIdexCabinetOrderByWithAggregationInput | WorkSessionIdexCabinetOrderByWithAggregationInput[]
    by: WorkSessionIdexCabinetScalarFieldEnum[] | WorkSessionIdexCabinetScalarFieldEnum
    having?: WorkSessionIdexCabinetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkSessionIdexCabinetCountAggregateInputType | true
    _avg?: WorkSessionIdexCabinetAvgAggregateInputType
    _sum?: WorkSessionIdexCabinetSumAggregateInputType
    _min?: WorkSessionIdexCabinetMinAggregateInputType
    _max?: WorkSessionIdexCabinetMaxAggregateInputType
  }

  export type WorkSessionIdexCabinetGroupByOutputType = {
    workSessionId: number
    idexCabinetId: number
    assignedAt: Date
    _count: WorkSessionIdexCabinetCountAggregateOutputType | null
    _avg: WorkSessionIdexCabinetAvgAggregateOutputType | null
    _sum: WorkSessionIdexCabinetSumAggregateOutputType | null
    _min: WorkSessionIdexCabinetMinAggregateOutputType | null
    _max: WorkSessionIdexCabinetMaxAggregateOutputType | null
  }

  type GetWorkSessionIdexCabinetGroupByPayload<T extends WorkSessionIdexCabinetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkSessionIdexCabinetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkSessionIdexCabinetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkSessionIdexCabinetGroupByOutputType[P]>
            : GetScalarType<T[P], WorkSessionIdexCabinetGroupByOutputType[P]>
        }
      >
    >


  export type WorkSessionIdexCabinetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workSessionId?: boolean
    idexCabinetId?: boolean
    assignedAt?: boolean
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
    WorkSession?: boolean | WorkSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workSessionIdexCabinet"]>

  export type WorkSessionIdexCabinetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workSessionId?: boolean
    idexCabinetId?: boolean
    assignedAt?: boolean
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
    WorkSession?: boolean | WorkSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workSessionIdexCabinet"]>

  export type WorkSessionIdexCabinetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workSessionId?: boolean
    idexCabinetId?: boolean
    assignedAt?: boolean
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
    WorkSession?: boolean | WorkSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workSessionIdexCabinet"]>

  export type WorkSessionIdexCabinetSelectScalar = {
    workSessionId?: boolean
    idexCabinetId?: boolean
    assignedAt?: boolean
  }

  export type WorkSessionIdexCabinetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workSessionId" | "idexCabinetId" | "assignedAt", ExtArgs["result"]["workSessionIdexCabinet"]>
  export type WorkSessionIdexCabinetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
    WorkSession?: boolean | WorkSessionDefaultArgs<ExtArgs>
  }
  export type WorkSessionIdexCabinetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
    WorkSession?: boolean | WorkSessionDefaultArgs<ExtArgs>
  }
  export type WorkSessionIdexCabinetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    IdexCabinet?: boolean | IdexCabinetDefaultArgs<ExtArgs>
    WorkSession?: boolean | WorkSessionDefaultArgs<ExtArgs>
  }

  export type $WorkSessionIdexCabinetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkSessionIdexCabinet"
    objects: {
      IdexCabinet: Prisma.$IdexCabinetPayload<ExtArgs>
      WorkSession: Prisma.$WorkSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workSessionId: number
      idexCabinetId: number
      assignedAt: Date
    }, ExtArgs["result"]["workSessionIdexCabinet"]>
    composites: {}
  }

  type WorkSessionIdexCabinetGetPayload<S extends boolean | null | undefined | WorkSessionIdexCabinetDefaultArgs> = $Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload, S>

  type WorkSessionIdexCabinetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkSessionIdexCabinetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkSessionIdexCabinetCountAggregateInputType | true
    }

  export interface WorkSessionIdexCabinetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkSessionIdexCabinet'], meta: { name: 'WorkSessionIdexCabinet' } }
    /**
     * Find zero or one WorkSessionIdexCabinet that matches the filter.
     * @param {WorkSessionIdexCabinetFindUniqueArgs} args - Arguments to find a WorkSessionIdexCabinet
     * @example
     * // Get one WorkSessionIdexCabinet
     * const workSessionIdexCabinet = await prisma.workSessionIdexCabinet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkSessionIdexCabinetFindUniqueArgs>(args: SelectSubset<T, WorkSessionIdexCabinetFindUniqueArgs<ExtArgs>>): Prisma__WorkSessionIdexCabinetClient<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkSessionIdexCabinet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkSessionIdexCabinetFindUniqueOrThrowArgs} args - Arguments to find a WorkSessionIdexCabinet
     * @example
     * // Get one WorkSessionIdexCabinet
     * const workSessionIdexCabinet = await prisma.workSessionIdexCabinet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkSessionIdexCabinetFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkSessionIdexCabinetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkSessionIdexCabinetClient<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkSessionIdexCabinet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionIdexCabinetFindFirstArgs} args - Arguments to find a WorkSessionIdexCabinet
     * @example
     * // Get one WorkSessionIdexCabinet
     * const workSessionIdexCabinet = await prisma.workSessionIdexCabinet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkSessionIdexCabinetFindFirstArgs>(args?: SelectSubset<T, WorkSessionIdexCabinetFindFirstArgs<ExtArgs>>): Prisma__WorkSessionIdexCabinetClient<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkSessionIdexCabinet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionIdexCabinetFindFirstOrThrowArgs} args - Arguments to find a WorkSessionIdexCabinet
     * @example
     * // Get one WorkSessionIdexCabinet
     * const workSessionIdexCabinet = await prisma.workSessionIdexCabinet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkSessionIdexCabinetFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkSessionIdexCabinetFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkSessionIdexCabinetClient<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkSessionIdexCabinets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionIdexCabinetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkSessionIdexCabinets
     * const workSessionIdexCabinets = await prisma.workSessionIdexCabinet.findMany()
     * 
     * // Get first 10 WorkSessionIdexCabinets
     * const workSessionIdexCabinets = await prisma.workSessionIdexCabinet.findMany({ take: 10 })
     * 
     * // Only select the `workSessionId`
     * const workSessionIdexCabinetWithWorkSessionIdOnly = await prisma.workSessionIdexCabinet.findMany({ select: { workSessionId: true } })
     * 
     */
    findMany<T extends WorkSessionIdexCabinetFindManyArgs>(args?: SelectSubset<T, WorkSessionIdexCabinetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkSessionIdexCabinet.
     * @param {WorkSessionIdexCabinetCreateArgs} args - Arguments to create a WorkSessionIdexCabinet.
     * @example
     * // Create one WorkSessionIdexCabinet
     * const WorkSessionIdexCabinet = await prisma.workSessionIdexCabinet.create({
     *   data: {
     *     // ... data to create a WorkSessionIdexCabinet
     *   }
     * })
     * 
     */
    create<T extends WorkSessionIdexCabinetCreateArgs>(args: SelectSubset<T, WorkSessionIdexCabinetCreateArgs<ExtArgs>>): Prisma__WorkSessionIdexCabinetClient<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkSessionIdexCabinets.
     * @param {WorkSessionIdexCabinetCreateManyArgs} args - Arguments to create many WorkSessionIdexCabinets.
     * @example
     * // Create many WorkSessionIdexCabinets
     * const workSessionIdexCabinet = await prisma.workSessionIdexCabinet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkSessionIdexCabinetCreateManyArgs>(args?: SelectSubset<T, WorkSessionIdexCabinetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkSessionIdexCabinets and returns the data saved in the database.
     * @param {WorkSessionIdexCabinetCreateManyAndReturnArgs} args - Arguments to create many WorkSessionIdexCabinets.
     * @example
     * // Create many WorkSessionIdexCabinets
     * const workSessionIdexCabinet = await prisma.workSessionIdexCabinet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkSessionIdexCabinets and only return the `workSessionId`
     * const workSessionIdexCabinetWithWorkSessionIdOnly = await prisma.workSessionIdexCabinet.createManyAndReturn({
     *   select: { workSessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkSessionIdexCabinetCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkSessionIdexCabinetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkSessionIdexCabinet.
     * @param {WorkSessionIdexCabinetDeleteArgs} args - Arguments to delete one WorkSessionIdexCabinet.
     * @example
     * // Delete one WorkSessionIdexCabinet
     * const WorkSessionIdexCabinet = await prisma.workSessionIdexCabinet.delete({
     *   where: {
     *     // ... filter to delete one WorkSessionIdexCabinet
     *   }
     * })
     * 
     */
    delete<T extends WorkSessionIdexCabinetDeleteArgs>(args: SelectSubset<T, WorkSessionIdexCabinetDeleteArgs<ExtArgs>>): Prisma__WorkSessionIdexCabinetClient<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkSessionIdexCabinet.
     * @param {WorkSessionIdexCabinetUpdateArgs} args - Arguments to update one WorkSessionIdexCabinet.
     * @example
     * // Update one WorkSessionIdexCabinet
     * const workSessionIdexCabinet = await prisma.workSessionIdexCabinet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkSessionIdexCabinetUpdateArgs>(args: SelectSubset<T, WorkSessionIdexCabinetUpdateArgs<ExtArgs>>): Prisma__WorkSessionIdexCabinetClient<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkSessionIdexCabinets.
     * @param {WorkSessionIdexCabinetDeleteManyArgs} args - Arguments to filter WorkSessionIdexCabinets to delete.
     * @example
     * // Delete a few WorkSessionIdexCabinets
     * const { count } = await prisma.workSessionIdexCabinet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkSessionIdexCabinetDeleteManyArgs>(args?: SelectSubset<T, WorkSessionIdexCabinetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkSessionIdexCabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionIdexCabinetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkSessionIdexCabinets
     * const workSessionIdexCabinet = await prisma.workSessionIdexCabinet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkSessionIdexCabinetUpdateManyArgs>(args: SelectSubset<T, WorkSessionIdexCabinetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkSessionIdexCabinets and returns the data updated in the database.
     * @param {WorkSessionIdexCabinetUpdateManyAndReturnArgs} args - Arguments to update many WorkSessionIdexCabinets.
     * @example
     * // Update many WorkSessionIdexCabinets
     * const workSessionIdexCabinet = await prisma.workSessionIdexCabinet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkSessionIdexCabinets and only return the `workSessionId`
     * const workSessionIdexCabinetWithWorkSessionIdOnly = await prisma.workSessionIdexCabinet.updateManyAndReturn({
     *   select: { workSessionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkSessionIdexCabinetUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkSessionIdexCabinetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkSessionIdexCabinet.
     * @param {WorkSessionIdexCabinetUpsertArgs} args - Arguments to update or create a WorkSessionIdexCabinet.
     * @example
     * // Update or create a WorkSessionIdexCabinet
     * const workSessionIdexCabinet = await prisma.workSessionIdexCabinet.upsert({
     *   create: {
     *     // ... data to create a WorkSessionIdexCabinet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkSessionIdexCabinet we want to update
     *   }
     * })
     */
    upsert<T extends WorkSessionIdexCabinetUpsertArgs>(args: SelectSubset<T, WorkSessionIdexCabinetUpsertArgs<ExtArgs>>): Prisma__WorkSessionIdexCabinetClient<$Result.GetResult<Prisma.$WorkSessionIdexCabinetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkSessionIdexCabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionIdexCabinetCountArgs} args - Arguments to filter WorkSessionIdexCabinets to count.
     * @example
     * // Count the number of WorkSessionIdexCabinets
     * const count = await prisma.workSessionIdexCabinet.count({
     *   where: {
     *     // ... the filter for the WorkSessionIdexCabinets we want to count
     *   }
     * })
    **/
    count<T extends WorkSessionIdexCabinetCountArgs>(
      args?: Subset<T, WorkSessionIdexCabinetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkSessionIdexCabinetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkSessionIdexCabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionIdexCabinetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkSessionIdexCabinetAggregateArgs>(args: Subset<T, WorkSessionIdexCabinetAggregateArgs>): Prisma.PrismaPromise<GetWorkSessionIdexCabinetAggregateType<T>>

    /**
     * Group by WorkSessionIdexCabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSessionIdexCabinetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkSessionIdexCabinetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkSessionIdexCabinetGroupByArgs['orderBy'] }
        : { orderBy?: WorkSessionIdexCabinetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkSessionIdexCabinetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkSessionIdexCabinetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkSessionIdexCabinet model
   */
  readonly fields: WorkSessionIdexCabinetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkSessionIdexCabinet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkSessionIdexCabinetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    IdexCabinet<T extends IdexCabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IdexCabinetDefaultArgs<ExtArgs>>): Prisma__IdexCabinetClient<$Result.GetResult<Prisma.$IdexCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    WorkSession<T extends WorkSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkSessionDefaultArgs<ExtArgs>>): Prisma__WorkSessionClient<$Result.GetResult<Prisma.$WorkSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkSessionIdexCabinet model
   */
  interface WorkSessionIdexCabinetFieldRefs {
    readonly workSessionId: FieldRef<"WorkSessionIdexCabinet", 'Int'>
    readonly idexCabinetId: FieldRef<"WorkSessionIdexCabinet", 'Int'>
    readonly assignedAt: FieldRef<"WorkSessionIdexCabinet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkSessionIdexCabinet findUnique
   */
  export type WorkSessionIdexCabinetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
    /**
     * Filter, which WorkSessionIdexCabinet to fetch.
     */
    where: WorkSessionIdexCabinetWhereUniqueInput
  }

  /**
   * WorkSessionIdexCabinet findUniqueOrThrow
   */
  export type WorkSessionIdexCabinetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
    /**
     * Filter, which WorkSessionIdexCabinet to fetch.
     */
    where: WorkSessionIdexCabinetWhereUniqueInput
  }

  /**
   * WorkSessionIdexCabinet findFirst
   */
  export type WorkSessionIdexCabinetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
    /**
     * Filter, which WorkSessionIdexCabinet to fetch.
     */
    where?: WorkSessionIdexCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSessionIdexCabinets to fetch.
     */
    orderBy?: WorkSessionIdexCabinetOrderByWithRelationInput | WorkSessionIdexCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkSessionIdexCabinets.
     */
    cursor?: WorkSessionIdexCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSessionIdexCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSessionIdexCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkSessionIdexCabinets.
     */
    distinct?: WorkSessionIdexCabinetScalarFieldEnum | WorkSessionIdexCabinetScalarFieldEnum[]
  }

  /**
   * WorkSessionIdexCabinet findFirstOrThrow
   */
  export type WorkSessionIdexCabinetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
    /**
     * Filter, which WorkSessionIdexCabinet to fetch.
     */
    where?: WorkSessionIdexCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSessionIdexCabinets to fetch.
     */
    orderBy?: WorkSessionIdexCabinetOrderByWithRelationInput | WorkSessionIdexCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkSessionIdexCabinets.
     */
    cursor?: WorkSessionIdexCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSessionIdexCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSessionIdexCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkSessionIdexCabinets.
     */
    distinct?: WorkSessionIdexCabinetScalarFieldEnum | WorkSessionIdexCabinetScalarFieldEnum[]
  }

  /**
   * WorkSessionIdexCabinet findMany
   */
  export type WorkSessionIdexCabinetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
    /**
     * Filter, which WorkSessionIdexCabinets to fetch.
     */
    where?: WorkSessionIdexCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSessionIdexCabinets to fetch.
     */
    orderBy?: WorkSessionIdexCabinetOrderByWithRelationInput | WorkSessionIdexCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkSessionIdexCabinets.
     */
    cursor?: WorkSessionIdexCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSessionIdexCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSessionIdexCabinets.
     */
    skip?: number
    distinct?: WorkSessionIdexCabinetScalarFieldEnum | WorkSessionIdexCabinetScalarFieldEnum[]
  }

  /**
   * WorkSessionIdexCabinet create
   */
  export type WorkSessionIdexCabinetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkSessionIdexCabinet.
     */
    data: XOR<WorkSessionIdexCabinetCreateInput, WorkSessionIdexCabinetUncheckedCreateInput>
  }

  /**
   * WorkSessionIdexCabinet createMany
   */
  export type WorkSessionIdexCabinetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkSessionIdexCabinets.
     */
    data: WorkSessionIdexCabinetCreateManyInput | WorkSessionIdexCabinetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkSessionIdexCabinet createManyAndReturn
   */
  export type WorkSessionIdexCabinetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * The data used to create many WorkSessionIdexCabinets.
     */
    data: WorkSessionIdexCabinetCreateManyInput | WorkSessionIdexCabinetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkSessionIdexCabinet update
   */
  export type WorkSessionIdexCabinetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkSessionIdexCabinet.
     */
    data: XOR<WorkSessionIdexCabinetUpdateInput, WorkSessionIdexCabinetUncheckedUpdateInput>
    /**
     * Choose, which WorkSessionIdexCabinet to update.
     */
    where: WorkSessionIdexCabinetWhereUniqueInput
  }

  /**
   * WorkSessionIdexCabinet updateMany
   */
  export type WorkSessionIdexCabinetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkSessionIdexCabinets.
     */
    data: XOR<WorkSessionIdexCabinetUpdateManyMutationInput, WorkSessionIdexCabinetUncheckedUpdateManyInput>
    /**
     * Filter which WorkSessionIdexCabinets to update
     */
    where?: WorkSessionIdexCabinetWhereInput
    /**
     * Limit how many WorkSessionIdexCabinets to update.
     */
    limit?: number
  }

  /**
   * WorkSessionIdexCabinet updateManyAndReturn
   */
  export type WorkSessionIdexCabinetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * The data used to update WorkSessionIdexCabinets.
     */
    data: XOR<WorkSessionIdexCabinetUpdateManyMutationInput, WorkSessionIdexCabinetUncheckedUpdateManyInput>
    /**
     * Filter which WorkSessionIdexCabinets to update
     */
    where?: WorkSessionIdexCabinetWhereInput
    /**
     * Limit how many WorkSessionIdexCabinets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkSessionIdexCabinet upsert
   */
  export type WorkSessionIdexCabinetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkSessionIdexCabinet to update in case it exists.
     */
    where: WorkSessionIdexCabinetWhereUniqueInput
    /**
     * In case the WorkSessionIdexCabinet found by the `where` argument doesn't exist, create a new WorkSessionIdexCabinet with this data.
     */
    create: XOR<WorkSessionIdexCabinetCreateInput, WorkSessionIdexCabinetUncheckedCreateInput>
    /**
     * In case the WorkSessionIdexCabinet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkSessionIdexCabinetUpdateInput, WorkSessionIdexCabinetUncheckedUpdateInput>
  }

  /**
   * WorkSessionIdexCabinet delete
   */
  export type WorkSessionIdexCabinetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
    /**
     * Filter which WorkSessionIdexCabinet to delete.
     */
    where: WorkSessionIdexCabinetWhereUniqueInput
  }

  /**
   * WorkSessionIdexCabinet deleteMany
   */
  export type WorkSessionIdexCabinetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkSessionIdexCabinets to delete
     */
    where?: WorkSessionIdexCabinetWhereInput
    /**
     * Limit how many WorkSessionIdexCabinets to delete.
     */
    limit?: number
  }

  /**
   * WorkSessionIdexCabinet without action
   */
  export type WorkSessionIdexCabinetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSessionIdexCabinet
     */
    select?: WorkSessionIdexCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkSessionIdexCabinet
     */
    omit?: WorkSessionIdexCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSessionIdexCabinetInclude<ExtArgs> | null
  }


  /**
   * Model BybitCabinet
   */

  export type AggregateBybitCabinet = {
    _count: BybitCabinetCountAggregateOutputType | null
    _avg: BybitCabinetAvgAggregateOutputType | null
    _sum: BybitCabinetSumAggregateOutputType | null
    _min: BybitCabinetMinAggregateOutputType | null
    _max: BybitCabinetMaxAggregateOutputType | null
  }

  export type BybitCabinetAvgAggregateOutputType = {
    id: number | null
  }

  export type BybitCabinetSumAggregateOutputType = {
    id: number | null
  }

  export type BybitCabinetMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    bybitEmail: string | null
    bybitApiSecret: string | null
    bybitApiToken: string | null
    lastBybitSyncAt: Date | null
    lastBybitSyncStatus: string | null
  }

  export type BybitCabinetMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    bybitEmail: string | null
    bybitApiSecret: string | null
    bybitApiToken: string | null
    lastBybitSyncAt: Date | null
    lastBybitSyncStatus: string | null
  }

  export type BybitCabinetCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    bybitEmail: number
    bybitApiSecret: number
    bybitApiToken: number
    lastBybitSyncAt: number
    lastBybitSyncStatus: number
    _all: number
  }


  export type BybitCabinetAvgAggregateInputType = {
    id?: true
  }

  export type BybitCabinetSumAggregateInputType = {
    id?: true
  }

  export type BybitCabinetMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    bybitEmail?: true
    bybitApiSecret?: true
    bybitApiToken?: true
    lastBybitSyncAt?: true
    lastBybitSyncStatus?: true
  }

  export type BybitCabinetMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    bybitEmail?: true
    bybitApiSecret?: true
    bybitApiToken?: true
    lastBybitSyncAt?: true
    lastBybitSyncStatus?: true
  }

  export type BybitCabinetCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    bybitEmail?: true
    bybitApiSecret?: true
    bybitApiToken?: true
    lastBybitSyncAt?: true
    lastBybitSyncStatus?: true
    _all?: true
  }

  export type BybitCabinetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitCabinet to aggregate.
     */
    where?: BybitCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitCabinets to fetch.
     */
    orderBy?: BybitCabinetOrderByWithRelationInput | BybitCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BybitCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BybitCabinets
    **/
    _count?: true | BybitCabinetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BybitCabinetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BybitCabinetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BybitCabinetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BybitCabinetMaxAggregateInputType
  }

  export type GetBybitCabinetAggregateType<T extends BybitCabinetAggregateArgs> = {
        [P in keyof T & keyof AggregateBybitCabinet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBybitCabinet[P]>
      : GetScalarType<T[P], AggregateBybitCabinet[P]>
  }




  export type BybitCabinetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitCabinetWhereInput
    orderBy?: BybitCabinetOrderByWithAggregationInput | BybitCabinetOrderByWithAggregationInput[]
    by: BybitCabinetScalarFieldEnum[] | BybitCabinetScalarFieldEnum
    having?: BybitCabinetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BybitCabinetCountAggregateInputType | true
    _avg?: BybitCabinetAvgAggregateInputType
    _sum?: BybitCabinetSumAggregateInputType
    _min?: BybitCabinetMinAggregateInputType
    _max?: BybitCabinetMaxAggregateInputType
  }

  export type BybitCabinetGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    bybitEmail: string
    bybitApiSecret: string | null
    bybitApiToken: string | null
    lastBybitSyncAt: Date | null
    lastBybitSyncStatus: string | null
    _count: BybitCabinetCountAggregateOutputType | null
    _avg: BybitCabinetAvgAggregateOutputType | null
    _sum: BybitCabinetSumAggregateOutputType | null
    _min: BybitCabinetMinAggregateOutputType | null
    _max: BybitCabinetMaxAggregateOutputType | null
  }

  type GetBybitCabinetGroupByPayload<T extends BybitCabinetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BybitCabinetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BybitCabinetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BybitCabinetGroupByOutputType[P]>
            : GetScalarType<T[P], BybitCabinetGroupByOutputType[P]>
        }
      >
    >


  export type BybitCabinetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bybitEmail?: boolean
    bybitApiSecret?: boolean
    bybitApiToken?: boolean
    lastBybitSyncAt?: boolean
    lastBybitSyncStatus?: boolean
    BybitTransactionFromCabinet?: boolean | BybitCabinet$BybitTransactionFromCabinetArgs<ExtArgs>
    BybitOrderInfo?: boolean | BybitCabinet$BybitOrderInfoArgs<ExtArgs>
    _count?: boolean | BybitCabinetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitCabinet"]>

  export type BybitCabinetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bybitEmail?: boolean
    bybitApiSecret?: boolean
    bybitApiToken?: boolean
    lastBybitSyncAt?: boolean
    lastBybitSyncStatus?: boolean
  }, ExtArgs["result"]["bybitCabinet"]>

  export type BybitCabinetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bybitEmail?: boolean
    bybitApiSecret?: boolean
    bybitApiToken?: boolean
    lastBybitSyncAt?: boolean
    lastBybitSyncStatus?: boolean
  }, ExtArgs["result"]["bybitCabinet"]>

  export type BybitCabinetSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bybitEmail?: boolean
    bybitApiSecret?: boolean
    bybitApiToken?: boolean
    lastBybitSyncAt?: boolean
    lastBybitSyncStatus?: boolean
  }

  export type BybitCabinetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "bybitEmail" | "bybitApiSecret" | "bybitApiToken" | "lastBybitSyncAt" | "lastBybitSyncStatus", ExtArgs["result"]["bybitCabinet"]>
  export type BybitCabinetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitTransactionFromCabinet?: boolean | BybitCabinet$BybitTransactionFromCabinetArgs<ExtArgs>
    BybitOrderInfo?: boolean | BybitCabinet$BybitOrderInfoArgs<ExtArgs>
    _count?: boolean | BybitCabinetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BybitCabinetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BybitCabinetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BybitCabinetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BybitCabinet"
    objects: {
      BybitTransactionFromCabinet: Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>[]
      BybitOrderInfo: Prisma.$BybitOrderInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      bybitEmail: string
      bybitApiSecret: string | null
      bybitApiToken: string | null
      lastBybitSyncAt: Date | null
      lastBybitSyncStatus: string | null
    }, ExtArgs["result"]["bybitCabinet"]>
    composites: {}
  }

  type BybitCabinetGetPayload<S extends boolean | null | undefined | BybitCabinetDefaultArgs> = $Result.GetResult<Prisma.$BybitCabinetPayload, S>

  type BybitCabinetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BybitCabinetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BybitCabinetCountAggregateInputType | true
    }

  export interface BybitCabinetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BybitCabinet'], meta: { name: 'BybitCabinet' } }
    /**
     * Find zero or one BybitCabinet that matches the filter.
     * @param {BybitCabinetFindUniqueArgs} args - Arguments to find a BybitCabinet
     * @example
     * // Get one BybitCabinet
     * const bybitCabinet = await prisma.bybitCabinet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BybitCabinetFindUniqueArgs>(args: SelectSubset<T, BybitCabinetFindUniqueArgs<ExtArgs>>): Prisma__BybitCabinetClient<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BybitCabinet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BybitCabinetFindUniqueOrThrowArgs} args - Arguments to find a BybitCabinet
     * @example
     * // Get one BybitCabinet
     * const bybitCabinet = await prisma.bybitCabinet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BybitCabinetFindUniqueOrThrowArgs>(args: SelectSubset<T, BybitCabinetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BybitCabinetClient<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitCabinet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitCabinetFindFirstArgs} args - Arguments to find a BybitCabinet
     * @example
     * // Get one BybitCabinet
     * const bybitCabinet = await prisma.bybitCabinet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BybitCabinetFindFirstArgs>(args?: SelectSubset<T, BybitCabinetFindFirstArgs<ExtArgs>>): Prisma__BybitCabinetClient<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitCabinet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitCabinetFindFirstOrThrowArgs} args - Arguments to find a BybitCabinet
     * @example
     * // Get one BybitCabinet
     * const bybitCabinet = await prisma.bybitCabinet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BybitCabinetFindFirstOrThrowArgs>(args?: SelectSubset<T, BybitCabinetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BybitCabinetClient<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BybitCabinets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitCabinetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BybitCabinets
     * const bybitCabinets = await prisma.bybitCabinet.findMany()
     * 
     * // Get first 10 BybitCabinets
     * const bybitCabinets = await prisma.bybitCabinet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bybitCabinetWithIdOnly = await prisma.bybitCabinet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BybitCabinetFindManyArgs>(args?: SelectSubset<T, BybitCabinetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BybitCabinet.
     * @param {BybitCabinetCreateArgs} args - Arguments to create a BybitCabinet.
     * @example
     * // Create one BybitCabinet
     * const BybitCabinet = await prisma.bybitCabinet.create({
     *   data: {
     *     // ... data to create a BybitCabinet
     *   }
     * })
     * 
     */
    create<T extends BybitCabinetCreateArgs>(args: SelectSubset<T, BybitCabinetCreateArgs<ExtArgs>>): Prisma__BybitCabinetClient<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BybitCabinets.
     * @param {BybitCabinetCreateManyArgs} args - Arguments to create many BybitCabinets.
     * @example
     * // Create many BybitCabinets
     * const bybitCabinet = await prisma.bybitCabinet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BybitCabinetCreateManyArgs>(args?: SelectSubset<T, BybitCabinetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BybitCabinets and returns the data saved in the database.
     * @param {BybitCabinetCreateManyAndReturnArgs} args - Arguments to create many BybitCabinets.
     * @example
     * // Create many BybitCabinets
     * const bybitCabinet = await prisma.bybitCabinet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BybitCabinets and only return the `id`
     * const bybitCabinetWithIdOnly = await prisma.bybitCabinet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BybitCabinetCreateManyAndReturnArgs>(args?: SelectSubset<T, BybitCabinetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BybitCabinet.
     * @param {BybitCabinetDeleteArgs} args - Arguments to delete one BybitCabinet.
     * @example
     * // Delete one BybitCabinet
     * const BybitCabinet = await prisma.bybitCabinet.delete({
     *   where: {
     *     // ... filter to delete one BybitCabinet
     *   }
     * })
     * 
     */
    delete<T extends BybitCabinetDeleteArgs>(args: SelectSubset<T, BybitCabinetDeleteArgs<ExtArgs>>): Prisma__BybitCabinetClient<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BybitCabinet.
     * @param {BybitCabinetUpdateArgs} args - Arguments to update one BybitCabinet.
     * @example
     * // Update one BybitCabinet
     * const bybitCabinet = await prisma.bybitCabinet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BybitCabinetUpdateArgs>(args: SelectSubset<T, BybitCabinetUpdateArgs<ExtArgs>>): Prisma__BybitCabinetClient<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BybitCabinets.
     * @param {BybitCabinetDeleteManyArgs} args - Arguments to filter BybitCabinets to delete.
     * @example
     * // Delete a few BybitCabinets
     * const { count } = await prisma.bybitCabinet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BybitCabinetDeleteManyArgs>(args?: SelectSubset<T, BybitCabinetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitCabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitCabinetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BybitCabinets
     * const bybitCabinet = await prisma.bybitCabinet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BybitCabinetUpdateManyArgs>(args: SelectSubset<T, BybitCabinetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitCabinets and returns the data updated in the database.
     * @param {BybitCabinetUpdateManyAndReturnArgs} args - Arguments to update many BybitCabinets.
     * @example
     * // Update many BybitCabinets
     * const bybitCabinet = await prisma.bybitCabinet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BybitCabinets and only return the `id`
     * const bybitCabinetWithIdOnly = await prisma.bybitCabinet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BybitCabinetUpdateManyAndReturnArgs>(args: SelectSubset<T, BybitCabinetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BybitCabinet.
     * @param {BybitCabinetUpsertArgs} args - Arguments to update or create a BybitCabinet.
     * @example
     * // Update or create a BybitCabinet
     * const bybitCabinet = await prisma.bybitCabinet.upsert({
     *   create: {
     *     // ... data to create a BybitCabinet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BybitCabinet we want to update
     *   }
     * })
     */
    upsert<T extends BybitCabinetUpsertArgs>(args: SelectSubset<T, BybitCabinetUpsertArgs<ExtArgs>>): Prisma__BybitCabinetClient<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BybitCabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitCabinetCountArgs} args - Arguments to filter BybitCabinets to count.
     * @example
     * // Count the number of BybitCabinets
     * const count = await prisma.bybitCabinet.count({
     *   where: {
     *     // ... the filter for the BybitCabinets we want to count
     *   }
     * })
    **/
    count<T extends BybitCabinetCountArgs>(
      args?: Subset<T, BybitCabinetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BybitCabinetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BybitCabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitCabinetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BybitCabinetAggregateArgs>(args: Subset<T, BybitCabinetAggregateArgs>): Prisma.PrismaPromise<GetBybitCabinetAggregateType<T>>

    /**
     * Group by BybitCabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitCabinetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BybitCabinetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BybitCabinetGroupByArgs['orderBy'] }
        : { orderBy?: BybitCabinetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BybitCabinetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBybitCabinetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BybitCabinet model
   */
  readonly fields: BybitCabinetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BybitCabinet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BybitCabinetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BybitTransactionFromCabinet<T extends BybitCabinet$BybitTransactionFromCabinetArgs<ExtArgs> = {}>(args?: Subset<T, BybitCabinet$BybitTransactionFromCabinetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BybitOrderInfo<T extends BybitCabinet$BybitOrderInfoArgs<ExtArgs> = {}>(args?: Subset<T, BybitCabinet$BybitOrderInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitOrderInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BybitCabinet model
   */
  interface BybitCabinetFieldRefs {
    readonly id: FieldRef<"BybitCabinet", 'Int'>
    readonly createdAt: FieldRef<"BybitCabinet", 'DateTime'>
    readonly updatedAt: FieldRef<"BybitCabinet", 'DateTime'>
    readonly bybitEmail: FieldRef<"BybitCabinet", 'String'>
    readonly bybitApiSecret: FieldRef<"BybitCabinet", 'String'>
    readonly bybitApiToken: FieldRef<"BybitCabinet", 'String'>
    readonly lastBybitSyncAt: FieldRef<"BybitCabinet", 'DateTime'>
    readonly lastBybitSyncStatus: FieldRef<"BybitCabinet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BybitCabinet findUnique
   */
  export type BybitCabinetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitCabinetInclude<ExtArgs> | null
    /**
     * Filter, which BybitCabinet to fetch.
     */
    where: BybitCabinetWhereUniqueInput
  }

  /**
   * BybitCabinet findUniqueOrThrow
   */
  export type BybitCabinetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitCabinetInclude<ExtArgs> | null
    /**
     * Filter, which BybitCabinet to fetch.
     */
    where: BybitCabinetWhereUniqueInput
  }

  /**
   * BybitCabinet findFirst
   */
  export type BybitCabinetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitCabinetInclude<ExtArgs> | null
    /**
     * Filter, which BybitCabinet to fetch.
     */
    where?: BybitCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitCabinets to fetch.
     */
    orderBy?: BybitCabinetOrderByWithRelationInput | BybitCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitCabinets.
     */
    cursor?: BybitCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitCabinets.
     */
    distinct?: BybitCabinetScalarFieldEnum | BybitCabinetScalarFieldEnum[]
  }

  /**
   * BybitCabinet findFirstOrThrow
   */
  export type BybitCabinetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitCabinetInclude<ExtArgs> | null
    /**
     * Filter, which BybitCabinet to fetch.
     */
    where?: BybitCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitCabinets to fetch.
     */
    orderBy?: BybitCabinetOrderByWithRelationInput | BybitCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitCabinets.
     */
    cursor?: BybitCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitCabinets.
     */
    distinct?: BybitCabinetScalarFieldEnum | BybitCabinetScalarFieldEnum[]
  }

  /**
   * BybitCabinet findMany
   */
  export type BybitCabinetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitCabinetInclude<ExtArgs> | null
    /**
     * Filter, which BybitCabinets to fetch.
     */
    where?: BybitCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitCabinets to fetch.
     */
    orderBy?: BybitCabinetOrderByWithRelationInput | BybitCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BybitCabinets.
     */
    cursor?: BybitCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitCabinets.
     */
    skip?: number
    distinct?: BybitCabinetScalarFieldEnum | BybitCabinetScalarFieldEnum[]
  }

  /**
   * BybitCabinet create
   */
  export type BybitCabinetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitCabinetInclude<ExtArgs> | null
    /**
     * The data needed to create a BybitCabinet.
     */
    data: XOR<BybitCabinetCreateInput, BybitCabinetUncheckedCreateInput>
  }

  /**
   * BybitCabinet createMany
   */
  export type BybitCabinetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BybitCabinets.
     */
    data: BybitCabinetCreateManyInput | BybitCabinetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BybitCabinet createManyAndReturn
   */
  export type BybitCabinetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * The data used to create many BybitCabinets.
     */
    data: BybitCabinetCreateManyInput | BybitCabinetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BybitCabinet update
   */
  export type BybitCabinetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitCabinetInclude<ExtArgs> | null
    /**
     * The data needed to update a BybitCabinet.
     */
    data: XOR<BybitCabinetUpdateInput, BybitCabinetUncheckedUpdateInput>
    /**
     * Choose, which BybitCabinet to update.
     */
    where: BybitCabinetWhereUniqueInput
  }

  /**
   * BybitCabinet updateMany
   */
  export type BybitCabinetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BybitCabinets.
     */
    data: XOR<BybitCabinetUpdateManyMutationInput, BybitCabinetUncheckedUpdateManyInput>
    /**
     * Filter which BybitCabinets to update
     */
    where?: BybitCabinetWhereInput
    /**
     * Limit how many BybitCabinets to update.
     */
    limit?: number
  }

  /**
   * BybitCabinet updateManyAndReturn
   */
  export type BybitCabinetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * The data used to update BybitCabinets.
     */
    data: XOR<BybitCabinetUpdateManyMutationInput, BybitCabinetUncheckedUpdateManyInput>
    /**
     * Filter which BybitCabinets to update
     */
    where?: BybitCabinetWhereInput
    /**
     * Limit how many BybitCabinets to update.
     */
    limit?: number
  }

  /**
   * BybitCabinet upsert
   */
  export type BybitCabinetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitCabinetInclude<ExtArgs> | null
    /**
     * The filter to search for the BybitCabinet to update in case it exists.
     */
    where: BybitCabinetWhereUniqueInput
    /**
     * In case the BybitCabinet found by the `where` argument doesn't exist, create a new BybitCabinet with this data.
     */
    create: XOR<BybitCabinetCreateInput, BybitCabinetUncheckedCreateInput>
    /**
     * In case the BybitCabinet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BybitCabinetUpdateInput, BybitCabinetUncheckedUpdateInput>
  }

  /**
   * BybitCabinet delete
   */
  export type BybitCabinetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitCabinetInclude<ExtArgs> | null
    /**
     * Filter which BybitCabinet to delete.
     */
    where: BybitCabinetWhereUniqueInput
  }

  /**
   * BybitCabinet deleteMany
   */
  export type BybitCabinetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitCabinets to delete
     */
    where?: BybitCabinetWhereInput
    /**
     * Limit how many BybitCabinets to delete.
     */
    limit?: number
  }

  /**
   * BybitCabinet.BybitTransactionFromCabinet
   */
  export type BybitCabinet$BybitTransactionFromCabinetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetInclude<ExtArgs> | null
    where?: BybitTransactionFromCabinetWhereInput
    orderBy?: BybitTransactionFromCabinetOrderByWithRelationInput | BybitTransactionFromCabinetOrderByWithRelationInput[]
    cursor?: BybitTransactionFromCabinetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BybitTransactionFromCabinetScalarFieldEnum | BybitTransactionFromCabinetScalarFieldEnum[]
  }

  /**
   * BybitCabinet.BybitOrderInfo
   */
  export type BybitCabinet$BybitOrderInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitOrderInfo
     */
    select?: BybitOrderInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitOrderInfo
     */
    omit?: BybitOrderInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitOrderInfoInclude<ExtArgs> | null
    where?: BybitOrderInfoWhereInput
    orderBy?: BybitOrderInfoOrderByWithRelationInput | BybitOrderInfoOrderByWithRelationInput[]
    cursor?: BybitOrderInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BybitOrderInfoScalarFieldEnum | BybitOrderInfoScalarFieldEnum[]
  }

  /**
   * BybitCabinet without action
   */
  export type BybitCabinetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitCabinet
     */
    select?: BybitCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitCabinet
     */
    omit?: BybitCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitCabinetInclude<ExtArgs> | null
  }


  /**
   * Model BybitClipMatch
   */

  export type AggregateBybitClipMatch = {
    _count: BybitClipMatchCountAggregateOutputType | null
    _avg: BybitClipMatchAvgAggregateOutputType | null
    _sum: BybitClipMatchSumAggregateOutputType | null
    _min: BybitClipMatchMinAggregateOutputType | null
    _max: BybitClipMatchMaxAggregateOutputType | null
  }

  export type BybitClipMatchAvgAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    bybitTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    matchBybitReportId: number | null
    userId: number | null
  }

  export type BybitClipMatchSumAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    bybitTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    matchBybitReportId: number | null
    userId: number | null
  }

  export type BybitClipMatchMinAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    bybitTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    matchBybitReportId: number | null
    userId: number | null
  }

  export type BybitClipMatchMaxAggregateOutputType = {
    id: number | null
    idexTransactionId: number | null
    bybitTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    matchBybitReportId: number | null
    userId: number | null
  }

  export type BybitClipMatchCountAggregateOutputType = {
    id: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt: number
    updatedAt: number
    matchBybitReportId: number
    userId: number
    _all: number
  }


  export type BybitClipMatchAvgAggregateInputType = {
    id?: true
    idexTransactionId?: true
    bybitTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    matchBybitReportId?: true
    userId?: true
  }

  export type BybitClipMatchSumAggregateInputType = {
    id?: true
    idexTransactionId?: true
    bybitTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    matchBybitReportId?: true
    userId?: true
  }

  export type BybitClipMatchMinAggregateInputType = {
    id?: true
    idexTransactionId?: true
    bybitTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
    matchBybitReportId?: true
    userId?: true
  }

  export type BybitClipMatchMaxAggregateInputType = {
    id?: true
    idexTransactionId?: true
    bybitTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
    matchBybitReportId?: true
    userId?: true
  }

  export type BybitClipMatchCountAggregateInputType = {
    id?: true
    idexTransactionId?: true
    bybitTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
    matchBybitReportId?: true
    userId?: true
    _all?: true
  }

  export type BybitClipMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitClipMatch to aggregate.
     */
    where?: BybitClipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitClipMatches to fetch.
     */
    orderBy?: BybitClipMatchOrderByWithRelationInput | BybitClipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BybitClipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitClipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitClipMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BybitClipMatches
    **/
    _count?: true | BybitClipMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BybitClipMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BybitClipMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BybitClipMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BybitClipMatchMaxAggregateInputType
  }

  export type GetBybitClipMatchAggregateType<T extends BybitClipMatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBybitClipMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBybitClipMatch[P]>
      : GetScalarType<T[P], AggregateBybitClipMatch[P]>
  }




  export type BybitClipMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitClipMatchWhereInput
    orderBy?: BybitClipMatchOrderByWithAggregationInput | BybitClipMatchOrderByWithAggregationInput[]
    by: BybitClipMatchScalarFieldEnum[] | BybitClipMatchScalarFieldEnum
    having?: BybitClipMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BybitClipMatchCountAggregateInputType | true
    _avg?: BybitClipMatchAvgAggregateInputType
    _sum?: BybitClipMatchSumAggregateInputType
    _min?: BybitClipMatchMinAggregateInputType
    _max?: BybitClipMatchMaxAggregateInputType
  }

  export type BybitClipMatchGroupByOutputType = {
    id: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt: Date
    updatedAt: Date
    matchBybitReportId: number | null
    userId: number
    _count: BybitClipMatchCountAggregateOutputType | null
    _avg: BybitClipMatchAvgAggregateOutputType | null
    _sum: BybitClipMatchSumAggregateOutputType | null
    _min: BybitClipMatchMinAggregateOutputType | null
    _max: BybitClipMatchMaxAggregateOutputType | null
  }

  type GetBybitClipMatchGroupByPayload<T extends BybitClipMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BybitClipMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BybitClipMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BybitClipMatchGroupByOutputType[P]>
            : GetScalarType<T[P], BybitClipMatchGroupByOutputType[P]>
        }
      >
    >


  export type BybitClipMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idexTransactionId?: boolean
    bybitTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchBybitReportId?: boolean
    userId?: boolean
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    MatchBybitReport?: boolean | BybitClipMatch$MatchBybitReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitClipMatch"]>

  export type BybitClipMatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idexTransactionId?: boolean
    bybitTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchBybitReportId?: boolean
    userId?: boolean
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    MatchBybitReport?: boolean | BybitClipMatch$MatchBybitReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitClipMatch"]>

  export type BybitClipMatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idexTransactionId?: boolean
    bybitTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchBybitReportId?: boolean
    userId?: boolean
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    MatchBybitReport?: boolean | BybitClipMatch$MatchBybitReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitClipMatch"]>

  export type BybitClipMatchSelectScalar = {
    id?: boolean
    idexTransactionId?: boolean
    bybitTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchBybitReportId?: boolean
    userId?: boolean
  }

  export type BybitClipMatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idexTransactionId" | "bybitTransactionId" | "timeDifference" | "grossExpense" | "grossIncome" | "grossProfit" | "profitPercentage" | "createdAt" | "updatedAt" | "matchBybitReportId" | "userId", ExtArgs["result"]["bybitClipMatch"]>
  export type BybitClipMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    MatchBybitReport?: boolean | BybitClipMatch$MatchBybitReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BybitClipMatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    MatchBybitReport?: boolean | BybitClipMatch$MatchBybitReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BybitClipMatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    IdexTransaction?: boolean | IdexTransactionDefaultArgs<ExtArgs>
    MatchBybitReport?: boolean | BybitClipMatch$MatchBybitReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BybitClipMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BybitClipMatch"
    objects: {
      BybitTransactionFromCabinet: Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>
      IdexTransaction: Prisma.$IdexTransactionPayload<ExtArgs>
      MatchBybitReport: Prisma.$MatchBybitReportPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idexTransactionId: number
      bybitTransactionId: number
      timeDifference: number
      grossExpense: number
      grossIncome: number
      grossProfit: number
      profitPercentage: number
      createdAt: Date
      updatedAt: Date
      matchBybitReportId: number | null
      userId: number
    }, ExtArgs["result"]["bybitClipMatch"]>
    composites: {}
  }

  type BybitClipMatchGetPayload<S extends boolean | null | undefined | BybitClipMatchDefaultArgs> = $Result.GetResult<Prisma.$BybitClipMatchPayload, S>

  type BybitClipMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BybitClipMatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BybitClipMatchCountAggregateInputType | true
    }

  export interface BybitClipMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BybitClipMatch'], meta: { name: 'BybitClipMatch' } }
    /**
     * Find zero or one BybitClipMatch that matches the filter.
     * @param {BybitClipMatchFindUniqueArgs} args - Arguments to find a BybitClipMatch
     * @example
     * // Get one BybitClipMatch
     * const bybitClipMatch = await prisma.bybitClipMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BybitClipMatchFindUniqueArgs>(args: SelectSubset<T, BybitClipMatchFindUniqueArgs<ExtArgs>>): Prisma__BybitClipMatchClient<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BybitClipMatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BybitClipMatchFindUniqueOrThrowArgs} args - Arguments to find a BybitClipMatch
     * @example
     * // Get one BybitClipMatch
     * const bybitClipMatch = await prisma.bybitClipMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BybitClipMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, BybitClipMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BybitClipMatchClient<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitClipMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitClipMatchFindFirstArgs} args - Arguments to find a BybitClipMatch
     * @example
     * // Get one BybitClipMatch
     * const bybitClipMatch = await prisma.bybitClipMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BybitClipMatchFindFirstArgs>(args?: SelectSubset<T, BybitClipMatchFindFirstArgs<ExtArgs>>): Prisma__BybitClipMatchClient<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitClipMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitClipMatchFindFirstOrThrowArgs} args - Arguments to find a BybitClipMatch
     * @example
     * // Get one BybitClipMatch
     * const bybitClipMatch = await prisma.bybitClipMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BybitClipMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, BybitClipMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BybitClipMatchClient<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BybitClipMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitClipMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BybitClipMatches
     * const bybitClipMatches = await prisma.bybitClipMatch.findMany()
     * 
     * // Get first 10 BybitClipMatches
     * const bybitClipMatches = await prisma.bybitClipMatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bybitClipMatchWithIdOnly = await prisma.bybitClipMatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BybitClipMatchFindManyArgs>(args?: SelectSubset<T, BybitClipMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BybitClipMatch.
     * @param {BybitClipMatchCreateArgs} args - Arguments to create a BybitClipMatch.
     * @example
     * // Create one BybitClipMatch
     * const BybitClipMatch = await prisma.bybitClipMatch.create({
     *   data: {
     *     // ... data to create a BybitClipMatch
     *   }
     * })
     * 
     */
    create<T extends BybitClipMatchCreateArgs>(args: SelectSubset<T, BybitClipMatchCreateArgs<ExtArgs>>): Prisma__BybitClipMatchClient<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BybitClipMatches.
     * @param {BybitClipMatchCreateManyArgs} args - Arguments to create many BybitClipMatches.
     * @example
     * // Create many BybitClipMatches
     * const bybitClipMatch = await prisma.bybitClipMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BybitClipMatchCreateManyArgs>(args?: SelectSubset<T, BybitClipMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BybitClipMatches and returns the data saved in the database.
     * @param {BybitClipMatchCreateManyAndReturnArgs} args - Arguments to create many BybitClipMatches.
     * @example
     * // Create many BybitClipMatches
     * const bybitClipMatch = await prisma.bybitClipMatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BybitClipMatches and only return the `id`
     * const bybitClipMatchWithIdOnly = await prisma.bybitClipMatch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BybitClipMatchCreateManyAndReturnArgs>(args?: SelectSubset<T, BybitClipMatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BybitClipMatch.
     * @param {BybitClipMatchDeleteArgs} args - Arguments to delete one BybitClipMatch.
     * @example
     * // Delete one BybitClipMatch
     * const BybitClipMatch = await prisma.bybitClipMatch.delete({
     *   where: {
     *     // ... filter to delete one BybitClipMatch
     *   }
     * })
     * 
     */
    delete<T extends BybitClipMatchDeleteArgs>(args: SelectSubset<T, BybitClipMatchDeleteArgs<ExtArgs>>): Prisma__BybitClipMatchClient<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BybitClipMatch.
     * @param {BybitClipMatchUpdateArgs} args - Arguments to update one BybitClipMatch.
     * @example
     * // Update one BybitClipMatch
     * const bybitClipMatch = await prisma.bybitClipMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BybitClipMatchUpdateArgs>(args: SelectSubset<T, BybitClipMatchUpdateArgs<ExtArgs>>): Prisma__BybitClipMatchClient<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BybitClipMatches.
     * @param {BybitClipMatchDeleteManyArgs} args - Arguments to filter BybitClipMatches to delete.
     * @example
     * // Delete a few BybitClipMatches
     * const { count } = await prisma.bybitClipMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BybitClipMatchDeleteManyArgs>(args?: SelectSubset<T, BybitClipMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitClipMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitClipMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BybitClipMatches
     * const bybitClipMatch = await prisma.bybitClipMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BybitClipMatchUpdateManyArgs>(args: SelectSubset<T, BybitClipMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitClipMatches and returns the data updated in the database.
     * @param {BybitClipMatchUpdateManyAndReturnArgs} args - Arguments to update many BybitClipMatches.
     * @example
     * // Update many BybitClipMatches
     * const bybitClipMatch = await prisma.bybitClipMatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BybitClipMatches and only return the `id`
     * const bybitClipMatchWithIdOnly = await prisma.bybitClipMatch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BybitClipMatchUpdateManyAndReturnArgs>(args: SelectSubset<T, BybitClipMatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BybitClipMatch.
     * @param {BybitClipMatchUpsertArgs} args - Arguments to update or create a BybitClipMatch.
     * @example
     * // Update or create a BybitClipMatch
     * const bybitClipMatch = await prisma.bybitClipMatch.upsert({
     *   create: {
     *     // ... data to create a BybitClipMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BybitClipMatch we want to update
     *   }
     * })
     */
    upsert<T extends BybitClipMatchUpsertArgs>(args: SelectSubset<T, BybitClipMatchUpsertArgs<ExtArgs>>): Prisma__BybitClipMatchClient<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BybitClipMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitClipMatchCountArgs} args - Arguments to filter BybitClipMatches to count.
     * @example
     * // Count the number of BybitClipMatches
     * const count = await prisma.bybitClipMatch.count({
     *   where: {
     *     // ... the filter for the BybitClipMatches we want to count
     *   }
     * })
    **/
    count<T extends BybitClipMatchCountArgs>(
      args?: Subset<T, BybitClipMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BybitClipMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BybitClipMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitClipMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BybitClipMatchAggregateArgs>(args: Subset<T, BybitClipMatchAggregateArgs>): Prisma.PrismaPromise<GetBybitClipMatchAggregateType<T>>

    /**
     * Group by BybitClipMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitClipMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BybitClipMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BybitClipMatchGroupByArgs['orderBy'] }
        : { orderBy?: BybitClipMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BybitClipMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBybitClipMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BybitClipMatch model
   */
  readonly fields: BybitClipMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BybitClipMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BybitClipMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BybitTransactionFromCabinet<T extends BybitTransactionFromCabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BybitTransactionFromCabinetDefaultArgs<ExtArgs>>): Prisma__BybitTransactionFromCabinetClient<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    IdexTransaction<T extends IdexTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IdexTransactionDefaultArgs<ExtArgs>>): Prisma__IdexTransactionClient<$Result.GetResult<Prisma.$IdexTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    MatchBybitReport<T extends BybitClipMatch$MatchBybitReportArgs<ExtArgs> = {}>(args?: Subset<T, BybitClipMatch$MatchBybitReportArgs<ExtArgs>>): Prisma__MatchBybitReportClient<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BybitClipMatch model
   */
  interface BybitClipMatchFieldRefs {
    readonly id: FieldRef<"BybitClipMatch", 'Int'>
    readonly idexTransactionId: FieldRef<"BybitClipMatch", 'Int'>
    readonly bybitTransactionId: FieldRef<"BybitClipMatch", 'Int'>
    readonly timeDifference: FieldRef<"BybitClipMatch", 'Int'>
    readonly grossExpense: FieldRef<"BybitClipMatch", 'Float'>
    readonly grossIncome: FieldRef<"BybitClipMatch", 'Float'>
    readonly grossProfit: FieldRef<"BybitClipMatch", 'Float'>
    readonly profitPercentage: FieldRef<"BybitClipMatch", 'Float'>
    readonly createdAt: FieldRef<"BybitClipMatch", 'DateTime'>
    readonly updatedAt: FieldRef<"BybitClipMatch", 'DateTime'>
    readonly matchBybitReportId: FieldRef<"BybitClipMatch", 'Int'>
    readonly userId: FieldRef<"BybitClipMatch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BybitClipMatch findUnique
   */
  export type BybitClipMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    /**
     * Filter, which BybitClipMatch to fetch.
     */
    where: BybitClipMatchWhereUniqueInput
  }

  /**
   * BybitClipMatch findUniqueOrThrow
   */
  export type BybitClipMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    /**
     * Filter, which BybitClipMatch to fetch.
     */
    where: BybitClipMatchWhereUniqueInput
  }

  /**
   * BybitClipMatch findFirst
   */
  export type BybitClipMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    /**
     * Filter, which BybitClipMatch to fetch.
     */
    where?: BybitClipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitClipMatches to fetch.
     */
    orderBy?: BybitClipMatchOrderByWithRelationInput | BybitClipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitClipMatches.
     */
    cursor?: BybitClipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitClipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitClipMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitClipMatches.
     */
    distinct?: BybitClipMatchScalarFieldEnum | BybitClipMatchScalarFieldEnum[]
  }

  /**
   * BybitClipMatch findFirstOrThrow
   */
  export type BybitClipMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    /**
     * Filter, which BybitClipMatch to fetch.
     */
    where?: BybitClipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitClipMatches to fetch.
     */
    orderBy?: BybitClipMatchOrderByWithRelationInput | BybitClipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitClipMatches.
     */
    cursor?: BybitClipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitClipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitClipMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitClipMatches.
     */
    distinct?: BybitClipMatchScalarFieldEnum | BybitClipMatchScalarFieldEnum[]
  }

  /**
   * BybitClipMatch findMany
   */
  export type BybitClipMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    /**
     * Filter, which BybitClipMatches to fetch.
     */
    where?: BybitClipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitClipMatches to fetch.
     */
    orderBy?: BybitClipMatchOrderByWithRelationInput | BybitClipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BybitClipMatches.
     */
    cursor?: BybitClipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitClipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitClipMatches.
     */
    skip?: number
    distinct?: BybitClipMatchScalarFieldEnum | BybitClipMatchScalarFieldEnum[]
  }

  /**
   * BybitClipMatch create
   */
  export type BybitClipMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a BybitClipMatch.
     */
    data: XOR<BybitClipMatchCreateInput, BybitClipMatchUncheckedCreateInput>
  }

  /**
   * BybitClipMatch createMany
   */
  export type BybitClipMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BybitClipMatches.
     */
    data: BybitClipMatchCreateManyInput | BybitClipMatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BybitClipMatch createManyAndReturn
   */
  export type BybitClipMatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * The data used to create many BybitClipMatches.
     */
    data: BybitClipMatchCreateManyInput | BybitClipMatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BybitClipMatch update
   */
  export type BybitClipMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a BybitClipMatch.
     */
    data: XOR<BybitClipMatchUpdateInput, BybitClipMatchUncheckedUpdateInput>
    /**
     * Choose, which BybitClipMatch to update.
     */
    where: BybitClipMatchWhereUniqueInput
  }

  /**
   * BybitClipMatch updateMany
   */
  export type BybitClipMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BybitClipMatches.
     */
    data: XOR<BybitClipMatchUpdateManyMutationInput, BybitClipMatchUncheckedUpdateManyInput>
    /**
     * Filter which BybitClipMatches to update
     */
    where?: BybitClipMatchWhereInput
    /**
     * Limit how many BybitClipMatches to update.
     */
    limit?: number
  }

  /**
   * BybitClipMatch updateManyAndReturn
   */
  export type BybitClipMatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * The data used to update BybitClipMatches.
     */
    data: XOR<BybitClipMatchUpdateManyMutationInput, BybitClipMatchUncheckedUpdateManyInput>
    /**
     * Filter which BybitClipMatches to update
     */
    where?: BybitClipMatchWhereInput
    /**
     * Limit how many BybitClipMatches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BybitClipMatch upsert
   */
  export type BybitClipMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the BybitClipMatch to update in case it exists.
     */
    where: BybitClipMatchWhereUniqueInput
    /**
     * In case the BybitClipMatch found by the `where` argument doesn't exist, create a new BybitClipMatch with this data.
     */
    create: XOR<BybitClipMatchCreateInput, BybitClipMatchUncheckedCreateInput>
    /**
     * In case the BybitClipMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BybitClipMatchUpdateInput, BybitClipMatchUncheckedUpdateInput>
  }

  /**
   * BybitClipMatch delete
   */
  export type BybitClipMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    /**
     * Filter which BybitClipMatch to delete.
     */
    where: BybitClipMatchWhereUniqueInput
  }

  /**
   * BybitClipMatch deleteMany
   */
  export type BybitClipMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitClipMatches to delete
     */
    where?: BybitClipMatchWhereInput
    /**
     * Limit how many BybitClipMatches to delete.
     */
    limit?: number
  }

  /**
   * BybitClipMatch.MatchBybitReport
   */
  export type BybitClipMatch$MatchBybitReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
    where?: MatchBybitReportWhereInput
  }

  /**
   * BybitClipMatch without action
   */
  export type BybitClipMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
  }


  /**
   * Model BybitTransactionFromCabinet
   */

  export type AggregateBybitTransactionFromCabinet = {
    _count: BybitTransactionFromCabinetCountAggregateOutputType | null
    _avg: BybitTransactionFromCabinetAvgAggregateOutputType | null
    _sum: BybitTransactionFromCabinetSumAggregateOutputType | null
    _min: BybitTransactionFromCabinetMinAggregateOutputType | null
    _max: BybitTransactionFromCabinetMaxAggregateOutputType | null
  }

  export type BybitTransactionFromCabinetAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    totalPrice: number | null
    unitPrice: number | null
    cabinetId: number | null
  }

  export type BybitTransactionFromCabinetSumAggregateOutputType = {
    id: number | null
    amount: number | null
    totalPrice: number | null
    unitPrice: number | null
    cabinetId: number | null
  }

  export type BybitTransactionFromCabinetMinAggregateOutputType = {
    id: number | null
    orderNo: string | null
    counterparty: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    amount: number | null
    asset: string | null
    dateTime: Date | null
    totalPrice: number | null
    type: string | null
    unitPrice: number | null
    processed: boolean | null
    lastAttemptError: string | null
    cabinetId: number | null
  }

  export type BybitTransactionFromCabinetMaxAggregateOutputType = {
    id: number | null
    orderNo: string | null
    counterparty: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    amount: number | null
    asset: string | null
    dateTime: Date | null
    totalPrice: number | null
    type: string | null
    unitPrice: number | null
    processed: boolean | null
    lastAttemptError: string | null
    cabinetId: number | null
  }

  export type BybitTransactionFromCabinetCountAggregateOutputType = {
    id: number
    orderNo: number
    counterparty: number
    status: number
    createdAt: number
    updatedAt: number
    amount: number
    asset: number
    dateTime: number
    originalData: number
    totalPrice: number
    type: number
    unitPrice: number
    processed: number
    extractedPhones: number
    lastAttemptError: number
    cabinetId: number
    _all: number
  }


  export type BybitTransactionFromCabinetAvgAggregateInputType = {
    id?: true
    amount?: true
    totalPrice?: true
    unitPrice?: true
    cabinetId?: true
  }

  export type BybitTransactionFromCabinetSumAggregateInputType = {
    id?: true
    amount?: true
    totalPrice?: true
    unitPrice?: true
    cabinetId?: true
  }

  export type BybitTransactionFromCabinetMinAggregateInputType = {
    id?: true
    orderNo?: true
    counterparty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    amount?: true
    asset?: true
    dateTime?: true
    totalPrice?: true
    type?: true
    unitPrice?: true
    processed?: true
    lastAttemptError?: true
    cabinetId?: true
  }

  export type BybitTransactionFromCabinetMaxAggregateInputType = {
    id?: true
    orderNo?: true
    counterparty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    amount?: true
    asset?: true
    dateTime?: true
    totalPrice?: true
    type?: true
    unitPrice?: true
    processed?: true
    lastAttemptError?: true
    cabinetId?: true
  }

  export type BybitTransactionFromCabinetCountAggregateInputType = {
    id?: true
    orderNo?: true
    counterparty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    amount?: true
    asset?: true
    dateTime?: true
    originalData?: true
    totalPrice?: true
    type?: true
    unitPrice?: true
    processed?: true
    extractedPhones?: true
    lastAttemptError?: true
    cabinetId?: true
    _all?: true
  }

  export type BybitTransactionFromCabinetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitTransactionFromCabinet to aggregate.
     */
    where?: BybitTransactionFromCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitTransactionFromCabinets to fetch.
     */
    orderBy?: BybitTransactionFromCabinetOrderByWithRelationInput | BybitTransactionFromCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BybitTransactionFromCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitTransactionFromCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitTransactionFromCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BybitTransactionFromCabinets
    **/
    _count?: true | BybitTransactionFromCabinetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BybitTransactionFromCabinetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BybitTransactionFromCabinetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BybitTransactionFromCabinetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BybitTransactionFromCabinetMaxAggregateInputType
  }

  export type GetBybitTransactionFromCabinetAggregateType<T extends BybitTransactionFromCabinetAggregateArgs> = {
        [P in keyof T & keyof AggregateBybitTransactionFromCabinet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBybitTransactionFromCabinet[P]>
      : GetScalarType<T[P], AggregateBybitTransactionFromCabinet[P]>
  }




  export type BybitTransactionFromCabinetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BybitTransactionFromCabinetWhereInput
    orderBy?: BybitTransactionFromCabinetOrderByWithAggregationInput | BybitTransactionFromCabinetOrderByWithAggregationInput[]
    by: BybitTransactionFromCabinetScalarFieldEnum[] | BybitTransactionFromCabinetScalarFieldEnum
    having?: BybitTransactionFromCabinetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BybitTransactionFromCabinetCountAggregateInputType | true
    _avg?: BybitTransactionFromCabinetAvgAggregateInputType
    _sum?: BybitTransactionFromCabinetSumAggregateInputType
    _min?: BybitTransactionFromCabinetMinAggregateInputType
    _max?: BybitTransactionFromCabinetMaxAggregateInputType
  }

  export type BybitTransactionFromCabinetGroupByOutputType = {
    id: number
    orderNo: string
    counterparty: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    amount: number
    asset: string
    dateTime: Date
    originalData: JsonValue | null
    totalPrice: number
    type: string
    unitPrice: number
    processed: boolean
    extractedPhones: string[]
    lastAttemptError: string | null
    cabinetId: number
    _count: BybitTransactionFromCabinetCountAggregateOutputType | null
    _avg: BybitTransactionFromCabinetAvgAggregateOutputType | null
    _sum: BybitTransactionFromCabinetSumAggregateOutputType | null
    _min: BybitTransactionFromCabinetMinAggregateOutputType | null
    _max: BybitTransactionFromCabinetMaxAggregateOutputType | null
  }

  type GetBybitTransactionFromCabinetGroupByPayload<T extends BybitTransactionFromCabinetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BybitTransactionFromCabinetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BybitTransactionFromCabinetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BybitTransactionFromCabinetGroupByOutputType[P]>
            : GetScalarType<T[P], BybitTransactionFromCabinetGroupByOutputType[P]>
        }
      >
    >


  export type BybitTransactionFromCabinetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    counterparty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    amount?: boolean
    asset?: boolean
    dateTime?: boolean
    originalData?: boolean
    totalPrice?: boolean
    type?: boolean
    unitPrice?: boolean
    processed?: boolean
    extractedPhones?: boolean
    lastAttemptError?: boolean
    cabinetId?: boolean
    BybitClipMatch?: boolean | BybitTransactionFromCabinet$BybitClipMatchArgs<ExtArgs>
    BybitCabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
    ViresClipMatch?: boolean | BybitTransactionFromCabinet$ViresClipMatchArgs<ExtArgs>
    _count?: boolean | BybitTransactionFromCabinetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitTransactionFromCabinet"]>

  export type BybitTransactionFromCabinetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    counterparty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    amount?: boolean
    asset?: boolean
    dateTime?: boolean
    originalData?: boolean
    totalPrice?: boolean
    type?: boolean
    unitPrice?: boolean
    processed?: boolean
    extractedPhones?: boolean
    lastAttemptError?: boolean
    cabinetId?: boolean
    BybitCabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitTransactionFromCabinet"]>

  export type BybitTransactionFromCabinetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    counterparty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    amount?: boolean
    asset?: boolean
    dateTime?: boolean
    originalData?: boolean
    totalPrice?: boolean
    type?: boolean
    unitPrice?: boolean
    processed?: boolean
    extractedPhones?: boolean
    lastAttemptError?: boolean
    cabinetId?: boolean
    BybitCabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bybitTransactionFromCabinet"]>

  export type BybitTransactionFromCabinetSelectScalar = {
    id?: boolean
    orderNo?: boolean
    counterparty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    amount?: boolean
    asset?: boolean
    dateTime?: boolean
    originalData?: boolean
    totalPrice?: boolean
    type?: boolean
    unitPrice?: boolean
    processed?: boolean
    extractedPhones?: boolean
    lastAttemptError?: boolean
    cabinetId?: boolean
  }

  export type BybitTransactionFromCabinetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNo" | "counterparty" | "status" | "createdAt" | "updatedAt" | "amount" | "asset" | "dateTime" | "originalData" | "totalPrice" | "type" | "unitPrice" | "processed" | "extractedPhones" | "lastAttemptError" | "cabinetId", ExtArgs["result"]["bybitTransactionFromCabinet"]>
  export type BybitTransactionFromCabinetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitClipMatch?: boolean | BybitTransactionFromCabinet$BybitClipMatchArgs<ExtArgs>
    BybitCabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
    ViresClipMatch?: boolean | BybitTransactionFromCabinet$ViresClipMatchArgs<ExtArgs>
    _count?: boolean | BybitTransactionFromCabinetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BybitTransactionFromCabinetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitCabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
  }
  export type BybitTransactionFromCabinetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitCabinet?: boolean | BybitCabinetDefaultArgs<ExtArgs>
  }

  export type $BybitTransactionFromCabinetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BybitTransactionFromCabinet"
    objects: {
      BybitClipMatch: Prisma.$BybitClipMatchPayload<ExtArgs>[]
      BybitCabinet: Prisma.$BybitCabinetPayload<ExtArgs>
      ViresClipMatch: Prisma.$ViresClipMatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderNo: string
      counterparty: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      amount: number
      asset: string
      dateTime: Date
      originalData: Prisma.JsonValue | null
      totalPrice: number
      type: string
      unitPrice: number
      processed: boolean
      extractedPhones: string[]
      lastAttemptError: string | null
      cabinetId: number
    }, ExtArgs["result"]["bybitTransactionFromCabinet"]>
    composites: {}
  }

  type BybitTransactionFromCabinetGetPayload<S extends boolean | null | undefined | BybitTransactionFromCabinetDefaultArgs> = $Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload, S>

  type BybitTransactionFromCabinetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BybitTransactionFromCabinetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BybitTransactionFromCabinetCountAggregateInputType | true
    }

  export interface BybitTransactionFromCabinetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BybitTransactionFromCabinet'], meta: { name: 'BybitTransactionFromCabinet' } }
    /**
     * Find zero or one BybitTransactionFromCabinet that matches the filter.
     * @param {BybitTransactionFromCabinetFindUniqueArgs} args - Arguments to find a BybitTransactionFromCabinet
     * @example
     * // Get one BybitTransactionFromCabinet
     * const bybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BybitTransactionFromCabinetFindUniqueArgs>(args: SelectSubset<T, BybitTransactionFromCabinetFindUniqueArgs<ExtArgs>>): Prisma__BybitTransactionFromCabinetClient<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BybitTransactionFromCabinet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BybitTransactionFromCabinetFindUniqueOrThrowArgs} args - Arguments to find a BybitTransactionFromCabinet
     * @example
     * // Get one BybitTransactionFromCabinet
     * const bybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BybitTransactionFromCabinetFindUniqueOrThrowArgs>(args: SelectSubset<T, BybitTransactionFromCabinetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BybitTransactionFromCabinetClient<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitTransactionFromCabinet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionFromCabinetFindFirstArgs} args - Arguments to find a BybitTransactionFromCabinet
     * @example
     * // Get one BybitTransactionFromCabinet
     * const bybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BybitTransactionFromCabinetFindFirstArgs>(args?: SelectSubset<T, BybitTransactionFromCabinetFindFirstArgs<ExtArgs>>): Prisma__BybitTransactionFromCabinetClient<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BybitTransactionFromCabinet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionFromCabinetFindFirstOrThrowArgs} args - Arguments to find a BybitTransactionFromCabinet
     * @example
     * // Get one BybitTransactionFromCabinet
     * const bybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BybitTransactionFromCabinetFindFirstOrThrowArgs>(args?: SelectSubset<T, BybitTransactionFromCabinetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BybitTransactionFromCabinetClient<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BybitTransactionFromCabinets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionFromCabinetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BybitTransactionFromCabinets
     * const bybitTransactionFromCabinets = await prisma.bybitTransactionFromCabinet.findMany()
     * 
     * // Get first 10 BybitTransactionFromCabinets
     * const bybitTransactionFromCabinets = await prisma.bybitTransactionFromCabinet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bybitTransactionFromCabinetWithIdOnly = await prisma.bybitTransactionFromCabinet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BybitTransactionFromCabinetFindManyArgs>(args?: SelectSubset<T, BybitTransactionFromCabinetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BybitTransactionFromCabinet.
     * @param {BybitTransactionFromCabinetCreateArgs} args - Arguments to create a BybitTransactionFromCabinet.
     * @example
     * // Create one BybitTransactionFromCabinet
     * const BybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.create({
     *   data: {
     *     // ... data to create a BybitTransactionFromCabinet
     *   }
     * })
     * 
     */
    create<T extends BybitTransactionFromCabinetCreateArgs>(args: SelectSubset<T, BybitTransactionFromCabinetCreateArgs<ExtArgs>>): Prisma__BybitTransactionFromCabinetClient<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BybitTransactionFromCabinets.
     * @param {BybitTransactionFromCabinetCreateManyArgs} args - Arguments to create many BybitTransactionFromCabinets.
     * @example
     * // Create many BybitTransactionFromCabinets
     * const bybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BybitTransactionFromCabinetCreateManyArgs>(args?: SelectSubset<T, BybitTransactionFromCabinetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BybitTransactionFromCabinets and returns the data saved in the database.
     * @param {BybitTransactionFromCabinetCreateManyAndReturnArgs} args - Arguments to create many BybitTransactionFromCabinets.
     * @example
     * // Create many BybitTransactionFromCabinets
     * const bybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BybitTransactionFromCabinets and only return the `id`
     * const bybitTransactionFromCabinetWithIdOnly = await prisma.bybitTransactionFromCabinet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BybitTransactionFromCabinetCreateManyAndReturnArgs>(args?: SelectSubset<T, BybitTransactionFromCabinetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BybitTransactionFromCabinet.
     * @param {BybitTransactionFromCabinetDeleteArgs} args - Arguments to delete one BybitTransactionFromCabinet.
     * @example
     * // Delete one BybitTransactionFromCabinet
     * const BybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.delete({
     *   where: {
     *     // ... filter to delete one BybitTransactionFromCabinet
     *   }
     * })
     * 
     */
    delete<T extends BybitTransactionFromCabinetDeleteArgs>(args: SelectSubset<T, BybitTransactionFromCabinetDeleteArgs<ExtArgs>>): Prisma__BybitTransactionFromCabinetClient<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BybitTransactionFromCabinet.
     * @param {BybitTransactionFromCabinetUpdateArgs} args - Arguments to update one BybitTransactionFromCabinet.
     * @example
     * // Update one BybitTransactionFromCabinet
     * const bybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BybitTransactionFromCabinetUpdateArgs>(args: SelectSubset<T, BybitTransactionFromCabinetUpdateArgs<ExtArgs>>): Prisma__BybitTransactionFromCabinetClient<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BybitTransactionFromCabinets.
     * @param {BybitTransactionFromCabinetDeleteManyArgs} args - Arguments to filter BybitTransactionFromCabinets to delete.
     * @example
     * // Delete a few BybitTransactionFromCabinets
     * const { count } = await prisma.bybitTransactionFromCabinet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BybitTransactionFromCabinetDeleteManyArgs>(args?: SelectSubset<T, BybitTransactionFromCabinetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitTransactionFromCabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionFromCabinetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BybitTransactionFromCabinets
     * const bybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BybitTransactionFromCabinetUpdateManyArgs>(args: SelectSubset<T, BybitTransactionFromCabinetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BybitTransactionFromCabinets and returns the data updated in the database.
     * @param {BybitTransactionFromCabinetUpdateManyAndReturnArgs} args - Arguments to update many BybitTransactionFromCabinets.
     * @example
     * // Update many BybitTransactionFromCabinets
     * const bybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BybitTransactionFromCabinets and only return the `id`
     * const bybitTransactionFromCabinetWithIdOnly = await prisma.bybitTransactionFromCabinet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BybitTransactionFromCabinetUpdateManyAndReturnArgs>(args: SelectSubset<T, BybitTransactionFromCabinetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BybitTransactionFromCabinet.
     * @param {BybitTransactionFromCabinetUpsertArgs} args - Arguments to update or create a BybitTransactionFromCabinet.
     * @example
     * // Update or create a BybitTransactionFromCabinet
     * const bybitTransactionFromCabinet = await prisma.bybitTransactionFromCabinet.upsert({
     *   create: {
     *     // ... data to create a BybitTransactionFromCabinet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BybitTransactionFromCabinet we want to update
     *   }
     * })
     */
    upsert<T extends BybitTransactionFromCabinetUpsertArgs>(args: SelectSubset<T, BybitTransactionFromCabinetUpsertArgs<ExtArgs>>): Prisma__BybitTransactionFromCabinetClient<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BybitTransactionFromCabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionFromCabinetCountArgs} args - Arguments to filter BybitTransactionFromCabinets to count.
     * @example
     * // Count the number of BybitTransactionFromCabinets
     * const count = await prisma.bybitTransactionFromCabinet.count({
     *   where: {
     *     // ... the filter for the BybitTransactionFromCabinets we want to count
     *   }
     * })
    **/
    count<T extends BybitTransactionFromCabinetCountArgs>(
      args?: Subset<T, BybitTransactionFromCabinetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BybitTransactionFromCabinetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BybitTransactionFromCabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionFromCabinetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BybitTransactionFromCabinetAggregateArgs>(args: Subset<T, BybitTransactionFromCabinetAggregateArgs>): Prisma.PrismaPromise<GetBybitTransactionFromCabinetAggregateType<T>>

    /**
     * Group by BybitTransactionFromCabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BybitTransactionFromCabinetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BybitTransactionFromCabinetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BybitTransactionFromCabinetGroupByArgs['orderBy'] }
        : { orderBy?: BybitTransactionFromCabinetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BybitTransactionFromCabinetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBybitTransactionFromCabinetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BybitTransactionFromCabinet model
   */
  readonly fields: BybitTransactionFromCabinetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BybitTransactionFromCabinet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BybitTransactionFromCabinetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BybitClipMatch<T extends BybitTransactionFromCabinet$BybitClipMatchArgs<ExtArgs> = {}>(args?: Subset<T, BybitTransactionFromCabinet$BybitClipMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BybitCabinet<T extends BybitCabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BybitCabinetDefaultArgs<ExtArgs>>): Prisma__BybitCabinetClient<$Result.GetResult<Prisma.$BybitCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ViresClipMatch<T extends BybitTransactionFromCabinet$ViresClipMatchArgs<ExtArgs> = {}>(args?: Subset<T, BybitTransactionFromCabinet$ViresClipMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BybitTransactionFromCabinet model
   */
  interface BybitTransactionFromCabinetFieldRefs {
    readonly id: FieldRef<"BybitTransactionFromCabinet", 'Int'>
    readonly orderNo: FieldRef<"BybitTransactionFromCabinet", 'String'>
    readonly counterparty: FieldRef<"BybitTransactionFromCabinet", 'String'>
    readonly status: FieldRef<"BybitTransactionFromCabinet", 'String'>
    readonly createdAt: FieldRef<"BybitTransactionFromCabinet", 'DateTime'>
    readonly updatedAt: FieldRef<"BybitTransactionFromCabinet", 'DateTime'>
    readonly amount: FieldRef<"BybitTransactionFromCabinet", 'Float'>
    readonly asset: FieldRef<"BybitTransactionFromCabinet", 'String'>
    readonly dateTime: FieldRef<"BybitTransactionFromCabinet", 'DateTime'>
    readonly originalData: FieldRef<"BybitTransactionFromCabinet", 'Json'>
    readonly totalPrice: FieldRef<"BybitTransactionFromCabinet", 'Float'>
    readonly type: FieldRef<"BybitTransactionFromCabinet", 'String'>
    readonly unitPrice: FieldRef<"BybitTransactionFromCabinet", 'Float'>
    readonly processed: FieldRef<"BybitTransactionFromCabinet", 'Boolean'>
    readonly extractedPhones: FieldRef<"BybitTransactionFromCabinet", 'String[]'>
    readonly lastAttemptError: FieldRef<"BybitTransactionFromCabinet", 'String'>
    readonly cabinetId: FieldRef<"BybitTransactionFromCabinet", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BybitTransactionFromCabinet findUnique
   */
  export type BybitTransactionFromCabinetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetInclude<ExtArgs> | null
    /**
     * Filter, which BybitTransactionFromCabinet to fetch.
     */
    where: BybitTransactionFromCabinetWhereUniqueInput
  }

  /**
   * BybitTransactionFromCabinet findUniqueOrThrow
   */
  export type BybitTransactionFromCabinetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetInclude<ExtArgs> | null
    /**
     * Filter, which BybitTransactionFromCabinet to fetch.
     */
    where: BybitTransactionFromCabinetWhereUniqueInput
  }

  /**
   * BybitTransactionFromCabinet findFirst
   */
  export type BybitTransactionFromCabinetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetInclude<ExtArgs> | null
    /**
     * Filter, which BybitTransactionFromCabinet to fetch.
     */
    where?: BybitTransactionFromCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitTransactionFromCabinets to fetch.
     */
    orderBy?: BybitTransactionFromCabinetOrderByWithRelationInput | BybitTransactionFromCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitTransactionFromCabinets.
     */
    cursor?: BybitTransactionFromCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitTransactionFromCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitTransactionFromCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitTransactionFromCabinets.
     */
    distinct?: BybitTransactionFromCabinetScalarFieldEnum | BybitTransactionFromCabinetScalarFieldEnum[]
  }

  /**
   * BybitTransactionFromCabinet findFirstOrThrow
   */
  export type BybitTransactionFromCabinetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetInclude<ExtArgs> | null
    /**
     * Filter, which BybitTransactionFromCabinet to fetch.
     */
    where?: BybitTransactionFromCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitTransactionFromCabinets to fetch.
     */
    orderBy?: BybitTransactionFromCabinetOrderByWithRelationInput | BybitTransactionFromCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BybitTransactionFromCabinets.
     */
    cursor?: BybitTransactionFromCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitTransactionFromCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitTransactionFromCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BybitTransactionFromCabinets.
     */
    distinct?: BybitTransactionFromCabinetScalarFieldEnum | BybitTransactionFromCabinetScalarFieldEnum[]
  }

  /**
   * BybitTransactionFromCabinet findMany
   */
  export type BybitTransactionFromCabinetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetInclude<ExtArgs> | null
    /**
     * Filter, which BybitTransactionFromCabinets to fetch.
     */
    where?: BybitTransactionFromCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BybitTransactionFromCabinets to fetch.
     */
    orderBy?: BybitTransactionFromCabinetOrderByWithRelationInput | BybitTransactionFromCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BybitTransactionFromCabinets.
     */
    cursor?: BybitTransactionFromCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BybitTransactionFromCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BybitTransactionFromCabinets.
     */
    skip?: number
    distinct?: BybitTransactionFromCabinetScalarFieldEnum | BybitTransactionFromCabinetScalarFieldEnum[]
  }

  /**
   * BybitTransactionFromCabinet create
   */
  export type BybitTransactionFromCabinetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetInclude<ExtArgs> | null
    /**
     * The data needed to create a BybitTransactionFromCabinet.
     */
    data: XOR<BybitTransactionFromCabinetCreateInput, BybitTransactionFromCabinetUncheckedCreateInput>
  }

  /**
   * BybitTransactionFromCabinet createMany
   */
  export type BybitTransactionFromCabinetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BybitTransactionFromCabinets.
     */
    data: BybitTransactionFromCabinetCreateManyInput | BybitTransactionFromCabinetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BybitTransactionFromCabinet createManyAndReturn
   */
  export type BybitTransactionFromCabinetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * The data used to create many BybitTransactionFromCabinets.
     */
    data: BybitTransactionFromCabinetCreateManyInput | BybitTransactionFromCabinetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BybitTransactionFromCabinet update
   */
  export type BybitTransactionFromCabinetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetInclude<ExtArgs> | null
    /**
     * The data needed to update a BybitTransactionFromCabinet.
     */
    data: XOR<BybitTransactionFromCabinetUpdateInput, BybitTransactionFromCabinetUncheckedUpdateInput>
    /**
     * Choose, which BybitTransactionFromCabinet to update.
     */
    where: BybitTransactionFromCabinetWhereUniqueInput
  }

  /**
   * BybitTransactionFromCabinet updateMany
   */
  export type BybitTransactionFromCabinetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BybitTransactionFromCabinets.
     */
    data: XOR<BybitTransactionFromCabinetUpdateManyMutationInput, BybitTransactionFromCabinetUncheckedUpdateManyInput>
    /**
     * Filter which BybitTransactionFromCabinets to update
     */
    where?: BybitTransactionFromCabinetWhereInput
    /**
     * Limit how many BybitTransactionFromCabinets to update.
     */
    limit?: number
  }

  /**
   * BybitTransactionFromCabinet updateManyAndReturn
   */
  export type BybitTransactionFromCabinetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * The data used to update BybitTransactionFromCabinets.
     */
    data: XOR<BybitTransactionFromCabinetUpdateManyMutationInput, BybitTransactionFromCabinetUncheckedUpdateManyInput>
    /**
     * Filter which BybitTransactionFromCabinets to update
     */
    where?: BybitTransactionFromCabinetWhereInput
    /**
     * Limit how many BybitTransactionFromCabinets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BybitTransactionFromCabinet upsert
   */
  export type BybitTransactionFromCabinetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetInclude<ExtArgs> | null
    /**
     * The filter to search for the BybitTransactionFromCabinet to update in case it exists.
     */
    where: BybitTransactionFromCabinetWhereUniqueInput
    /**
     * In case the BybitTransactionFromCabinet found by the `where` argument doesn't exist, create a new BybitTransactionFromCabinet with this data.
     */
    create: XOR<BybitTransactionFromCabinetCreateInput, BybitTransactionFromCabinetUncheckedCreateInput>
    /**
     * In case the BybitTransactionFromCabinet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BybitTransactionFromCabinetUpdateInput, BybitTransactionFromCabinetUncheckedUpdateInput>
  }

  /**
   * BybitTransactionFromCabinet delete
   */
  export type BybitTransactionFromCabinetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetInclude<ExtArgs> | null
    /**
     * Filter which BybitTransactionFromCabinet to delete.
     */
    where: BybitTransactionFromCabinetWhereUniqueInput
  }

  /**
   * BybitTransactionFromCabinet deleteMany
   */
  export type BybitTransactionFromCabinetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BybitTransactionFromCabinets to delete
     */
    where?: BybitTransactionFromCabinetWhereInput
    /**
     * Limit how many BybitTransactionFromCabinets to delete.
     */
    limit?: number
  }

  /**
   * BybitTransactionFromCabinet.BybitClipMatch
   */
  export type BybitTransactionFromCabinet$BybitClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    where?: BybitClipMatchWhereInput
    orderBy?: BybitClipMatchOrderByWithRelationInput | BybitClipMatchOrderByWithRelationInput[]
    cursor?: BybitClipMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BybitClipMatchScalarFieldEnum | BybitClipMatchScalarFieldEnum[]
  }

  /**
   * BybitTransactionFromCabinet.ViresClipMatch
   */
  export type BybitTransactionFromCabinet$ViresClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    where?: ViresClipMatchWhereInput
    orderBy?: ViresClipMatchOrderByWithRelationInput | ViresClipMatchOrderByWithRelationInput[]
    cursor?: ViresClipMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViresClipMatchScalarFieldEnum | ViresClipMatchScalarFieldEnum[]
  }

  /**
   * BybitTransactionFromCabinet without action
   */
  export type BybitTransactionFromCabinetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitTransactionFromCabinet
     */
    select?: BybitTransactionFromCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitTransactionFromCabinet
     */
    omit?: BybitTransactionFromCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitTransactionFromCabinetInclude<ExtArgs> | null
  }


  /**
   * Model MatchBybitReport
   */

  export type AggregateMatchBybitReport = {
    _count: MatchBybitReportCountAggregateOutputType | null
    _avg: MatchBybitReportAvgAggregateOutputType | null
    _sum: MatchBybitReportSumAggregateOutputType | null
    _min: MatchBybitReportMinAggregateOutputType | null
    _max: MatchBybitReportMaxAggregateOutputType | null
  }

  export type MatchBybitReportAvgAggregateOutputType = {
    id: number | null
    totalMatches: number | null
    totalProfit: number | null
    averageProfit: number | null
    successRate: number | null
    userId: number | null
  }

  export type MatchBybitReportSumAggregateOutputType = {
    id: number | null
    totalMatches: number | null
    totalProfit: number | null
    averageProfit: number | null
    successRate: number | null
    userId: number | null
  }

  export type MatchBybitReportMinAggregateOutputType = {
    id: number | null
    reportDate: Date | null
    totalMatches: number | null
    totalProfit: number | null
    averageProfit: number | null
    successRate: number | null
    timeRangeStart: Date | null
    timeRangeEnd: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type MatchBybitReportMaxAggregateOutputType = {
    id: number | null
    reportDate: Date | null
    totalMatches: number | null
    totalProfit: number | null
    averageProfit: number | null
    successRate: number | null
    timeRangeStart: Date | null
    timeRangeEnd: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type MatchBybitReportCountAggregateOutputType = {
    id: number
    reportDate: number
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: number
    timeRangeEnd: number
    notes: number
    idexCabinets: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type MatchBybitReportAvgAggregateInputType = {
    id?: true
    totalMatches?: true
    totalProfit?: true
    averageProfit?: true
    successRate?: true
    userId?: true
  }

  export type MatchBybitReportSumAggregateInputType = {
    id?: true
    totalMatches?: true
    totalProfit?: true
    averageProfit?: true
    successRate?: true
    userId?: true
  }

  export type MatchBybitReportMinAggregateInputType = {
    id?: true
    reportDate?: true
    totalMatches?: true
    totalProfit?: true
    averageProfit?: true
    successRate?: true
    timeRangeStart?: true
    timeRangeEnd?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type MatchBybitReportMaxAggregateInputType = {
    id?: true
    reportDate?: true
    totalMatches?: true
    totalProfit?: true
    averageProfit?: true
    successRate?: true
    timeRangeStart?: true
    timeRangeEnd?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type MatchBybitReportCountAggregateInputType = {
    id?: true
    reportDate?: true
    totalMatches?: true
    totalProfit?: true
    averageProfit?: true
    successRate?: true
    timeRangeStart?: true
    timeRangeEnd?: true
    notes?: true
    idexCabinets?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type MatchBybitReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchBybitReport to aggregate.
     */
    where?: MatchBybitReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchBybitReports to fetch.
     */
    orderBy?: MatchBybitReportOrderByWithRelationInput | MatchBybitReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchBybitReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchBybitReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchBybitReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchBybitReports
    **/
    _count?: true | MatchBybitReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchBybitReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchBybitReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchBybitReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchBybitReportMaxAggregateInputType
  }

  export type GetMatchBybitReportAggregateType<T extends MatchBybitReportAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchBybitReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchBybitReport[P]>
      : GetScalarType<T[P], AggregateMatchBybitReport[P]>
  }




  export type MatchBybitReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchBybitReportWhereInput
    orderBy?: MatchBybitReportOrderByWithAggregationInput | MatchBybitReportOrderByWithAggregationInput[]
    by: MatchBybitReportScalarFieldEnum[] | MatchBybitReportScalarFieldEnum
    having?: MatchBybitReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchBybitReportCountAggregateInputType | true
    _avg?: MatchBybitReportAvgAggregateInputType
    _sum?: MatchBybitReportSumAggregateInputType
    _min?: MatchBybitReportMinAggregateInputType
    _max?: MatchBybitReportMaxAggregateInputType
  }

  export type MatchBybitReportGroupByOutputType = {
    id: number
    reportDate: Date
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date
    timeRangeEnd: Date
    notes: string | null
    idexCabinets: JsonValue | null
    createdAt: Date
    updatedAt: Date
    userId: number
    _count: MatchBybitReportCountAggregateOutputType | null
    _avg: MatchBybitReportAvgAggregateOutputType | null
    _sum: MatchBybitReportSumAggregateOutputType | null
    _min: MatchBybitReportMinAggregateOutputType | null
    _max: MatchBybitReportMaxAggregateOutputType | null
  }

  type GetMatchBybitReportGroupByPayload<T extends MatchBybitReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchBybitReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchBybitReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchBybitReportGroupByOutputType[P]>
            : GetScalarType<T[P], MatchBybitReportGroupByOutputType[P]>
        }
      >
    >


  export type MatchBybitReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportDate?: boolean
    totalMatches?: boolean
    totalProfit?: boolean
    averageProfit?: boolean
    successRate?: boolean
    timeRangeStart?: boolean
    timeRangeEnd?: boolean
    notes?: boolean
    idexCabinets?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    BybitClipMatch?: boolean | MatchBybitReport$BybitClipMatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | MatchBybitReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchBybitReport"]>

  export type MatchBybitReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportDate?: boolean
    totalMatches?: boolean
    totalProfit?: boolean
    averageProfit?: boolean
    successRate?: boolean
    timeRangeStart?: boolean
    timeRangeEnd?: boolean
    notes?: boolean
    idexCabinets?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchBybitReport"]>

  export type MatchBybitReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportDate?: boolean
    totalMatches?: boolean
    totalProfit?: boolean
    averageProfit?: boolean
    successRate?: boolean
    timeRangeStart?: boolean
    timeRangeEnd?: boolean
    notes?: boolean
    idexCabinets?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchBybitReport"]>

  export type MatchBybitReportSelectScalar = {
    id?: boolean
    reportDate?: boolean
    totalMatches?: boolean
    totalProfit?: boolean
    averageProfit?: boolean
    successRate?: boolean
    timeRangeStart?: boolean
    timeRangeEnd?: boolean
    notes?: boolean
    idexCabinets?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type MatchBybitReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportDate" | "totalMatches" | "totalProfit" | "averageProfit" | "successRate" | "timeRangeStart" | "timeRangeEnd" | "notes" | "idexCabinets" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["matchBybitReport"]>
  export type MatchBybitReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitClipMatch?: boolean | MatchBybitReport$BybitClipMatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | MatchBybitReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatchBybitReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MatchBybitReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchBybitReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchBybitReport"
    objects: {
      BybitClipMatch: Prisma.$BybitClipMatchPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reportDate: Date
      totalMatches: number
      totalProfit: number
      averageProfit: number
      successRate: number
      timeRangeStart: Date
      timeRangeEnd: Date
      notes: string | null
      idexCabinets: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      userId: number
    }, ExtArgs["result"]["matchBybitReport"]>
    composites: {}
  }

  type MatchBybitReportGetPayload<S extends boolean | null | undefined | MatchBybitReportDefaultArgs> = $Result.GetResult<Prisma.$MatchBybitReportPayload, S>

  type MatchBybitReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchBybitReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchBybitReportCountAggregateInputType | true
    }

  export interface MatchBybitReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchBybitReport'], meta: { name: 'MatchBybitReport' } }
    /**
     * Find zero or one MatchBybitReport that matches the filter.
     * @param {MatchBybitReportFindUniqueArgs} args - Arguments to find a MatchBybitReport
     * @example
     * // Get one MatchBybitReport
     * const matchBybitReport = await prisma.matchBybitReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchBybitReportFindUniqueArgs>(args: SelectSubset<T, MatchBybitReportFindUniqueArgs<ExtArgs>>): Prisma__MatchBybitReportClient<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchBybitReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchBybitReportFindUniqueOrThrowArgs} args - Arguments to find a MatchBybitReport
     * @example
     * // Get one MatchBybitReport
     * const matchBybitReport = await prisma.matchBybitReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchBybitReportFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchBybitReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchBybitReportClient<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchBybitReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchBybitReportFindFirstArgs} args - Arguments to find a MatchBybitReport
     * @example
     * // Get one MatchBybitReport
     * const matchBybitReport = await prisma.matchBybitReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchBybitReportFindFirstArgs>(args?: SelectSubset<T, MatchBybitReportFindFirstArgs<ExtArgs>>): Prisma__MatchBybitReportClient<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchBybitReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchBybitReportFindFirstOrThrowArgs} args - Arguments to find a MatchBybitReport
     * @example
     * // Get one MatchBybitReport
     * const matchBybitReport = await prisma.matchBybitReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchBybitReportFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchBybitReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchBybitReportClient<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchBybitReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchBybitReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchBybitReports
     * const matchBybitReports = await prisma.matchBybitReport.findMany()
     * 
     * // Get first 10 MatchBybitReports
     * const matchBybitReports = await prisma.matchBybitReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchBybitReportWithIdOnly = await prisma.matchBybitReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchBybitReportFindManyArgs>(args?: SelectSubset<T, MatchBybitReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchBybitReport.
     * @param {MatchBybitReportCreateArgs} args - Arguments to create a MatchBybitReport.
     * @example
     * // Create one MatchBybitReport
     * const MatchBybitReport = await prisma.matchBybitReport.create({
     *   data: {
     *     // ... data to create a MatchBybitReport
     *   }
     * })
     * 
     */
    create<T extends MatchBybitReportCreateArgs>(args: SelectSubset<T, MatchBybitReportCreateArgs<ExtArgs>>): Prisma__MatchBybitReportClient<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchBybitReports.
     * @param {MatchBybitReportCreateManyArgs} args - Arguments to create many MatchBybitReports.
     * @example
     * // Create many MatchBybitReports
     * const matchBybitReport = await prisma.matchBybitReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchBybitReportCreateManyArgs>(args?: SelectSubset<T, MatchBybitReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchBybitReports and returns the data saved in the database.
     * @param {MatchBybitReportCreateManyAndReturnArgs} args - Arguments to create many MatchBybitReports.
     * @example
     * // Create many MatchBybitReports
     * const matchBybitReport = await prisma.matchBybitReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchBybitReports and only return the `id`
     * const matchBybitReportWithIdOnly = await prisma.matchBybitReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchBybitReportCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchBybitReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchBybitReport.
     * @param {MatchBybitReportDeleteArgs} args - Arguments to delete one MatchBybitReport.
     * @example
     * // Delete one MatchBybitReport
     * const MatchBybitReport = await prisma.matchBybitReport.delete({
     *   where: {
     *     // ... filter to delete one MatchBybitReport
     *   }
     * })
     * 
     */
    delete<T extends MatchBybitReportDeleteArgs>(args: SelectSubset<T, MatchBybitReportDeleteArgs<ExtArgs>>): Prisma__MatchBybitReportClient<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchBybitReport.
     * @param {MatchBybitReportUpdateArgs} args - Arguments to update one MatchBybitReport.
     * @example
     * // Update one MatchBybitReport
     * const matchBybitReport = await prisma.matchBybitReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchBybitReportUpdateArgs>(args: SelectSubset<T, MatchBybitReportUpdateArgs<ExtArgs>>): Prisma__MatchBybitReportClient<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchBybitReports.
     * @param {MatchBybitReportDeleteManyArgs} args - Arguments to filter MatchBybitReports to delete.
     * @example
     * // Delete a few MatchBybitReports
     * const { count } = await prisma.matchBybitReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchBybitReportDeleteManyArgs>(args?: SelectSubset<T, MatchBybitReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchBybitReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchBybitReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchBybitReports
     * const matchBybitReport = await prisma.matchBybitReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchBybitReportUpdateManyArgs>(args: SelectSubset<T, MatchBybitReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchBybitReports and returns the data updated in the database.
     * @param {MatchBybitReportUpdateManyAndReturnArgs} args - Arguments to update many MatchBybitReports.
     * @example
     * // Update many MatchBybitReports
     * const matchBybitReport = await prisma.matchBybitReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchBybitReports and only return the `id`
     * const matchBybitReportWithIdOnly = await prisma.matchBybitReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchBybitReportUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchBybitReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchBybitReport.
     * @param {MatchBybitReportUpsertArgs} args - Arguments to update or create a MatchBybitReport.
     * @example
     * // Update or create a MatchBybitReport
     * const matchBybitReport = await prisma.matchBybitReport.upsert({
     *   create: {
     *     // ... data to create a MatchBybitReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchBybitReport we want to update
     *   }
     * })
     */
    upsert<T extends MatchBybitReportUpsertArgs>(args: SelectSubset<T, MatchBybitReportUpsertArgs<ExtArgs>>): Prisma__MatchBybitReportClient<$Result.GetResult<Prisma.$MatchBybitReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchBybitReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchBybitReportCountArgs} args - Arguments to filter MatchBybitReports to count.
     * @example
     * // Count the number of MatchBybitReports
     * const count = await prisma.matchBybitReport.count({
     *   where: {
     *     // ... the filter for the MatchBybitReports we want to count
     *   }
     * })
    **/
    count<T extends MatchBybitReportCountArgs>(
      args?: Subset<T, MatchBybitReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchBybitReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchBybitReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchBybitReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchBybitReportAggregateArgs>(args: Subset<T, MatchBybitReportAggregateArgs>): Prisma.PrismaPromise<GetMatchBybitReportAggregateType<T>>

    /**
     * Group by MatchBybitReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchBybitReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchBybitReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchBybitReportGroupByArgs['orderBy'] }
        : { orderBy?: MatchBybitReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchBybitReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchBybitReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchBybitReport model
   */
  readonly fields: MatchBybitReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchBybitReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchBybitReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BybitClipMatch<T extends MatchBybitReport$BybitClipMatchArgs<ExtArgs> = {}>(args?: Subset<T, MatchBybitReport$BybitClipMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BybitClipMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchBybitReport model
   */
  interface MatchBybitReportFieldRefs {
    readonly id: FieldRef<"MatchBybitReport", 'Int'>
    readonly reportDate: FieldRef<"MatchBybitReport", 'DateTime'>
    readonly totalMatches: FieldRef<"MatchBybitReport", 'Int'>
    readonly totalProfit: FieldRef<"MatchBybitReport", 'Float'>
    readonly averageProfit: FieldRef<"MatchBybitReport", 'Float'>
    readonly successRate: FieldRef<"MatchBybitReport", 'Float'>
    readonly timeRangeStart: FieldRef<"MatchBybitReport", 'DateTime'>
    readonly timeRangeEnd: FieldRef<"MatchBybitReport", 'DateTime'>
    readonly notes: FieldRef<"MatchBybitReport", 'String'>
    readonly idexCabinets: FieldRef<"MatchBybitReport", 'Json'>
    readonly createdAt: FieldRef<"MatchBybitReport", 'DateTime'>
    readonly updatedAt: FieldRef<"MatchBybitReport", 'DateTime'>
    readonly userId: FieldRef<"MatchBybitReport", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MatchBybitReport findUnique
   */
  export type MatchBybitReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
    /**
     * Filter, which MatchBybitReport to fetch.
     */
    where: MatchBybitReportWhereUniqueInput
  }

  /**
   * MatchBybitReport findUniqueOrThrow
   */
  export type MatchBybitReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
    /**
     * Filter, which MatchBybitReport to fetch.
     */
    where: MatchBybitReportWhereUniqueInput
  }

  /**
   * MatchBybitReport findFirst
   */
  export type MatchBybitReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
    /**
     * Filter, which MatchBybitReport to fetch.
     */
    where?: MatchBybitReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchBybitReports to fetch.
     */
    orderBy?: MatchBybitReportOrderByWithRelationInput | MatchBybitReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchBybitReports.
     */
    cursor?: MatchBybitReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchBybitReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchBybitReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchBybitReports.
     */
    distinct?: MatchBybitReportScalarFieldEnum | MatchBybitReportScalarFieldEnum[]
  }

  /**
   * MatchBybitReport findFirstOrThrow
   */
  export type MatchBybitReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
    /**
     * Filter, which MatchBybitReport to fetch.
     */
    where?: MatchBybitReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchBybitReports to fetch.
     */
    orderBy?: MatchBybitReportOrderByWithRelationInput | MatchBybitReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchBybitReports.
     */
    cursor?: MatchBybitReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchBybitReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchBybitReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchBybitReports.
     */
    distinct?: MatchBybitReportScalarFieldEnum | MatchBybitReportScalarFieldEnum[]
  }

  /**
   * MatchBybitReport findMany
   */
  export type MatchBybitReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
    /**
     * Filter, which MatchBybitReports to fetch.
     */
    where?: MatchBybitReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchBybitReports to fetch.
     */
    orderBy?: MatchBybitReportOrderByWithRelationInput | MatchBybitReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchBybitReports.
     */
    cursor?: MatchBybitReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchBybitReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchBybitReports.
     */
    skip?: number
    distinct?: MatchBybitReportScalarFieldEnum | MatchBybitReportScalarFieldEnum[]
  }

  /**
   * MatchBybitReport create
   */
  export type MatchBybitReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchBybitReport.
     */
    data: XOR<MatchBybitReportCreateInput, MatchBybitReportUncheckedCreateInput>
  }

  /**
   * MatchBybitReport createMany
   */
  export type MatchBybitReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchBybitReports.
     */
    data: MatchBybitReportCreateManyInput | MatchBybitReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchBybitReport createManyAndReturn
   */
  export type MatchBybitReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * The data used to create many MatchBybitReports.
     */
    data: MatchBybitReportCreateManyInput | MatchBybitReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchBybitReport update
   */
  export type MatchBybitReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchBybitReport.
     */
    data: XOR<MatchBybitReportUpdateInput, MatchBybitReportUncheckedUpdateInput>
    /**
     * Choose, which MatchBybitReport to update.
     */
    where: MatchBybitReportWhereUniqueInput
  }

  /**
   * MatchBybitReport updateMany
   */
  export type MatchBybitReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchBybitReports.
     */
    data: XOR<MatchBybitReportUpdateManyMutationInput, MatchBybitReportUncheckedUpdateManyInput>
    /**
     * Filter which MatchBybitReports to update
     */
    where?: MatchBybitReportWhereInput
    /**
     * Limit how many MatchBybitReports to update.
     */
    limit?: number
  }

  /**
   * MatchBybitReport updateManyAndReturn
   */
  export type MatchBybitReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * The data used to update MatchBybitReports.
     */
    data: XOR<MatchBybitReportUpdateManyMutationInput, MatchBybitReportUncheckedUpdateManyInput>
    /**
     * Filter which MatchBybitReports to update
     */
    where?: MatchBybitReportWhereInput
    /**
     * Limit how many MatchBybitReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchBybitReport upsert
   */
  export type MatchBybitReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchBybitReport to update in case it exists.
     */
    where: MatchBybitReportWhereUniqueInput
    /**
     * In case the MatchBybitReport found by the `where` argument doesn't exist, create a new MatchBybitReport with this data.
     */
    create: XOR<MatchBybitReportCreateInput, MatchBybitReportUncheckedCreateInput>
    /**
     * In case the MatchBybitReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchBybitReportUpdateInput, MatchBybitReportUncheckedUpdateInput>
  }

  /**
   * MatchBybitReport delete
   */
  export type MatchBybitReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
    /**
     * Filter which MatchBybitReport to delete.
     */
    where: MatchBybitReportWhereUniqueInput
  }

  /**
   * MatchBybitReport deleteMany
   */
  export type MatchBybitReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchBybitReports to delete
     */
    where?: MatchBybitReportWhereInput
    /**
     * Limit how many MatchBybitReports to delete.
     */
    limit?: number
  }

  /**
   * MatchBybitReport.BybitClipMatch
   */
  export type MatchBybitReport$BybitClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BybitClipMatch
     */
    select?: BybitClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BybitClipMatch
     */
    omit?: BybitClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BybitClipMatchInclude<ExtArgs> | null
    where?: BybitClipMatchWhereInput
    orderBy?: BybitClipMatchOrderByWithRelationInput | BybitClipMatchOrderByWithRelationInput[]
    cursor?: BybitClipMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BybitClipMatchScalarFieldEnum | BybitClipMatchScalarFieldEnum[]
  }

  /**
   * MatchBybitReport without action
   */
  export type MatchBybitReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchBybitReport
     */
    select?: MatchBybitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchBybitReport
     */
    omit?: MatchBybitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchBybitReportInclude<ExtArgs> | null
  }


  /**
   * Model MatchViresReport
   */

  export type AggregateMatchViresReport = {
    _count: MatchViresReportCountAggregateOutputType | null
    _avg: MatchViresReportAvgAggregateOutputType | null
    _sum: MatchViresReportSumAggregateOutputType | null
    _min: MatchViresReportMinAggregateOutputType | null
    _max: MatchViresReportMaxAggregateOutputType | null
  }

  export type MatchViresReportAvgAggregateOutputType = {
    id: number | null
    totalMatches: number | null
    totalProfit: number | null
    averageProfit: number | null
    successRate: number | null
    userId: number | null
  }

  export type MatchViresReportSumAggregateOutputType = {
    id: number | null
    totalMatches: number | null
    totalProfit: number | null
    averageProfit: number | null
    successRate: number | null
    userId: number | null
  }

  export type MatchViresReportMinAggregateOutputType = {
    id: number | null
    reportDate: Date | null
    totalMatches: number | null
    totalProfit: number | null
    averageProfit: number | null
    successRate: number | null
    timeRangeStart: Date | null
    timeRangeEnd: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type MatchViresReportMaxAggregateOutputType = {
    id: number | null
    reportDate: Date | null
    totalMatches: number | null
    totalProfit: number | null
    averageProfit: number | null
    successRate: number | null
    timeRangeStart: Date | null
    timeRangeEnd: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type MatchViresReportCountAggregateOutputType = {
    id: number
    reportDate: number
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: number
    timeRangeEnd: number
    notes: number
    idexCabinets: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type MatchViresReportAvgAggregateInputType = {
    id?: true
    totalMatches?: true
    totalProfit?: true
    averageProfit?: true
    successRate?: true
    userId?: true
  }

  export type MatchViresReportSumAggregateInputType = {
    id?: true
    totalMatches?: true
    totalProfit?: true
    averageProfit?: true
    successRate?: true
    userId?: true
  }

  export type MatchViresReportMinAggregateInputType = {
    id?: true
    reportDate?: true
    totalMatches?: true
    totalProfit?: true
    averageProfit?: true
    successRate?: true
    timeRangeStart?: true
    timeRangeEnd?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type MatchViresReportMaxAggregateInputType = {
    id?: true
    reportDate?: true
    totalMatches?: true
    totalProfit?: true
    averageProfit?: true
    successRate?: true
    timeRangeStart?: true
    timeRangeEnd?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type MatchViresReportCountAggregateInputType = {
    id?: true
    reportDate?: true
    totalMatches?: true
    totalProfit?: true
    averageProfit?: true
    successRate?: true
    timeRangeStart?: true
    timeRangeEnd?: true
    notes?: true
    idexCabinets?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type MatchViresReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchViresReport to aggregate.
     */
    where?: MatchViresReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchViresReports to fetch.
     */
    orderBy?: MatchViresReportOrderByWithRelationInput | MatchViresReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchViresReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchViresReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchViresReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchViresReports
    **/
    _count?: true | MatchViresReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchViresReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchViresReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchViresReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchViresReportMaxAggregateInputType
  }

  export type GetMatchViresReportAggregateType<T extends MatchViresReportAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchViresReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchViresReport[P]>
      : GetScalarType<T[P], AggregateMatchViresReport[P]>
  }




  export type MatchViresReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchViresReportWhereInput
    orderBy?: MatchViresReportOrderByWithAggregationInput | MatchViresReportOrderByWithAggregationInput[]
    by: MatchViresReportScalarFieldEnum[] | MatchViresReportScalarFieldEnum
    having?: MatchViresReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchViresReportCountAggregateInputType | true
    _avg?: MatchViresReportAvgAggregateInputType
    _sum?: MatchViresReportSumAggregateInputType
    _min?: MatchViresReportMinAggregateInputType
    _max?: MatchViresReportMaxAggregateInputType
  }

  export type MatchViresReportGroupByOutputType = {
    id: number
    reportDate: Date
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date
    timeRangeEnd: Date
    notes: string | null
    idexCabinets: JsonValue | null
    createdAt: Date
    updatedAt: Date
    userId: number
    _count: MatchViresReportCountAggregateOutputType | null
    _avg: MatchViresReportAvgAggregateOutputType | null
    _sum: MatchViresReportSumAggregateOutputType | null
    _min: MatchViresReportMinAggregateOutputType | null
    _max: MatchViresReportMaxAggregateOutputType | null
  }

  type GetMatchViresReportGroupByPayload<T extends MatchViresReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchViresReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchViresReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchViresReportGroupByOutputType[P]>
            : GetScalarType<T[P], MatchViresReportGroupByOutputType[P]>
        }
      >
    >


  export type MatchViresReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportDate?: boolean
    totalMatches?: boolean
    totalProfit?: boolean
    averageProfit?: boolean
    successRate?: boolean
    timeRangeStart?: boolean
    timeRangeEnd?: boolean
    notes?: boolean
    idexCabinets?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    ViresClipMatch?: boolean | MatchViresReport$ViresClipMatchArgs<ExtArgs>
    _count?: boolean | MatchViresReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchViresReport"]>

  export type MatchViresReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportDate?: boolean
    totalMatches?: boolean
    totalProfit?: boolean
    averageProfit?: boolean
    successRate?: boolean
    timeRangeStart?: boolean
    timeRangeEnd?: boolean
    notes?: boolean
    idexCabinets?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchViresReport"]>

  export type MatchViresReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportDate?: boolean
    totalMatches?: boolean
    totalProfit?: boolean
    averageProfit?: boolean
    successRate?: boolean
    timeRangeStart?: boolean
    timeRangeEnd?: boolean
    notes?: boolean
    idexCabinets?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchViresReport"]>

  export type MatchViresReportSelectScalar = {
    id?: boolean
    reportDate?: boolean
    totalMatches?: boolean
    totalProfit?: boolean
    averageProfit?: boolean
    successRate?: boolean
    timeRangeStart?: boolean
    timeRangeEnd?: boolean
    notes?: boolean
    idexCabinets?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type MatchViresReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportDate" | "totalMatches" | "totalProfit" | "averageProfit" | "successRate" | "timeRangeStart" | "timeRangeEnd" | "notes" | "idexCabinets" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["matchViresReport"]>
  export type MatchViresReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    ViresClipMatch?: boolean | MatchViresReport$ViresClipMatchArgs<ExtArgs>
    _count?: boolean | MatchViresReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatchViresReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MatchViresReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchViresReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchViresReport"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      ViresClipMatch: Prisma.$ViresClipMatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reportDate: Date
      totalMatches: number
      totalProfit: number
      averageProfit: number
      successRate: number
      timeRangeStart: Date
      timeRangeEnd: Date
      notes: string | null
      idexCabinets: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      userId: number
    }, ExtArgs["result"]["matchViresReport"]>
    composites: {}
  }

  type MatchViresReportGetPayload<S extends boolean | null | undefined | MatchViresReportDefaultArgs> = $Result.GetResult<Prisma.$MatchViresReportPayload, S>

  type MatchViresReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchViresReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchViresReportCountAggregateInputType | true
    }

  export interface MatchViresReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchViresReport'], meta: { name: 'MatchViresReport' } }
    /**
     * Find zero or one MatchViresReport that matches the filter.
     * @param {MatchViresReportFindUniqueArgs} args - Arguments to find a MatchViresReport
     * @example
     * // Get one MatchViresReport
     * const matchViresReport = await prisma.matchViresReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchViresReportFindUniqueArgs>(args: SelectSubset<T, MatchViresReportFindUniqueArgs<ExtArgs>>): Prisma__MatchViresReportClient<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchViresReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchViresReportFindUniqueOrThrowArgs} args - Arguments to find a MatchViresReport
     * @example
     * // Get one MatchViresReport
     * const matchViresReport = await prisma.matchViresReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchViresReportFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchViresReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchViresReportClient<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchViresReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchViresReportFindFirstArgs} args - Arguments to find a MatchViresReport
     * @example
     * // Get one MatchViresReport
     * const matchViresReport = await prisma.matchViresReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchViresReportFindFirstArgs>(args?: SelectSubset<T, MatchViresReportFindFirstArgs<ExtArgs>>): Prisma__MatchViresReportClient<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchViresReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchViresReportFindFirstOrThrowArgs} args - Arguments to find a MatchViresReport
     * @example
     * // Get one MatchViresReport
     * const matchViresReport = await prisma.matchViresReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchViresReportFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchViresReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchViresReportClient<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchViresReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchViresReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchViresReports
     * const matchViresReports = await prisma.matchViresReport.findMany()
     * 
     * // Get first 10 MatchViresReports
     * const matchViresReports = await prisma.matchViresReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchViresReportWithIdOnly = await prisma.matchViresReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchViresReportFindManyArgs>(args?: SelectSubset<T, MatchViresReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchViresReport.
     * @param {MatchViresReportCreateArgs} args - Arguments to create a MatchViresReport.
     * @example
     * // Create one MatchViresReport
     * const MatchViresReport = await prisma.matchViresReport.create({
     *   data: {
     *     // ... data to create a MatchViresReport
     *   }
     * })
     * 
     */
    create<T extends MatchViresReportCreateArgs>(args: SelectSubset<T, MatchViresReportCreateArgs<ExtArgs>>): Prisma__MatchViresReportClient<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchViresReports.
     * @param {MatchViresReportCreateManyArgs} args - Arguments to create many MatchViresReports.
     * @example
     * // Create many MatchViresReports
     * const matchViresReport = await prisma.matchViresReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchViresReportCreateManyArgs>(args?: SelectSubset<T, MatchViresReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchViresReports and returns the data saved in the database.
     * @param {MatchViresReportCreateManyAndReturnArgs} args - Arguments to create many MatchViresReports.
     * @example
     * // Create many MatchViresReports
     * const matchViresReport = await prisma.matchViresReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchViresReports and only return the `id`
     * const matchViresReportWithIdOnly = await prisma.matchViresReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchViresReportCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchViresReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchViresReport.
     * @param {MatchViresReportDeleteArgs} args - Arguments to delete one MatchViresReport.
     * @example
     * // Delete one MatchViresReport
     * const MatchViresReport = await prisma.matchViresReport.delete({
     *   where: {
     *     // ... filter to delete one MatchViresReport
     *   }
     * })
     * 
     */
    delete<T extends MatchViresReportDeleteArgs>(args: SelectSubset<T, MatchViresReportDeleteArgs<ExtArgs>>): Prisma__MatchViresReportClient<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchViresReport.
     * @param {MatchViresReportUpdateArgs} args - Arguments to update one MatchViresReport.
     * @example
     * // Update one MatchViresReport
     * const matchViresReport = await prisma.matchViresReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchViresReportUpdateArgs>(args: SelectSubset<T, MatchViresReportUpdateArgs<ExtArgs>>): Prisma__MatchViresReportClient<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchViresReports.
     * @param {MatchViresReportDeleteManyArgs} args - Arguments to filter MatchViresReports to delete.
     * @example
     * // Delete a few MatchViresReports
     * const { count } = await prisma.matchViresReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchViresReportDeleteManyArgs>(args?: SelectSubset<T, MatchViresReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchViresReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchViresReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchViresReports
     * const matchViresReport = await prisma.matchViresReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchViresReportUpdateManyArgs>(args: SelectSubset<T, MatchViresReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchViresReports and returns the data updated in the database.
     * @param {MatchViresReportUpdateManyAndReturnArgs} args - Arguments to update many MatchViresReports.
     * @example
     * // Update many MatchViresReports
     * const matchViresReport = await prisma.matchViresReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchViresReports and only return the `id`
     * const matchViresReportWithIdOnly = await prisma.matchViresReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchViresReportUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchViresReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchViresReport.
     * @param {MatchViresReportUpsertArgs} args - Arguments to update or create a MatchViresReport.
     * @example
     * // Update or create a MatchViresReport
     * const matchViresReport = await prisma.matchViresReport.upsert({
     *   create: {
     *     // ... data to create a MatchViresReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchViresReport we want to update
     *   }
     * })
     */
    upsert<T extends MatchViresReportUpsertArgs>(args: SelectSubset<T, MatchViresReportUpsertArgs<ExtArgs>>): Prisma__MatchViresReportClient<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchViresReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchViresReportCountArgs} args - Arguments to filter MatchViresReports to count.
     * @example
     * // Count the number of MatchViresReports
     * const count = await prisma.matchViresReport.count({
     *   where: {
     *     // ... the filter for the MatchViresReports we want to count
     *   }
     * })
    **/
    count<T extends MatchViresReportCountArgs>(
      args?: Subset<T, MatchViresReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchViresReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchViresReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchViresReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchViresReportAggregateArgs>(args: Subset<T, MatchViresReportAggregateArgs>): Prisma.PrismaPromise<GetMatchViresReportAggregateType<T>>

    /**
     * Group by MatchViresReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchViresReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchViresReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchViresReportGroupByArgs['orderBy'] }
        : { orderBy?: MatchViresReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchViresReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchViresReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchViresReport model
   */
  readonly fields: MatchViresReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchViresReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchViresReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ViresClipMatch<T extends MatchViresReport$ViresClipMatchArgs<ExtArgs> = {}>(args?: Subset<T, MatchViresReport$ViresClipMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchViresReport model
   */
  interface MatchViresReportFieldRefs {
    readonly id: FieldRef<"MatchViresReport", 'Int'>
    readonly reportDate: FieldRef<"MatchViresReport", 'DateTime'>
    readonly totalMatches: FieldRef<"MatchViresReport", 'Int'>
    readonly totalProfit: FieldRef<"MatchViresReport", 'Float'>
    readonly averageProfit: FieldRef<"MatchViresReport", 'Float'>
    readonly successRate: FieldRef<"MatchViresReport", 'Float'>
    readonly timeRangeStart: FieldRef<"MatchViresReport", 'DateTime'>
    readonly timeRangeEnd: FieldRef<"MatchViresReport", 'DateTime'>
    readonly notes: FieldRef<"MatchViresReport", 'String'>
    readonly idexCabinets: FieldRef<"MatchViresReport", 'Json'>
    readonly createdAt: FieldRef<"MatchViresReport", 'DateTime'>
    readonly updatedAt: FieldRef<"MatchViresReport", 'DateTime'>
    readonly userId: FieldRef<"MatchViresReport", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MatchViresReport findUnique
   */
  export type MatchViresReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
    /**
     * Filter, which MatchViresReport to fetch.
     */
    where: MatchViresReportWhereUniqueInput
  }

  /**
   * MatchViresReport findUniqueOrThrow
   */
  export type MatchViresReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
    /**
     * Filter, which MatchViresReport to fetch.
     */
    where: MatchViresReportWhereUniqueInput
  }

  /**
   * MatchViresReport findFirst
   */
  export type MatchViresReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
    /**
     * Filter, which MatchViresReport to fetch.
     */
    where?: MatchViresReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchViresReports to fetch.
     */
    orderBy?: MatchViresReportOrderByWithRelationInput | MatchViresReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchViresReports.
     */
    cursor?: MatchViresReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchViresReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchViresReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchViresReports.
     */
    distinct?: MatchViresReportScalarFieldEnum | MatchViresReportScalarFieldEnum[]
  }

  /**
   * MatchViresReport findFirstOrThrow
   */
  export type MatchViresReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
    /**
     * Filter, which MatchViresReport to fetch.
     */
    where?: MatchViresReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchViresReports to fetch.
     */
    orderBy?: MatchViresReportOrderByWithRelationInput | MatchViresReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchViresReports.
     */
    cursor?: MatchViresReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchViresReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchViresReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchViresReports.
     */
    distinct?: MatchViresReportScalarFieldEnum | MatchViresReportScalarFieldEnum[]
  }

  /**
   * MatchViresReport findMany
   */
  export type MatchViresReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
    /**
     * Filter, which MatchViresReports to fetch.
     */
    where?: MatchViresReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchViresReports to fetch.
     */
    orderBy?: MatchViresReportOrderByWithRelationInput | MatchViresReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchViresReports.
     */
    cursor?: MatchViresReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchViresReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchViresReports.
     */
    skip?: number
    distinct?: MatchViresReportScalarFieldEnum | MatchViresReportScalarFieldEnum[]
  }

  /**
   * MatchViresReport create
   */
  export type MatchViresReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchViresReport.
     */
    data: XOR<MatchViresReportCreateInput, MatchViresReportUncheckedCreateInput>
  }

  /**
   * MatchViresReport createMany
   */
  export type MatchViresReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchViresReports.
     */
    data: MatchViresReportCreateManyInput | MatchViresReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchViresReport createManyAndReturn
   */
  export type MatchViresReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * The data used to create many MatchViresReports.
     */
    data: MatchViresReportCreateManyInput | MatchViresReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchViresReport update
   */
  export type MatchViresReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchViresReport.
     */
    data: XOR<MatchViresReportUpdateInput, MatchViresReportUncheckedUpdateInput>
    /**
     * Choose, which MatchViresReport to update.
     */
    where: MatchViresReportWhereUniqueInput
  }

  /**
   * MatchViresReport updateMany
   */
  export type MatchViresReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchViresReports.
     */
    data: XOR<MatchViresReportUpdateManyMutationInput, MatchViresReportUncheckedUpdateManyInput>
    /**
     * Filter which MatchViresReports to update
     */
    where?: MatchViresReportWhereInput
    /**
     * Limit how many MatchViresReports to update.
     */
    limit?: number
  }

  /**
   * MatchViresReport updateManyAndReturn
   */
  export type MatchViresReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * The data used to update MatchViresReports.
     */
    data: XOR<MatchViresReportUpdateManyMutationInput, MatchViresReportUncheckedUpdateManyInput>
    /**
     * Filter which MatchViresReports to update
     */
    where?: MatchViresReportWhereInput
    /**
     * Limit how many MatchViresReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchViresReport upsert
   */
  export type MatchViresReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchViresReport to update in case it exists.
     */
    where: MatchViresReportWhereUniqueInput
    /**
     * In case the MatchViresReport found by the `where` argument doesn't exist, create a new MatchViresReport with this data.
     */
    create: XOR<MatchViresReportCreateInput, MatchViresReportUncheckedCreateInput>
    /**
     * In case the MatchViresReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchViresReportUpdateInput, MatchViresReportUncheckedUpdateInput>
  }

  /**
   * MatchViresReport delete
   */
  export type MatchViresReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
    /**
     * Filter which MatchViresReport to delete.
     */
    where: MatchViresReportWhereUniqueInput
  }

  /**
   * MatchViresReport deleteMany
   */
  export type MatchViresReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchViresReports to delete
     */
    where?: MatchViresReportWhereInput
    /**
     * Limit how many MatchViresReports to delete.
     */
    limit?: number
  }

  /**
   * MatchViresReport.ViresClipMatch
   */
  export type MatchViresReport$ViresClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    where?: ViresClipMatchWhereInput
    orderBy?: ViresClipMatchOrderByWithRelationInput | ViresClipMatchOrderByWithRelationInput[]
    cursor?: ViresClipMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViresClipMatchScalarFieldEnum | ViresClipMatchScalarFieldEnum[]
  }

  /**
   * MatchViresReport without action
   */
  export type MatchViresReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
  }


  /**
   * Model ViresCabinet
   */

  export type AggregateViresCabinet = {
    _count: ViresCabinetCountAggregateOutputType | null
    _avg: ViresCabinetAvgAggregateOutputType | null
    _sum: ViresCabinetSumAggregateOutputType | null
    _min: ViresCabinetMinAggregateOutputType | null
    _max: ViresCabinetMaxAggregateOutputType | null
  }

  export type ViresCabinetAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ViresCabinetSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ViresCabinetMinAggregateOutputType = {
    id: number | null
    name: string | null
    login: string | null
    password: string | null
    type: $Enums.PasswordType | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
    userId: number | null
    lastUpdate: Date | null
  }

  export type ViresCabinetMaxAggregateOutputType = {
    id: number | null
    name: string | null
    login: string | null
    password: string | null
    type: $Enums.PasswordType | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
    userId: number | null
    lastUpdate: Date | null
  }

  export type ViresCabinetCountAggregateOutputType = {
    id: number
    name: number
    login: number
    password: number
    type: number
    createdAt: number
    updatedAt: number
    comment: number
    userId: number
    lastUpdate: number
    _all: number
  }


  export type ViresCabinetAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ViresCabinetSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ViresCabinetMinAggregateInputType = {
    id?: true
    name?: true
    login?: true
    password?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    userId?: true
    lastUpdate?: true
  }

  export type ViresCabinetMaxAggregateInputType = {
    id?: true
    name?: true
    login?: true
    password?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    userId?: true
    lastUpdate?: true
  }

  export type ViresCabinetCountAggregateInputType = {
    id?: true
    name?: true
    login?: true
    password?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    userId?: true
    lastUpdate?: true
    _all?: true
  }

  export type ViresCabinetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViresCabinet to aggregate.
     */
    where?: ViresCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresCabinets to fetch.
     */
    orderBy?: ViresCabinetOrderByWithRelationInput | ViresCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViresCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViresCabinets
    **/
    _count?: true | ViresCabinetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViresCabinetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViresCabinetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViresCabinetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViresCabinetMaxAggregateInputType
  }

  export type GetViresCabinetAggregateType<T extends ViresCabinetAggregateArgs> = {
        [P in keyof T & keyof AggregateViresCabinet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViresCabinet[P]>
      : GetScalarType<T[P], AggregateViresCabinet[P]>
  }




  export type ViresCabinetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViresCabinetWhereInput
    orderBy?: ViresCabinetOrderByWithAggregationInput | ViresCabinetOrderByWithAggregationInput[]
    by: ViresCabinetScalarFieldEnum[] | ViresCabinetScalarFieldEnum
    having?: ViresCabinetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViresCabinetCountAggregateInputType | true
    _avg?: ViresCabinetAvgAggregateInputType
    _sum?: ViresCabinetSumAggregateInputType
    _min?: ViresCabinetMinAggregateInputType
    _max?: ViresCabinetMaxAggregateInputType
  }

  export type ViresCabinetGroupByOutputType = {
    id: number
    name: string | null
    login: string
    password: string
    type: $Enums.PasswordType
    createdAt: Date
    updatedAt: Date
    comment: string | null
    userId: number
    lastUpdate: Date
    _count: ViresCabinetCountAggregateOutputType | null
    _avg: ViresCabinetAvgAggregateOutputType | null
    _sum: ViresCabinetSumAggregateOutputType | null
    _min: ViresCabinetMinAggregateOutputType | null
    _max: ViresCabinetMaxAggregateOutputType | null
  }

  type GetViresCabinetGroupByPayload<T extends ViresCabinetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViresCabinetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViresCabinetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViresCabinetGroupByOutputType[P]>
            : GetScalarType<T[P], ViresCabinetGroupByOutputType[P]>
        }
      >
    >


  export type ViresCabinetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    login?: boolean
    password?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    userId?: boolean
    lastUpdate?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    ViresTransactionPayin?: boolean | ViresCabinet$ViresTransactionPayinArgs<ExtArgs>
    _count?: boolean | ViresCabinetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viresCabinet"]>

  export type ViresCabinetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    login?: boolean
    password?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    userId?: boolean
    lastUpdate?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viresCabinet"]>

  export type ViresCabinetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    login?: boolean
    password?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    userId?: boolean
    lastUpdate?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viresCabinet"]>

  export type ViresCabinetSelectScalar = {
    id?: boolean
    name?: boolean
    login?: boolean
    password?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    userId?: boolean
    lastUpdate?: boolean
  }

  export type ViresCabinetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "login" | "password" | "type" | "createdAt" | "updatedAt" | "comment" | "userId" | "lastUpdate", ExtArgs["result"]["viresCabinet"]>
  export type ViresCabinetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    ViresTransactionPayin?: boolean | ViresCabinet$ViresTransactionPayinArgs<ExtArgs>
    _count?: boolean | ViresCabinetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ViresCabinetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ViresCabinetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ViresCabinetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViresCabinet"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      ViresTransactionPayin: Prisma.$ViresTransactionPayinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      login: string
      password: string
      type: $Enums.PasswordType
      createdAt: Date
      updatedAt: Date
      comment: string | null
      userId: number
      lastUpdate: Date
    }, ExtArgs["result"]["viresCabinet"]>
    composites: {}
  }

  type ViresCabinetGetPayload<S extends boolean | null | undefined | ViresCabinetDefaultArgs> = $Result.GetResult<Prisma.$ViresCabinetPayload, S>

  type ViresCabinetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViresCabinetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViresCabinetCountAggregateInputType | true
    }

  export interface ViresCabinetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViresCabinet'], meta: { name: 'ViresCabinet' } }
    /**
     * Find zero or one ViresCabinet that matches the filter.
     * @param {ViresCabinetFindUniqueArgs} args - Arguments to find a ViresCabinet
     * @example
     * // Get one ViresCabinet
     * const viresCabinet = await prisma.viresCabinet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViresCabinetFindUniqueArgs>(args: SelectSubset<T, ViresCabinetFindUniqueArgs<ExtArgs>>): Prisma__ViresCabinetClient<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViresCabinet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViresCabinetFindUniqueOrThrowArgs} args - Arguments to find a ViresCabinet
     * @example
     * // Get one ViresCabinet
     * const viresCabinet = await prisma.viresCabinet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViresCabinetFindUniqueOrThrowArgs>(args: SelectSubset<T, ViresCabinetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViresCabinetClient<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViresCabinet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresCabinetFindFirstArgs} args - Arguments to find a ViresCabinet
     * @example
     * // Get one ViresCabinet
     * const viresCabinet = await prisma.viresCabinet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViresCabinetFindFirstArgs>(args?: SelectSubset<T, ViresCabinetFindFirstArgs<ExtArgs>>): Prisma__ViresCabinetClient<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViresCabinet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresCabinetFindFirstOrThrowArgs} args - Arguments to find a ViresCabinet
     * @example
     * // Get one ViresCabinet
     * const viresCabinet = await prisma.viresCabinet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViresCabinetFindFirstOrThrowArgs>(args?: SelectSubset<T, ViresCabinetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViresCabinetClient<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViresCabinets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresCabinetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViresCabinets
     * const viresCabinets = await prisma.viresCabinet.findMany()
     * 
     * // Get first 10 ViresCabinets
     * const viresCabinets = await prisma.viresCabinet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viresCabinetWithIdOnly = await prisma.viresCabinet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViresCabinetFindManyArgs>(args?: SelectSubset<T, ViresCabinetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViresCabinet.
     * @param {ViresCabinetCreateArgs} args - Arguments to create a ViresCabinet.
     * @example
     * // Create one ViresCabinet
     * const ViresCabinet = await prisma.viresCabinet.create({
     *   data: {
     *     // ... data to create a ViresCabinet
     *   }
     * })
     * 
     */
    create<T extends ViresCabinetCreateArgs>(args: SelectSubset<T, ViresCabinetCreateArgs<ExtArgs>>): Prisma__ViresCabinetClient<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViresCabinets.
     * @param {ViresCabinetCreateManyArgs} args - Arguments to create many ViresCabinets.
     * @example
     * // Create many ViresCabinets
     * const viresCabinet = await prisma.viresCabinet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViresCabinetCreateManyArgs>(args?: SelectSubset<T, ViresCabinetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViresCabinets and returns the data saved in the database.
     * @param {ViresCabinetCreateManyAndReturnArgs} args - Arguments to create many ViresCabinets.
     * @example
     * // Create many ViresCabinets
     * const viresCabinet = await prisma.viresCabinet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViresCabinets and only return the `id`
     * const viresCabinetWithIdOnly = await prisma.viresCabinet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViresCabinetCreateManyAndReturnArgs>(args?: SelectSubset<T, ViresCabinetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ViresCabinet.
     * @param {ViresCabinetDeleteArgs} args - Arguments to delete one ViresCabinet.
     * @example
     * // Delete one ViresCabinet
     * const ViresCabinet = await prisma.viresCabinet.delete({
     *   where: {
     *     // ... filter to delete one ViresCabinet
     *   }
     * })
     * 
     */
    delete<T extends ViresCabinetDeleteArgs>(args: SelectSubset<T, ViresCabinetDeleteArgs<ExtArgs>>): Prisma__ViresCabinetClient<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViresCabinet.
     * @param {ViresCabinetUpdateArgs} args - Arguments to update one ViresCabinet.
     * @example
     * // Update one ViresCabinet
     * const viresCabinet = await prisma.viresCabinet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViresCabinetUpdateArgs>(args: SelectSubset<T, ViresCabinetUpdateArgs<ExtArgs>>): Prisma__ViresCabinetClient<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViresCabinets.
     * @param {ViresCabinetDeleteManyArgs} args - Arguments to filter ViresCabinets to delete.
     * @example
     * // Delete a few ViresCabinets
     * const { count } = await prisma.viresCabinet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViresCabinetDeleteManyArgs>(args?: SelectSubset<T, ViresCabinetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViresCabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresCabinetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViresCabinets
     * const viresCabinet = await prisma.viresCabinet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViresCabinetUpdateManyArgs>(args: SelectSubset<T, ViresCabinetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViresCabinets and returns the data updated in the database.
     * @param {ViresCabinetUpdateManyAndReturnArgs} args - Arguments to update many ViresCabinets.
     * @example
     * // Update many ViresCabinets
     * const viresCabinet = await prisma.viresCabinet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViresCabinets and only return the `id`
     * const viresCabinetWithIdOnly = await prisma.viresCabinet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViresCabinetUpdateManyAndReturnArgs>(args: SelectSubset<T, ViresCabinetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ViresCabinet.
     * @param {ViresCabinetUpsertArgs} args - Arguments to update or create a ViresCabinet.
     * @example
     * // Update or create a ViresCabinet
     * const viresCabinet = await prisma.viresCabinet.upsert({
     *   create: {
     *     // ... data to create a ViresCabinet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViresCabinet we want to update
     *   }
     * })
     */
    upsert<T extends ViresCabinetUpsertArgs>(args: SelectSubset<T, ViresCabinetUpsertArgs<ExtArgs>>): Prisma__ViresCabinetClient<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViresCabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresCabinetCountArgs} args - Arguments to filter ViresCabinets to count.
     * @example
     * // Count the number of ViresCabinets
     * const count = await prisma.viresCabinet.count({
     *   where: {
     *     // ... the filter for the ViresCabinets we want to count
     *   }
     * })
    **/
    count<T extends ViresCabinetCountArgs>(
      args?: Subset<T, ViresCabinetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViresCabinetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViresCabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresCabinetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViresCabinetAggregateArgs>(args: Subset<T, ViresCabinetAggregateArgs>): Prisma.PrismaPromise<GetViresCabinetAggregateType<T>>

    /**
     * Group by ViresCabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresCabinetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViresCabinetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViresCabinetGroupByArgs['orderBy'] }
        : { orderBy?: ViresCabinetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViresCabinetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViresCabinetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViresCabinet model
   */
  readonly fields: ViresCabinetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViresCabinet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViresCabinetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ViresTransactionPayin<T extends ViresCabinet$ViresTransactionPayinArgs<ExtArgs> = {}>(args?: Subset<T, ViresCabinet$ViresTransactionPayinArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViresCabinet model
   */
  interface ViresCabinetFieldRefs {
    readonly id: FieldRef<"ViresCabinet", 'Int'>
    readonly name: FieldRef<"ViresCabinet", 'String'>
    readonly login: FieldRef<"ViresCabinet", 'String'>
    readonly password: FieldRef<"ViresCabinet", 'String'>
    readonly type: FieldRef<"ViresCabinet", 'PasswordType'>
    readonly createdAt: FieldRef<"ViresCabinet", 'DateTime'>
    readonly updatedAt: FieldRef<"ViresCabinet", 'DateTime'>
    readonly comment: FieldRef<"ViresCabinet", 'String'>
    readonly userId: FieldRef<"ViresCabinet", 'Int'>
    readonly lastUpdate: FieldRef<"ViresCabinet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ViresCabinet findUnique
   */
  export type ViresCabinetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetInclude<ExtArgs> | null
    /**
     * Filter, which ViresCabinet to fetch.
     */
    where: ViresCabinetWhereUniqueInput
  }

  /**
   * ViresCabinet findUniqueOrThrow
   */
  export type ViresCabinetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetInclude<ExtArgs> | null
    /**
     * Filter, which ViresCabinet to fetch.
     */
    where: ViresCabinetWhereUniqueInput
  }

  /**
   * ViresCabinet findFirst
   */
  export type ViresCabinetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetInclude<ExtArgs> | null
    /**
     * Filter, which ViresCabinet to fetch.
     */
    where?: ViresCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresCabinets to fetch.
     */
    orderBy?: ViresCabinetOrderByWithRelationInput | ViresCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViresCabinets.
     */
    cursor?: ViresCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViresCabinets.
     */
    distinct?: ViresCabinetScalarFieldEnum | ViresCabinetScalarFieldEnum[]
  }

  /**
   * ViresCabinet findFirstOrThrow
   */
  export type ViresCabinetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetInclude<ExtArgs> | null
    /**
     * Filter, which ViresCabinet to fetch.
     */
    where?: ViresCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresCabinets to fetch.
     */
    orderBy?: ViresCabinetOrderByWithRelationInput | ViresCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViresCabinets.
     */
    cursor?: ViresCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresCabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViresCabinets.
     */
    distinct?: ViresCabinetScalarFieldEnum | ViresCabinetScalarFieldEnum[]
  }

  /**
   * ViresCabinet findMany
   */
  export type ViresCabinetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetInclude<ExtArgs> | null
    /**
     * Filter, which ViresCabinets to fetch.
     */
    where?: ViresCabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresCabinets to fetch.
     */
    orderBy?: ViresCabinetOrderByWithRelationInput | ViresCabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViresCabinets.
     */
    cursor?: ViresCabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresCabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresCabinets.
     */
    skip?: number
    distinct?: ViresCabinetScalarFieldEnum | ViresCabinetScalarFieldEnum[]
  }

  /**
   * ViresCabinet create
   */
  export type ViresCabinetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetInclude<ExtArgs> | null
    /**
     * The data needed to create a ViresCabinet.
     */
    data: XOR<ViresCabinetCreateInput, ViresCabinetUncheckedCreateInput>
  }

  /**
   * ViresCabinet createMany
   */
  export type ViresCabinetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViresCabinets.
     */
    data: ViresCabinetCreateManyInput | ViresCabinetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViresCabinet createManyAndReturn
   */
  export type ViresCabinetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * The data used to create many ViresCabinets.
     */
    data: ViresCabinetCreateManyInput | ViresCabinetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViresCabinet update
   */
  export type ViresCabinetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetInclude<ExtArgs> | null
    /**
     * The data needed to update a ViresCabinet.
     */
    data: XOR<ViresCabinetUpdateInput, ViresCabinetUncheckedUpdateInput>
    /**
     * Choose, which ViresCabinet to update.
     */
    where: ViresCabinetWhereUniqueInput
  }

  /**
   * ViresCabinet updateMany
   */
  export type ViresCabinetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViresCabinets.
     */
    data: XOR<ViresCabinetUpdateManyMutationInput, ViresCabinetUncheckedUpdateManyInput>
    /**
     * Filter which ViresCabinets to update
     */
    where?: ViresCabinetWhereInput
    /**
     * Limit how many ViresCabinets to update.
     */
    limit?: number
  }

  /**
   * ViresCabinet updateManyAndReturn
   */
  export type ViresCabinetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * The data used to update ViresCabinets.
     */
    data: XOR<ViresCabinetUpdateManyMutationInput, ViresCabinetUncheckedUpdateManyInput>
    /**
     * Filter which ViresCabinets to update
     */
    where?: ViresCabinetWhereInput
    /**
     * Limit how many ViresCabinets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViresCabinet upsert
   */
  export type ViresCabinetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetInclude<ExtArgs> | null
    /**
     * The filter to search for the ViresCabinet to update in case it exists.
     */
    where: ViresCabinetWhereUniqueInput
    /**
     * In case the ViresCabinet found by the `where` argument doesn't exist, create a new ViresCabinet with this data.
     */
    create: XOR<ViresCabinetCreateInput, ViresCabinetUncheckedCreateInput>
    /**
     * In case the ViresCabinet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViresCabinetUpdateInput, ViresCabinetUncheckedUpdateInput>
  }

  /**
   * ViresCabinet delete
   */
  export type ViresCabinetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetInclude<ExtArgs> | null
    /**
     * Filter which ViresCabinet to delete.
     */
    where: ViresCabinetWhereUniqueInput
  }

  /**
   * ViresCabinet deleteMany
   */
  export type ViresCabinetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViresCabinets to delete
     */
    where?: ViresCabinetWhereInput
    /**
     * Limit how many ViresCabinets to delete.
     */
    limit?: number
  }

  /**
   * ViresCabinet.ViresTransactionPayin
   */
  export type ViresCabinet$ViresTransactionPayinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinInclude<ExtArgs> | null
    where?: ViresTransactionPayinWhereInput
    orderBy?: ViresTransactionPayinOrderByWithRelationInput | ViresTransactionPayinOrderByWithRelationInput[]
    cursor?: ViresTransactionPayinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViresTransactionPayinScalarFieldEnum | ViresTransactionPayinScalarFieldEnum[]
  }

  /**
   * ViresCabinet without action
   */
  export type ViresCabinetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresCabinet
     */
    select?: ViresCabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresCabinet
     */
    omit?: ViresCabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresCabinetInclude<ExtArgs> | null
  }


  /**
   * Model ViresClipMatch
   */

  export type AggregateViresClipMatch = {
    _count: ViresClipMatchCountAggregateOutputType | null
    _avg: ViresClipMatchAvgAggregateOutputType | null
    _sum: ViresClipMatchSumAggregateOutputType | null
    _min: ViresClipMatchMinAggregateOutputType | null
    _max: ViresClipMatchMaxAggregateOutputType | null
  }

  export type ViresClipMatchAvgAggregateOutputType = {
    id: number | null
    viresTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    matchViresReportId: number | null
    userId: number | null
    bybitTransactionId: number | null
  }

  export type ViresClipMatchSumAggregateOutputType = {
    id: number | null
    viresTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    matchViresReportId: number | null
    userId: number | null
    bybitTransactionId: number | null
  }

  export type ViresClipMatchMinAggregateOutputType = {
    id: number | null
    viresTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    matchViresReportId: number | null
    userId: number | null
    bybitTransactionId: number | null
  }

  export type ViresClipMatchMaxAggregateOutputType = {
    id: number | null
    viresTransactionId: number | null
    timeDifference: number | null
    grossExpense: number | null
    grossIncome: number | null
    grossProfit: number | null
    profitPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    matchViresReportId: number | null
    userId: number | null
    bybitTransactionId: number | null
  }

  export type ViresClipMatchCountAggregateOutputType = {
    id: number
    viresTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt: number
    updatedAt: number
    matchViresReportId: number
    userId: number
    bybitTransactionId: number
    _all: number
  }


  export type ViresClipMatchAvgAggregateInputType = {
    id?: true
    viresTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    matchViresReportId?: true
    userId?: true
    bybitTransactionId?: true
  }

  export type ViresClipMatchSumAggregateInputType = {
    id?: true
    viresTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    matchViresReportId?: true
    userId?: true
    bybitTransactionId?: true
  }

  export type ViresClipMatchMinAggregateInputType = {
    id?: true
    viresTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
    matchViresReportId?: true
    userId?: true
    bybitTransactionId?: true
  }

  export type ViresClipMatchMaxAggregateInputType = {
    id?: true
    viresTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
    matchViresReportId?: true
    userId?: true
    bybitTransactionId?: true
  }

  export type ViresClipMatchCountAggregateInputType = {
    id?: true
    viresTransactionId?: true
    timeDifference?: true
    grossExpense?: true
    grossIncome?: true
    grossProfit?: true
    profitPercentage?: true
    createdAt?: true
    updatedAt?: true
    matchViresReportId?: true
    userId?: true
    bybitTransactionId?: true
    _all?: true
  }

  export type ViresClipMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViresClipMatch to aggregate.
     */
    where?: ViresClipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresClipMatches to fetch.
     */
    orderBy?: ViresClipMatchOrderByWithRelationInput | ViresClipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViresClipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresClipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresClipMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViresClipMatches
    **/
    _count?: true | ViresClipMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViresClipMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViresClipMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViresClipMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViresClipMatchMaxAggregateInputType
  }

  export type GetViresClipMatchAggregateType<T extends ViresClipMatchAggregateArgs> = {
        [P in keyof T & keyof AggregateViresClipMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViresClipMatch[P]>
      : GetScalarType<T[P], AggregateViresClipMatch[P]>
  }




  export type ViresClipMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViresClipMatchWhereInput
    orderBy?: ViresClipMatchOrderByWithAggregationInput | ViresClipMatchOrderByWithAggregationInput[]
    by: ViresClipMatchScalarFieldEnum[] | ViresClipMatchScalarFieldEnum
    having?: ViresClipMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViresClipMatchCountAggregateInputType | true
    _avg?: ViresClipMatchAvgAggregateInputType
    _sum?: ViresClipMatchSumAggregateInputType
    _min?: ViresClipMatchMinAggregateInputType
    _max?: ViresClipMatchMaxAggregateInputType
  }

  export type ViresClipMatchGroupByOutputType = {
    id: number
    viresTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt: Date
    updatedAt: Date
    matchViresReportId: number | null
    userId: number
    bybitTransactionId: number
    _count: ViresClipMatchCountAggregateOutputType | null
    _avg: ViresClipMatchAvgAggregateOutputType | null
    _sum: ViresClipMatchSumAggregateOutputType | null
    _min: ViresClipMatchMinAggregateOutputType | null
    _max: ViresClipMatchMaxAggregateOutputType | null
  }

  type GetViresClipMatchGroupByPayload<T extends ViresClipMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViresClipMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViresClipMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViresClipMatchGroupByOutputType[P]>
            : GetScalarType<T[P], ViresClipMatchGroupByOutputType[P]>
        }
      >
    >


  export type ViresClipMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    viresTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchViresReportId?: boolean
    userId?: boolean
    bybitTransactionId?: boolean
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    MatchViresReport?: boolean | ViresClipMatch$MatchViresReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    ViresTransactionPayin?: boolean | ViresTransactionPayinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viresClipMatch"]>

  export type ViresClipMatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    viresTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchViresReportId?: boolean
    userId?: boolean
    bybitTransactionId?: boolean
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    MatchViresReport?: boolean | ViresClipMatch$MatchViresReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    ViresTransactionPayin?: boolean | ViresTransactionPayinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viresClipMatch"]>

  export type ViresClipMatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    viresTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchViresReportId?: boolean
    userId?: boolean
    bybitTransactionId?: boolean
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    MatchViresReport?: boolean | ViresClipMatch$MatchViresReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    ViresTransactionPayin?: boolean | ViresTransactionPayinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viresClipMatch"]>

  export type ViresClipMatchSelectScalar = {
    id?: boolean
    viresTransactionId?: boolean
    timeDifference?: boolean
    grossExpense?: boolean
    grossIncome?: boolean
    grossProfit?: boolean
    profitPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matchViresReportId?: boolean
    userId?: boolean
    bybitTransactionId?: boolean
  }

  export type ViresClipMatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "viresTransactionId" | "timeDifference" | "grossExpense" | "grossIncome" | "grossProfit" | "profitPercentage" | "createdAt" | "updatedAt" | "matchViresReportId" | "userId" | "bybitTransactionId", ExtArgs["result"]["viresClipMatch"]>
  export type ViresClipMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    MatchViresReport?: boolean | ViresClipMatch$MatchViresReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    ViresTransactionPayin?: boolean | ViresTransactionPayinDefaultArgs<ExtArgs>
  }
  export type ViresClipMatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    MatchViresReport?: boolean | ViresClipMatch$MatchViresReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    ViresTransactionPayin?: boolean | ViresTransactionPayinDefaultArgs<ExtArgs>
  }
  export type ViresClipMatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BybitTransactionFromCabinet?: boolean | BybitTransactionFromCabinetDefaultArgs<ExtArgs>
    MatchViresReport?: boolean | ViresClipMatch$MatchViresReportArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    ViresTransactionPayin?: boolean | ViresTransactionPayinDefaultArgs<ExtArgs>
  }

  export type $ViresClipMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViresClipMatch"
    objects: {
      BybitTransactionFromCabinet: Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>
      MatchViresReport: Prisma.$MatchViresReportPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
      ViresTransactionPayin: Prisma.$ViresTransactionPayinPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      viresTransactionId: number
      timeDifference: number
      grossExpense: number
      grossIncome: number
      grossProfit: number
      profitPercentage: number
      createdAt: Date
      updatedAt: Date
      matchViresReportId: number | null
      userId: number
      bybitTransactionId: number
    }, ExtArgs["result"]["viresClipMatch"]>
    composites: {}
  }

  type ViresClipMatchGetPayload<S extends boolean | null | undefined | ViresClipMatchDefaultArgs> = $Result.GetResult<Prisma.$ViresClipMatchPayload, S>

  type ViresClipMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViresClipMatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViresClipMatchCountAggregateInputType | true
    }

  export interface ViresClipMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViresClipMatch'], meta: { name: 'ViresClipMatch' } }
    /**
     * Find zero or one ViresClipMatch that matches the filter.
     * @param {ViresClipMatchFindUniqueArgs} args - Arguments to find a ViresClipMatch
     * @example
     * // Get one ViresClipMatch
     * const viresClipMatch = await prisma.viresClipMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViresClipMatchFindUniqueArgs>(args: SelectSubset<T, ViresClipMatchFindUniqueArgs<ExtArgs>>): Prisma__ViresClipMatchClient<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViresClipMatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViresClipMatchFindUniqueOrThrowArgs} args - Arguments to find a ViresClipMatch
     * @example
     * // Get one ViresClipMatch
     * const viresClipMatch = await prisma.viresClipMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViresClipMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, ViresClipMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViresClipMatchClient<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViresClipMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresClipMatchFindFirstArgs} args - Arguments to find a ViresClipMatch
     * @example
     * // Get one ViresClipMatch
     * const viresClipMatch = await prisma.viresClipMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViresClipMatchFindFirstArgs>(args?: SelectSubset<T, ViresClipMatchFindFirstArgs<ExtArgs>>): Prisma__ViresClipMatchClient<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViresClipMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresClipMatchFindFirstOrThrowArgs} args - Arguments to find a ViresClipMatch
     * @example
     * // Get one ViresClipMatch
     * const viresClipMatch = await prisma.viresClipMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViresClipMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, ViresClipMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViresClipMatchClient<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViresClipMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresClipMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViresClipMatches
     * const viresClipMatches = await prisma.viresClipMatch.findMany()
     * 
     * // Get first 10 ViresClipMatches
     * const viresClipMatches = await prisma.viresClipMatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viresClipMatchWithIdOnly = await prisma.viresClipMatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViresClipMatchFindManyArgs>(args?: SelectSubset<T, ViresClipMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViresClipMatch.
     * @param {ViresClipMatchCreateArgs} args - Arguments to create a ViresClipMatch.
     * @example
     * // Create one ViresClipMatch
     * const ViresClipMatch = await prisma.viresClipMatch.create({
     *   data: {
     *     // ... data to create a ViresClipMatch
     *   }
     * })
     * 
     */
    create<T extends ViresClipMatchCreateArgs>(args: SelectSubset<T, ViresClipMatchCreateArgs<ExtArgs>>): Prisma__ViresClipMatchClient<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViresClipMatches.
     * @param {ViresClipMatchCreateManyArgs} args - Arguments to create many ViresClipMatches.
     * @example
     * // Create many ViresClipMatches
     * const viresClipMatch = await prisma.viresClipMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViresClipMatchCreateManyArgs>(args?: SelectSubset<T, ViresClipMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViresClipMatches and returns the data saved in the database.
     * @param {ViresClipMatchCreateManyAndReturnArgs} args - Arguments to create many ViresClipMatches.
     * @example
     * // Create many ViresClipMatches
     * const viresClipMatch = await prisma.viresClipMatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViresClipMatches and only return the `id`
     * const viresClipMatchWithIdOnly = await prisma.viresClipMatch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViresClipMatchCreateManyAndReturnArgs>(args?: SelectSubset<T, ViresClipMatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ViresClipMatch.
     * @param {ViresClipMatchDeleteArgs} args - Arguments to delete one ViresClipMatch.
     * @example
     * // Delete one ViresClipMatch
     * const ViresClipMatch = await prisma.viresClipMatch.delete({
     *   where: {
     *     // ... filter to delete one ViresClipMatch
     *   }
     * })
     * 
     */
    delete<T extends ViresClipMatchDeleteArgs>(args: SelectSubset<T, ViresClipMatchDeleteArgs<ExtArgs>>): Prisma__ViresClipMatchClient<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViresClipMatch.
     * @param {ViresClipMatchUpdateArgs} args - Arguments to update one ViresClipMatch.
     * @example
     * // Update one ViresClipMatch
     * const viresClipMatch = await prisma.viresClipMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViresClipMatchUpdateArgs>(args: SelectSubset<T, ViresClipMatchUpdateArgs<ExtArgs>>): Prisma__ViresClipMatchClient<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViresClipMatches.
     * @param {ViresClipMatchDeleteManyArgs} args - Arguments to filter ViresClipMatches to delete.
     * @example
     * // Delete a few ViresClipMatches
     * const { count } = await prisma.viresClipMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViresClipMatchDeleteManyArgs>(args?: SelectSubset<T, ViresClipMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViresClipMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresClipMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViresClipMatches
     * const viresClipMatch = await prisma.viresClipMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViresClipMatchUpdateManyArgs>(args: SelectSubset<T, ViresClipMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViresClipMatches and returns the data updated in the database.
     * @param {ViresClipMatchUpdateManyAndReturnArgs} args - Arguments to update many ViresClipMatches.
     * @example
     * // Update many ViresClipMatches
     * const viresClipMatch = await prisma.viresClipMatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViresClipMatches and only return the `id`
     * const viresClipMatchWithIdOnly = await prisma.viresClipMatch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViresClipMatchUpdateManyAndReturnArgs>(args: SelectSubset<T, ViresClipMatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ViresClipMatch.
     * @param {ViresClipMatchUpsertArgs} args - Arguments to update or create a ViresClipMatch.
     * @example
     * // Update or create a ViresClipMatch
     * const viresClipMatch = await prisma.viresClipMatch.upsert({
     *   create: {
     *     // ... data to create a ViresClipMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViresClipMatch we want to update
     *   }
     * })
     */
    upsert<T extends ViresClipMatchUpsertArgs>(args: SelectSubset<T, ViresClipMatchUpsertArgs<ExtArgs>>): Prisma__ViresClipMatchClient<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViresClipMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresClipMatchCountArgs} args - Arguments to filter ViresClipMatches to count.
     * @example
     * // Count the number of ViresClipMatches
     * const count = await prisma.viresClipMatch.count({
     *   where: {
     *     // ... the filter for the ViresClipMatches we want to count
     *   }
     * })
    **/
    count<T extends ViresClipMatchCountArgs>(
      args?: Subset<T, ViresClipMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViresClipMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViresClipMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresClipMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViresClipMatchAggregateArgs>(args: Subset<T, ViresClipMatchAggregateArgs>): Prisma.PrismaPromise<GetViresClipMatchAggregateType<T>>

    /**
     * Group by ViresClipMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresClipMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViresClipMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViresClipMatchGroupByArgs['orderBy'] }
        : { orderBy?: ViresClipMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViresClipMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViresClipMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViresClipMatch model
   */
  readonly fields: ViresClipMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViresClipMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViresClipMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BybitTransactionFromCabinet<T extends BybitTransactionFromCabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BybitTransactionFromCabinetDefaultArgs<ExtArgs>>): Prisma__BybitTransactionFromCabinetClient<$Result.GetResult<Prisma.$BybitTransactionFromCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    MatchViresReport<T extends ViresClipMatch$MatchViresReportArgs<ExtArgs> = {}>(args?: Subset<T, ViresClipMatch$MatchViresReportArgs<ExtArgs>>): Prisma__MatchViresReportClient<$Result.GetResult<Prisma.$MatchViresReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ViresTransactionPayin<T extends ViresTransactionPayinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViresTransactionPayinDefaultArgs<ExtArgs>>): Prisma__ViresTransactionPayinClient<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViresClipMatch model
   */
  interface ViresClipMatchFieldRefs {
    readonly id: FieldRef<"ViresClipMatch", 'Int'>
    readonly viresTransactionId: FieldRef<"ViresClipMatch", 'Int'>
    readonly timeDifference: FieldRef<"ViresClipMatch", 'Int'>
    readonly grossExpense: FieldRef<"ViresClipMatch", 'Float'>
    readonly grossIncome: FieldRef<"ViresClipMatch", 'Float'>
    readonly grossProfit: FieldRef<"ViresClipMatch", 'Float'>
    readonly profitPercentage: FieldRef<"ViresClipMatch", 'Float'>
    readonly createdAt: FieldRef<"ViresClipMatch", 'DateTime'>
    readonly updatedAt: FieldRef<"ViresClipMatch", 'DateTime'>
    readonly matchViresReportId: FieldRef<"ViresClipMatch", 'Int'>
    readonly userId: FieldRef<"ViresClipMatch", 'Int'>
    readonly bybitTransactionId: FieldRef<"ViresClipMatch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ViresClipMatch findUnique
   */
  export type ViresClipMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    /**
     * Filter, which ViresClipMatch to fetch.
     */
    where: ViresClipMatchWhereUniqueInput
  }

  /**
   * ViresClipMatch findUniqueOrThrow
   */
  export type ViresClipMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    /**
     * Filter, which ViresClipMatch to fetch.
     */
    where: ViresClipMatchWhereUniqueInput
  }

  /**
   * ViresClipMatch findFirst
   */
  export type ViresClipMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    /**
     * Filter, which ViresClipMatch to fetch.
     */
    where?: ViresClipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresClipMatches to fetch.
     */
    orderBy?: ViresClipMatchOrderByWithRelationInput | ViresClipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViresClipMatches.
     */
    cursor?: ViresClipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresClipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresClipMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViresClipMatches.
     */
    distinct?: ViresClipMatchScalarFieldEnum | ViresClipMatchScalarFieldEnum[]
  }

  /**
   * ViresClipMatch findFirstOrThrow
   */
  export type ViresClipMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    /**
     * Filter, which ViresClipMatch to fetch.
     */
    where?: ViresClipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresClipMatches to fetch.
     */
    orderBy?: ViresClipMatchOrderByWithRelationInput | ViresClipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViresClipMatches.
     */
    cursor?: ViresClipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresClipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresClipMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViresClipMatches.
     */
    distinct?: ViresClipMatchScalarFieldEnum | ViresClipMatchScalarFieldEnum[]
  }

  /**
   * ViresClipMatch findMany
   */
  export type ViresClipMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    /**
     * Filter, which ViresClipMatches to fetch.
     */
    where?: ViresClipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresClipMatches to fetch.
     */
    orderBy?: ViresClipMatchOrderByWithRelationInput | ViresClipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViresClipMatches.
     */
    cursor?: ViresClipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresClipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresClipMatches.
     */
    skip?: number
    distinct?: ViresClipMatchScalarFieldEnum | ViresClipMatchScalarFieldEnum[]
  }

  /**
   * ViresClipMatch create
   */
  export type ViresClipMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a ViresClipMatch.
     */
    data: XOR<ViresClipMatchCreateInput, ViresClipMatchUncheckedCreateInput>
  }

  /**
   * ViresClipMatch createMany
   */
  export type ViresClipMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViresClipMatches.
     */
    data: ViresClipMatchCreateManyInput | ViresClipMatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViresClipMatch createManyAndReturn
   */
  export type ViresClipMatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * The data used to create many ViresClipMatches.
     */
    data: ViresClipMatchCreateManyInput | ViresClipMatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViresClipMatch update
   */
  export type ViresClipMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a ViresClipMatch.
     */
    data: XOR<ViresClipMatchUpdateInput, ViresClipMatchUncheckedUpdateInput>
    /**
     * Choose, which ViresClipMatch to update.
     */
    where: ViresClipMatchWhereUniqueInput
  }

  /**
   * ViresClipMatch updateMany
   */
  export type ViresClipMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViresClipMatches.
     */
    data: XOR<ViresClipMatchUpdateManyMutationInput, ViresClipMatchUncheckedUpdateManyInput>
    /**
     * Filter which ViresClipMatches to update
     */
    where?: ViresClipMatchWhereInput
    /**
     * Limit how many ViresClipMatches to update.
     */
    limit?: number
  }

  /**
   * ViresClipMatch updateManyAndReturn
   */
  export type ViresClipMatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * The data used to update ViresClipMatches.
     */
    data: XOR<ViresClipMatchUpdateManyMutationInput, ViresClipMatchUncheckedUpdateManyInput>
    /**
     * Filter which ViresClipMatches to update
     */
    where?: ViresClipMatchWhereInput
    /**
     * Limit how many ViresClipMatches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViresClipMatch upsert
   */
  export type ViresClipMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the ViresClipMatch to update in case it exists.
     */
    where: ViresClipMatchWhereUniqueInput
    /**
     * In case the ViresClipMatch found by the `where` argument doesn't exist, create a new ViresClipMatch with this data.
     */
    create: XOR<ViresClipMatchCreateInput, ViresClipMatchUncheckedCreateInput>
    /**
     * In case the ViresClipMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViresClipMatchUpdateInput, ViresClipMatchUncheckedUpdateInput>
  }

  /**
   * ViresClipMatch delete
   */
  export type ViresClipMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    /**
     * Filter which ViresClipMatch to delete.
     */
    where: ViresClipMatchWhereUniqueInput
  }

  /**
   * ViresClipMatch deleteMany
   */
  export type ViresClipMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViresClipMatches to delete
     */
    where?: ViresClipMatchWhereInput
    /**
     * Limit how many ViresClipMatches to delete.
     */
    limit?: number
  }

  /**
   * ViresClipMatch.MatchViresReport
   */
  export type ViresClipMatch$MatchViresReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchViresReport
     */
    select?: MatchViresReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchViresReport
     */
    omit?: MatchViresReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchViresReportInclude<ExtArgs> | null
    where?: MatchViresReportWhereInput
  }

  /**
   * ViresClipMatch without action
   */
  export type ViresClipMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
  }


  /**
   * Model ViresTransactionPayin
   */

  export type AggregateViresTransactionPayin = {
    _count: ViresTransactionPayinCountAggregateOutputType | null
    _avg: ViresTransactionPayinAvgAggregateOutputType | null
    _sum: ViresTransactionPayinSumAggregateOutputType | null
    _min: ViresTransactionPayinMinAggregateOutputType | null
    _max: ViresTransactionPayinMaxAggregateOutputType | null
  }

  export type ViresTransactionPayinAvgAggregateOutputType = {
    id: number | null
    cabinetId: number | null
    sum_rub: number | null
    sum_usdt: number | null
  }

  export type ViresTransactionPayinSumAggregateOutputType = {
    id: number | null
    cabinetId: number | null
    sum_rub: number | null
    sum_usdt: number | null
  }

  export type ViresTransactionPayinMinAggregateOutputType = {
    id: number | null
    cabinetId: number | null
    createdAt: Date | null
    sum_rub: number | null
    sum_usdt: number | null
    card: string | null
    fio: string | null
    bank: string | null
    uuid: string | null
  }

  export type ViresTransactionPayinMaxAggregateOutputType = {
    id: number | null
    cabinetId: number | null
    createdAt: Date | null
    sum_rub: number | null
    sum_usdt: number | null
    card: string | null
    fio: string | null
    bank: string | null
    uuid: string | null
  }

  export type ViresTransactionPayinCountAggregateOutputType = {
    id: number
    cabinetId: number
    createdAt: number
    sum_rub: number
    sum_usdt: number
    card: number
    fio: number
    bank: number
    uuid: number
    _all: number
  }


  export type ViresTransactionPayinAvgAggregateInputType = {
    id?: true
    cabinetId?: true
    sum_rub?: true
    sum_usdt?: true
  }

  export type ViresTransactionPayinSumAggregateInputType = {
    id?: true
    cabinetId?: true
    sum_rub?: true
    sum_usdt?: true
  }

  export type ViresTransactionPayinMinAggregateInputType = {
    id?: true
    cabinetId?: true
    createdAt?: true
    sum_rub?: true
    sum_usdt?: true
    card?: true
    fio?: true
    bank?: true
    uuid?: true
  }

  export type ViresTransactionPayinMaxAggregateInputType = {
    id?: true
    cabinetId?: true
    createdAt?: true
    sum_rub?: true
    sum_usdt?: true
    card?: true
    fio?: true
    bank?: true
    uuid?: true
  }

  export type ViresTransactionPayinCountAggregateInputType = {
    id?: true
    cabinetId?: true
    createdAt?: true
    sum_rub?: true
    sum_usdt?: true
    card?: true
    fio?: true
    bank?: true
    uuid?: true
    _all?: true
  }

  export type ViresTransactionPayinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViresTransactionPayin to aggregate.
     */
    where?: ViresTransactionPayinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresTransactionPayins to fetch.
     */
    orderBy?: ViresTransactionPayinOrderByWithRelationInput | ViresTransactionPayinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViresTransactionPayinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresTransactionPayins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresTransactionPayins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViresTransactionPayins
    **/
    _count?: true | ViresTransactionPayinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViresTransactionPayinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViresTransactionPayinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViresTransactionPayinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViresTransactionPayinMaxAggregateInputType
  }

  export type GetViresTransactionPayinAggregateType<T extends ViresTransactionPayinAggregateArgs> = {
        [P in keyof T & keyof AggregateViresTransactionPayin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViresTransactionPayin[P]>
      : GetScalarType<T[P], AggregateViresTransactionPayin[P]>
  }




  export type ViresTransactionPayinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViresTransactionPayinWhereInput
    orderBy?: ViresTransactionPayinOrderByWithAggregationInput | ViresTransactionPayinOrderByWithAggregationInput[]
    by: ViresTransactionPayinScalarFieldEnum[] | ViresTransactionPayinScalarFieldEnum
    having?: ViresTransactionPayinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViresTransactionPayinCountAggregateInputType | true
    _avg?: ViresTransactionPayinAvgAggregateInputType
    _sum?: ViresTransactionPayinSumAggregateInputType
    _min?: ViresTransactionPayinMinAggregateInputType
    _max?: ViresTransactionPayinMaxAggregateInputType
  }

  export type ViresTransactionPayinGroupByOutputType = {
    id: number
    cabinetId: number
    createdAt: Date
    sum_rub: number
    sum_usdt: number
    card: string
    fio: string
    bank: string
    uuid: string
    _count: ViresTransactionPayinCountAggregateOutputType | null
    _avg: ViresTransactionPayinAvgAggregateOutputType | null
    _sum: ViresTransactionPayinSumAggregateOutputType | null
    _min: ViresTransactionPayinMinAggregateOutputType | null
    _max: ViresTransactionPayinMaxAggregateOutputType | null
  }

  type GetViresTransactionPayinGroupByPayload<T extends ViresTransactionPayinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViresTransactionPayinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViresTransactionPayinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViresTransactionPayinGroupByOutputType[P]>
            : GetScalarType<T[P], ViresTransactionPayinGroupByOutputType[P]>
        }
      >
    >


  export type ViresTransactionPayinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cabinetId?: boolean
    createdAt?: boolean
    sum_rub?: boolean
    sum_usdt?: boolean
    card?: boolean
    fio?: boolean
    bank?: boolean
    uuid?: boolean
    ViresClipMatch?: boolean | ViresTransactionPayin$ViresClipMatchArgs<ExtArgs>
    ViresCabinet?: boolean | ViresCabinetDefaultArgs<ExtArgs>
    _count?: boolean | ViresTransactionPayinCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viresTransactionPayin"]>

  export type ViresTransactionPayinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cabinetId?: boolean
    createdAt?: boolean
    sum_rub?: boolean
    sum_usdt?: boolean
    card?: boolean
    fio?: boolean
    bank?: boolean
    uuid?: boolean
    ViresCabinet?: boolean | ViresCabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viresTransactionPayin"]>

  export type ViresTransactionPayinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cabinetId?: boolean
    createdAt?: boolean
    sum_rub?: boolean
    sum_usdt?: boolean
    card?: boolean
    fio?: boolean
    bank?: boolean
    uuid?: boolean
    ViresCabinet?: boolean | ViresCabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viresTransactionPayin"]>

  export type ViresTransactionPayinSelectScalar = {
    id?: boolean
    cabinetId?: boolean
    createdAt?: boolean
    sum_rub?: boolean
    sum_usdt?: boolean
    card?: boolean
    fio?: boolean
    bank?: boolean
    uuid?: boolean
  }

  export type ViresTransactionPayinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cabinetId" | "createdAt" | "sum_rub" | "sum_usdt" | "card" | "fio" | "bank" | "uuid", ExtArgs["result"]["viresTransactionPayin"]>
  export type ViresTransactionPayinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ViresClipMatch?: boolean | ViresTransactionPayin$ViresClipMatchArgs<ExtArgs>
    ViresCabinet?: boolean | ViresCabinetDefaultArgs<ExtArgs>
    _count?: boolean | ViresTransactionPayinCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ViresTransactionPayinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ViresCabinet?: boolean | ViresCabinetDefaultArgs<ExtArgs>
  }
  export type ViresTransactionPayinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ViresCabinet?: boolean | ViresCabinetDefaultArgs<ExtArgs>
  }

  export type $ViresTransactionPayinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViresTransactionPayin"
    objects: {
      ViresClipMatch: Prisma.$ViresClipMatchPayload<ExtArgs>[]
      ViresCabinet: Prisma.$ViresCabinetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cabinetId: number
      createdAt: Date
      sum_rub: number
      sum_usdt: number
      card: string
      fio: string
      bank: string
      uuid: string
    }, ExtArgs["result"]["viresTransactionPayin"]>
    composites: {}
  }

  type ViresTransactionPayinGetPayload<S extends boolean | null | undefined | ViresTransactionPayinDefaultArgs> = $Result.GetResult<Prisma.$ViresTransactionPayinPayload, S>

  type ViresTransactionPayinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViresTransactionPayinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViresTransactionPayinCountAggregateInputType | true
    }

  export interface ViresTransactionPayinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViresTransactionPayin'], meta: { name: 'ViresTransactionPayin' } }
    /**
     * Find zero or one ViresTransactionPayin that matches the filter.
     * @param {ViresTransactionPayinFindUniqueArgs} args - Arguments to find a ViresTransactionPayin
     * @example
     * // Get one ViresTransactionPayin
     * const viresTransactionPayin = await prisma.viresTransactionPayin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViresTransactionPayinFindUniqueArgs>(args: SelectSubset<T, ViresTransactionPayinFindUniqueArgs<ExtArgs>>): Prisma__ViresTransactionPayinClient<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViresTransactionPayin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViresTransactionPayinFindUniqueOrThrowArgs} args - Arguments to find a ViresTransactionPayin
     * @example
     * // Get one ViresTransactionPayin
     * const viresTransactionPayin = await prisma.viresTransactionPayin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViresTransactionPayinFindUniqueOrThrowArgs>(args: SelectSubset<T, ViresTransactionPayinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViresTransactionPayinClient<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViresTransactionPayin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresTransactionPayinFindFirstArgs} args - Arguments to find a ViresTransactionPayin
     * @example
     * // Get one ViresTransactionPayin
     * const viresTransactionPayin = await prisma.viresTransactionPayin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViresTransactionPayinFindFirstArgs>(args?: SelectSubset<T, ViresTransactionPayinFindFirstArgs<ExtArgs>>): Prisma__ViresTransactionPayinClient<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViresTransactionPayin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresTransactionPayinFindFirstOrThrowArgs} args - Arguments to find a ViresTransactionPayin
     * @example
     * // Get one ViresTransactionPayin
     * const viresTransactionPayin = await prisma.viresTransactionPayin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViresTransactionPayinFindFirstOrThrowArgs>(args?: SelectSubset<T, ViresTransactionPayinFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViresTransactionPayinClient<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViresTransactionPayins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresTransactionPayinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViresTransactionPayins
     * const viresTransactionPayins = await prisma.viresTransactionPayin.findMany()
     * 
     * // Get first 10 ViresTransactionPayins
     * const viresTransactionPayins = await prisma.viresTransactionPayin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viresTransactionPayinWithIdOnly = await prisma.viresTransactionPayin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViresTransactionPayinFindManyArgs>(args?: SelectSubset<T, ViresTransactionPayinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViresTransactionPayin.
     * @param {ViresTransactionPayinCreateArgs} args - Arguments to create a ViresTransactionPayin.
     * @example
     * // Create one ViresTransactionPayin
     * const ViresTransactionPayin = await prisma.viresTransactionPayin.create({
     *   data: {
     *     // ... data to create a ViresTransactionPayin
     *   }
     * })
     * 
     */
    create<T extends ViresTransactionPayinCreateArgs>(args: SelectSubset<T, ViresTransactionPayinCreateArgs<ExtArgs>>): Prisma__ViresTransactionPayinClient<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViresTransactionPayins.
     * @param {ViresTransactionPayinCreateManyArgs} args - Arguments to create many ViresTransactionPayins.
     * @example
     * // Create many ViresTransactionPayins
     * const viresTransactionPayin = await prisma.viresTransactionPayin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViresTransactionPayinCreateManyArgs>(args?: SelectSubset<T, ViresTransactionPayinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViresTransactionPayins and returns the data saved in the database.
     * @param {ViresTransactionPayinCreateManyAndReturnArgs} args - Arguments to create many ViresTransactionPayins.
     * @example
     * // Create many ViresTransactionPayins
     * const viresTransactionPayin = await prisma.viresTransactionPayin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViresTransactionPayins and only return the `id`
     * const viresTransactionPayinWithIdOnly = await prisma.viresTransactionPayin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViresTransactionPayinCreateManyAndReturnArgs>(args?: SelectSubset<T, ViresTransactionPayinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ViresTransactionPayin.
     * @param {ViresTransactionPayinDeleteArgs} args - Arguments to delete one ViresTransactionPayin.
     * @example
     * // Delete one ViresTransactionPayin
     * const ViresTransactionPayin = await prisma.viresTransactionPayin.delete({
     *   where: {
     *     // ... filter to delete one ViresTransactionPayin
     *   }
     * })
     * 
     */
    delete<T extends ViresTransactionPayinDeleteArgs>(args: SelectSubset<T, ViresTransactionPayinDeleteArgs<ExtArgs>>): Prisma__ViresTransactionPayinClient<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViresTransactionPayin.
     * @param {ViresTransactionPayinUpdateArgs} args - Arguments to update one ViresTransactionPayin.
     * @example
     * // Update one ViresTransactionPayin
     * const viresTransactionPayin = await prisma.viresTransactionPayin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViresTransactionPayinUpdateArgs>(args: SelectSubset<T, ViresTransactionPayinUpdateArgs<ExtArgs>>): Prisma__ViresTransactionPayinClient<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViresTransactionPayins.
     * @param {ViresTransactionPayinDeleteManyArgs} args - Arguments to filter ViresTransactionPayins to delete.
     * @example
     * // Delete a few ViresTransactionPayins
     * const { count } = await prisma.viresTransactionPayin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViresTransactionPayinDeleteManyArgs>(args?: SelectSubset<T, ViresTransactionPayinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViresTransactionPayins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresTransactionPayinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViresTransactionPayins
     * const viresTransactionPayin = await prisma.viresTransactionPayin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViresTransactionPayinUpdateManyArgs>(args: SelectSubset<T, ViresTransactionPayinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViresTransactionPayins and returns the data updated in the database.
     * @param {ViresTransactionPayinUpdateManyAndReturnArgs} args - Arguments to update many ViresTransactionPayins.
     * @example
     * // Update many ViresTransactionPayins
     * const viresTransactionPayin = await prisma.viresTransactionPayin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViresTransactionPayins and only return the `id`
     * const viresTransactionPayinWithIdOnly = await prisma.viresTransactionPayin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViresTransactionPayinUpdateManyAndReturnArgs>(args: SelectSubset<T, ViresTransactionPayinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ViresTransactionPayin.
     * @param {ViresTransactionPayinUpsertArgs} args - Arguments to update or create a ViresTransactionPayin.
     * @example
     * // Update or create a ViresTransactionPayin
     * const viresTransactionPayin = await prisma.viresTransactionPayin.upsert({
     *   create: {
     *     // ... data to create a ViresTransactionPayin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViresTransactionPayin we want to update
     *   }
     * })
     */
    upsert<T extends ViresTransactionPayinUpsertArgs>(args: SelectSubset<T, ViresTransactionPayinUpsertArgs<ExtArgs>>): Prisma__ViresTransactionPayinClient<$Result.GetResult<Prisma.$ViresTransactionPayinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViresTransactionPayins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresTransactionPayinCountArgs} args - Arguments to filter ViresTransactionPayins to count.
     * @example
     * // Count the number of ViresTransactionPayins
     * const count = await prisma.viresTransactionPayin.count({
     *   where: {
     *     // ... the filter for the ViresTransactionPayins we want to count
     *   }
     * })
    **/
    count<T extends ViresTransactionPayinCountArgs>(
      args?: Subset<T, ViresTransactionPayinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViresTransactionPayinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViresTransactionPayin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresTransactionPayinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViresTransactionPayinAggregateArgs>(args: Subset<T, ViresTransactionPayinAggregateArgs>): Prisma.PrismaPromise<GetViresTransactionPayinAggregateType<T>>

    /**
     * Group by ViresTransactionPayin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViresTransactionPayinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViresTransactionPayinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViresTransactionPayinGroupByArgs['orderBy'] }
        : { orderBy?: ViresTransactionPayinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViresTransactionPayinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViresTransactionPayinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViresTransactionPayin model
   */
  readonly fields: ViresTransactionPayinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViresTransactionPayin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViresTransactionPayinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ViresClipMatch<T extends ViresTransactionPayin$ViresClipMatchArgs<ExtArgs> = {}>(args?: Subset<T, ViresTransactionPayin$ViresClipMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViresClipMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ViresCabinet<T extends ViresCabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViresCabinetDefaultArgs<ExtArgs>>): Prisma__ViresCabinetClient<$Result.GetResult<Prisma.$ViresCabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViresTransactionPayin model
   */
  interface ViresTransactionPayinFieldRefs {
    readonly id: FieldRef<"ViresTransactionPayin", 'Int'>
    readonly cabinetId: FieldRef<"ViresTransactionPayin", 'Int'>
    readonly createdAt: FieldRef<"ViresTransactionPayin", 'DateTime'>
    readonly sum_rub: FieldRef<"ViresTransactionPayin", 'Float'>
    readonly sum_usdt: FieldRef<"ViresTransactionPayin", 'Float'>
    readonly card: FieldRef<"ViresTransactionPayin", 'String'>
    readonly fio: FieldRef<"ViresTransactionPayin", 'String'>
    readonly bank: FieldRef<"ViresTransactionPayin", 'String'>
    readonly uuid: FieldRef<"ViresTransactionPayin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ViresTransactionPayin findUnique
   */
  export type ViresTransactionPayinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinInclude<ExtArgs> | null
    /**
     * Filter, which ViresTransactionPayin to fetch.
     */
    where: ViresTransactionPayinWhereUniqueInput
  }

  /**
   * ViresTransactionPayin findUniqueOrThrow
   */
  export type ViresTransactionPayinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinInclude<ExtArgs> | null
    /**
     * Filter, which ViresTransactionPayin to fetch.
     */
    where: ViresTransactionPayinWhereUniqueInput
  }

  /**
   * ViresTransactionPayin findFirst
   */
  export type ViresTransactionPayinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinInclude<ExtArgs> | null
    /**
     * Filter, which ViresTransactionPayin to fetch.
     */
    where?: ViresTransactionPayinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresTransactionPayins to fetch.
     */
    orderBy?: ViresTransactionPayinOrderByWithRelationInput | ViresTransactionPayinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViresTransactionPayins.
     */
    cursor?: ViresTransactionPayinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresTransactionPayins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresTransactionPayins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViresTransactionPayins.
     */
    distinct?: ViresTransactionPayinScalarFieldEnum | ViresTransactionPayinScalarFieldEnum[]
  }

  /**
   * ViresTransactionPayin findFirstOrThrow
   */
  export type ViresTransactionPayinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinInclude<ExtArgs> | null
    /**
     * Filter, which ViresTransactionPayin to fetch.
     */
    where?: ViresTransactionPayinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresTransactionPayins to fetch.
     */
    orderBy?: ViresTransactionPayinOrderByWithRelationInput | ViresTransactionPayinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViresTransactionPayins.
     */
    cursor?: ViresTransactionPayinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresTransactionPayins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresTransactionPayins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViresTransactionPayins.
     */
    distinct?: ViresTransactionPayinScalarFieldEnum | ViresTransactionPayinScalarFieldEnum[]
  }

  /**
   * ViresTransactionPayin findMany
   */
  export type ViresTransactionPayinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinInclude<ExtArgs> | null
    /**
     * Filter, which ViresTransactionPayins to fetch.
     */
    where?: ViresTransactionPayinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViresTransactionPayins to fetch.
     */
    orderBy?: ViresTransactionPayinOrderByWithRelationInput | ViresTransactionPayinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViresTransactionPayins.
     */
    cursor?: ViresTransactionPayinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViresTransactionPayins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViresTransactionPayins.
     */
    skip?: number
    distinct?: ViresTransactionPayinScalarFieldEnum | ViresTransactionPayinScalarFieldEnum[]
  }

  /**
   * ViresTransactionPayin create
   */
  export type ViresTransactionPayinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinInclude<ExtArgs> | null
    /**
     * The data needed to create a ViresTransactionPayin.
     */
    data: XOR<ViresTransactionPayinCreateInput, ViresTransactionPayinUncheckedCreateInput>
  }

  /**
   * ViresTransactionPayin createMany
   */
  export type ViresTransactionPayinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViresTransactionPayins.
     */
    data: ViresTransactionPayinCreateManyInput | ViresTransactionPayinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViresTransactionPayin createManyAndReturn
   */
  export type ViresTransactionPayinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * The data used to create many ViresTransactionPayins.
     */
    data: ViresTransactionPayinCreateManyInput | ViresTransactionPayinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViresTransactionPayin update
   */
  export type ViresTransactionPayinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinInclude<ExtArgs> | null
    /**
     * The data needed to update a ViresTransactionPayin.
     */
    data: XOR<ViresTransactionPayinUpdateInput, ViresTransactionPayinUncheckedUpdateInput>
    /**
     * Choose, which ViresTransactionPayin to update.
     */
    where: ViresTransactionPayinWhereUniqueInput
  }

  /**
   * ViresTransactionPayin updateMany
   */
  export type ViresTransactionPayinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViresTransactionPayins.
     */
    data: XOR<ViresTransactionPayinUpdateManyMutationInput, ViresTransactionPayinUncheckedUpdateManyInput>
    /**
     * Filter which ViresTransactionPayins to update
     */
    where?: ViresTransactionPayinWhereInput
    /**
     * Limit how many ViresTransactionPayins to update.
     */
    limit?: number
  }

  /**
   * ViresTransactionPayin updateManyAndReturn
   */
  export type ViresTransactionPayinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * The data used to update ViresTransactionPayins.
     */
    data: XOR<ViresTransactionPayinUpdateManyMutationInput, ViresTransactionPayinUncheckedUpdateManyInput>
    /**
     * Filter which ViresTransactionPayins to update
     */
    where?: ViresTransactionPayinWhereInput
    /**
     * Limit how many ViresTransactionPayins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViresTransactionPayin upsert
   */
  export type ViresTransactionPayinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinInclude<ExtArgs> | null
    /**
     * The filter to search for the ViresTransactionPayin to update in case it exists.
     */
    where: ViresTransactionPayinWhereUniqueInput
    /**
     * In case the ViresTransactionPayin found by the `where` argument doesn't exist, create a new ViresTransactionPayin with this data.
     */
    create: XOR<ViresTransactionPayinCreateInput, ViresTransactionPayinUncheckedCreateInput>
    /**
     * In case the ViresTransactionPayin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViresTransactionPayinUpdateInput, ViresTransactionPayinUncheckedUpdateInput>
  }

  /**
   * ViresTransactionPayin delete
   */
  export type ViresTransactionPayinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinInclude<ExtArgs> | null
    /**
     * Filter which ViresTransactionPayin to delete.
     */
    where: ViresTransactionPayinWhereUniqueInput
  }

  /**
   * ViresTransactionPayin deleteMany
   */
  export type ViresTransactionPayinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViresTransactionPayins to delete
     */
    where?: ViresTransactionPayinWhereInput
    /**
     * Limit how many ViresTransactionPayins to delete.
     */
    limit?: number
  }

  /**
   * ViresTransactionPayin.ViresClipMatch
   */
  export type ViresTransactionPayin$ViresClipMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresClipMatch
     */
    select?: ViresClipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresClipMatch
     */
    omit?: ViresClipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresClipMatchInclude<ExtArgs> | null
    where?: ViresClipMatchWhereInput
    orderBy?: ViresClipMatchOrderByWithRelationInput | ViresClipMatchOrderByWithRelationInput[]
    cursor?: ViresClipMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViresClipMatchScalarFieldEnum | ViresClipMatchScalarFieldEnum[]
  }

  /**
   * ViresTransactionPayin without action
   */
  export type ViresTransactionPayinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViresTransactionPayin
     */
    select?: ViresTransactionPayinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViresTransactionPayin
     */
    omit?: ViresTransactionPayinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViresTransactionPayinInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    telegramId: 'telegramId',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    userId: 'userId',
    timestamp: 'timestamp',
    oldValue: 'oldValue',
    newValue: 'newValue',
    cardBalanceId: 'cardBalanceId',
    cardId: 'cardId',
    cardPouringId: 'cardPouringId'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const BalanceEntryScalarFieldEnum: {
    id: 'id',
    date: 'date',
    time: 'time',
    amount: 'amount',
    currency: 'currency',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    section: 'section'
  };

  export type BalanceEntryScalarFieldEnum = (typeof BalanceEntryScalarFieldEnum)[keyof typeof BalanceEntryScalarFieldEnum]


  export const BybitMatchScalarFieldEnum: {
    id: 'id',
    idexTransactionId: 'idexTransactionId',
    bybitTransactionId: 'bybitTransactionId',
    timeDifference: 'timeDifference',
    grossExpense: 'grossExpense',
    grossIncome: 'grossIncome',
    grossProfit: 'grossProfit',
    profitPercentage: 'profitPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BybitMatchScalarFieldEnum = (typeof BybitMatchScalarFieldEnum)[keyof typeof BybitMatchScalarFieldEnum]


  export const BybitOrderInfoScalarFieldEnum: {
    id: 'id',
    phoneNumbers: 'phoneNumbers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    orderNo: 'orderNo',
    dateTime: 'dateTime',
    originalData: 'originalData',
    status: 'status',
    type: 'type',
    amount: 'amount',
    totalPrice: 'totalPrice',
    processed: 'processed',
    unitPrice: 'unitPrice',
    bybitCabinetId: 'bybitCabinetId'
  };

  export type BybitOrderInfoScalarFieldEnum = (typeof BybitOrderInfoScalarFieldEnum)[keyof typeof BybitOrderInfoScalarFieldEnum]


  export const BybitTransactionScalarFieldEnum: {
    id: 'id',
    orderNo: 'orderNo',
    counterparty: 'counterparty',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    amount: 'amount',
    asset: 'asset',
    dateTime: 'dateTime',
    originalData: 'originalData',
    totalPrice: 'totalPrice',
    type: 'type',
    unitPrice: 'unitPrice',
    processed: 'processed',
    extractedPhones: 'extractedPhones',
    lastAttemptError: 'lastAttemptError'
  };

  export type BybitTransactionScalarFieldEnum = (typeof BybitTransactionScalarFieldEnum)[keyof typeof BybitTransactionScalarFieldEnum]


  export const CardScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    provider: 'provider',
    cardNumber: 'cardNumber',
    bank: 'bank',
    phoneNumber: 'phoneNumber',
    appPin: 'appPin',
    terminalPin: 'terminalPin',
    comment: 'comment',
    picachu: 'picachu',
    status: 'status',
    cardPrice: 'cardPrice',
    isPaid: 'isPaid',
    letterCode: 'letterCode',
    actor: 'actor',
    inWork: 'inWork',
    activePaymentMethod: 'activePaymentMethod'
  };

  export type CardScalarFieldEnum = (typeof CardScalarFieldEnum)[keyof typeof CardScalarFieldEnum]


  export const CardBalanceScalarFieldEnum: {
    id: 'id',
    cardId: 'cardId',
    date: 'date',
    startBalance: 'startBalance',
    endBalance: 'endBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    comment: 'comment'
  };

  export type CardBalanceScalarFieldEnum = (typeof CardBalanceScalarFieldEnum)[keyof typeof CardBalanceScalarFieldEnum]


  export const CardPouringScalarFieldEnum: {
    id: 'id',
    cardId: 'cardId',
    pouringDate: 'pouringDate',
    initialAmount: 'initialAmount',
    initialDate: 'initialDate',
    finalAmount: 'finalAmount',
    finalDate: 'finalDate',
    pouringAmount: 'pouringAmount',
    withdrawalAmount: 'withdrawalAmount',
    withdrawalDate: 'withdrawalDate',
    collectorName: 'collectorName',
    status: 'status',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CardPouringScalarFieldEnum = (typeof CardPouringScalarFieldEnum)[keyof typeof CardPouringScalarFieldEnum]


  export const CellScalarFieldEnum: {
    id: 'id',
    rowId: 'rowId',
    columnId: 'columnId',
    value: 'value',
    displayValue: 'displayValue',
    calculatedValue: 'calculatedValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CellScalarFieldEnum = (typeof CellScalarFieldEnum)[keyof typeof CellScalarFieldEnum]


  export const ColumnScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    tableId: 'tableId',
    width: 'width',
    isRequired: 'isRequired',
    isFilterable: 'isFilterable',
    isSummable: 'isSummable',
    defaultValue: 'defaultValue',
    format: 'format',
    order: 'order',
    options: 'options',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ColumnScalarFieldEnum = (typeof ColumnScalarFieldEnum)[keyof typeof ColumnScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    cellId: 'cellId',
    text: 'text',
    author: 'author',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const FilterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tableId: 'tableId',
    columnId: 'columnId',
    operator: 'operator',
    value: 'value',
    secondValue: 'secondValue',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FilterScalarFieldEnum = (typeof FilterScalarFieldEnum)[keyof typeof FilterScalarFieldEnum]


  export const FinRowScalarFieldEnum: {
    id: 'id',
    date: 'date',
    time: 'time',
    shift: 'shift',
    startBalance: 'startBalance',
    endBalance: 'endBalance',
    employeeId: 'employeeId',
    usdtAmount: 'usdtAmount',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currency: 'currency',
    section: 'section',
    exchangeRate: 'exchangeRate'
  };

  export type FinRowScalarFieldEnum = (typeof FinRowScalarFieldEnum)[keyof typeof FinRowScalarFieldEnum]


  export const FinRowExpenseScalarFieldEnum: {
    id: 'id',
    finRowId: 'finRowId',
    expenseType: 'expenseType',
    amount: 'amount',
    date: 'date',
    time: 'time',
    period: 'period',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currency: 'currency',
    section: 'section'
  };

  export type FinRowExpenseScalarFieldEnum = (typeof FinRowExpenseScalarFieldEnum)[keyof typeof FinRowExpenseScalarFieldEnum]


  export const IdexCabinetScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    idexId: 'idexId',
    login: 'login',
    password: 'password'
  };

  export type IdexCabinetScalarFieldEnum = (typeof IdexCabinetScalarFieldEnum)[keyof typeof IdexCabinetScalarFieldEnum]


  export const IdexSyncOrderScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cabinetId: 'cabinetId',
    processed: 'processed',
    status: 'status',
    startSyncAt: 'startSyncAt',
    endSyncAt: 'endSyncAt',
    pages: 'pages'
  };

  export type IdexSyncOrderScalarFieldEnum = (typeof IdexSyncOrderScalarFieldEnum)[keyof typeof IdexSyncOrderScalarFieldEnum]


  export const IdexTransactionScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    paymentMethodId: 'paymentMethodId',
    wallet: 'wallet',
    amount: 'amount',
    total: 'total',
    status: 'status',
    approvedAt: 'approvedAt',
    expiredAt: 'expiredAt',
    createdAtExternal: 'createdAtExternal',
    updatedAtExternal: 'updatedAtExternal',
    extraData: 'extraData',
    cabinetId: 'cabinetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IdexTransactionScalarFieldEnum = (typeof IdexTransactionScalarFieldEnum)[keyof typeof IdexTransactionScalarFieldEnum]


  export const ImportExportScalarFieldEnum: {
    id: 'id',
    tableId: 'tableId',
    name: 'name',
    type: 'type',
    mappings: 'mappings',
    options: 'options',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImportExportScalarFieldEnum = (typeof ImportExportScalarFieldEnum)[keyof typeof ImportExportScalarFieldEnum]


  export const MatchScalarFieldEnum: {
    id: 'id',
    idexTransactionId: 'idexTransactionId',
    transactionId: 'transactionId',
    timeDifference: 'timeDifference',
    grossExpense: 'grossExpense',
    grossIncome: 'grossIncome',
    grossProfit: 'grossProfit',
    profitPercentage: 'profitPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchScalarFieldEnum = (typeof MatchScalarFieldEnum)[keyof typeof MatchScalarFieldEnum]


  export const NotificationSettingsScalarFieldEnum: {
    id: 'id',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationSettingsScalarFieldEnum = (typeof NotificationSettingsScalarFieldEnum)[keyof typeof NotificationSettingsScalarFieldEnum]


  export const PasswordScalarFieldEnum: {
    id: 'id',
    name: 'name',
    login: 'login',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    comment: 'comment',
    type: 'type'
  };

  export type PasswordScalarFieldEnum = (typeof PasswordScalarFieldEnum)[keyof typeof PasswordScalarFieldEnum]


  export const ReportNotificationScalarFieldEnum: {
    id: 'id',
    notificationTime: 'notificationTime',
    reportReceived: 'reportReceived',
    reportTime: 'reportTime',
    adminNotified: 'adminNotified',
    adminNotifyTime: 'adminNotifyTime',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportNotificationScalarFieldEnum = (typeof ReportNotificationScalarFieldEnum)[keyof typeof ReportNotificationScalarFieldEnum]


  export const RowScalarFieldEnum: {
    id: 'id',
    tableId: 'tableId',
    order: 'order',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RowScalarFieldEnum = (typeof RowScalarFieldEnum)[keyof typeof RowScalarFieldEnum]


  export const SalaryScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    position: 'position',
    startDate: 'startDate',
    payday: 'payday',
    paydayMonth: 'paydayMonth',
    fixedSalary: 'fixedSalary',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    comment: 'comment',
    periodic: 'periodic',
    payday2: 'payday2',
    payday3: 'payday3',
    section: 'section'
  };

  export type SalaryScalarFieldEnum = (typeof SalaryScalarFieldEnum)[keyof typeof SalaryScalarFieldEnum]


  export const SalaryDebtScalarFieldEnum: {
    id: 'id',
    salaryId: 'salaryId',
    amount: 'amount',
    debtDate: 'debtDate',
    description: 'description',
    isPaid: 'isPaid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalaryDebtScalarFieldEnum = (typeof SalaryDebtScalarFieldEnum)[keyof typeof SalaryDebtScalarFieldEnum]


  export const SalaryEarningScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    earningDate: 'earningDate',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    salaryId: 'salaryId'
  };

  export type SalaryEarningScalarFieldEnum = (typeof SalaryEarningScalarFieldEnum)[keyof typeof SalaryEarningScalarFieldEnum]


  export const SalaryPaymentScalarFieldEnum: {
    id: 'id',
    salaryId: 'salaryId',
    amount: 'amount',
    paymentDate: 'paymentDate',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currency: 'currency'
  };

  export type SalaryPaymentScalarFieldEnum = (typeof SalaryPaymentScalarFieldEnum)[keyof typeof SalaryPaymentScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    slug: 'slug',
    isActive: 'isActive',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const ShiftReportScalarFieldEnum: {
    id: 'id',
    date: 'date',
    time: 'time',
    shift: 'shift',
    startBalance: 'startBalance',
    endBalance: 'endBalance',
    employeeId: 'employeeId',
    usdtAmount: 'usdtAmount',
    currency: 'currency',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftReportScalarFieldEnum = (typeof ShiftReportScalarFieldEnum)[keyof typeof ShiftReportScalarFieldEnum]


  export const ShiftReportExpenseScalarFieldEnum: {
    id: 'id',
    shiftReportId: 'shiftReportId',
    expenseType: 'expenseType',
    amount: 'amount',
    currency: 'currency',
    date: 'date',
    time: 'time',
    period: 'period',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftReportExpenseScalarFieldEnum = (typeof ShiftReportExpenseScalarFieldEnum)[keyof typeof ShiftReportExpenseScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    reportReminderInterval: 'reportReminderInterval',
    reportWaitTime: 'reportWaitTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const TableScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    sectionId: 'sectionId',
    isSearchable: 'isSearchable',
    hasPagination: 'hasPagination',
    pageSize: 'pageSize',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TableScalarFieldEnum = (typeof TableScalarFieldEnum)[keyof typeof TableScalarFieldEnum]


  export const TelegramAccountScalarFieldEnum: {
    id: 'id',
    telegramId: 'telegramId',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TelegramAccountScalarFieldEnum = (typeof TelegramAccountScalarFieldEnum)[keyof typeof TelegramAccountScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    orderNo: 'orderNo',
    dateTime: 'dateTime',
    type: 'type',
    asset: 'asset',
    amount: 'amount',
    totalPrice: 'totalPrice',
    unitPrice: 'unitPrice',
    counterparty: 'counterparty',
    status: 'status',
    originalData: 'originalData',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    passCode: 'passCode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastNotification: 'lastNotification',
    role: 'role',
    bybitApiSecret: 'bybitApiSecret',
    bybitApiToken: 'bybitApiToken',
    lastBybitSyncAt: 'lastBybitSyncAt',
    lastBybitSyncStatus: 'lastBybitSyncStatus'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WorkSessionScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    autoCompleted: 'autoCompleted',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    comment: 'comment'
  };

  export type WorkSessionScalarFieldEnum = (typeof WorkSessionScalarFieldEnum)[keyof typeof WorkSessionScalarFieldEnum]


  export const WorkSessionIdexCabinetScalarFieldEnum: {
    workSessionId: 'workSessionId',
    idexCabinetId: 'idexCabinetId',
    assignedAt: 'assignedAt'
  };

  export type WorkSessionIdexCabinetScalarFieldEnum = (typeof WorkSessionIdexCabinetScalarFieldEnum)[keyof typeof WorkSessionIdexCabinetScalarFieldEnum]


  export const BybitCabinetScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    bybitEmail: 'bybitEmail',
    bybitApiSecret: 'bybitApiSecret',
    bybitApiToken: 'bybitApiToken',
    lastBybitSyncAt: 'lastBybitSyncAt',
    lastBybitSyncStatus: 'lastBybitSyncStatus'
  };

  export type BybitCabinetScalarFieldEnum = (typeof BybitCabinetScalarFieldEnum)[keyof typeof BybitCabinetScalarFieldEnum]


  export const BybitClipMatchScalarFieldEnum: {
    id: 'id',
    idexTransactionId: 'idexTransactionId',
    bybitTransactionId: 'bybitTransactionId',
    timeDifference: 'timeDifference',
    grossExpense: 'grossExpense',
    grossIncome: 'grossIncome',
    grossProfit: 'grossProfit',
    profitPercentage: 'profitPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    matchBybitReportId: 'matchBybitReportId',
    userId: 'userId'
  };

  export type BybitClipMatchScalarFieldEnum = (typeof BybitClipMatchScalarFieldEnum)[keyof typeof BybitClipMatchScalarFieldEnum]


  export const BybitTransactionFromCabinetScalarFieldEnum: {
    id: 'id',
    orderNo: 'orderNo',
    counterparty: 'counterparty',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    amount: 'amount',
    asset: 'asset',
    dateTime: 'dateTime',
    originalData: 'originalData',
    totalPrice: 'totalPrice',
    type: 'type',
    unitPrice: 'unitPrice',
    processed: 'processed',
    extractedPhones: 'extractedPhones',
    lastAttemptError: 'lastAttemptError',
    cabinetId: 'cabinetId'
  };

  export type BybitTransactionFromCabinetScalarFieldEnum = (typeof BybitTransactionFromCabinetScalarFieldEnum)[keyof typeof BybitTransactionFromCabinetScalarFieldEnum]


  export const MatchBybitReportScalarFieldEnum: {
    id: 'id',
    reportDate: 'reportDate',
    totalMatches: 'totalMatches',
    totalProfit: 'totalProfit',
    averageProfit: 'averageProfit',
    successRate: 'successRate',
    timeRangeStart: 'timeRangeStart',
    timeRangeEnd: 'timeRangeEnd',
    notes: 'notes',
    idexCabinets: 'idexCabinets',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type MatchBybitReportScalarFieldEnum = (typeof MatchBybitReportScalarFieldEnum)[keyof typeof MatchBybitReportScalarFieldEnum]


  export const MatchViresReportScalarFieldEnum: {
    id: 'id',
    reportDate: 'reportDate',
    totalMatches: 'totalMatches',
    totalProfit: 'totalProfit',
    averageProfit: 'averageProfit',
    successRate: 'successRate',
    timeRangeStart: 'timeRangeStart',
    timeRangeEnd: 'timeRangeEnd',
    notes: 'notes',
    idexCabinets: 'idexCabinets',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type MatchViresReportScalarFieldEnum = (typeof MatchViresReportScalarFieldEnum)[keyof typeof MatchViresReportScalarFieldEnum]


  export const ViresCabinetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    login: 'login',
    password: 'password',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    comment: 'comment',
    userId: 'userId',
    lastUpdate: 'lastUpdate'
  };

  export type ViresCabinetScalarFieldEnum = (typeof ViresCabinetScalarFieldEnum)[keyof typeof ViresCabinetScalarFieldEnum]


  export const ViresClipMatchScalarFieldEnum: {
    id: 'id',
    viresTransactionId: 'viresTransactionId',
    timeDifference: 'timeDifference',
    grossExpense: 'grossExpense',
    grossIncome: 'grossIncome',
    grossProfit: 'grossProfit',
    profitPercentage: 'profitPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    matchViresReportId: 'matchViresReportId',
    userId: 'userId',
    bybitTransactionId: 'bybitTransactionId'
  };

  export type ViresClipMatchScalarFieldEnum = (typeof ViresClipMatchScalarFieldEnum)[keyof typeof ViresClipMatchScalarFieldEnum]


  export const ViresTransactionPayinScalarFieldEnum: {
    id: 'id',
    cabinetId: 'cabinetId',
    createdAt: 'createdAt',
    sum_rub: 'sum_rub',
    sum_usdt: 'sum_usdt',
    card: 'card',
    fio: 'fio',
    bank: 'bank',
    uuid: 'uuid'
  };

  export type ViresTransactionPayinScalarFieldEnum = (typeof ViresTransactionPayinScalarFieldEnum)[keyof typeof ViresTransactionPayinScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SalarySection'
   */
  export type EnumSalarySectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalarySection'>
    


  /**
   * Reference to a field of type 'SalarySection[]'
   */
  export type ListEnumSalarySectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalarySection[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CardStatus'
   */
  export type EnumCardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardStatus'>
    


  /**
   * Reference to a field of type 'CardStatus[]'
   */
  export type ListEnumCardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardStatus[]'>
    


  /**
   * Reference to a field of type 'ColumnType'
   */
  export type EnumColumnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ColumnType'>
    


  /**
   * Reference to a field of type 'ColumnType[]'
   */
  export type ListEnumColumnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ColumnType[]'>
    


  /**
   * Reference to a field of type 'FilterOperator'
   */
  export type EnumFilterOperatorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FilterOperator'>
    


  /**
   * Reference to a field of type 'FilterOperator[]'
   */
  export type ListEnumFilterOperatorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FilterOperator[]'>
    


  /**
   * Reference to a field of type 'IdexSyncOrderStatus'
   */
  export type EnumIdexSyncOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdexSyncOrderStatus'>
    


  /**
   * Reference to a field of type 'IdexSyncOrderStatus[]'
   */
  export type ListEnumIdexSyncOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdexSyncOrderStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'PasswordType'
   */
  export type EnumPasswordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PasswordType'>
    


  /**
   * Reference to a field of type 'PasswordType[]'
   */
  export type ListEnumPasswordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PasswordType[]'>
    


  /**
   * Reference to a field of type 'PeriodType'
   */
  export type EnumPeriodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PeriodType'>
    


  /**
   * Reference to a field of type 'PeriodType[]'
   */
  export type ListEnumPeriodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PeriodType[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    telegramId?: StringFilter<"Admin"> | string
    username?: StringNullableFilter<"Admin"> | string | null
    firstName?: StringNullableFilter<"Admin"> | string | null
    lastName?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    telegramId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    username?: StringNullableFilter<"Admin"> | string | null
    firstName?: StringNullableFilter<"Admin"> | string | null
    lastName?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }, "id" | "telegramId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    telegramId?: StringWithAggregatesFilter<"Admin"> | string
    username?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: IntFilter<"AuditLog"> | number
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    userId?: IntFilter<"AuditLog"> | number
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    cardBalanceId?: IntNullableFilter<"AuditLog"> | number | null
    cardId?: IntNullableFilter<"AuditLog"> | number | null
    cardPouringId?: IntNullableFilter<"AuditLog"> | number | null
    CardBalance?: XOR<CardBalanceNullableScalarRelationFilter, CardBalanceWhereInput> | null
    Card?: XOR<CardNullableScalarRelationFilter, CardWhereInput> | null
    CardPouring?: XOR<CardPouringNullableScalarRelationFilter, CardPouringWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    cardBalanceId?: SortOrderInput | SortOrder
    cardId?: SortOrderInput | SortOrder
    cardPouringId?: SortOrderInput | SortOrder
    CardBalance?: CardBalanceOrderByWithRelationInput
    Card?: CardOrderByWithRelationInput
    CardPouring?: CardPouringOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: IntFilter<"AuditLog"> | number
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    userId?: IntFilter<"AuditLog"> | number
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    cardBalanceId?: IntNullableFilter<"AuditLog"> | number | null
    cardId?: IntNullableFilter<"AuditLog"> | number | null
    cardPouringId?: IntNullableFilter<"AuditLog"> | number | null
    CardBalance?: XOR<CardBalanceNullableScalarRelationFilter, CardBalanceWhereInput> | null
    Card?: XOR<CardNullableScalarRelationFilter, CardWhereInput> | null
    CardPouring?: XOR<CardPouringNullableScalarRelationFilter, CardPouringWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    cardBalanceId?: SortOrderInput | SortOrder
    cardId?: SortOrderInput | SortOrder
    cardPouringId?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: IntWithAggregatesFilter<"AuditLog"> | number
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    userId?: IntWithAggregatesFilter<"AuditLog"> | number
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    oldValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    cardBalanceId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    cardId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    cardPouringId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
  }

  export type BalanceEntryWhereInput = {
    AND?: BalanceEntryWhereInput | BalanceEntryWhereInput[]
    OR?: BalanceEntryWhereInput[]
    NOT?: BalanceEntryWhereInput | BalanceEntryWhereInput[]
    id?: IntFilter<"BalanceEntry"> | number
    date?: DateTimeFilter<"BalanceEntry"> | Date | string
    time?: StringFilter<"BalanceEntry"> | string
    amount?: FloatFilter<"BalanceEntry"> | number
    currency?: StringFilter<"BalanceEntry"> | string
    comment?: StringNullableFilter<"BalanceEntry"> | string | null
    createdAt?: DateTimeFilter<"BalanceEntry"> | Date | string
    updatedAt?: DateTimeFilter<"BalanceEntry"> | Date | string
    section?: EnumSalarySectionFilter<"BalanceEntry"> | $Enums.SalarySection
  }

  export type BalanceEntryOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SortOrder
  }

  export type BalanceEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BalanceEntryWhereInput | BalanceEntryWhereInput[]
    OR?: BalanceEntryWhereInput[]
    NOT?: BalanceEntryWhereInput | BalanceEntryWhereInput[]
    date?: DateTimeFilter<"BalanceEntry"> | Date | string
    time?: StringFilter<"BalanceEntry"> | string
    amount?: FloatFilter<"BalanceEntry"> | number
    currency?: StringFilter<"BalanceEntry"> | string
    comment?: StringNullableFilter<"BalanceEntry"> | string | null
    createdAt?: DateTimeFilter<"BalanceEntry"> | Date | string
    updatedAt?: DateTimeFilter<"BalanceEntry"> | Date | string
    section?: EnumSalarySectionFilter<"BalanceEntry"> | $Enums.SalarySection
  }, "id">

  export type BalanceEntryOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SortOrder
    _count?: BalanceEntryCountOrderByAggregateInput
    _avg?: BalanceEntryAvgOrderByAggregateInput
    _max?: BalanceEntryMaxOrderByAggregateInput
    _min?: BalanceEntryMinOrderByAggregateInput
    _sum?: BalanceEntrySumOrderByAggregateInput
  }

  export type BalanceEntryScalarWhereWithAggregatesInput = {
    AND?: BalanceEntryScalarWhereWithAggregatesInput | BalanceEntryScalarWhereWithAggregatesInput[]
    OR?: BalanceEntryScalarWhereWithAggregatesInput[]
    NOT?: BalanceEntryScalarWhereWithAggregatesInput | BalanceEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BalanceEntry"> | number
    date?: DateTimeWithAggregatesFilter<"BalanceEntry"> | Date | string
    time?: StringWithAggregatesFilter<"BalanceEntry"> | string
    amount?: FloatWithAggregatesFilter<"BalanceEntry"> | number
    currency?: StringWithAggregatesFilter<"BalanceEntry"> | string
    comment?: StringNullableWithAggregatesFilter<"BalanceEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BalanceEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BalanceEntry"> | Date | string
    section?: EnumSalarySectionWithAggregatesFilter<"BalanceEntry"> | $Enums.SalarySection
  }

  export type BybitMatchWhereInput = {
    AND?: BybitMatchWhereInput | BybitMatchWhereInput[]
    OR?: BybitMatchWhereInput[]
    NOT?: BybitMatchWhereInput | BybitMatchWhereInput[]
    id?: IntFilter<"BybitMatch"> | number
    idexTransactionId?: IntFilter<"BybitMatch"> | number
    bybitTransactionId?: IntFilter<"BybitMatch"> | number
    timeDifference?: IntFilter<"BybitMatch"> | number
    grossExpense?: FloatFilter<"BybitMatch"> | number
    grossIncome?: FloatFilter<"BybitMatch"> | number
    grossProfit?: FloatFilter<"BybitMatch"> | number
    profitPercentage?: FloatFilter<"BybitMatch"> | number
    createdAt?: DateTimeFilter<"BybitMatch"> | Date | string
    updatedAt?: DateTimeFilter<"BybitMatch"> | Date | string
    BybitTransaction?: XOR<BybitTransactionScalarRelationFilter, BybitTransactionWhereInput>
    IdexTransaction?: XOR<IdexTransactionScalarRelationFilter, IdexTransactionWhereInput>
  }

  export type BybitMatchOrderByWithRelationInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    BybitTransaction?: BybitTransactionOrderByWithRelationInput
    IdexTransaction?: IdexTransactionOrderByWithRelationInput
  }

  export type BybitMatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    idexTransactionId_bybitTransactionId?: BybitMatchIdexTransactionIdBybitTransactionIdCompoundUniqueInput
    AND?: BybitMatchWhereInput | BybitMatchWhereInput[]
    OR?: BybitMatchWhereInput[]
    NOT?: BybitMatchWhereInput | BybitMatchWhereInput[]
    idexTransactionId?: IntFilter<"BybitMatch"> | number
    bybitTransactionId?: IntFilter<"BybitMatch"> | number
    timeDifference?: IntFilter<"BybitMatch"> | number
    grossExpense?: FloatFilter<"BybitMatch"> | number
    grossIncome?: FloatFilter<"BybitMatch"> | number
    grossProfit?: FloatFilter<"BybitMatch"> | number
    profitPercentage?: FloatFilter<"BybitMatch"> | number
    createdAt?: DateTimeFilter<"BybitMatch"> | Date | string
    updatedAt?: DateTimeFilter<"BybitMatch"> | Date | string
    BybitTransaction?: XOR<BybitTransactionScalarRelationFilter, BybitTransactionWhereInput>
    IdexTransaction?: XOR<IdexTransactionScalarRelationFilter, IdexTransactionWhereInput>
  }, "id" | "idexTransactionId_bybitTransactionId">

  export type BybitMatchOrderByWithAggregationInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BybitMatchCountOrderByAggregateInput
    _avg?: BybitMatchAvgOrderByAggregateInput
    _max?: BybitMatchMaxOrderByAggregateInput
    _min?: BybitMatchMinOrderByAggregateInput
    _sum?: BybitMatchSumOrderByAggregateInput
  }

  export type BybitMatchScalarWhereWithAggregatesInput = {
    AND?: BybitMatchScalarWhereWithAggregatesInput | BybitMatchScalarWhereWithAggregatesInput[]
    OR?: BybitMatchScalarWhereWithAggregatesInput[]
    NOT?: BybitMatchScalarWhereWithAggregatesInput | BybitMatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BybitMatch"> | number
    idexTransactionId?: IntWithAggregatesFilter<"BybitMatch"> | number
    bybitTransactionId?: IntWithAggregatesFilter<"BybitMatch"> | number
    timeDifference?: IntWithAggregatesFilter<"BybitMatch"> | number
    grossExpense?: FloatWithAggregatesFilter<"BybitMatch"> | number
    grossIncome?: FloatWithAggregatesFilter<"BybitMatch"> | number
    grossProfit?: FloatWithAggregatesFilter<"BybitMatch"> | number
    profitPercentage?: FloatWithAggregatesFilter<"BybitMatch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BybitMatch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BybitMatch"> | Date | string
  }

  export type BybitOrderInfoWhereInput = {
    AND?: BybitOrderInfoWhereInput | BybitOrderInfoWhereInput[]
    OR?: BybitOrderInfoWhereInput[]
    NOT?: BybitOrderInfoWhereInput | BybitOrderInfoWhereInput[]
    id?: IntFilter<"BybitOrderInfo"> | number
    phoneNumbers?: StringNullableListFilter<"BybitOrderInfo">
    createdAt?: DateTimeFilter<"BybitOrderInfo"> | Date | string
    updatedAt?: DateTimeFilter<"BybitOrderInfo"> | Date | string
    orderNo?: StringFilter<"BybitOrderInfo"> | string
    dateTime?: DateTimeFilter<"BybitOrderInfo"> | Date | string
    originalData?: JsonNullableFilter<"BybitOrderInfo">
    status?: StringFilter<"BybitOrderInfo"> | string
    type?: StringFilter<"BybitOrderInfo"> | string
    amount?: IntFilter<"BybitOrderInfo"> | number
    totalPrice?: FloatFilter<"BybitOrderInfo"> | number
    processed?: BoolFilter<"BybitOrderInfo"> | boolean
    unitPrice?: FloatFilter<"BybitOrderInfo"> | number
    bybitCabinetId?: IntFilter<"BybitOrderInfo"> | number
    cabinet?: XOR<BybitCabinetScalarRelationFilter, BybitCabinetWhereInput>
  }

  export type BybitOrderInfoOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumbers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNo?: SortOrder
    dateTime?: SortOrder
    originalData?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    processed?: SortOrder
    unitPrice?: SortOrder
    bybitCabinetId?: SortOrder
    cabinet?: BybitCabinetOrderByWithRelationInput
  }

  export type BybitOrderInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderNo_bybitCabinetId?: BybitOrderInfoOrderNoBybitCabinetIdCompoundUniqueInput
    AND?: BybitOrderInfoWhereInput | BybitOrderInfoWhereInput[]
    OR?: BybitOrderInfoWhereInput[]
    NOT?: BybitOrderInfoWhereInput | BybitOrderInfoWhereInput[]
    phoneNumbers?: StringNullableListFilter<"BybitOrderInfo">
    createdAt?: DateTimeFilter<"BybitOrderInfo"> | Date | string
    updatedAt?: DateTimeFilter<"BybitOrderInfo"> | Date | string
    orderNo?: StringFilter<"BybitOrderInfo"> | string
    dateTime?: DateTimeFilter<"BybitOrderInfo"> | Date | string
    originalData?: JsonNullableFilter<"BybitOrderInfo">
    status?: StringFilter<"BybitOrderInfo"> | string
    type?: StringFilter<"BybitOrderInfo"> | string
    amount?: IntFilter<"BybitOrderInfo"> | number
    totalPrice?: FloatFilter<"BybitOrderInfo"> | number
    processed?: BoolFilter<"BybitOrderInfo"> | boolean
    unitPrice?: FloatFilter<"BybitOrderInfo"> | number
    bybitCabinetId?: IntFilter<"BybitOrderInfo"> | number
    cabinet?: XOR<BybitCabinetScalarRelationFilter, BybitCabinetWhereInput>
  }, "id" | "orderNo_bybitCabinetId">

  export type BybitOrderInfoOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumbers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNo?: SortOrder
    dateTime?: SortOrder
    originalData?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    processed?: SortOrder
    unitPrice?: SortOrder
    bybitCabinetId?: SortOrder
    _count?: BybitOrderInfoCountOrderByAggregateInput
    _avg?: BybitOrderInfoAvgOrderByAggregateInput
    _max?: BybitOrderInfoMaxOrderByAggregateInput
    _min?: BybitOrderInfoMinOrderByAggregateInput
    _sum?: BybitOrderInfoSumOrderByAggregateInput
  }

  export type BybitOrderInfoScalarWhereWithAggregatesInput = {
    AND?: BybitOrderInfoScalarWhereWithAggregatesInput | BybitOrderInfoScalarWhereWithAggregatesInput[]
    OR?: BybitOrderInfoScalarWhereWithAggregatesInput[]
    NOT?: BybitOrderInfoScalarWhereWithAggregatesInput | BybitOrderInfoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BybitOrderInfo"> | number
    phoneNumbers?: StringNullableListFilter<"BybitOrderInfo">
    createdAt?: DateTimeWithAggregatesFilter<"BybitOrderInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BybitOrderInfo"> | Date | string
    orderNo?: StringWithAggregatesFilter<"BybitOrderInfo"> | string
    dateTime?: DateTimeWithAggregatesFilter<"BybitOrderInfo"> | Date | string
    originalData?: JsonNullableWithAggregatesFilter<"BybitOrderInfo">
    status?: StringWithAggregatesFilter<"BybitOrderInfo"> | string
    type?: StringWithAggregatesFilter<"BybitOrderInfo"> | string
    amount?: IntWithAggregatesFilter<"BybitOrderInfo"> | number
    totalPrice?: FloatWithAggregatesFilter<"BybitOrderInfo"> | number
    processed?: BoolWithAggregatesFilter<"BybitOrderInfo"> | boolean
    unitPrice?: FloatWithAggregatesFilter<"BybitOrderInfo"> | number
    bybitCabinetId?: IntWithAggregatesFilter<"BybitOrderInfo"> | number
  }

  export type BybitTransactionWhereInput = {
    AND?: BybitTransactionWhereInput | BybitTransactionWhereInput[]
    OR?: BybitTransactionWhereInput[]
    NOT?: BybitTransactionWhereInput | BybitTransactionWhereInput[]
    id?: IntFilter<"BybitTransaction"> | number
    orderNo?: StringFilter<"BybitTransaction"> | string
    counterparty?: StringNullableFilter<"BybitTransaction"> | string | null
    status?: StringFilter<"BybitTransaction"> | string
    userId?: IntFilter<"BybitTransaction"> | number
    createdAt?: DateTimeFilter<"BybitTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BybitTransaction"> | Date | string
    amount?: FloatFilter<"BybitTransaction"> | number
    asset?: StringFilter<"BybitTransaction"> | string
    dateTime?: DateTimeFilter<"BybitTransaction"> | Date | string
    originalData?: JsonNullableFilter<"BybitTransaction">
    totalPrice?: FloatFilter<"BybitTransaction"> | number
    type?: StringFilter<"BybitTransaction"> | string
    unitPrice?: FloatFilter<"BybitTransaction"> | number
    processed?: BoolFilter<"BybitTransaction"> | boolean
    extractedPhones?: StringNullableListFilter<"BybitTransaction">
    lastAttemptError?: StringNullableFilter<"BybitTransaction"> | string | null
    bybitMatch?: BybitMatchListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BybitTransactionOrderByWithRelationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    counterparty?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    amount?: SortOrder
    asset?: SortOrder
    dateTime?: SortOrder
    originalData?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    type?: SortOrder
    unitPrice?: SortOrder
    processed?: SortOrder
    extractedPhones?: SortOrder
    lastAttemptError?: SortOrderInput | SortOrder
    bybitMatch?: BybitMatchOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type BybitTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderNo?: string
    orderNo_userId?: BybitTransactionOrderNoUserIdCompoundUniqueInput
    AND?: BybitTransactionWhereInput | BybitTransactionWhereInput[]
    OR?: BybitTransactionWhereInput[]
    NOT?: BybitTransactionWhereInput | BybitTransactionWhereInput[]
    counterparty?: StringNullableFilter<"BybitTransaction"> | string | null
    status?: StringFilter<"BybitTransaction"> | string
    userId?: IntFilter<"BybitTransaction"> | number
    createdAt?: DateTimeFilter<"BybitTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BybitTransaction"> | Date | string
    amount?: FloatFilter<"BybitTransaction"> | number
    asset?: StringFilter<"BybitTransaction"> | string
    dateTime?: DateTimeFilter<"BybitTransaction"> | Date | string
    originalData?: JsonNullableFilter<"BybitTransaction">
    totalPrice?: FloatFilter<"BybitTransaction"> | number
    type?: StringFilter<"BybitTransaction"> | string
    unitPrice?: FloatFilter<"BybitTransaction"> | number
    processed?: BoolFilter<"BybitTransaction"> | boolean
    extractedPhones?: StringNullableListFilter<"BybitTransaction">
    lastAttemptError?: StringNullableFilter<"BybitTransaction"> | string | null
    bybitMatch?: BybitMatchListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "orderNo" | "orderNo_userId">

  export type BybitTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    counterparty?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    amount?: SortOrder
    asset?: SortOrder
    dateTime?: SortOrder
    originalData?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    type?: SortOrder
    unitPrice?: SortOrder
    processed?: SortOrder
    extractedPhones?: SortOrder
    lastAttemptError?: SortOrderInput | SortOrder
    _count?: BybitTransactionCountOrderByAggregateInput
    _avg?: BybitTransactionAvgOrderByAggregateInput
    _max?: BybitTransactionMaxOrderByAggregateInput
    _min?: BybitTransactionMinOrderByAggregateInput
    _sum?: BybitTransactionSumOrderByAggregateInput
  }

  export type BybitTransactionScalarWhereWithAggregatesInput = {
    AND?: BybitTransactionScalarWhereWithAggregatesInput | BybitTransactionScalarWhereWithAggregatesInput[]
    OR?: BybitTransactionScalarWhereWithAggregatesInput[]
    NOT?: BybitTransactionScalarWhereWithAggregatesInput | BybitTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BybitTransaction"> | number
    orderNo?: StringWithAggregatesFilter<"BybitTransaction"> | string
    counterparty?: StringNullableWithAggregatesFilter<"BybitTransaction"> | string | null
    status?: StringWithAggregatesFilter<"BybitTransaction"> | string
    userId?: IntWithAggregatesFilter<"BybitTransaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BybitTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BybitTransaction"> | Date | string
    amount?: FloatWithAggregatesFilter<"BybitTransaction"> | number
    asset?: StringWithAggregatesFilter<"BybitTransaction"> | string
    dateTime?: DateTimeWithAggregatesFilter<"BybitTransaction"> | Date | string
    originalData?: JsonNullableWithAggregatesFilter<"BybitTransaction">
    totalPrice?: FloatWithAggregatesFilter<"BybitTransaction"> | number
    type?: StringWithAggregatesFilter<"BybitTransaction"> | string
    unitPrice?: FloatWithAggregatesFilter<"BybitTransaction"> | number
    processed?: BoolWithAggregatesFilter<"BybitTransaction"> | boolean
    extractedPhones?: StringNullableListFilter<"BybitTransaction">
    lastAttemptError?: StringNullableWithAggregatesFilter<"BybitTransaction"> | string | null
  }

  export type CardWhereInput = {
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    id?: IntFilter<"Card"> | number
    externalId?: IntFilter<"Card"> | number
    createdAt?: DateTimeFilter<"Card"> | Date | string
    updatedAt?: DateTimeFilter<"Card"> | Date | string
    provider?: StringFilter<"Card"> | string
    cardNumber?: StringFilter<"Card"> | string
    bank?: StringFilter<"Card"> | string
    phoneNumber?: StringFilter<"Card"> | string
    appPin?: IntFilter<"Card"> | number
    terminalPin?: StringFilter<"Card"> | string
    comment?: StringNullableFilter<"Card"> | string | null
    picachu?: StringNullableFilter<"Card"> | string | null
    status?: EnumCardStatusFilter<"Card"> | $Enums.CardStatus
    cardPrice?: FloatNullableFilter<"Card"> | number | null
    isPaid?: BoolFilter<"Card"> | boolean
    letterCode?: StringNullableFilter<"Card"> | string | null
    actor?: StringNullableFilter<"Card"> | string | null
    inWork?: BoolFilter<"Card"> | boolean
    activePaymentMethod?: StringNullableFilter<"Card"> | string | null
    AuditLog?: AuditLogListRelationFilter
    CardBalance?: CardBalanceListRelationFilter
    CardPouring?: CardPouringListRelationFilter
  }

  export type CardOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: SortOrder
    cardNumber?: SortOrder
    bank?: SortOrder
    phoneNumber?: SortOrder
    appPin?: SortOrder
    terminalPin?: SortOrder
    comment?: SortOrderInput | SortOrder
    picachu?: SortOrderInput | SortOrder
    status?: SortOrder
    cardPrice?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    letterCode?: SortOrderInput | SortOrder
    actor?: SortOrderInput | SortOrder
    inWork?: SortOrder
    activePaymentMethod?: SortOrderInput | SortOrder
    AuditLog?: AuditLogOrderByRelationAggregateInput
    CardBalance?: CardBalanceOrderByRelationAggregateInput
    CardPouring?: CardPouringOrderByRelationAggregateInput
  }

  export type CardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    externalId?: IntFilter<"Card"> | number
    createdAt?: DateTimeFilter<"Card"> | Date | string
    updatedAt?: DateTimeFilter<"Card"> | Date | string
    provider?: StringFilter<"Card"> | string
    cardNumber?: StringFilter<"Card"> | string
    bank?: StringFilter<"Card"> | string
    phoneNumber?: StringFilter<"Card"> | string
    appPin?: IntFilter<"Card"> | number
    terminalPin?: StringFilter<"Card"> | string
    comment?: StringNullableFilter<"Card"> | string | null
    picachu?: StringNullableFilter<"Card"> | string | null
    status?: EnumCardStatusFilter<"Card"> | $Enums.CardStatus
    cardPrice?: FloatNullableFilter<"Card"> | number | null
    isPaid?: BoolFilter<"Card"> | boolean
    letterCode?: StringNullableFilter<"Card"> | string | null
    actor?: StringNullableFilter<"Card"> | string | null
    inWork?: BoolFilter<"Card"> | boolean
    activePaymentMethod?: StringNullableFilter<"Card"> | string | null
    AuditLog?: AuditLogListRelationFilter
    CardBalance?: CardBalanceListRelationFilter
    CardPouring?: CardPouringListRelationFilter
  }, "id">

  export type CardOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: SortOrder
    cardNumber?: SortOrder
    bank?: SortOrder
    phoneNumber?: SortOrder
    appPin?: SortOrder
    terminalPin?: SortOrder
    comment?: SortOrderInput | SortOrder
    picachu?: SortOrderInput | SortOrder
    status?: SortOrder
    cardPrice?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    letterCode?: SortOrderInput | SortOrder
    actor?: SortOrderInput | SortOrder
    inWork?: SortOrder
    activePaymentMethod?: SortOrderInput | SortOrder
    _count?: CardCountOrderByAggregateInput
    _avg?: CardAvgOrderByAggregateInput
    _max?: CardMaxOrderByAggregateInput
    _min?: CardMinOrderByAggregateInput
    _sum?: CardSumOrderByAggregateInput
  }

  export type CardScalarWhereWithAggregatesInput = {
    AND?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    OR?: CardScalarWhereWithAggregatesInput[]
    NOT?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Card"> | number
    externalId?: IntWithAggregatesFilter<"Card"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Card"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Card"> | Date | string
    provider?: StringWithAggregatesFilter<"Card"> | string
    cardNumber?: StringWithAggregatesFilter<"Card"> | string
    bank?: StringWithAggregatesFilter<"Card"> | string
    phoneNumber?: StringWithAggregatesFilter<"Card"> | string
    appPin?: IntWithAggregatesFilter<"Card"> | number
    terminalPin?: StringWithAggregatesFilter<"Card"> | string
    comment?: StringNullableWithAggregatesFilter<"Card"> | string | null
    picachu?: StringNullableWithAggregatesFilter<"Card"> | string | null
    status?: EnumCardStatusWithAggregatesFilter<"Card"> | $Enums.CardStatus
    cardPrice?: FloatNullableWithAggregatesFilter<"Card"> | number | null
    isPaid?: BoolWithAggregatesFilter<"Card"> | boolean
    letterCode?: StringNullableWithAggregatesFilter<"Card"> | string | null
    actor?: StringNullableWithAggregatesFilter<"Card"> | string | null
    inWork?: BoolWithAggregatesFilter<"Card"> | boolean
    activePaymentMethod?: StringNullableWithAggregatesFilter<"Card"> | string | null
  }

  export type CardBalanceWhereInput = {
    AND?: CardBalanceWhereInput | CardBalanceWhereInput[]
    OR?: CardBalanceWhereInput[]
    NOT?: CardBalanceWhereInput | CardBalanceWhereInput[]
    id?: IntFilter<"CardBalance"> | number
    cardId?: IntFilter<"CardBalance"> | number
    date?: DateTimeFilter<"CardBalance"> | Date | string
    startBalance?: FloatFilter<"CardBalance"> | number
    endBalance?: FloatFilter<"CardBalance"> | number
    createdAt?: DateTimeFilter<"CardBalance"> | Date | string
    updatedAt?: DateTimeFilter<"CardBalance"> | Date | string
    comment?: StringNullableFilter<"CardBalance"> | string | null
    AuditLog?: AuditLogListRelationFilter
    Card?: XOR<CardScalarRelationFilter, CardWhereInput>
  }

  export type CardBalanceOrderByWithRelationInput = {
    id?: SortOrder
    cardId?: SortOrder
    date?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrderInput | SortOrder
    AuditLog?: AuditLogOrderByRelationAggregateInput
    Card?: CardOrderByWithRelationInput
  }

  export type CardBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cardId_date?: CardBalanceCardIdDateCompoundUniqueInput
    AND?: CardBalanceWhereInput | CardBalanceWhereInput[]
    OR?: CardBalanceWhereInput[]
    NOT?: CardBalanceWhereInput | CardBalanceWhereInput[]
    cardId?: IntFilter<"CardBalance"> | number
    date?: DateTimeFilter<"CardBalance"> | Date | string
    startBalance?: FloatFilter<"CardBalance"> | number
    endBalance?: FloatFilter<"CardBalance"> | number
    createdAt?: DateTimeFilter<"CardBalance"> | Date | string
    updatedAt?: DateTimeFilter<"CardBalance"> | Date | string
    comment?: StringNullableFilter<"CardBalance"> | string | null
    AuditLog?: AuditLogListRelationFilter
    Card?: XOR<CardScalarRelationFilter, CardWhereInput>
  }, "id" | "cardId_date">

  export type CardBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    cardId?: SortOrder
    date?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: CardBalanceCountOrderByAggregateInput
    _avg?: CardBalanceAvgOrderByAggregateInput
    _max?: CardBalanceMaxOrderByAggregateInput
    _min?: CardBalanceMinOrderByAggregateInput
    _sum?: CardBalanceSumOrderByAggregateInput
  }

  export type CardBalanceScalarWhereWithAggregatesInput = {
    AND?: CardBalanceScalarWhereWithAggregatesInput | CardBalanceScalarWhereWithAggregatesInput[]
    OR?: CardBalanceScalarWhereWithAggregatesInput[]
    NOT?: CardBalanceScalarWhereWithAggregatesInput | CardBalanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CardBalance"> | number
    cardId?: IntWithAggregatesFilter<"CardBalance"> | number
    date?: DateTimeWithAggregatesFilter<"CardBalance"> | Date | string
    startBalance?: FloatWithAggregatesFilter<"CardBalance"> | number
    endBalance?: FloatWithAggregatesFilter<"CardBalance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CardBalance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CardBalance"> | Date | string
    comment?: StringNullableWithAggregatesFilter<"CardBalance"> | string | null
  }

  export type CardPouringWhereInput = {
    AND?: CardPouringWhereInput | CardPouringWhereInput[]
    OR?: CardPouringWhereInput[]
    NOT?: CardPouringWhereInput | CardPouringWhereInput[]
    id?: IntFilter<"CardPouring"> | number
    cardId?: IntFilter<"CardPouring"> | number
    pouringDate?: DateTimeFilter<"CardPouring"> | Date | string
    initialAmount?: FloatFilter<"CardPouring"> | number
    initialDate?: DateTimeFilter<"CardPouring"> | Date | string
    finalAmount?: FloatNullableFilter<"CardPouring"> | number | null
    finalDate?: DateTimeNullableFilter<"CardPouring"> | Date | string | null
    pouringAmount?: FloatFilter<"CardPouring"> | number
    withdrawalAmount?: FloatNullableFilter<"CardPouring"> | number | null
    withdrawalDate?: DateTimeNullableFilter<"CardPouring"> | Date | string | null
    collectorName?: StringNullableFilter<"CardPouring"> | string | null
    status?: EnumCardStatusFilter<"CardPouring"> | $Enums.CardStatus
    comment?: StringNullableFilter<"CardPouring"> | string | null
    createdAt?: DateTimeFilter<"CardPouring"> | Date | string
    updatedAt?: DateTimeFilter<"CardPouring"> | Date | string
    AuditLog?: AuditLogListRelationFilter
    Card?: XOR<CardScalarRelationFilter, CardWhereInput>
  }

  export type CardPouringOrderByWithRelationInput = {
    id?: SortOrder
    cardId?: SortOrder
    pouringDate?: SortOrder
    initialAmount?: SortOrder
    initialDate?: SortOrder
    finalAmount?: SortOrderInput | SortOrder
    finalDate?: SortOrderInput | SortOrder
    pouringAmount?: SortOrder
    withdrawalAmount?: SortOrderInput | SortOrder
    withdrawalDate?: SortOrderInput | SortOrder
    collectorName?: SortOrderInput | SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AuditLog?: AuditLogOrderByRelationAggregateInput
    Card?: CardOrderByWithRelationInput
  }

  export type CardPouringWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CardPouringWhereInput | CardPouringWhereInput[]
    OR?: CardPouringWhereInput[]
    NOT?: CardPouringWhereInput | CardPouringWhereInput[]
    cardId?: IntFilter<"CardPouring"> | number
    pouringDate?: DateTimeFilter<"CardPouring"> | Date | string
    initialAmount?: FloatFilter<"CardPouring"> | number
    initialDate?: DateTimeFilter<"CardPouring"> | Date | string
    finalAmount?: FloatNullableFilter<"CardPouring"> | number | null
    finalDate?: DateTimeNullableFilter<"CardPouring"> | Date | string | null
    pouringAmount?: FloatFilter<"CardPouring"> | number
    withdrawalAmount?: FloatNullableFilter<"CardPouring"> | number | null
    withdrawalDate?: DateTimeNullableFilter<"CardPouring"> | Date | string | null
    collectorName?: StringNullableFilter<"CardPouring"> | string | null
    status?: EnumCardStatusFilter<"CardPouring"> | $Enums.CardStatus
    comment?: StringNullableFilter<"CardPouring"> | string | null
    createdAt?: DateTimeFilter<"CardPouring"> | Date | string
    updatedAt?: DateTimeFilter<"CardPouring"> | Date | string
    AuditLog?: AuditLogListRelationFilter
    Card?: XOR<CardScalarRelationFilter, CardWhereInput>
  }, "id">

  export type CardPouringOrderByWithAggregationInput = {
    id?: SortOrder
    cardId?: SortOrder
    pouringDate?: SortOrder
    initialAmount?: SortOrder
    initialDate?: SortOrder
    finalAmount?: SortOrderInput | SortOrder
    finalDate?: SortOrderInput | SortOrder
    pouringAmount?: SortOrder
    withdrawalAmount?: SortOrderInput | SortOrder
    withdrawalDate?: SortOrderInput | SortOrder
    collectorName?: SortOrderInput | SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CardPouringCountOrderByAggregateInput
    _avg?: CardPouringAvgOrderByAggregateInput
    _max?: CardPouringMaxOrderByAggregateInput
    _min?: CardPouringMinOrderByAggregateInput
    _sum?: CardPouringSumOrderByAggregateInput
  }

  export type CardPouringScalarWhereWithAggregatesInput = {
    AND?: CardPouringScalarWhereWithAggregatesInput | CardPouringScalarWhereWithAggregatesInput[]
    OR?: CardPouringScalarWhereWithAggregatesInput[]
    NOT?: CardPouringScalarWhereWithAggregatesInput | CardPouringScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CardPouring"> | number
    cardId?: IntWithAggregatesFilter<"CardPouring"> | number
    pouringDate?: DateTimeWithAggregatesFilter<"CardPouring"> | Date | string
    initialAmount?: FloatWithAggregatesFilter<"CardPouring"> | number
    initialDate?: DateTimeWithAggregatesFilter<"CardPouring"> | Date | string
    finalAmount?: FloatNullableWithAggregatesFilter<"CardPouring"> | number | null
    finalDate?: DateTimeNullableWithAggregatesFilter<"CardPouring"> | Date | string | null
    pouringAmount?: FloatWithAggregatesFilter<"CardPouring"> | number
    withdrawalAmount?: FloatNullableWithAggregatesFilter<"CardPouring"> | number | null
    withdrawalDate?: DateTimeNullableWithAggregatesFilter<"CardPouring"> | Date | string | null
    collectorName?: StringNullableWithAggregatesFilter<"CardPouring"> | string | null
    status?: EnumCardStatusWithAggregatesFilter<"CardPouring"> | $Enums.CardStatus
    comment?: StringNullableWithAggregatesFilter<"CardPouring"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CardPouring"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CardPouring"> | Date | string
  }

  export type CellWhereInput = {
    AND?: CellWhereInput | CellWhereInput[]
    OR?: CellWhereInput[]
    NOT?: CellWhereInput | CellWhereInput[]
    id?: IntFilter<"Cell"> | number
    rowId?: IntFilter<"Cell"> | number
    columnId?: IntFilter<"Cell"> | number
    value?: StringNullableFilter<"Cell"> | string | null
    displayValue?: StringNullableFilter<"Cell"> | string | null
    calculatedValue?: StringNullableFilter<"Cell"> | string | null
    createdAt?: DateTimeFilter<"Cell"> | Date | string
    updatedAt?: DateTimeFilter<"Cell"> | Date | string
    Column?: XOR<ColumnScalarRelationFilter, ColumnWhereInput>
    Row?: XOR<RowScalarRelationFilter, RowWhereInput>
    Comment?: CommentListRelationFilter
  }

  export type CellOrderByWithRelationInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    value?: SortOrderInput | SortOrder
    displayValue?: SortOrderInput | SortOrder
    calculatedValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Column?: ColumnOrderByWithRelationInput
    Row?: RowOrderByWithRelationInput
    Comment?: CommentOrderByRelationAggregateInput
  }

  export type CellWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    rowId_columnId?: CellRowIdColumnIdCompoundUniqueInput
    AND?: CellWhereInput | CellWhereInput[]
    OR?: CellWhereInput[]
    NOT?: CellWhereInput | CellWhereInput[]
    rowId?: IntFilter<"Cell"> | number
    columnId?: IntFilter<"Cell"> | number
    value?: StringNullableFilter<"Cell"> | string | null
    displayValue?: StringNullableFilter<"Cell"> | string | null
    calculatedValue?: StringNullableFilter<"Cell"> | string | null
    createdAt?: DateTimeFilter<"Cell"> | Date | string
    updatedAt?: DateTimeFilter<"Cell"> | Date | string
    Column?: XOR<ColumnScalarRelationFilter, ColumnWhereInput>
    Row?: XOR<RowScalarRelationFilter, RowWhereInput>
    Comment?: CommentListRelationFilter
  }, "id" | "rowId_columnId">

  export type CellOrderByWithAggregationInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    value?: SortOrderInput | SortOrder
    displayValue?: SortOrderInput | SortOrder
    calculatedValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CellCountOrderByAggregateInput
    _avg?: CellAvgOrderByAggregateInput
    _max?: CellMaxOrderByAggregateInput
    _min?: CellMinOrderByAggregateInput
    _sum?: CellSumOrderByAggregateInput
  }

  export type CellScalarWhereWithAggregatesInput = {
    AND?: CellScalarWhereWithAggregatesInput | CellScalarWhereWithAggregatesInput[]
    OR?: CellScalarWhereWithAggregatesInput[]
    NOT?: CellScalarWhereWithAggregatesInput | CellScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cell"> | number
    rowId?: IntWithAggregatesFilter<"Cell"> | number
    columnId?: IntWithAggregatesFilter<"Cell"> | number
    value?: StringNullableWithAggregatesFilter<"Cell"> | string | null
    displayValue?: StringNullableWithAggregatesFilter<"Cell"> | string | null
    calculatedValue?: StringNullableWithAggregatesFilter<"Cell"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cell"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cell"> | Date | string
  }

  export type ColumnWhereInput = {
    AND?: ColumnWhereInput | ColumnWhereInput[]
    OR?: ColumnWhereInput[]
    NOT?: ColumnWhereInput | ColumnWhereInput[]
    id?: IntFilter<"Column"> | number
    name?: StringFilter<"Column"> | string
    type?: EnumColumnTypeFilter<"Column"> | $Enums.ColumnType
    tableId?: IntFilter<"Column"> | number
    width?: IntNullableFilter<"Column"> | number | null
    isRequired?: BoolFilter<"Column"> | boolean
    isFilterable?: BoolFilter<"Column"> | boolean
    isSummable?: BoolFilter<"Column"> | boolean
    defaultValue?: StringNullableFilter<"Column"> | string | null
    format?: StringNullableFilter<"Column"> | string | null
    order?: IntFilter<"Column"> | number
    options?: JsonNullableFilter<"Column">
    createdAt?: DateTimeFilter<"Column"> | Date | string
    updatedAt?: DateTimeFilter<"Column"> | Date | string
    Cell?: CellListRelationFilter
    Table?: XOR<TableScalarRelationFilter, TableWhereInput>
    Filter?: FilterListRelationFilter
  }

  export type ColumnOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tableId?: SortOrder
    width?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    isFilterable?: SortOrder
    isSummable?: SortOrder
    defaultValue?: SortOrderInput | SortOrder
    format?: SortOrderInput | SortOrder
    order?: SortOrder
    options?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Cell?: CellOrderByRelationAggregateInput
    Table?: TableOrderByWithRelationInput
    Filter?: FilterOrderByRelationAggregateInput
  }

  export type ColumnWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ColumnWhereInput | ColumnWhereInput[]
    OR?: ColumnWhereInput[]
    NOT?: ColumnWhereInput | ColumnWhereInput[]
    name?: StringFilter<"Column"> | string
    type?: EnumColumnTypeFilter<"Column"> | $Enums.ColumnType
    tableId?: IntFilter<"Column"> | number
    width?: IntNullableFilter<"Column"> | number | null
    isRequired?: BoolFilter<"Column"> | boolean
    isFilterable?: BoolFilter<"Column"> | boolean
    isSummable?: BoolFilter<"Column"> | boolean
    defaultValue?: StringNullableFilter<"Column"> | string | null
    format?: StringNullableFilter<"Column"> | string | null
    order?: IntFilter<"Column"> | number
    options?: JsonNullableFilter<"Column">
    createdAt?: DateTimeFilter<"Column"> | Date | string
    updatedAt?: DateTimeFilter<"Column"> | Date | string
    Cell?: CellListRelationFilter
    Table?: XOR<TableScalarRelationFilter, TableWhereInput>
    Filter?: FilterListRelationFilter
  }, "id">

  export type ColumnOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tableId?: SortOrder
    width?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    isFilterable?: SortOrder
    isSummable?: SortOrder
    defaultValue?: SortOrderInput | SortOrder
    format?: SortOrderInput | SortOrder
    order?: SortOrder
    options?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ColumnCountOrderByAggregateInput
    _avg?: ColumnAvgOrderByAggregateInput
    _max?: ColumnMaxOrderByAggregateInput
    _min?: ColumnMinOrderByAggregateInput
    _sum?: ColumnSumOrderByAggregateInput
  }

  export type ColumnScalarWhereWithAggregatesInput = {
    AND?: ColumnScalarWhereWithAggregatesInput | ColumnScalarWhereWithAggregatesInput[]
    OR?: ColumnScalarWhereWithAggregatesInput[]
    NOT?: ColumnScalarWhereWithAggregatesInput | ColumnScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Column"> | number
    name?: StringWithAggregatesFilter<"Column"> | string
    type?: EnumColumnTypeWithAggregatesFilter<"Column"> | $Enums.ColumnType
    tableId?: IntWithAggregatesFilter<"Column"> | number
    width?: IntNullableWithAggregatesFilter<"Column"> | number | null
    isRequired?: BoolWithAggregatesFilter<"Column"> | boolean
    isFilterable?: BoolWithAggregatesFilter<"Column"> | boolean
    isSummable?: BoolWithAggregatesFilter<"Column"> | boolean
    defaultValue?: StringNullableWithAggregatesFilter<"Column"> | string | null
    format?: StringNullableWithAggregatesFilter<"Column"> | string | null
    order?: IntWithAggregatesFilter<"Column"> | number
    options?: JsonNullableWithAggregatesFilter<"Column">
    createdAt?: DateTimeWithAggregatesFilter<"Column"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Column"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    cellId?: IntFilter<"Comment"> | number
    text?: StringFilter<"Comment"> | string
    author?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    Cell?: XOR<CellScalarRelationFilter, CellWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    cellId?: SortOrder
    text?: SortOrder
    author?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Cell?: CellOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    cellId?: IntFilter<"Comment"> | number
    text?: StringFilter<"Comment"> | string
    author?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    Cell?: XOR<CellScalarRelationFilter, CellWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    cellId?: SortOrder
    text?: SortOrder
    author?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    cellId?: IntWithAggregatesFilter<"Comment"> | number
    text?: StringWithAggregatesFilter<"Comment"> | string
    author?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type FilterWhereInput = {
    AND?: FilterWhereInput | FilterWhereInput[]
    OR?: FilterWhereInput[]
    NOT?: FilterWhereInput | FilterWhereInput[]
    id?: IntFilter<"Filter"> | number
    name?: StringFilter<"Filter"> | string
    tableId?: IntFilter<"Filter"> | number
    columnId?: IntFilter<"Filter"> | number
    operator?: EnumFilterOperatorFilter<"Filter"> | $Enums.FilterOperator
    value?: StringNullableFilter<"Filter"> | string | null
    secondValue?: StringNullableFilter<"Filter"> | string | null
    isActive?: BoolFilter<"Filter"> | boolean
    createdAt?: DateTimeFilter<"Filter"> | Date | string
    updatedAt?: DateTimeFilter<"Filter"> | Date | string
    Column?: XOR<ColumnScalarRelationFilter, ColumnWhereInput>
    Table?: XOR<TableScalarRelationFilter, TableWhereInput>
  }

  export type FilterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tableId?: SortOrder
    columnId?: SortOrder
    operator?: SortOrder
    value?: SortOrderInput | SortOrder
    secondValue?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Column?: ColumnOrderByWithRelationInput
    Table?: TableOrderByWithRelationInput
  }

  export type FilterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FilterWhereInput | FilterWhereInput[]
    OR?: FilterWhereInput[]
    NOT?: FilterWhereInput | FilterWhereInput[]
    name?: StringFilter<"Filter"> | string
    tableId?: IntFilter<"Filter"> | number
    columnId?: IntFilter<"Filter"> | number
    operator?: EnumFilterOperatorFilter<"Filter"> | $Enums.FilterOperator
    value?: StringNullableFilter<"Filter"> | string | null
    secondValue?: StringNullableFilter<"Filter"> | string | null
    isActive?: BoolFilter<"Filter"> | boolean
    createdAt?: DateTimeFilter<"Filter"> | Date | string
    updatedAt?: DateTimeFilter<"Filter"> | Date | string
    Column?: XOR<ColumnScalarRelationFilter, ColumnWhereInput>
    Table?: XOR<TableScalarRelationFilter, TableWhereInput>
  }, "id">

  export type FilterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tableId?: SortOrder
    columnId?: SortOrder
    operator?: SortOrder
    value?: SortOrderInput | SortOrder
    secondValue?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FilterCountOrderByAggregateInput
    _avg?: FilterAvgOrderByAggregateInput
    _max?: FilterMaxOrderByAggregateInput
    _min?: FilterMinOrderByAggregateInput
    _sum?: FilterSumOrderByAggregateInput
  }

  export type FilterScalarWhereWithAggregatesInput = {
    AND?: FilterScalarWhereWithAggregatesInput | FilterScalarWhereWithAggregatesInput[]
    OR?: FilterScalarWhereWithAggregatesInput[]
    NOT?: FilterScalarWhereWithAggregatesInput | FilterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Filter"> | number
    name?: StringWithAggregatesFilter<"Filter"> | string
    tableId?: IntWithAggregatesFilter<"Filter"> | number
    columnId?: IntWithAggregatesFilter<"Filter"> | number
    operator?: EnumFilterOperatorWithAggregatesFilter<"Filter"> | $Enums.FilterOperator
    value?: StringNullableWithAggregatesFilter<"Filter"> | string | null
    secondValue?: StringNullableWithAggregatesFilter<"Filter"> | string | null
    isActive?: BoolWithAggregatesFilter<"Filter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Filter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Filter"> | Date | string
  }

  export type FinRowWhereInput = {
    AND?: FinRowWhereInput | FinRowWhereInput[]
    OR?: FinRowWhereInput[]
    NOT?: FinRowWhereInput | FinRowWhereInput[]
    id?: IntFilter<"FinRow"> | number
    date?: DateTimeFilter<"FinRow"> | Date | string
    time?: StringFilter<"FinRow"> | string
    shift?: StringFilter<"FinRow"> | string
    startBalance?: FloatFilter<"FinRow"> | number
    endBalance?: FloatFilter<"FinRow"> | number
    employeeId?: IntNullableFilter<"FinRow"> | number | null
    usdtAmount?: FloatFilter<"FinRow"> | number
    comment?: StringNullableFilter<"FinRow"> | string | null
    createdAt?: DateTimeFilter<"FinRow"> | Date | string
    updatedAt?: DateTimeFilter<"FinRow"> | Date | string
    currency?: StringFilter<"FinRow"> | string
    section?: EnumSalarySectionFilter<"FinRow"> | $Enums.SalarySection
    exchangeRate?: FloatNullableFilter<"FinRow"> | number | null
    Salary?: XOR<SalaryNullableScalarRelationFilter, SalaryWhereInput> | null
    FinRowExpense?: FinRowExpenseListRelationFilter
  }

  export type FinRowOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    shift?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    usdtAmount?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    section?: SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    Salary?: SalaryOrderByWithRelationInput
    FinRowExpense?: FinRowExpenseOrderByRelationAggregateInput
  }

  export type FinRowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FinRowWhereInput | FinRowWhereInput[]
    OR?: FinRowWhereInput[]
    NOT?: FinRowWhereInput | FinRowWhereInput[]
    date?: DateTimeFilter<"FinRow"> | Date | string
    time?: StringFilter<"FinRow"> | string
    shift?: StringFilter<"FinRow"> | string
    startBalance?: FloatFilter<"FinRow"> | number
    endBalance?: FloatFilter<"FinRow"> | number
    employeeId?: IntNullableFilter<"FinRow"> | number | null
    usdtAmount?: FloatFilter<"FinRow"> | number
    comment?: StringNullableFilter<"FinRow"> | string | null
    createdAt?: DateTimeFilter<"FinRow"> | Date | string
    updatedAt?: DateTimeFilter<"FinRow"> | Date | string
    currency?: StringFilter<"FinRow"> | string
    section?: EnumSalarySectionFilter<"FinRow"> | $Enums.SalarySection
    exchangeRate?: FloatNullableFilter<"FinRow"> | number | null
    Salary?: XOR<SalaryNullableScalarRelationFilter, SalaryWhereInput> | null
    FinRowExpense?: FinRowExpenseListRelationFilter
  }, "id">

  export type FinRowOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    shift?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    usdtAmount?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    section?: SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    _count?: FinRowCountOrderByAggregateInput
    _avg?: FinRowAvgOrderByAggregateInput
    _max?: FinRowMaxOrderByAggregateInput
    _min?: FinRowMinOrderByAggregateInput
    _sum?: FinRowSumOrderByAggregateInput
  }

  export type FinRowScalarWhereWithAggregatesInput = {
    AND?: FinRowScalarWhereWithAggregatesInput | FinRowScalarWhereWithAggregatesInput[]
    OR?: FinRowScalarWhereWithAggregatesInput[]
    NOT?: FinRowScalarWhereWithAggregatesInput | FinRowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FinRow"> | number
    date?: DateTimeWithAggregatesFilter<"FinRow"> | Date | string
    time?: StringWithAggregatesFilter<"FinRow"> | string
    shift?: StringWithAggregatesFilter<"FinRow"> | string
    startBalance?: FloatWithAggregatesFilter<"FinRow"> | number
    endBalance?: FloatWithAggregatesFilter<"FinRow"> | number
    employeeId?: IntNullableWithAggregatesFilter<"FinRow"> | number | null
    usdtAmount?: FloatWithAggregatesFilter<"FinRow"> | number
    comment?: StringNullableWithAggregatesFilter<"FinRow"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FinRow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FinRow"> | Date | string
    currency?: StringWithAggregatesFilter<"FinRow"> | string
    section?: EnumSalarySectionWithAggregatesFilter<"FinRow"> | $Enums.SalarySection
    exchangeRate?: FloatNullableWithAggregatesFilter<"FinRow"> | number | null
  }

  export type FinRowExpenseWhereInput = {
    AND?: FinRowExpenseWhereInput | FinRowExpenseWhereInput[]
    OR?: FinRowExpenseWhereInput[]
    NOT?: FinRowExpenseWhereInput | FinRowExpenseWhereInput[]
    id?: IntFilter<"FinRowExpense"> | number
    finRowId?: IntNullableFilter<"FinRowExpense"> | number | null
    expenseType?: StringFilter<"FinRowExpense"> | string
    amount?: FloatFilter<"FinRowExpense"> | number
    date?: DateTimeFilter<"FinRowExpense"> | Date | string
    time?: StringFilter<"FinRowExpense"> | string
    period?: StringNullableFilter<"FinRowExpense"> | string | null
    description?: StringNullableFilter<"FinRowExpense"> | string | null
    createdAt?: DateTimeFilter<"FinRowExpense"> | Date | string
    updatedAt?: DateTimeFilter<"FinRowExpense"> | Date | string
    currency?: StringFilter<"FinRowExpense"> | string
    section?: EnumSalarySectionFilter<"FinRowExpense"> | $Enums.SalarySection
    FinRow?: XOR<FinRowNullableScalarRelationFilter, FinRowWhereInput> | null
  }

  export type FinRowExpenseOrderByWithRelationInput = {
    id?: SortOrder
    finRowId?: SortOrderInput | SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    time?: SortOrder
    period?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    section?: SortOrder
    FinRow?: FinRowOrderByWithRelationInput
  }

  export type FinRowExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FinRowExpenseWhereInput | FinRowExpenseWhereInput[]
    OR?: FinRowExpenseWhereInput[]
    NOT?: FinRowExpenseWhereInput | FinRowExpenseWhereInput[]
    finRowId?: IntNullableFilter<"FinRowExpense"> | number | null
    expenseType?: StringFilter<"FinRowExpense"> | string
    amount?: FloatFilter<"FinRowExpense"> | number
    date?: DateTimeFilter<"FinRowExpense"> | Date | string
    time?: StringFilter<"FinRowExpense"> | string
    period?: StringNullableFilter<"FinRowExpense"> | string | null
    description?: StringNullableFilter<"FinRowExpense"> | string | null
    createdAt?: DateTimeFilter<"FinRowExpense"> | Date | string
    updatedAt?: DateTimeFilter<"FinRowExpense"> | Date | string
    currency?: StringFilter<"FinRowExpense"> | string
    section?: EnumSalarySectionFilter<"FinRowExpense"> | $Enums.SalarySection
    FinRow?: XOR<FinRowNullableScalarRelationFilter, FinRowWhereInput> | null
  }, "id">

  export type FinRowExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    finRowId?: SortOrderInput | SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    time?: SortOrder
    period?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    section?: SortOrder
    _count?: FinRowExpenseCountOrderByAggregateInput
    _avg?: FinRowExpenseAvgOrderByAggregateInput
    _max?: FinRowExpenseMaxOrderByAggregateInput
    _min?: FinRowExpenseMinOrderByAggregateInput
    _sum?: FinRowExpenseSumOrderByAggregateInput
  }

  export type FinRowExpenseScalarWhereWithAggregatesInput = {
    AND?: FinRowExpenseScalarWhereWithAggregatesInput | FinRowExpenseScalarWhereWithAggregatesInput[]
    OR?: FinRowExpenseScalarWhereWithAggregatesInput[]
    NOT?: FinRowExpenseScalarWhereWithAggregatesInput | FinRowExpenseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FinRowExpense"> | number
    finRowId?: IntNullableWithAggregatesFilter<"FinRowExpense"> | number | null
    expenseType?: StringWithAggregatesFilter<"FinRowExpense"> | string
    amount?: FloatWithAggregatesFilter<"FinRowExpense"> | number
    date?: DateTimeWithAggregatesFilter<"FinRowExpense"> | Date | string
    time?: StringWithAggregatesFilter<"FinRowExpense"> | string
    period?: StringNullableWithAggregatesFilter<"FinRowExpense"> | string | null
    description?: StringNullableWithAggregatesFilter<"FinRowExpense"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FinRowExpense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FinRowExpense"> | Date | string
    currency?: StringWithAggregatesFilter<"FinRowExpense"> | string
    section?: EnumSalarySectionWithAggregatesFilter<"FinRowExpense"> | $Enums.SalarySection
  }

  export type IdexCabinetWhereInput = {
    AND?: IdexCabinetWhereInput | IdexCabinetWhereInput[]
    OR?: IdexCabinetWhereInput[]
    NOT?: IdexCabinetWhereInput | IdexCabinetWhereInput[]
    id?: IntFilter<"IdexCabinet"> | number
    createdAt?: DateTimeFilter<"IdexCabinet"> | Date | string
    updatedAt?: DateTimeFilter<"IdexCabinet"> | Date | string
    idexId?: IntFilter<"IdexCabinet"> | number
    login?: StringFilter<"IdexCabinet"> | string
    password?: StringFilter<"IdexCabinet"> | string
    IdexSyncOrder?: IdexSyncOrderListRelationFilter
    IdexTransaction?: IdexTransactionListRelationFilter
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetListRelationFilter
  }

  export type IdexCabinetOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idexId?: SortOrder
    login?: SortOrder
    password?: SortOrder
    IdexSyncOrder?: IdexSyncOrderOrderByRelationAggregateInput
    IdexTransaction?: IdexTransactionOrderByRelationAggregateInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetOrderByRelationAggregateInput
  }

  export type IdexCabinetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IdexCabinetWhereInput | IdexCabinetWhereInput[]
    OR?: IdexCabinetWhereInput[]
    NOT?: IdexCabinetWhereInput | IdexCabinetWhereInput[]
    createdAt?: DateTimeFilter<"IdexCabinet"> | Date | string
    updatedAt?: DateTimeFilter<"IdexCabinet"> | Date | string
    idexId?: IntFilter<"IdexCabinet"> | number
    login?: StringFilter<"IdexCabinet"> | string
    password?: StringFilter<"IdexCabinet"> | string
    IdexSyncOrder?: IdexSyncOrderListRelationFilter
    IdexTransaction?: IdexTransactionListRelationFilter
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetListRelationFilter
  }, "id">

  export type IdexCabinetOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idexId?: SortOrder
    login?: SortOrder
    password?: SortOrder
    _count?: IdexCabinetCountOrderByAggregateInput
    _avg?: IdexCabinetAvgOrderByAggregateInput
    _max?: IdexCabinetMaxOrderByAggregateInput
    _min?: IdexCabinetMinOrderByAggregateInput
    _sum?: IdexCabinetSumOrderByAggregateInput
  }

  export type IdexCabinetScalarWhereWithAggregatesInput = {
    AND?: IdexCabinetScalarWhereWithAggregatesInput | IdexCabinetScalarWhereWithAggregatesInput[]
    OR?: IdexCabinetScalarWhereWithAggregatesInput[]
    NOT?: IdexCabinetScalarWhereWithAggregatesInput | IdexCabinetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IdexCabinet"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IdexCabinet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IdexCabinet"> | Date | string
    idexId?: IntWithAggregatesFilter<"IdexCabinet"> | number
    login?: StringWithAggregatesFilter<"IdexCabinet"> | string
    password?: StringWithAggregatesFilter<"IdexCabinet"> | string
  }

  export type IdexSyncOrderWhereInput = {
    AND?: IdexSyncOrderWhereInput | IdexSyncOrderWhereInput[]
    OR?: IdexSyncOrderWhereInput[]
    NOT?: IdexSyncOrderWhereInput | IdexSyncOrderWhereInput[]
    id?: IntFilter<"IdexSyncOrder"> | number
    createdAt?: DateTimeFilter<"IdexSyncOrder"> | Date | string
    updatedAt?: DateTimeFilter<"IdexSyncOrder"> | Date | string
    cabinetId?: IntNullableFilter<"IdexSyncOrder"> | number | null
    processed?: JsonNullableFilter<"IdexSyncOrder">
    status?: EnumIdexSyncOrderStatusFilter<"IdexSyncOrder"> | $Enums.IdexSyncOrderStatus
    startSyncAt?: DateTimeNullableFilter<"IdexSyncOrder"> | Date | string | null
    endSyncAt?: DateTimeNullableFilter<"IdexSyncOrder"> | Date | string | null
    pages?: IntNullableListFilter<"IdexSyncOrder">
    IdexCabinet?: XOR<IdexCabinetNullableScalarRelationFilter, IdexCabinetWhereInput> | null
  }

  export type IdexSyncOrderOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinetId?: SortOrderInput | SortOrder
    processed?: SortOrderInput | SortOrder
    status?: SortOrder
    startSyncAt?: SortOrderInput | SortOrder
    endSyncAt?: SortOrderInput | SortOrder
    pages?: SortOrder
    IdexCabinet?: IdexCabinetOrderByWithRelationInput
  }

  export type IdexSyncOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IdexSyncOrderWhereInput | IdexSyncOrderWhereInput[]
    OR?: IdexSyncOrderWhereInput[]
    NOT?: IdexSyncOrderWhereInput | IdexSyncOrderWhereInput[]
    createdAt?: DateTimeFilter<"IdexSyncOrder"> | Date | string
    updatedAt?: DateTimeFilter<"IdexSyncOrder"> | Date | string
    cabinetId?: IntNullableFilter<"IdexSyncOrder"> | number | null
    processed?: JsonNullableFilter<"IdexSyncOrder">
    status?: EnumIdexSyncOrderStatusFilter<"IdexSyncOrder"> | $Enums.IdexSyncOrderStatus
    startSyncAt?: DateTimeNullableFilter<"IdexSyncOrder"> | Date | string | null
    endSyncAt?: DateTimeNullableFilter<"IdexSyncOrder"> | Date | string | null
    pages?: IntNullableListFilter<"IdexSyncOrder">
    IdexCabinet?: XOR<IdexCabinetNullableScalarRelationFilter, IdexCabinetWhereInput> | null
  }, "id">

  export type IdexSyncOrderOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinetId?: SortOrderInput | SortOrder
    processed?: SortOrderInput | SortOrder
    status?: SortOrder
    startSyncAt?: SortOrderInput | SortOrder
    endSyncAt?: SortOrderInput | SortOrder
    pages?: SortOrder
    _count?: IdexSyncOrderCountOrderByAggregateInput
    _avg?: IdexSyncOrderAvgOrderByAggregateInput
    _max?: IdexSyncOrderMaxOrderByAggregateInput
    _min?: IdexSyncOrderMinOrderByAggregateInput
    _sum?: IdexSyncOrderSumOrderByAggregateInput
  }

  export type IdexSyncOrderScalarWhereWithAggregatesInput = {
    AND?: IdexSyncOrderScalarWhereWithAggregatesInput | IdexSyncOrderScalarWhereWithAggregatesInput[]
    OR?: IdexSyncOrderScalarWhereWithAggregatesInput[]
    NOT?: IdexSyncOrderScalarWhereWithAggregatesInput | IdexSyncOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IdexSyncOrder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IdexSyncOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IdexSyncOrder"> | Date | string
    cabinetId?: IntNullableWithAggregatesFilter<"IdexSyncOrder"> | number | null
    processed?: JsonNullableWithAggregatesFilter<"IdexSyncOrder">
    status?: EnumIdexSyncOrderStatusWithAggregatesFilter<"IdexSyncOrder"> | $Enums.IdexSyncOrderStatus
    startSyncAt?: DateTimeNullableWithAggregatesFilter<"IdexSyncOrder"> | Date | string | null
    endSyncAt?: DateTimeNullableWithAggregatesFilter<"IdexSyncOrder"> | Date | string | null
    pages?: IntNullableListFilter<"IdexSyncOrder">
  }

  export type IdexTransactionWhereInput = {
    AND?: IdexTransactionWhereInput | IdexTransactionWhereInput[]
    OR?: IdexTransactionWhereInput[]
    NOT?: IdexTransactionWhereInput | IdexTransactionWhereInput[]
    id?: IntFilter<"IdexTransaction"> | number
    externalId?: BigIntFilter<"IdexTransaction"> | bigint | number
    paymentMethodId?: BigIntFilter<"IdexTransaction"> | bigint | number
    wallet?: StringFilter<"IdexTransaction"> | string
    amount?: JsonFilter<"IdexTransaction">
    total?: JsonFilter<"IdexTransaction">
    status?: IntFilter<"IdexTransaction"> | number
    approvedAt?: StringNullableFilter<"IdexTransaction"> | string | null
    expiredAt?: StringNullableFilter<"IdexTransaction"> | string | null
    createdAtExternal?: StringFilter<"IdexTransaction"> | string
    updatedAtExternal?: StringFilter<"IdexTransaction"> | string
    extraData?: JsonFilter<"IdexTransaction">
    cabinetId?: IntFilter<"IdexTransaction"> | number
    createdAt?: DateTimeFilter<"IdexTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"IdexTransaction"> | Date | string
    BybitClipMatch?: BybitClipMatchListRelationFilter
    BybitMatch?: BybitMatchListRelationFilter
    IdexCabinet?: XOR<IdexCabinetScalarRelationFilter, IdexCabinetWhereInput>
    Match?: MatchListRelationFilter
  }

  export type IdexTransactionOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    paymentMethodId?: SortOrder
    wallet?: SortOrder
    amount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    createdAtExternal?: SortOrder
    updatedAtExternal?: SortOrder
    extraData?: SortOrder
    cabinetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    BybitClipMatch?: BybitClipMatchOrderByRelationAggregateInput
    BybitMatch?: BybitMatchOrderByRelationAggregateInput
    IdexCabinet?: IdexCabinetOrderByWithRelationInput
    Match?: MatchOrderByRelationAggregateInput
  }

  export type IdexTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    externalId_cabinetId?: IdexTransactionExternalIdCabinetIdCompoundUniqueInput
    AND?: IdexTransactionWhereInput | IdexTransactionWhereInput[]
    OR?: IdexTransactionWhereInput[]
    NOT?: IdexTransactionWhereInput | IdexTransactionWhereInput[]
    externalId?: BigIntFilter<"IdexTransaction"> | bigint | number
    paymentMethodId?: BigIntFilter<"IdexTransaction"> | bigint | number
    wallet?: StringFilter<"IdexTransaction"> | string
    amount?: JsonFilter<"IdexTransaction">
    total?: JsonFilter<"IdexTransaction">
    status?: IntFilter<"IdexTransaction"> | number
    approvedAt?: StringNullableFilter<"IdexTransaction"> | string | null
    expiredAt?: StringNullableFilter<"IdexTransaction"> | string | null
    createdAtExternal?: StringFilter<"IdexTransaction"> | string
    updatedAtExternal?: StringFilter<"IdexTransaction"> | string
    extraData?: JsonFilter<"IdexTransaction">
    cabinetId?: IntFilter<"IdexTransaction"> | number
    createdAt?: DateTimeFilter<"IdexTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"IdexTransaction"> | Date | string
    BybitClipMatch?: BybitClipMatchListRelationFilter
    BybitMatch?: BybitMatchListRelationFilter
    IdexCabinet?: XOR<IdexCabinetScalarRelationFilter, IdexCabinetWhereInput>
    Match?: MatchListRelationFilter
  }, "id" | "externalId_cabinetId">

  export type IdexTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    paymentMethodId?: SortOrder
    wallet?: SortOrder
    amount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    createdAtExternal?: SortOrder
    updatedAtExternal?: SortOrder
    extraData?: SortOrder
    cabinetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IdexTransactionCountOrderByAggregateInput
    _avg?: IdexTransactionAvgOrderByAggregateInput
    _max?: IdexTransactionMaxOrderByAggregateInput
    _min?: IdexTransactionMinOrderByAggregateInput
    _sum?: IdexTransactionSumOrderByAggregateInput
  }

  export type IdexTransactionScalarWhereWithAggregatesInput = {
    AND?: IdexTransactionScalarWhereWithAggregatesInput | IdexTransactionScalarWhereWithAggregatesInput[]
    OR?: IdexTransactionScalarWhereWithAggregatesInput[]
    NOT?: IdexTransactionScalarWhereWithAggregatesInput | IdexTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IdexTransaction"> | number
    externalId?: BigIntWithAggregatesFilter<"IdexTransaction"> | bigint | number
    paymentMethodId?: BigIntWithAggregatesFilter<"IdexTransaction"> | bigint | number
    wallet?: StringWithAggregatesFilter<"IdexTransaction"> | string
    amount?: JsonWithAggregatesFilter<"IdexTransaction">
    total?: JsonWithAggregatesFilter<"IdexTransaction">
    status?: IntWithAggregatesFilter<"IdexTransaction"> | number
    approvedAt?: StringNullableWithAggregatesFilter<"IdexTransaction"> | string | null
    expiredAt?: StringNullableWithAggregatesFilter<"IdexTransaction"> | string | null
    createdAtExternal?: StringWithAggregatesFilter<"IdexTransaction"> | string
    updatedAtExternal?: StringWithAggregatesFilter<"IdexTransaction"> | string
    extraData?: JsonWithAggregatesFilter<"IdexTransaction">
    cabinetId?: IntWithAggregatesFilter<"IdexTransaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IdexTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IdexTransaction"> | Date | string
  }

  export type ImportExportWhereInput = {
    AND?: ImportExportWhereInput | ImportExportWhereInput[]
    OR?: ImportExportWhereInput[]
    NOT?: ImportExportWhereInput | ImportExportWhereInput[]
    id?: IntFilter<"ImportExport"> | number
    tableId?: IntFilter<"ImportExport"> | number
    name?: StringFilter<"ImportExport"> | string
    type?: StringFilter<"ImportExport"> | string
    mappings?: JsonFilter<"ImportExport">
    options?: JsonNullableFilter<"ImportExport">
    createdAt?: DateTimeFilter<"ImportExport"> | Date | string
    updatedAt?: DateTimeFilter<"ImportExport"> | Date | string
  }

  export type ImportExportOrderByWithRelationInput = {
    id?: SortOrder
    tableId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mappings?: SortOrder
    options?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportExportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ImportExportWhereInput | ImportExportWhereInput[]
    OR?: ImportExportWhereInput[]
    NOT?: ImportExportWhereInput | ImportExportWhereInput[]
    tableId?: IntFilter<"ImportExport"> | number
    name?: StringFilter<"ImportExport"> | string
    type?: StringFilter<"ImportExport"> | string
    mappings?: JsonFilter<"ImportExport">
    options?: JsonNullableFilter<"ImportExport">
    createdAt?: DateTimeFilter<"ImportExport"> | Date | string
    updatedAt?: DateTimeFilter<"ImportExport"> | Date | string
  }, "id">

  export type ImportExportOrderByWithAggregationInput = {
    id?: SortOrder
    tableId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mappings?: SortOrder
    options?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImportExportCountOrderByAggregateInput
    _avg?: ImportExportAvgOrderByAggregateInput
    _max?: ImportExportMaxOrderByAggregateInput
    _min?: ImportExportMinOrderByAggregateInput
    _sum?: ImportExportSumOrderByAggregateInput
  }

  export type ImportExportScalarWhereWithAggregatesInput = {
    AND?: ImportExportScalarWhereWithAggregatesInput | ImportExportScalarWhereWithAggregatesInput[]
    OR?: ImportExportScalarWhereWithAggregatesInput[]
    NOT?: ImportExportScalarWhereWithAggregatesInput | ImportExportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ImportExport"> | number
    tableId?: IntWithAggregatesFilter<"ImportExport"> | number
    name?: StringWithAggregatesFilter<"ImportExport"> | string
    type?: StringWithAggregatesFilter<"ImportExport"> | string
    mappings?: JsonWithAggregatesFilter<"ImportExport">
    options?: JsonNullableWithAggregatesFilter<"ImportExport">
    createdAt?: DateTimeWithAggregatesFilter<"ImportExport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImportExport"> | Date | string
  }

  export type MatchWhereInput = {
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    id?: IntFilter<"Match"> | number
    idexTransactionId?: IntFilter<"Match"> | number
    transactionId?: IntFilter<"Match"> | number
    timeDifference?: IntFilter<"Match"> | number
    grossExpense?: FloatFilter<"Match"> | number
    grossIncome?: FloatFilter<"Match"> | number
    grossProfit?: FloatFilter<"Match"> | number
    profitPercentage?: FloatFilter<"Match"> | number
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    IdexTransaction?: XOR<IdexTransactionScalarRelationFilter, IdexTransactionWhereInput>
    Transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type MatchOrderByWithRelationInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    transactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    IdexTransaction?: IdexTransactionOrderByWithRelationInput
    Transaction?: TransactionOrderByWithRelationInput
  }

  export type MatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    idexTransactionId_transactionId?: MatchIdexTransactionIdTransactionIdCompoundUniqueInput
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    idexTransactionId?: IntFilter<"Match"> | number
    transactionId?: IntFilter<"Match"> | number
    timeDifference?: IntFilter<"Match"> | number
    grossExpense?: FloatFilter<"Match"> | number
    grossIncome?: FloatFilter<"Match"> | number
    grossProfit?: FloatFilter<"Match"> | number
    profitPercentage?: FloatFilter<"Match"> | number
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    IdexTransaction?: XOR<IdexTransactionScalarRelationFilter, IdexTransactionWhereInput>
    Transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "id" | "idexTransactionId_transactionId">

  export type MatchOrderByWithAggregationInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    transactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatchCountOrderByAggregateInput
    _avg?: MatchAvgOrderByAggregateInput
    _max?: MatchMaxOrderByAggregateInput
    _min?: MatchMinOrderByAggregateInput
    _sum?: MatchSumOrderByAggregateInput
  }

  export type MatchScalarWhereWithAggregatesInput = {
    AND?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    OR?: MatchScalarWhereWithAggregatesInput[]
    NOT?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Match"> | number
    idexTransactionId?: IntWithAggregatesFilter<"Match"> | number
    transactionId?: IntWithAggregatesFilter<"Match"> | number
    timeDifference?: IntWithAggregatesFilter<"Match"> | number
    grossExpense?: FloatWithAggregatesFilter<"Match"> | number
    grossIncome?: FloatWithAggregatesFilter<"Match"> | number
    grossProfit?: FloatWithAggregatesFilter<"Match"> | number
    profitPercentage?: FloatWithAggregatesFilter<"Match"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
  }

  export type NotificationSettingsWhereInput = {
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    id?: IntFilter<"NotificationSettings"> | number
    settings?: JsonFilter<"NotificationSettings">
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
  }

  export type NotificationSettingsOrderByWithRelationInput = {
    id?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    settings?: JsonFilter<"NotificationSettings">
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
  }, "id">

  export type NotificationSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationSettingsCountOrderByAggregateInput
    _avg?: NotificationSettingsAvgOrderByAggregateInput
    _max?: NotificationSettingsMaxOrderByAggregateInput
    _min?: NotificationSettingsMinOrderByAggregateInput
    _sum?: NotificationSettingsSumOrderByAggregateInput
  }

  export type NotificationSettingsScalarWhereWithAggregatesInput = {
    AND?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    OR?: NotificationSettingsScalarWhereWithAggregatesInput[]
    NOT?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotificationSettings"> | number
    settings?: JsonWithAggregatesFilter<"NotificationSettings">
    createdAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
  }

  export type PasswordWhereInput = {
    AND?: PasswordWhereInput | PasswordWhereInput[]
    OR?: PasswordWhereInput[]
    NOT?: PasswordWhereInput | PasswordWhereInput[]
    id?: IntFilter<"Password"> | number
    name?: StringFilter<"Password"> | string
    login?: StringNullableFilter<"Password"> | string | null
    password?: StringFilter<"Password"> | string
    createdAt?: DateTimeFilter<"Password"> | Date | string
    updatedAt?: DateTimeFilter<"Password"> | Date | string
    comment?: StringNullableFilter<"Password"> | string | null
    type?: EnumPasswordTypeNullableFilter<"Password"> | $Enums.PasswordType | null
  }

  export type PasswordOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    login?: SortOrderInput | SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
  }

  export type PasswordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PasswordWhereInput | PasswordWhereInput[]
    OR?: PasswordWhereInput[]
    NOT?: PasswordWhereInput | PasswordWhereInput[]
    name?: StringFilter<"Password"> | string
    login?: StringNullableFilter<"Password"> | string | null
    password?: StringFilter<"Password"> | string
    createdAt?: DateTimeFilter<"Password"> | Date | string
    updatedAt?: DateTimeFilter<"Password"> | Date | string
    comment?: StringNullableFilter<"Password"> | string | null
    type?: EnumPasswordTypeNullableFilter<"Password"> | $Enums.PasswordType | null
  }, "id">

  export type PasswordOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    login?: SortOrderInput | SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: PasswordCountOrderByAggregateInput
    _avg?: PasswordAvgOrderByAggregateInput
    _max?: PasswordMaxOrderByAggregateInput
    _min?: PasswordMinOrderByAggregateInput
    _sum?: PasswordSumOrderByAggregateInput
  }

  export type PasswordScalarWhereWithAggregatesInput = {
    AND?: PasswordScalarWhereWithAggregatesInput | PasswordScalarWhereWithAggregatesInput[]
    OR?: PasswordScalarWhereWithAggregatesInput[]
    NOT?: PasswordScalarWhereWithAggregatesInput | PasswordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Password"> | number
    name?: StringWithAggregatesFilter<"Password"> | string
    login?: StringNullableWithAggregatesFilter<"Password"> | string | null
    password?: StringWithAggregatesFilter<"Password"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Password"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Password"> | Date | string
    comment?: StringNullableWithAggregatesFilter<"Password"> | string | null
    type?: EnumPasswordTypeNullableWithAggregatesFilter<"Password"> | $Enums.PasswordType | null
  }

  export type ReportNotificationWhereInput = {
    AND?: ReportNotificationWhereInput | ReportNotificationWhereInput[]
    OR?: ReportNotificationWhereInput[]
    NOT?: ReportNotificationWhereInput | ReportNotificationWhereInput[]
    id?: IntFilter<"ReportNotification"> | number
    notificationTime?: DateTimeFilter<"ReportNotification"> | Date | string
    reportReceived?: BoolFilter<"ReportNotification"> | boolean
    reportTime?: DateTimeNullableFilter<"ReportNotification"> | Date | string | null
    adminNotified?: BoolFilter<"ReportNotification"> | boolean
    adminNotifyTime?: DateTimeNullableFilter<"ReportNotification"> | Date | string | null
    userId?: IntFilter<"ReportNotification"> | number
    createdAt?: DateTimeFilter<"ReportNotification"> | Date | string
    updatedAt?: DateTimeFilter<"ReportNotification"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReportNotificationOrderByWithRelationInput = {
    id?: SortOrder
    notificationTime?: SortOrder
    reportReceived?: SortOrder
    reportTime?: SortOrderInput | SortOrder
    adminNotified?: SortOrder
    adminNotifyTime?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type ReportNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportNotificationWhereInput | ReportNotificationWhereInput[]
    OR?: ReportNotificationWhereInput[]
    NOT?: ReportNotificationWhereInput | ReportNotificationWhereInput[]
    notificationTime?: DateTimeFilter<"ReportNotification"> | Date | string
    reportReceived?: BoolFilter<"ReportNotification"> | boolean
    reportTime?: DateTimeNullableFilter<"ReportNotification"> | Date | string | null
    adminNotified?: BoolFilter<"ReportNotification"> | boolean
    adminNotifyTime?: DateTimeNullableFilter<"ReportNotification"> | Date | string | null
    userId?: IntFilter<"ReportNotification"> | number
    createdAt?: DateTimeFilter<"ReportNotification"> | Date | string
    updatedAt?: DateTimeFilter<"ReportNotification"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReportNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    notificationTime?: SortOrder
    reportReceived?: SortOrder
    reportTime?: SortOrderInput | SortOrder
    adminNotified?: SortOrder
    adminNotifyTime?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportNotificationCountOrderByAggregateInput
    _avg?: ReportNotificationAvgOrderByAggregateInput
    _max?: ReportNotificationMaxOrderByAggregateInput
    _min?: ReportNotificationMinOrderByAggregateInput
    _sum?: ReportNotificationSumOrderByAggregateInput
  }

  export type ReportNotificationScalarWhereWithAggregatesInput = {
    AND?: ReportNotificationScalarWhereWithAggregatesInput | ReportNotificationScalarWhereWithAggregatesInput[]
    OR?: ReportNotificationScalarWhereWithAggregatesInput[]
    NOT?: ReportNotificationScalarWhereWithAggregatesInput | ReportNotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReportNotification"> | number
    notificationTime?: DateTimeWithAggregatesFilter<"ReportNotification"> | Date | string
    reportReceived?: BoolWithAggregatesFilter<"ReportNotification"> | boolean
    reportTime?: DateTimeNullableWithAggregatesFilter<"ReportNotification"> | Date | string | null
    adminNotified?: BoolWithAggregatesFilter<"ReportNotification"> | boolean
    adminNotifyTime?: DateTimeNullableWithAggregatesFilter<"ReportNotification"> | Date | string | null
    userId?: IntWithAggregatesFilter<"ReportNotification"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ReportNotification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportNotification"> | Date | string
  }

  export type RowWhereInput = {
    AND?: RowWhereInput | RowWhereInput[]
    OR?: RowWhereInput[]
    NOT?: RowWhereInput | RowWhereInput[]
    id?: IntFilter<"Row"> | number
    tableId?: IntFilter<"Row"> | number
    order?: IntFilter<"Row"> | number
    isActive?: BoolFilter<"Row"> | boolean
    createdAt?: DateTimeFilter<"Row"> | Date | string
    updatedAt?: DateTimeFilter<"Row"> | Date | string
    Cell?: CellListRelationFilter
    Table?: XOR<TableScalarRelationFilter, TableWhereInput>
  }

  export type RowOrderByWithRelationInput = {
    id?: SortOrder
    tableId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Cell?: CellOrderByRelationAggregateInput
    Table?: TableOrderByWithRelationInput
  }

  export type RowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RowWhereInput | RowWhereInput[]
    OR?: RowWhereInput[]
    NOT?: RowWhereInput | RowWhereInput[]
    tableId?: IntFilter<"Row"> | number
    order?: IntFilter<"Row"> | number
    isActive?: BoolFilter<"Row"> | boolean
    createdAt?: DateTimeFilter<"Row"> | Date | string
    updatedAt?: DateTimeFilter<"Row"> | Date | string
    Cell?: CellListRelationFilter
    Table?: XOR<TableScalarRelationFilter, TableWhereInput>
  }, "id">

  export type RowOrderByWithAggregationInput = {
    id?: SortOrder
    tableId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RowCountOrderByAggregateInput
    _avg?: RowAvgOrderByAggregateInput
    _max?: RowMaxOrderByAggregateInput
    _min?: RowMinOrderByAggregateInput
    _sum?: RowSumOrderByAggregateInput
  }

  export type RowScalarWhereWithAggregatesInput = {
    AND?: RowScalarWhereWithAggregatesInput | RowScalarWhereWithAggregatesInput[]
    OR?: RowScalarWhereWithAggregatesInput[]
    NOT?: RowScalarWhereWithAggregatesInput | RowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Row"> | number
    tableId?: IntWithAggregatesFilter<"Row"> | number
    order?: IntWithAggregatesFilter<"Row"> | number
    isActive?: BoolWithAggregatesFilter<"Row"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Row"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Row"> | Date | string
  }

  export type SalaryWhereInput = {
    AND?: SalaryWhereInput | SalaryWhereInput[]
    OR?: SalaryWhereInput[]
    NOT?: SalaryWhereInput | SalaryWhereInput[]
    id?: IntFilter<"Salary"> | number
    fullName?: StringFilter<"Salary"> | string
    position?: StringFilter<"Salary"> | string
    startDate?: DateTimeFilter<"Salary"> | Date | string
    payday?: IntFilter<"Salary"> | number
    paydayMonth?: IntNullableFilter<"Salary"> | number | null
    fixedSalary?: FloatNullableFilter<"Salary"> | number | null
    isActive?: BoolFilter<"Salary"> | boolean
    createdAt?: DateTimeFilter<"Salary"> | Date | string
    updatedAt?: DateTimeFilter<"Salary"> | Date | string
    comment?: StringNullableFilter<"Salary"> | string | null
    periodic?: EnumPeriodTypeFilter<"Salary"> | $Enums.PeriodType
    payday2?: IntNullableFilter<"Salary"> | number | null
    payday3?: IntNullableFilter<"Salary"> | number | null
    section?: EnumSalarySectionFilter<"Salary"> | $Enums.SalarySection
    FinRow?: FinRowListRelationFilter
    SalaryDebt?: SalaryDebtListRelationFilter
    SalaryEarning?: SalaryEarningListRelationFilter
    SalaryPayment?: SalaryPaymentListRelationFilter
    ShiftReport?: ShiftReportListRelationFilter
  }

  export type SalaryOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    position?: SortOrder
    startDate?: SortOrder
    payday?: SortOrder
    paydayMonth?: SortOrderInput | SortOrder
    fixedSalary?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrderInput | SortOrder
    periodic?: SortOrder
    payday2?: SortOrderInput | SortOrder
    payday3?: SortOrderInput | SortOrder
    section?: SortOrder
    FinRow?: FinRowOrderByRelationAggregateInput
    SalaryDebt?: SalaryDebtOrderByRelationAggregateInput
    SalaryEarning?: SalaryEarningOrderByRelationAggregateInput
    SalaryPayment?: SalaryPaymentOrderByRelationAggregateInput
    ShiftReport?: ShiftReportOrderByRelationAggregateInput
  }

  export type SalaryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalaryWhereInput | SalaryWhereInput[]
    OR?: SalaryWhereInput[]
    NOT?: SalaryWhereInput | SalaryWhereInput[]
    fullName?: StringFilter<"Salary"> | string
    position?: StringFilter<"Salary"> | string
    startDate?: DateTimeFilter<"Salary"> | Date | string
    payday?: IntFilter<"Salary"> | number
    paydayMonth?: IntNullableFilter<"Salary"> | number | null
    fixedSalary?: FloatNullableFilter<"Salary"> | number | null
    isActive?: BoolFilter<"Salary"> | boolean
    createdAt?: DateTimeFilter<"Salary"> | Date | string
    updatedAt?: DateTimeFilter<"Salary"> | Date | string
    comment?: StringNullableFilter<"Salary"> | string | null
    periodic?: EnumPeriodTypeFilter<"Salary"> | $Enums.PeriodType
    payday2?: IntNullableFilter<"Salary"> | number | null
    payday3?: IntNullableFilter<"Salary"> | number | null
    section?: EnumSalarySectionFilter<"Salary"> | $Enums.SalarySection
    FinRow?: FinRowListRelationFilter
    SalaryDebt?: SalaryDebtListRelationFilter
    SalaryEarning?: SalaryEarningListRelationFilter
    SalaryPayment?: SalaryPaymentListRelationFilter
    ShiftReport?: ShiftReportListRelationFilter
  }, "id">

  export type SalaryOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    position?: SortOrder
    startDate?: SortOrder
    payday?: SortOrder
    paydayMonth?: SortOrderInput | SortOrder
    fixedSalary?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrderInput | SortOrder
    periodic?: SortOrder
    payday2?: SortOrderInput | SortOrder
    payday3?: SortOrderInput | SortOrder
    section?: SortOrder
    _count?: SalaryCountOrderByAggregateInput
    _avg?: SalaryAvgOrderByAggregateInput
    _max?: SalaryMaxOrderByAggregateInput
    _min?: SalaryMinOrderByAggregateInput
    _sum?: SalarySumOrderByAggregateInput
  }

  export type SalaryScalarWhereWithAggregatesInput = {
    AND?: SalaryScalarWhereWithAggregatesInput | SalaryScalarWhereWithAggregatesInput[]
    OR?: SalaryScalarWhereWithAggregatesInput[]
    NOT?: SalaryScalarWhereWithAggregatesInput | SalaryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Salary"> | number
    fullName?: StringWithAggregatesFilter<"Salary"> | string
    position?: StringWithAggregatesFilter<"Salary"> | string
    startDate?: DateTimeWithAggregatesFilter<"Salary"> | Date | string
    payday?: IntWithAggregatesFilter<"Salary"> | number
    paydayMonth?: IntNullableWithAggregatesFilter<"Salary"> | number | null
    fixedSalary?: FloatNullableWithAggregatesFilter<"Salary"> | number | null
    isActive?: BoolWithAggregatesFilter<"Salary"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Salary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Salary"> | Date | string
    comment?: StringNullableWithAggregatesFilter<"Salary"> | string | null
    periodic?: EnumPeriodTypeWithAggregatesFilter<"Salary"> | $Enums.PeriodType
    payday2?: IntNullableWithAggregatesFilter<"Salary"> | number | null
    payday3?: IntNullableWithAggregatesFilter<"Salary"> | number | null
    section?: EnumSalarySectionWithAggregatesFilter<"Salary"> | $Enums.SalarySection
  }

  export type SalaryDebtWhereInput = {
    AND?: SalaryDebtWhereInput | SalaryDebtWhereInput[]
    OR?: SalaryDebtWhereInput[]
    NOT?: SalaryDebtWhereInput | SalaryDebtWhereInput[]
    id?: IntFilter<"SalaryDebt"> | number
    salaryId?: IntFilter<"SalaryDebt"> | number
    amount?: FloatFilter<"SalaryDebt"> | number
    debtDate?: DateTimeFilter<"SalaryDebt"> | Date | string
    description?: StringNullableFilter<"SalaryDebt"> | string | null
    isPaid?: BoolFilter<"SalaryDebt"> | boolean
    createdAt?: DateTimeFilter<"SalaryDebt"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryDebt"> | Date | string
    Salary?: XOR<SalaryScalarRelationFilter, SalaryWhereInput>
  }

  export type SalaryDebtOrderByWithRelationInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    debtDate?: SortOrder
    description?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Salary?: SalaryOrderByWithRelationInput
  }

  export type SalaryDebtWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalaryDebtWhereInput | SalaryDebtWhereInput[]
    OR?: SalaryDebtWhereInput[]
    NOT?: SalaryDebtWhereInput | SalaryDebtWhereInput[]
    salaryId?: IntFilter<"SalaryDebt"> | number
    amount?: FloatFilter<"SalaryDebt"> | number
    debtDate?: DateTimeFilter<"SalaryDebt"> | Date | string
    description?: StringNullableFilter<"SalaryDebt"> | string | null
    isPaid?: BoolFilter<"SalaryDebt"> | boolean
    createdAt?: DateTimeFilter<"SalaryDebt"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryDebt"> | Date | string
    Salary?: XOR<SalaryScalarRelationFilter, SalaryWhereInput>
  }, "id">

  export type SalaryDebtOrderByWithAggregationInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    debtDate?: SortOrder
    description?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalaryDebtCountOrderByAggregateInput
    _avg?: SalaryDebtAvgOrderByAggregateInput
    _max?: SalaryDebtMaxOrderByAggregateInput
    _min?: SalaryDebtMinOrderByAggregateInput
    _sum?: SalaryDebtSumOrderByAggregateInput
  }

  export type SalaryDebtScalarWhereWithAggregatesInput = {
    AND?: SalaryDebtScalarWhereWithAggregatesInput | SalaryDebtScalarWhereWithAggregatesInput[]
    OR?: SalaryDebtScalarWhereWithAggregatesInput[]
    NOT?: SalaryDebtScalarWhereWithAggregatesInput | SalaryDebtScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalaryDebt"> | number
    salaryId?: IntWithAggregatesFilter<"SalaryDebt"> | number
    amount?: FloatWithAggregatesFilter<"SalaryDebt"> | number
    debtDate?: DateTimeWithAggregatesFilter<"SalaryDebt"> | Date | string
    description?: StringNullableWithAggregatesFilter<"SalaryDebt"> | string | null
    isPaid?: BoolWithAggregatesFilter<"SalaryDebt"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SalaryDebt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalaryDebt"> | Date | string
  }

  export type SalaryEarningWhereInput = {
    AND?: SalaryEarningWhereInput | SalaryEarningWhereInput[]
    OR?: SalaryEarningWhereInput[]
    NOT?: SalaryEarningWhereInput | SalaryEarningWhereInput[]
    id?: IntFilter<"SalaryEarning"> | number
    amount?: FloatFilter<"SalaryEarning"> | number
    earningDate?: DateTimeFilter<"SalaryEarning"> | Date | string
    description?: StringNullableFilter<"SalaryEarning"> | string | null
    createdAt?: DateTimeFilter<"SalaryEarning"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryEarning"> | Date | string
    salaryId?: IntFilter<"SalaryEarning"> | number
    Salary?: XOR<SalaryScalarRelationFilter, SalaryWhereInput>
  }

  export type SalaryEarningOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    earningDate?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salaryId?: SortOrder
    Salary?: SalaryOrderByWithRelationInput
  }

  export type SalaryEarningWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalaryEarningWhereInput | SalaryEarningWhereInput[]
    OR?: SalaryEarningWhereInput[]
    NOT?: SalaryEarningWhereInput | SalaryEarningWhereInput[]
    amount?: FloatFilter<"SalaryEarning"> | number
    earningDate?: DateTimeFilter<"SalaryEarning"> | Date | string
    description?: StringNullableFilter<"SalaryEarning"> | string | null
    createdAt?: DateTimeFilter<"SalaryEarning"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryEarning"> | Date | string
    salaryId?: IntFilter<"SalaryEarning"> | number
    Salary?: XOR<SalaryScalarRelationFilter, SalaryWhereInput>
  }, "id">

  export type SalaryEarningOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    earningDate?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salaryId?: SortOrder
    _count?: SalaryEarningCountOrderByAggregateInput
    _avg?: SalaryEarningAvgOrderByAggregateInput
    _max?: SalaryEarningMaxOrderByAggregateInput
    _min?: SalaryEarningMinOrderByAggregateInput
    _sum?: SalaryEarningSumOrderByAggregateInput
  }

  export type SalaryEarningScalarWhereWithAggregatesInput = {
    AND?: SalaryEarningScalarWhereWithAggregatesInput | SalaryEarningScalarWhereWithAggregatesInput[]
    OR?: SalaryEarningScalarWhereWithAggregatesInput[]
    NOT?: SalaryEarningScalarWhereWithAggregatesInput | SalaryEarningScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalaryEarning"> | number
    amount?: FloatWithAggregatesFilter<"SalaryEarning"> | number
    earningDate?: DateTimeWithAggregatesFilter<"SalaryEarning"> | Date | string
    description?: StringNullableWithAggregatesFilter<"SalaryEarning"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SalaryEarning"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalaryEarning"> | Date | string
    salaryId?: IntWithAggregatesFilter<"SalaryEarning"> | number
  }

  export type SalaryPaymentWhereInput = {
    AND?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    OR?: SalaryPaymentWhereInput[]
    NOT?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    id?: IntFilter<"SalaryPayment"> | number
    salaryId?: IntFilter<"SalaryPayment"> | number
    amount?: FloatFilter<"SalaryPayment"> | number
    paymentDate?: DateTimeFilter<"SalaryPayment"> | Date | string
    comment?: StringNullableFilter<"SalaryPayment"> | string | null
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    currency?: StringFilter<"SalaryPayment"> | string
    Salary?: XOR<SalaryScalarRelationFilter, SalaryWhereInput>
  }

  export type SalaryPaymentOrderByWithRelationInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    Salary?: SalaryOrderByWithRelationInput
  }

  export type SalaryPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    OR?: SalaryPaymentWhereInput[]
    NOT?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    salaryId?: IntFilter<"SalaryPayment"> | number
    amount?: FloatFilter<"SalaryPayment"> | number
    paymentDate?: DateTimeFilter<"SalaryPayment"> | Date | string
    comment?: StringNullableFilter<"SalaryPayment"> | string | null
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    currency?: StringFilter<"SalaryPayment"> | string
    Salary?: XOR<SalaryScalarRelationFilter, SalaryWhereInput>
  }, "id">

  export type SalaryPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    _count?: SalaryPaymentCountOrderByAggregateInput
    _avg?: SalaryPaymentAvgOrderByAggregateInput
    _max?: SalaryPaymentMaxOrderByAggregateInput
    _min?: SalaryPaymentMinOrderByAggregateInput
    _sum?: SalaryPaymentSumOrderByAggregateInput
  }

  export type SalaryPaymentScalarWhereWithAggregatesInput = {
    AND?: SalaryPaymentScalarWhereWithAggregatesInput | SalaryPaymentScalarWhereWithAggregatesInput[]
    OR?: SalaryPaymentScalarWhereWithAggregatesInput[]
    NOT?: SalaryPaymentScalarWhereWithAggregatesInput | SalaryPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalaryPayment"> | number
    salaryId?: IntWithAggregatesFilter<"SalaryPayment"> | number
    amount?: FloatWithAggregatesFilter<"SalaryPayment"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"SalaryPayment"> | Date | string
    comment?: StringNullableWithAggregatesFilter<"SalaryPayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalaryPayment"> | Date | string
    currency?: StringWithAggregatesFilter<"SalaryPayment"> | string
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    id?: IntFilter<"Section"> | number
    name?: StringFilter<"Section"> | string
    description?: StringNullableFilter<"Section"> | string | null
    slug?: StringFilter<"Section"> | string
    isActive?: BoolFilter<"Section"> | boolean
    order?: IntFilter<"Section"> | number
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
    Table?: TableListRelationFilter
  }

  export type SectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Table?: TableOrderByRelationAggregateInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    name?: StringFilter<"Section"> | string
    description?: StringNullableFilter<"Section"> | string | null
    isActive?: BoolFilter<"Section"> | boolean
    order?: IntFilter<"Section"> | number
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
    Table?: TableListRelationFilter
  }, "id" | "slug">

  export type SectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectionCountOrderByAggregateInput
    _avg?: SectionAvgOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
    _sum?: SectionSumOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Section"> | number
    name?: StringWithAggregatesFilter<"Section"> | string
    description?: StringNullableWithAggregatesFilter<"Section"> | string | null
    slug?: StringWithAggregatesFilter<"Section"> | string
    isActive?: BoolWithAggregatesFilter<"Section"> | boolean
    order?: IntWithAggregatesFilter<"Section"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
  }

  export type ShiftReportWhereInput = {
    AND?: ShiftReportWhereInput | ShiftReportWhereInput[]
    OR?: ShiftReportWhereInput[]
    NOT?: ShiftReportWhereInput | ShiftReportWhereInput[]
    id?: IntFilter<"ShiftReport"> | number
    date?: DateTimeFilter<"ShiftReport"> | Date | string
    time?: StringFilter<"ShiftReport"> | string
    shift?: StringFilter<"ShiftReport"> | string
    startBalance?: FloatFilter<"ShiftReport"> | number
    endBalance?: FloatFilter<"ShiftReport"> | number
    employeeId?: IntNullableFilter<"ShiftReport"> | number | null
    usdtAmount?: FloatFilter<"ShiftReport"> | number
    currency?: StringFilter<"ShiftReport"> | string
    comment?: StringNullableFilter<"ShiftReport"> | string | null
    createdAt?: DateTimeFilter<"ShiftReport"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftReport"> | Date | string
    Salary?: XOR<SalaryNullableScalarRelationFilter, SalaryWhereInput> | null
    ShiftReportExpense?: ShiftReportExpenseListRelationFilter
  }

  export type ShiftReportOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    shift?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    usdtAmount?: SortOrder
    currency?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Salary?: SalaryOrderByWithRelationInput
    ShiftReportExpense?: ShiftReportExpenseOrderByRelationAggregateInput
  }

  export type ShiftReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ShiftReportWhereInput | ShiftReportWhereInput[]
    OR?: ShiftReportWhereInput[]
    NOT?: ShiftReportWhereInput | ShiftReportWhereInput[]
    date?: DateTimeFilter<"ShiftReport"> | Date | string
    time?: StringFilter<"ShiftReport"> | string
    shift?: StringFilter<"ShiftReport"> | string
    startBalance?: FloatFilter<"ShiftReport"> | number
    endBalance?: FloatFilter<"ShiftReport"> | number
    employeeId?: IntNullableFilter<"ShiftReport"> | number | null
    usdtAmount?: FloatFilter<"ShiftReport"> | number
    currency?: StringFilter<"ShiftReport"> | string
    comment?: StringNullableFilter<"ShiftReport"> | string | null
    createdAt?: DateTimeFilter<"ShiftReport"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftReport"> | Date | string
    Salary?: XOR<SalaryNullableScalarRelationFilter, SalaryWhereInput> | null
    ShiftReportExpense?: ShiftReportExpenseListRelationFilter
  }, "id">

  export type ShiftReportOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    shift?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    usdtAmount?: SortOrder
    currency?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftReportCountOrderByAggregateInput
    _avg?: ShiftReportAvgOrderByAggregateInput
    _max?: ShiftReportMaxOrderByAggregateInput
    _min?: ShiftReportMinOrderByAggregateInput
    _sum?: ShiftReportSumOrderByAggregateInput
  }

  export type ShiftReportScalarWhereWithAggregatesInput = {
    AND?: ShiftReportScalarWhereWithAggregatesInput | ShiftReportScalarWhereWithAggregatesInput[]
    OR?: ShiftReportScalarWhereWithAggregatesInput[]
    NOT?: ShiftReportScalarWhereWithAggregatesInput | ShiftReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ShiftReport"> | number
    date?: DateTimeWithAggregatesFilter<"ShiftReport"> | Date | string
    time?: StringWithAggregatesFilter<"ShiftReport"> | string
    shift?: StringWithAggregatesFilter<"ShiftReport"> | string
    startBalance?: FloatWithAggregatesFilter<"ShiftReport"> | number
    endBalance?: FloatWithAggregatesFilter<"ShiftReport"> | number
    employeeId?: IntNullableWithAggregatesFilter<"ShiftReport"> | number | null
    usdtAmount?: FloatWithAggregatesFilter<"ShiftReport"> | number
    currency?: StringWithAggregatesFilter<"ShiftReport"> | string
    comment?: StringNullableWithAggregatesFilter<"ShiftReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShiftReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShiftReport"> | Date | string
  }

  export type ShiftReportExpenseWhereInput = {
    AND?: ShiftReportExpenseWhereInput | ShiftReportExpenseWhereInput[]
    OR?: ShiftReportExpenseWhereInput[]
    NOT?: ShiftReportExpenseWhereInput | ShiftReportExpenseWhereInput[]
    id?: IntFilter<"ShiftReportExpense"> | number
    shiftReportId?: IntNullableFilter<"ShiftReportExpense"> | number | null
    expenseType?: StringFilter<"ShiftReportExpense"> | string
    amount?: FloatFilter<"ShiftReportExpense"> | number
    currency?: StringFilter<"ShiftReportExpense"> | string
    date?: DateTimeFilter<"ShiftReportExpense"> | Date | string
    time?: StringFilter<"ShiftReportExpense"> | string
    period?: StringNullableFilter<"ShiftReportExpense"> | string | null
    description?: StringNullableFilter<"ShiftReportExpense"> | string | null
    createdAt?: DateTimeFilter<"ShiftReportExpense"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftReportExpense"> | Date | string
    ShiftReport?: XOR<ShiftReportNullableScalarRelationFilter, ShiftReportWhereInput> | null
  }

  export type ShiftReportExpenseOrderByWithRelationInput = {
    id?: SortOrder
    shiftReportId?: SortOrderInput | SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    time?: SortOrder
    period?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ShiftReport?: ShiftReportOrderByWithRelationInput
  }

  export type ShiftReportExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ShiftReportExpenseWhereInput | ShiftReportExpenseWhereInput[]
    OR?: ShiftReportExpenseWhereInput[]
    NOT?: ShiftReportExpenseWhereInput | ShiftReportExpenseWhereInput[]
    shiftReportId?: IntNullableFilter<"ShiftReportExpense"> | number | null
    expenseType?: StringFilter<"ShiftReportExpense"> | string
    amount?: FloatFilter<"ShiftReportExpense"> | number
    currency?: StringFilter<"ShiftReportExpense"> | string
    date?: DateTimeFilter<"ShiftReportExpense"> | Date | string
    time?: StringFilter<"ShiftReportExpense"> | string
    period?: StringNullableFilter<"ShiftReportExpense"> | string | null
    description?: StringNullableFilter<"ShiftReportExpense"> | string | null
    createdAt?: DateTimeFilter<"ShiftReportExpense"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftReportExpense"> | Date | string
    ShiftReport?: XOR<ShiftReportNullableScalarRelationFilter, ShiftReportWhereInput> | null
  }, "id">

  export type ShiftReportExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    shiftReportId?: SortOrderInput | SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    time?: SortOrder
    period?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftReportExpenseCountOrderByAggregateInput
    _avg?: ShiftReportExpenseAvgOrderByAggregateInput
    _max?: ShiftReportExpenseMaxOrderByAggregateInput
    _min?: ShiftReportExpenseMinOrderByAggregateInput
    _sum?: ShiftReportExpenseSumOrderByAggregateInput
  }

  export type ShiftReportExpenseScalarWhereWithAggregatesInput = {
    AND?: ShiftReportExpenseScalarWhereWithAggregatesInput | ShiftReportExpenseScalarWhereWithAggregatesInput[]
    OR?: ShiftReportExpenseScalarWhereWithAggregatesInput[]
    NOT?: ShiftReportExpenseScalarWhereWithAggregatesInput | ShiftReportExpenseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ShiftReportExpense"> | number
    shiftReportId?: IntNullableWithAggregatesFilter<"ShiftReportExpense"> | number | null
    expenseType?: StringWithAggregatesFilter<"ShiftReportExpense"> | string
    amount?: FloatWithAggregatesFilter<"ShiftReportExpense"> | number
    currency?: StringWithAggregatesFilter<"ShiftReportExpense"> | string
    date?: DateTimeWithAggregatesFilter<"ShiftReportExpense"> | Date | string
    time?: StringWithAggregatesFilter<"ShiftReportExpense"> | string
    period?: StringNullableWithAggregatesFilter<"ShiftReportExpense"> | string | null
    description?: StringNullableWithAggregatesFilter<"ShiftReportExpense"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShiftReportExpense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShiftReportExpense"> | Date | string
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: IntFilter<"SystemSettings"> | number
    reportReminderInterval?: IntFilter<"SystemSettings"> | number
    reportWaitTime?: IntFilter<"SystemSettings"> | number
    createdAt?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    reportReminderInterval?: SortOrder
    reportWaitTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    reportReminderInterval?: IntFilter<"SystemSettings"> | number
    reportWaitTime?: IntFilter<"SystemSettings"> | number
    createdAt?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }, "id">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    reportReminderInterval?: SortOrder
    reportWaitTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _avg?: SystemSettingsAvgOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
    _sum?: SystemSettingsSumOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemSettings"> | number
    reportReminderInterval?: IntWithAggregatesFilter<"SystemSettings"> | number
    reportWaitTime?: IntWithAggregatesFilter<"SystemSettings"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
  }

  export type TableWhereInput = {
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    id?: IntFilter<"Table"> | number
    name?: StringFilter<"Table"> | string
    description?: StringNullableFilter<"Table"> | string | null
    sectionId?: IntFilter<"Table"> | number
    isSearchable?: BoolFilter<"Table"> | boolean
    hasPagination?: BoolFilter<"Table"> | boolean
    pageSize?: IntFilter<"Table"> | number
    order?: IntFilter<"Table"> | number
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
    Column?: ColumnListRelationFilter
    Filter?: FilterListRelationFilter
    Row?: RowListRelationFilter
    Section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }

  export type TableOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sectionId?: SortOrder
    isSearchable?: SortOrder
    hasPagination?: SortOrder
    pageSize?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Column?: ColumnOrderByRelationAggregateInput
    Filter?: FilterOrderByRelationAggregateInput
    Row?: RowOrderByRelationAggregateInput
    Section?: SectionOrderByWithRelationInput
  }

  export type TableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    name?: StringFilter<"Table"> | string
    description?: StringNullableFilter<"Table"> | string | null
    sectionId?: IntFilter<"Table"> | number
    isSearchable?: BoolFilter<"Table"> | boolean
    hasPagination?: BoolFilter<"Table"> | boolean
    pageSize?: IntFilter<"Table"> | number
    order?: IntFilter<"Table"> | number
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
    Column?: ColumnListRelationFilter
    Filter?: FilterListRelationFilter
    Row?: RowListRelationFilter
    Section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }, "id">

  export type TableOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sectionId?: SortOrder
    isSearchable?: SortOrder
    hasPagination?: SortOrder
    pageSize?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TableCountOrderByAggregateInput
    _avg?: TableAvgOrderByAggregateInput
    _max?: TableMaxOrderByAggregateInput
    _min?: TableMinOrderByAggregateInput
    _sum?: TableSumOrderByAggregateInput
  }

  export type TableScalarWhereWithAggregatesInput = {
    AND?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    OR?: TableScalarWhereWithAggregatesInput[]
    NOT?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Table"> | number
    name?: StringWithAggregatesFilter<"Table"> | string
    description?: StringNullableWithAggregatesFilter<"Table"> | string | null
    sectionId?: IntWithAggregatesFilter<"Table"> | number
    isSearchable?: BoolWithAggregatesFilter<"Table"> | boolean
    hasPagination?: BoolWithAggregatesFilter<"Table"> | boolean
    pageSize?: IntWithAggregatesFilter<"Table"> | number
    order?: IntWithAggregatesFilter<"Table"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Table"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Table"> | Date | string
  }

  export type TelegramAccountWhereInput = {
    AND?: TelegramAccountWhereInput | TelegramAccountWhereInput[]
    OR?: TelegramAccountWhereInput[]
    NOT?: TelegramAccountWhereInput | TelegramAccountWhereInput[]
    id?: IntFilter<"TelegramAccount"> | number
    telegramId?: StringFilter<"TelegramAccount"> | string
    username?: StringNullableFilter<"TelegramAccount"> | string | null
    firstName?: StringNullableFilter<"TelegramAccount"> | string | null
    lastName?: StringNullableFilter<"TelegramAccount"> | string | null
    userId?: IntFilter<"TelegramAccount"> | number
    createdAt?: DateTimeFilter<"TelegramAccount"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramAccount"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TelegramAccountOrderByWithRelationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type TelegramAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    telegramId?: string
    AND?: TelegramAccountWhereInput | TelegramAccountWhereInput[]
    OR?: TelegramAccountWhereInput[]
    NOT?: TelegramAccountWhereInput | TelegramAccountWhereInput[]
    username?: StringNullableFilter<"TelegramAccount"> | string | null
    firstName?: StringNullableFilter<"TelegramAccount"> | string | null
    lastName?: StringNullableFilter<"TelegramAccount"> | string | null
    userId?: IntFilter<"TelegramAccount"> | number
    createdAt?: DateTimeFilter<"TelegramAccount"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramAccount"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "telegramId">

  export type TelegramAccountOrderByWithAggregationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TelegramAccountCountOrderByAggregateInput
    _avg?: TelegramAccountAvgOrderByAggregateInput
    _max?: TelegramAccountMaxOrderByAggregateInput
    _min?: TelegramAccountMinOrderByAggregateInput
    _sum?: TelegramAccountSumOrderByAggregateInput
  }

  export type TelegramAccountScalarWhereWithAggregatesInput = {
    AND?: TelegramAccountScalarWhereWithAggregatesInput | TelegramAccountScalarWhereWithAggregatesInput[]
    OR?: TelegramAccountScalarWhereWithAggregatesInput[]
    NOT?: TelegramAccountScalarWhereWithAggregatesInput | TelegramAccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TelegramAccount"> | number
    telegramId?: StringWithAggregatesFilter<"TelegramAccount"> | string
    username?: StringNullableWithAggregatesFilter<"TelegramAccount"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"TelegramAccount"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"TelegramAccount"> | string | null
    userId?: IntWithAggregatesFilter<"TelegramAccount"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TelegramAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TelegramAccount"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    externalId?: StringNullableFilter<"Transaction"> | string | null
    orderNo?: StringNullableFilter<"Transaction"> | string | null
    dateTime?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    asset?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    totalPrice?: FloatFilter<"Transaction"> | number
    unitPrice?: FloatFilter<"Transaction"> | number
    counterparty?: StringNullableFilter<"Transaction"> | string | null
    status?: StringFilter<"Transaction"> | string
    originalData?: JsonNullableFilter<"Transaction">
    userId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    Match?: MatchListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    dateTime?: SortOrder
    type?: SortOrder
    asset?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
    counterparty?: SortOrderInput | SortOrder
    status?: SortOrder
    originalData?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Match?: MatchOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    externalId_userId?: TransactionExternalIdUserIdCompoundUniqueInput
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    externalId?: StringNullableFilter<"Transaction"> | string | null
    orderNo?: StringNullableFilter<"Transaction"> | string | null
    dateTime?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    asset?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    totalPrice?: FloatFilter<"Transaction"> | number
    unitPrice?: FloatFilter<"Transaction"> | number
    counterparty?: StringNullableFilter<"Transaction"> | string | null
    status?: StringFilter<"Transaction"> | string
    originalData?: JsonNullableFilter<"Transaction">
    userId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    Match?: MatchListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "externalId_userId">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    dateTime?: SortOrder
    type?: SortOrder
    asset?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
    counterparty?: SortOrderInput | SortOrder
    status?: SortOrder
    originalData?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    externalId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    orderNo?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    dateTime?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    type?: StringWithAggregatesFilter<"Transaction"> | string
    asset?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    totalPrice?: FloatWithAggregatesFilter<"Transaction"> | number
    unitPrice?: FloatWithAggregatesFilter<"Transaction"> | number
    counterparty?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    status?: StringWithAggregatesFilter<"Transaction"> | string
    originalData?: JsonNullableWithAggregatesFilter<"Transaction">
    userId?: IntWithAggregatesFilter<"Transaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    passCode?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastNotification?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    bybitApiSecret?: StringNullableFilter<"User"> | string | null
    bybitApiToken?: StringNullableFilter<"User"> | string | null
    lastBybitSyncAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastBybitSyncStatus?: StringNullableFilter<"User"> | string | null
    AuditLog?: AuditLogListRelationFilter
    BybitClipMatch?: BybitClipMatchListRelationFilter
    BybitTransaction?: BybitTransactionListRelationFilter
    MatchBybitReport?: MatchBybitReportListRelationFilter
    MatchViresReport?: MatchViresReportListRelationFilter
    ReportNotification?: ReportNotificationListRelationFilter
    TelegramAccount?: TelegramAccountListRelationFilter
    Transaction?: TransactionListRelationFilter
    ViresCabinet?: ViresCabinetListRelationFilter
    ViresClipMatch?: ViresClipMatchListRelationFilter
    WorkSession?: WorkSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    passCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastNotification?: SortOrderInput | SortOrder
    role?: SortOrder
    bybitApiSecret?: SortOrderInput | SortOrder
    bybitApiToken?: SortOrderInput | SortOrder
    lastBybitSyncAt?: SortOrderInput | SortOrder
    lastBybitSyncStatus?: SortOrderInput | SortOrder
    AuditLog?: AuditLogOrderByRelationAggregateInput
    BybitClipMatch?: BybitClipMatchOrderByRelationAggregateInput
    BybitTransaction?: BybitTransactionOrderByRelationAggregateInput
    MatchBybitReport?: MatchBybitReportOrderByRelationAggregateInput
    MatchViresReport?: MatchViresReportOrderByRelationAggregateInput
    ReportNotification?: ReportNotificationOrderByRelationAggregateInput
    TelegramAccount?: TelegramAccountOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
    ViresCabinet?: ViresCabinetOrderByRelationAggregateInput
    ViresClipMatch?: ViresClipMatchOrderByRelationAggregateInput
    WorkSession?: WorkSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    passCode?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastNotification?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    bybitApiSecret?: StringNullableFilter<"User"> | string | null
    bybitApiToken?: StringNullableFilter<"User"> | string | null
    lastBybitSyncAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastBybitSyncStatus?: StringNullableFilter<"User"> | string | null
    AuditLog?: AuditLogListRelationFilter
    BybitClipMatch?: BybitClipMatchListRelationFilter
    BybitTransaction?: BybitTransactionListRelationFilter
    MatchBybitReport?: MatchBybitReportListRelationFilter
    MatchViresReport?: MatchViresReportListRelationFilter
    ReportNotification?: ReportNotificationListRelationFilter
    TelegramAccount?: TelegramAccountListRelationFilter
    Transaction?: TransactionListRelationFilter
    ViresCabinet?: ViresCabinetListRelationFilter
    ViresClipMatch?: ViresClipMatchListRelationFilter
    WorkSession?: WorkSessionListRelationFilter
  }, "id" | "passCode">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    passCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastNotification?: SortOrderInput | SortOrder
    role?: SortOrder
    bybitApiSecret?: SortOrderInput | SortOrder
    bybitApiToken?: SortOrderInput | SortOrder
    lastBybitSyncAt?: SortOrderInput | SortOrder
    lastBybitSyncStatus?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    passCode?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastNotification?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    bybitApiSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    bybitApiToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastBybitSyncAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastBybitSyncStatus?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type WorkSessionWhereInput = {
    AND?: WorkSessionWhereInput | WorkSessionWhereInput[]
    OR?: WorkSessionWhereInput[]
    NOT?: WorkSessionWhereInput | WorkSessionWhereInput[]
    id?: IntFilter<"WorkSession"> | number
    startTime?: DateTimeFilter<"WorkSession"> | Date | string
    endTime?: DateTimeNullableFilter<"WorkSession"> | Date | string | null
    duration?: IntNullableFilter<"WorkSession"> | number | null
    autoCompleted?: BoolFilter<"WorkSession"> | boolean
    userId?: IntFilter<"WorkSession"> | number
    createdAt?: DateTimeFilter<"WorkSession"> | Date | string
    updatedAt?: DateTimeFilter<"WorkSession"> | Date | string
    comment?: StringNullableFilter<"WorkSession"> | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetListRelationFilter
  }

  export type WorkSessionOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    autoCompleted?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetOrderByRelationAggregateInput
  }

  export type WorkSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorkSessionWhereInput | WorkSessionWhereInput[]
    OR?: WorkSessionWhereInput[]
    NOT?: WorkSessionWhereInput | WorkSessionWhereInput[]
    startTime?: DateTimeFilter<"WorkSession"> | Date | string
    endTime?: DateTimeNullableFilter<"WorkSession"> | Date | string | null
    duration?: IntNullableFilter<"WorkSession"> | number | null
    autoCompleted?: BoolFilter<"WorkSession"> | boolean
    userId?: IntFilter<"WorkSession"> | number
    createdAt?: DateTimeFilter<"WorkSession"> | Date | string
    updatedAt?: DateTimeFilter<"WorkSession"> | Date | string
    comment?: StringNullableFilter<"WorkSession"> | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetListRelationFilter
  }, "id">

  export type WorkSessionOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    autoCompleted?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: WorkSessionCountOrderByAggregateInput
    _avg?: WorkSessionAvgOrderByAggregateInput
    _max?: WorkSessionMaxOrderByAggregateInput
    _min?: WorkSessionMinOrderByAggregateInput
    _sum?: WorkSessionSumOrderByAggregateInput
  }

  export type WorkSessionScalarWhereWithAggregatesInput = {
    AND?: WorkSessionScalarWhereWithAggregatesInput | WorkSessionScalarWhereWithAggregatesInput[]
    OR?: WorkSessionScalarWhereWithAggregatesInput[]
    NOT?: WorkSessionScalarWhereWithAggregatesInput | WorkSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkSession"> | number
    startTime?: DateTimeWithAggregatesFilter<"WorkSession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"WorkSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"WorkSession"> | number | null
    autoCompleted?: BoolWithAggregatesFilter<"WorkSession"> | boolean
    userId?: IntWithAggregatesFilter<"WorkSession"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkSession"> | Date | string
    comment?: StringNullableWithAggregatesFilter<"WorkSession"> | string | null
  }

  export type WorkSessionIdexCabinetWhereInput = {
    AND?: WorkSessionIdexCabinetWhereInput | WorkSessionIdexCabinetWhereInput[]
    OR?: WorkSessionIdexCabinetWhereInput[]
    NOT?: WorkSessionIdexCabinetWhereInput | WorkSessionIdexCabinetWhereInput[]
    workSessionId?: IntFilter<"WorkSessionIdexCabinet"> | number
    idexCabinetId?: IntFilter<"WorkSessionIdexCabinet"> | number
    assignedAt?: DateTimeFilter<"WorkSessionIdexCabinet"> | Date | string
    IdexCabinet?: XOR<IdexCabinetScalarRelationFilter, IdexCabinetWhereInput>
    WorkSession?: XOR<WorkSessionScalarRelationFilter, WorkSessionWhereInput>
  }

  export type WorkSessionIdexCabinetOrderByWithRelationInput = {
    workSessionId?: SortOrder
    idexCabinetId?: SortOrder
    assignedAt?: SortOrder
    IdexCabinet?: IdexCabinetOrderByWithRelationInput
    WorkSession?: WorkSessionOrderByWithRelationInput
  }

  export type WorkSessionIdexCabinetWhereUniqueInput = Prisma.AtLeast<{
    workSessionId_idexCabinetId?: WorkSessionIdexCabinetWorkSessionIdIdexCabinetIdCompoundUniqueInput
    AND?: WorkSessionIdexCabinetWhereInput | WorkSessionIdexCabinetWhereInput[]
    OR?: WorkSessionIdexCabinetWhereInput[]
    NOT?: WorkSessionIdexCabinetWhereInput | WorkSessionIdexCabinetWhereInput[]
    workSessionId?: IntFilter<"WorkSessionIdexCabinet"> | number
    idexCabinetId?: IntFilter<"WorkSessionIdexCabinet"> | number
    assignedAt?: DateTimeFilter<"WorkSessionIdexCabinet"> | Date | string
    IdexCabinet?: XOR<IdexCabinetScalarRelationFilter, IdexCabinetWhereInput>
    WorkSession?: XOR<WorkSessionScalarRelationFilter, WorkSessionWhereInput>
  }, "workSessionId_idexCabinetId">

  export type WorkSessionIdexCabinetOrderByWithAggregationInput = {
    workSessionId?: SortOrder
    idexCabinetId?: SortOrder
    assignedAt?: SortOrder
    _count?: WorkSessionIdexCabinetCountOrderByAggregateInput
    _avg?: WorkSessionIdexCabinetAvgOrderByAggregateInput
    _max?: WorkSessionIdexCabinetMaxOrderByAggregateInput
    _min?: WorkSessionIdexCabinetMinOrderByAggregateInput
    _sum?: WorkSessionIdexCabinetSumOrderByAggregateInput
  }

  export type WorkSessionIdexCabinetScalarWhereWithAggregatesInput = {
    AND?: WorkSessionIdexCabinetScalarWhereWithAggregatesInput | WorkSessionIdexCabinetScalarWhereWithAggregatesInput[]
    OR?: WorkSessionIdexCabinetScalarWhereWithAggregatesInput[]
    NOT?: WorkSessionIdexCabinetScalarWhereWithAggregatesInput | WorkSessionIdexCabinetScalarWhereWithAggregatesInput[]
    workSessionId?: IntWithAggregatesFilter<"WorkSessionIdexCabinet"> | number
    idexCabinetId?: IntWithAggregatesFilter<"WorkSessionIdexCabinet"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"WorkSessionIdexCabinet"> | Date | string
  }

  export type BybitCabinetWhereInput = {
    AND?: BybitCabinetWhereInput | BybitCabinetWhereInput[]
    OR?: BybitCabinetWhereInput[]
    NOT?: BybitCabinetWhereInput | BybitCabinetWhereInput[]
    id?: IntFilter<"BybitCabinet"> | number
    createdAt?: DateTimeFilter<"BybitCabinet"> | Date | string
    updatedAt?: DateTimeFilter<"BybitCabinet"> | Date | string
    bybitEmail?: StringFilter<"BybitCabinet"> | string
    bybitApiSecret?: StringNullableFilter<"BybitCabinet"> | string | null
    bybitApiToken?: StringNullableFilter<"BybitCabinet"> | string | null
    lastBybitSyncAt?: DateTimeNullableFilter<"BybitCabinet"> | Date | string | null
    lastBybitSyncStatus?: StringNullableFilter<"BybitCabinet"> | string | null
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetListRelationFilter
    BybitOrderInfo?: BybitOrderInfoListRelationFilter
  }

  export type BybitCabinetOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bybitEmail?: SortOrder
    bybitApiSecret?: SortOrderInput | SortOrder
    bybitApiToken?: SortOrderInput | SortOrder
    lastBybitSyncAt?: SortOrderInput | SortOrder
    lastBybitSyncStatus?: SortOrderInput | SortOrder
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetOrderByRelationAggregateInput
    BybitOrderInfo?: BybitOrderInfoOrderByRelationAggregateInput
  }

  export type BybitCabinetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BybitCabinetWhereInput | BybitCabinetWhereInput[]
    OR?: BybitCabinetWhereInput[]
    NOT?: BybitCabinetWhereInput | BybitCabinetWhereInput[]
    createdAt?: DateTimeFilter<"BybitCabinet"> | Date | string
    updatedAt?: DateTimeFilter<"BybitCabinet"> | Date | string
    bybitEmail?: StringFilter<"BybitCabinet"> | string
    bybitApiSecret?: StringNullableFilter<"BybitCabinet"> | string | null
    bybitApiToken?: StringNullableFilter<"BybitCabinet"> | string | null
    lastBybitSyncAt?: DateTimeNullableFilter<"BybitCabinet"> | Date | string | null
    lastBybitSyncStatus?: StringNullableFilter<"BybitCabinet"> | string | null
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetListRelationFilter
    BybitOrderInfo?: BybitOrderInfoListRelationFilter
  }, "id">

  export type BybitCabinetOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bybitEmail?: SortOrder
    bybitApiSecret?: SortOrderInput | SortOrder
    bybitApiToken?: SortOrderInput | SortOrder
    lastBybitSyncAt?: SortOrderInput | SortOrder
    lastBybitSyncStatus?: SortOrderInput | SortOrder
    _count?: BybitCabinetCountOrderByAggregateInput
    _avg?: BybitCabinetAvgOrderByAggregateInput
    _max?: BybitCabinetMaxOrderByAggregateInput
    _min?: BybitCabinetMinOrderByAggregateInput
    _sum?: BybitCabinetSumOrderByAggregateInput
  }

  export type BybitCabinetScalarWhereWithAggregatesInput = {
    AND?: BybitCabinetScalarWhereWithAggregatesInput | BybitCabinetScalarWhereWithAggregatesInput[]
    OR?: BybitCabinetScalarWhereWithAggregatesInput[]
    NOT?: BybitCabinetScalarWhereWithAggregatesInput | BybitCabinetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BybitCabinet"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BybitCabinet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BybitCabinet"> | Date | string
    bybitEmail?: StringWithAggregatesFilter<"BybitCabinet"> | string
    bybitApiSecret?: StringNullableWithAggregatesFilter<"BybitCabinet"> | string | null
    bybitApiToken?: StringNullableWithAggregatesFilter<"BybitCabinet"> | string | null
    lastBybitSyncAt?: DateTimeNullableWithAggregatesFilter<"BybitCabinet"> | Date | string | null
    lastBybitSyncStatus?: StringNullableWithAggregatesFilter<"BybitCabinet"> | string | null
  }

  export type BybitClipMatchWhereInput = {
    AND?: BybitClipMatchWhereInput | BybitClipMatchWhereInput[]
    OR?: BybitClipMatchWhereInput[]
    NOT?: BybitClipMatchWhereInput | BybitClipMatchWhereInput[]
    id?: IntFilter<"BybitClipMatch"> | number
    idexTransactionId?: IntFilter<"BybitClipMatch"> | number
    bybitTransactionId?: IntFilter<"BybitClipMatch"> | number
    timeDifference?: IntFilter<"BybitClipMatch"> | number
    grossExpense?: FloatFilter<"BybitClipMatch"> | number
    grossIncome?: FloatFilter<"BybitClipMatch"> | number
    grossProfit?: FloatFilter<"BybitClipMatch"> | number
    profitPercentage?: FloatFilter<"BybitClipMatch"> | number
    createdAt?: DateTimeFilter<"BybitClipMatch"> | Date | string
    updatedAt?: DateTimeFilter<"BybitClipMatch"> | Date | string
    matchBybitReportId?: IntNullableFilter<"BybitClipMatch"> | number | null
    userId?: IntFilter<"BybitClipMatch"> | number
    BybitTransactionFromCabinet?: XOR<BybitTransactionFromCabinetScalarRelationFilter, BybitTransactionFromCabinetWhereInput>
    IdexTransaction?: XOR<IdexTransactionScalarRelationFilter, IdexTransactionWhereInput>
    MatchBybitReport?: XOR<MatchBybitReportNullableScalarRelationFilter, MatchBybitReportWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BybitClipMatchOrderByWithRelationInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchBybitReportId?: SortOrderInput | SortOrder
    userId?: SortOrder
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetOrderByWithRelationInput
    IdexTransaction?: IdexTransactionOrderByWithRelationInput
    MatchBybitReport?: MatchBybitReportOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type BybitClipMatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BybitClipMatchWhereInput | BybitClipMatchWhereInput[]
    OR?: BybitClipMatchWhereInput[]
    NOT?: BybitClipMatchWhereInput | BybitClipMatchWhereInput[]
    idexTransactionId?: IntFilter<"BybitClipMatch"> | number
    bybitTransactionId?: IntFilter<"BybitClipMatch"> | number
    timeDifference?: IntFilter<"BybitClipMatch"> | number
    grossExpense?: FloatFilter<"BybitClipMatch"> | number
    grossIncome?: FloatFilter<"BybitClipMatch"> | number
    grossProfit?: FloatFilter<"BybitClipMatch"> | number
    profitPercentage?: FloatFilter<"BybitClipMatch"> | number
    createdAt?: DateTimeFilter<"BybitClipMatch"> | Date | string
    updatedAt?: DateTimeFilter<"BybitClipMatch"> | Date | string
    matchBybitReportId?: IntNullableFilter<"BybitClipMatch"> | number | null
    userId?: IntFilter<"BybitClipMatch"> | number
    BybitTransactionFromCabinet?: XOR<BybitTransactionFromCabinetScalarRelationFilter, BybitTransactionFromCabinetWhereInput>
    IdexTransaction?: XOR<IdexTransactionScalarRelationFilter, IdexTransactionWhereInput>
    MatchBybitReport?: XOR<MatchBybitReportNullableScalarRelationFilter, MatchBybitReportWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BybitClipMatchOrderByWithAggregationInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchBybitReportId?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: BybitClipMatchCountOrderByAggregateInput
    _avg?: BybitClipMatchAvgOrderByAggregateInput
    _max?: BybitClipMatchMaxOrderByAggregateInput
    _min?: BybitClipMatchMinOrderByAggregateInput
    _sum?: BybitClipMatchSumOrderByAggregateInput
  }

  export type BybitClipMatchScalarWhereWithAggregatesInput = {
    AND?: BybitClipMatchScalarWhereWithAggregatesInput | BybitClipMatchScalarWhereWithAggregatesInput[]
    OR?: BybitClipMatchScalarWhereWithAggregatesInput[]
    NOT?: BybitClipMatchScalarWhereWithAggregatesInput | BybitClipMatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BybitClipMatch"> | number
    idexTransactionId?: IntWithAggregatesFilter<"BybitClipMatch"> | number
    bybitTransactionId?: IntWithAggregatesFilter<"BybitClipMatch"> | number
    timeDifference?: IntWithAggregatesFilter<"BybitClipMatch"> | number
    grossExpense?: FloatWithAggregatesFilter<"BybitClipMatch"> | number
    grossIncome?: FloatWithAggregatesFilter<"BybitClipMatch"> | number
    grossProfit?: FloatWithAggregatesFilter<"BybitClipMatch"> | number
    profitPercentage?: FloatWithAggregatesFilter<"BybitClipMatch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BybitClipMatch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BybitClipMatch"> | Date | string
    matchBybitReportId?: IntNullableWithAggregatesFilter<"BybitClipMatch"> | number | null
    userId?: IntWithAggregatesFilter<"BybitClipMatch"> | number
  }

  export type BybitTransactionFromCabinetWhereInput = {
    AND?: BybitTransactionFromCabinetWhereInput | BybitTransactionFromCabinetWhereInput[]
    OR?: BybitTransactionFromCabinetWhereInput[]
    NOT?: BybitTransactionFromCabinetWhereInput | BybitTransactionFromCabinetWhereInput[]
    id?: IntFilter<"BybitTransactionFromCabinet"> | number
    orderNo?: StringFilter<"BybitTransactionFromCabinet"> | string
    counterparty?: StringNullableFilter<"BybitTransactionFromCabinet"> | string | null
    status?: StringFilter<"BybitTransactionFromCabinet"> | string
    createdAt?: DateTimeFilter<"BybitTransactionFromCabinet"> | Date | string
    updatedAt?: DateTimeFilter<"BybitTransactionFromCabinet"> | Date | string
    amount?: FloatFilter<"BybitTransactionFromCabinet"> | number
    asset?: StringFilter<"BybitTransactionFromCabinet"> | string
    dateTime?: DateTimeFilter<"BybitTransactionFromCabinet"> | Date | string
    originalData?: JsonNullableFilter<"BybitTransactionFromCabinet">
    totalPrice?: FloatFilter<"BybitTransactionFromCabinet"> | number
    type?: StringFilter<"BybitTransactionFromCabinet"> | string
    unitPrice?: FloatFilter<"BybitTransactionFromCabinet"> | number
    processed?: BoolFilter<"BybitTransactionFromCabinet"> | boolean
    extractedPhones?: StringNullableListFilter<"BybitTransactionFromCabinet">
    lastAttemptError?: StringNullableFilter<"BybitTransactionFromCabinet"> | string | null
    cabinetId?: IntFilter<"BybitTransactionFromCabinet"> | number
    BybitClipMatch?: BybitClipMatchListRelationFilter
    BybitCabinet?: XOR<BybitCabinetScalarRelationFilter, BybitCabinetWhereInput>
    ViresClipMatch?: ViresClipMatchListRelationFilter
  }

  export type BybitTransactionFromCabinetOrderByWithRelationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    counterparty?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    amount?: SortOrder
    asset?: SortOrder
    dateTime?: SortOrder
    originalData?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    type?: SortOrder
    unitPrice?: SortOrder
    processed?: SortOrder
    extractedPhones?: SortOrder
    lastAttemptError?: SortOrderInput | SortOrder
    cabinetId?: SortOrder
    BybitClipMatch?: BybitClipMatchOrderByRelationAggregateInput
    BybitCabinet?: BybitCabinetOrderByWithRelationInput
    ViresClipMatch?: ViresClipMatchOrderByRelationAggregateInput
  }

  export type BybitTransactionFromCabinetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderNo?: string
    AND?: BybitTransactionFromCabinetWhereInput | BybitTransactionFromCabinetWhereInput[]
    OR?: BybitTransactionFromCabinetWhereInput[]
    NOT?: BybitTransactionFromCabinetWhereInput | BybitTransactionFromCabinetWhereInput[]
    counterparty?: StringNullableFilter<"BybitTransactionFromCabinet"> | string | null
    status?: StringFilter<"BybitTransactionFromCabinet"> | string
    createdAt?: DateTimeFilter<"BybitTransactionFromCabinet"> | Date | string
    updatedAt?: DateTimeFilter<"BybitTransactionFromCabinet"> | Date | string
    amount?: FloatFilter<"BybitTransactionFromCabinet"> | number
    asset?: StringFilter<"BybitTransactionFromCabinet"> | string
    dateTime?: DateTimeFilter<"BybitTransactionFromCabinet"> | Date | string
    originalData?: JsonNullableFilter<"BybitTransactionFromCabinet">
    totalPrice?: FloatFilter<"BybitTransactionFromCabinet"> | number
    type?: StringFilter<"BybitTransactionFromCabinet"> | string
    unitPrice?: FloatFilter<"BybitTransactionFromCabinet"> | number
    processed?: BoolFilter<"BybitTransactionFromCabinet"> | boolean
    extractedPhones?: StringNullableListFilter<"BybitTransactionFromCabinet">
    lastAttemptError?: StringNullableFilter<"BybitTransactionFromCabinet"> | string | null
    cabinetId?: IntFilter<"BybitTransactionFromCabinet"> | number
    BybitClipMatch?: BybitClipMatchListRelationFilter
    BybitCabinet?: XOR<BybitCabinetScalarRelationFilter, BybitCabinetWhereInput>
    ViresClipMatch?: ViresClipMatchListRelationFilter
  }, "id" | "orderNo">

  export type BybitTransactionFromCabinetOrderByWithAggregationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    counterparty?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    amount?: SortOrder
    asset?: SortOrder
    dateTime?: SortOrder
    originalData?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    type?: SortOrder
    unitPrice?: SortOrder
    processed?: SortOrder
    extractedPhones?: SortOrder
    lastAttemptError?: SortOrderInput | SortOrder
    cabinetId?: SortOrder
    _count?: BybitTransactionFromCabinetCountOrderByAggregateInput
    _avg?: BybitTransactionFromCabinetAvgOrderByAggregateInput
    _max?: BybitTransactionFromCabinetMaxOrderByAggregateInput
    _min?: BybitTransactionFromCabinetMinOrderByAggregateInput
    _sum?: BybitTransactionFromCabinetSumOrderByAggregateInput
  }

  export type BybitTransactionFromCabinetScalarWhereWithAggregatesInput = {
    AND?: BybitTransactionFromCabinetScalarWhereWithAggregatesInput | BybitTransactionFromCabinetScalarWhereWithAggregatesInput[]
    OR?: BybitTransactionFromCabinetScalarWhereWithAggregatesInput[]
    NOT?: BybitTransactionFromCabinetScalarWhereWithAggregatesInput | BybitTransactionFromCabinetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BybitTransactionFromCabinet"> | number
    orderNo?: StringWithAggregatesFilter<"BybitTransactionFromCabinet"> | string
    counterparty?: StringNullableWithAggregatesFilter<"BybitTransactionFromCabinet"> | string | null
    status?: StringWithAggregatesFilter<"BybitTransactionFromCabinet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BybitTransactionFromCabinet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BybitTransactionFromCabinet"> | Date | string
    amount?: FloatWithAggregatesFilter<"BybitTransactionFromCabinet"> | number
    asset?: StringWithAggregatesFilter<"BybitTransactionFromCabinet"> | string
    dateTime?: DateTimeWithAggregatesFilter<"BybitTransactionFromCabinet"> | Date | string
    originalData?: JsonNullableWithAggregatesFilter<"BybitTransactionFromCabinet">
    totalPrice?: FloatWithAggregatesFilter<"BybitTransactionFromCabinet"> | number
    type?: StringWithAggregatesFilter<"BybitTransactionFromCabinet"> | string
    unitPrice?: FloatWithAggregatesFilter<"BybitTransactionFromCabinet"> | number
    processed?: BoolWithAggregatesFilter<"BybitTransactionFromCabinet"> | boolean
    extractedPhones?: StringNullableListFilter<"BybitTransactionFromCabinet">
    lastAttemptError?: StringNullableWithAggregatesFilter<"BybitTransactionFromCabinet"> | string | null
    cabinetId?: IntWithAggregatesFilter<"BybitTransactionFromCabinet"> | number
  }

  export type MatchBybitReportWhereInput = {
    AND?: MatchBybitReportWhereInput | MatchBybitReportWhereInput[]
    OR?: MatchBybitReportWhereInput[]
    NOT?: MatchBybitReportWhereInput | MatchBybitReportWhereInput[]
    id?: IntFilter<"MatchBybitReport"> | number
    reportDate?: DateTimeFilter<"MatchBybitReport"> | Date | string
    totalMatches?: IntFilter<"MatchBybitReport"> | number
    totalProfit?: FloatFilter<"MatchBybitReport"> | number
    averageProfit?: FloatFilter<"MatchBybitReport"> | number
    successRate?: FloatFilter<"MatchBybitReport"> | number
    timeRangeStart?: DateTimeFilter<"MatchBybitReport"> | Date | string
    timeRangeEnd?: DateTimeFilter<"MatchBybitReport"> | Date | string
    notes?: StringNullableFilter<"MatchBybitReport"> | string | null
    idexCabinets?: JsonNullableFilter<"MatchBybitReport">
    createdAt?: DateTimeFilter<"MatchBybitReport"> | Date | string
    updatedAt?: DateTimeFilter<"MatchBybitReport"> | Date | string
    userId?: IntFilter<"MatchBybitReport"> | number
    BybitClipMatch?: BybitClipMatchListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MatchBybitReportOrderByWithRelationInput = {
    id?: SortOrder
    reportDate?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    timeRangeStart?: SortOrder
    timeRangeEnd?: SortOrder
    notes?: SortOrderInput | SortOrder
    idexCabinets?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    BybitClipMatch?: BybitClipMatchOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type MatchBybitReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MatchBybitReportWhereInput | MatchBybitReportWhereInput[]
    OR?: MatchBybitReportWhereInput[]
    NOT?: MatchBybitReportWhereInput | MatchBybitReportWhereInput[]
    reportDate?: DateTimeFilter<"MatchBybitReport"> | Date | string
    totalMatches?: IntFilter<"MatchBybitReport"> | number
    totalProfit?: FloatFilter<"MatchBybitReport"> | number
    averageProfit?: FloatFilter<"MatchBybitReport"> | number
    successRate?: FloatFilter<"MatchBybitReport"> | number
    timeRangeStart?: DateTimeFilter<"MatchBybitReport"> | Date | string
    timeRangeEnd?: DateTimeFilter<"MatchBybitReport"> | Date | string
    notes?: StringNullableFilter<"MatchBybitReport"> | string | null
    idexCabinets?: JsonNullableFilter<"MatchBybitReport">
    createdAt?: DateTimeFilter<"MatchBybitReport"> | Date | string
    updatedAt?: DateTimeFilter<"MatchBybitReport"> | Date | string
    userId?: IntFilter<"MatchBybitReport"> | number
    BybitClipMatch?: BybitClipMatchListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MatchBybitReportOrderByWithAggregationInput = {
    id?: SortOrder
    reportDate?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    timeRangeStart?: SortOrder
    timeRangeEnd?: SortOrder
    notes?: SortOrderInput | SortOrder
    idexCabinets?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: MatchBybitReportCountOrderByAggregateInput
    _avg?: MatchBybitReportAvgOrderByAggregateInput
    _max?: MatchBybitReportMaxOrderByAggregateInput
    _min?: MatchBybitReportMinOrderByAggregateInput
    _sum?: MatchBybitReportSumOrderByAggregateInput
  }

  export type MatchBybitReportScalarWhereWithAggregatesInput = {
    AND?: MatchBybitReportScalarWhereWithAggregatesInput | MatchBybitReportScalarWhereWithAggregatesInput[]
    OR?: MatchBybitReportScalarWhereWithAggregatesInput[]
    NOT?: MatchBybitReportScalarWhereWithAggregatesInput | MatchBybitReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MatchBybitReport"> | number
    reportDate?: DateTimeWithAggregatesFilter<"MatchBybitReport"> | Date | string
    totalMatches?: IntWithAggregatesFilter<"MatchBybitReport"> | number
    totalProfit?: FloatWithAggregatesFilter<"MatchBybitReport"> | number
    averageProfit?: FloatWithAggregatesFilter<"MatchBybitReport"> | number
    successRate?: FloatWithAggregatesFilter<"MatchBybitReport"> | number
    timeRangeStart?: DateTimeWithAggregatesFilter<"MatchBybitReport"> | Date | string
    timeRangeEnd?: DateTimeWithAggregatesFilter<"MatchBybitReport"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"MatchBybitReport"> | string | null
    idexCabinets?: JsonNullableWithAggregatesFilter<"MatchBybitReport">
    createdAt?: DateTimeWithAggregatesFilter<"MatchBybitReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MatchBybitReport"> | Date | string
    userId?: IntWithAggregatesFilter<"MatchBybitReport"> | number
  }

  export type MatchViresReportWhereInput = {
    AND?: MatchViresReportWhereInput | MatchViresReportWhereInput[]
    OR?: MatchViresReportWhereInput[]
    NOT?: MatchViresReportWhereInput | MatchViresReportWhereInput[]
    id?: IntFilter<"MatchViresReport"> | number
    reportDate?: DateTimeFilter<"MatchViresReport"> | Date | string
    totalMatches?: IntFilter<"MatchViresReport"> | number
    totalProfit?: FloatFilter<"MatchViresReport"> | number
    averageProfit?: FloatFilter<"MatchViresReport"> | number
    successRate?: FloatFilter<"MatchViresReport"> | number
    timeRangeStart?: DateTimeFilter<"MatchViresReport"> | Date | string
    timeRangeEnd?: DateTimeFilter<"MatchViresReport"> | Date | string
    notes?: StringNullableFilter<"MatchViresReport"> | string | null
    idexCabinets?: JsonNullableFilter<"MatchViresReport">
    createdAt?: DateTimeFilter<"MatchViresReport"> | Date | string
    updatedAt?: DateTimeFilter<"MatchViresReport"> | Date | string
    userId?: IntFilter<"MatchViresReport"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    ViresClipMatch?: ViresClipMatchListRelationFilter
  }

  export type MatchViresReportOrderByWithRelationInput = {
    id?: SortOrder
    reportDate?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    timeRangeStart?: SortOrder
    timeRangeEnd?: SortOrder
    notes?: SortOrderInput | SortOrder
    idexCabinets?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    User?: UserOrderByWithRelationInput
    ViresClipMatch?: ViresClipMatchOrderByRelationAggregateInput
  }

  export type MatchViresReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MatchViresReportWhereInput | MatchViresReportWhereInput[]
    OR?: MatchViresReportWhereInput[]
    NOT?: MatchViresReportWhereInput | MatchViresReportWhereInput[]
    reportDate?: DateTimeFilter<"MatchViresReport"> | Date | string
    totalMatches?: IntFilter<"MatchViresReport"> | number
    totalProfit?: FloatFilter<"MatchViresReport"> | number
    averageProfit?: FloatFilter<"MatchViresReport"> | number
    successRate?: FloatFilter<"MatchViresReport"> | number
    timeRangeStart?: DateTimeFilter<"MatchViresReport"> | Date | string
    timeRangeEnd?: DateTimeFilter<"MatchViresReport"> | Date | string
    notes?: StringNullableFilter<"MatchViresReport"> | string | null
    idexCabinets?: JsonNullableFilter<"MatchViresReport">
    createdAt?: DateTimeFilter<"MatchViresReport"> | Date | string
    updatedAt?: DateTimeFilter<"MatchViresReport"> | Date | string
    userId?: IntFilter<"MatchViresReport"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    ViresClipMatch?: ViresClipMatchListRelationFilter
  }, "id">

  export type MatchViresReportOrderByWithAggregationInput = {
    id?: SortOrder
    reportDate?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    timeRangeStart?: SortOrder
    timeRangeEnd?: SortOrder
    notes?: SortOrderInput | SortOrder
    idexCabinets?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: MatchViresReportCountOrderByAggregateInput
    _avg?: MatchViresReportAvgOrderByAggregateInput
    _max?: MatchViresReportMaxOrderByAggregateInput
    _min?: MatchViresReportMinOrderByAggregateInput
    _sum?: MatchViresReportSumOrderByAggregateInput
  }

  export type MatchViresReportScalarWhereWithAggregatesInput = {
    AND?: MatchViresReportScalarWhereWithAggregatesInput | MatchViresReportScalarWhereWithAggregatesInput[]
    OR?: MatchViresReportScalarWhereWithAggregatesInput[]
    NOT?: MatchViresReportScalarWhereWithAggregatesInput | MatchViresReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MatchViresReport"> | number
    reportDate?: DateTimeWithAggregatesFilter<"MatchViresReport"> | Date | string
    totalMatches?: IntWithAggregatesFilter<"MatchViresReport"> | number
    totalProfit?: FloatWithAggregatesFilter<"MatchViresReport"> | number
    averageProfit?: FloatWithAggregatesFilter<"MatchViresReport"> | number
    successRate?: FloatWithAggregatesFilter<"MatchViresReport"> | number
    timeRangeStart?: DateTimeWithAggregatesFilter<"MatchViresReport"> | Date | string
    timeRangeEnd?: DateTimeWithAggregatesFilter<"MatchViresReport"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"MatchViresReport"> | string | null
    idexCabinets?: JsonNullableWithAggregatesFilter<"MatchViresReport">
    createdAt?: DateTimeWithAggregatesFilter<"MatchViresReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MatchViresReport"> | Date | string
    userId?: IntWithAggregatesFilter<"MatchViresReport"> | number
  }

  export type ViresCabinetWhereInput = {
    AND?: ViresCabinetWhereInput | ViresCabinetWhereInput[]
    OR?: ViresCabinetWhereInput[]
    NOT?: ViresCabinetWhereInput | ViresCabinetWhereInput[]
    id?: IntFilter<"ViresCabinet"> | number
    name?: StringNullableFilter<"ViresCabinet"> | string | null
    login?: StringFilter<"ViresCabinet"> | string
    password?: StringFilter<"ViresCabinet"> | string
    type?: EnumPasswordTypeFilter<"ViresCabinet"> | $Enums.PasswordType
    createdAt?: DateTimeFilter<"ViresCabinet"> | Date | string
    updatedAt?: DateTimeFilter<"ViresCabinet"> | Date | string
    comment?: StringNullableFilter<"ViresCabinet"> | string | null
    userId?: IntFilter<"ViresCabinet"> | number
    lastUpdate?: DateTimeFilter<"ViresCabinet"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    ViresTransactionPayin?: ViresTransactionPayinListRelationFilter
  }

  export type ViresCabinetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    login?: SortOrder
    password?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrderInput | SortOrder
    userId?: SortOrder
    lastUpdate?: SortOrder
    User?: UserOrderByWithRelationInput
    ViresTransactionPayin?: ViresTransactionPayinOrderByRelationAggregateInput
  }

  export type ViresCabinetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ViresCabinetWhereInput | ViresCabinetWhereInput[]
    OR?: ViresCabinetWhereInput[]
    NOT?: ViresCabinetWhereInput | ViresCabinetWhereInput[]
    name?: StringNullableFilter<"ViresCabinet"> | string | null
    login?: StringFilter<"ViresCabinet"> | string
    password?: StringFilter<"ViresCabinet"> | string
    type?: EnumPasswordTypeFilter<"ViresCabinet"> | $Enums.PasswordType
    createdAt?: DateTimeFilter<"ViresCabinet"> | Date | string
    updatedAt?: DateTimeFilter<"ViresCabinet"> | Date | string
    comment?: StringNullableFilter<"ViresCabinet"> | string | null
    userId?: IntFilter<"ViresCabinet"> | number
    lastUpdate?: DateTimeFilter<"ViresCabinet"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    ViresTransactionPayin?: ViresTransactionPayinListRelationFilter
  }, "id">

  export type ViresCabinetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    login?: SortOrder
    password?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrderInput | SortOrder
    userId?: SortOrder
    lastUpdate?: SortOrder
    _count?: ViresCabinetCountOrderByAggregateInput
    _avg?: ViresCabinetAvgOrderByAggregateInput
    _max?: ViresCabinetMaxOrderByAggregateInput
    _min?: ViresCabinetMinOrderByAggregateInput
    _sum?: ViresCabinetSumOrderByAggregateInput
  }

  export type ViresCabinetScalarWhereWithAggregatesInput = {
    AND?: ViresCabinetScalarWhereWithAggregatesInput | ViresCabinetScalarWhereWithAggregatesInput[]
    OR?: ViresCabinetScalarWhereWithAggregatesInput[]
    NOT?: ViresCabinetScalarWhereWithAggregatesInput | ViresCabinetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ViresCabinet"> | number
    name?: StringNullableWithAggregatesFilter<"ViresCabinet"> | string | null
    login?: StringWithAggregatesFilter<"ViresCabinet"> | string
    password?: StringWithAggregatesFilter<"ViresCabinet"> | string
    type?: EnumPasswordTypeWithAggregatesFilter<"ViresCabinet"> | $Enums.PasswordType
    createdAt?: DateTimeWithAggregatesFilter<"ViresCabinet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ViresCabinet"> | Date | string
    comment?: StringNullableWithAggregatesFilter<"ViresCabinet"> | string | null
    userId?: IntWithAggregatesFilter<"ViresCabinet"> | number
    lastUpdate?: DateTimeWithAggregatesFilter<"ViresCabinet"> | Date | string
  }

  export type ViresClipMatchWhereInput = {
    AND?: ViresClipMatchWhereInput | ViresClipMatchWhereInput[]
    OR?: ViresClipMatchWhereInput[]
    NOT?: ViresClipMatchWhereInput | ViresClipMatchWhereInput[]
    id?: IntFilter<"ViresClipMatch"> | number
    viresTransactionId?: IntFilter<"ViresClipMatch"> | number
    timeDifference?: IntFilter<"ViresClipMatch"> | number
    grossExpense?: FloatFilter<"ViresClipMatch"> | number
    grossIncome?: FloatFilter<"ViresClipMatch"> | number
    grossProfit?: FloatFilter<"ViresClipMatch"> | number
    profitPercentage?: FloatFilter<"ViresClipMatch"> | number
    createdAt?: DateTimeFilter<"ViresClipMatch"> | Date | string
    updatedAt?: DateTimeFilter<"ViresClipMatch"> | Date | string
    matchViresReportId?: IntNullableFilter<"ViresClipMatch"> | number | null
    userId?: IntFilter<"ViresClipMatch"> | number
    bybitTransactionId?: IntFilter<"ViresClipMatch"> | number
    BybitTransactionFromCabinet?: XOR<BybitTransactionFromCabinetScalarRelationFilter, BybitTransactionFromCabinetWhereInput>
    MatchViresReport?: XOR<MatchViresReportNullableScalarRelationFilter, MatchViresReportWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    ViresTransactionPayin?: XOR<ViresTransactionPayinScalarRelationFilter, ViresTransactionPayinWhereInput>
  }

  export type ViresClipMatchOrderByWithRelationInput = {
    id?: SortOrder
    viresTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchViresReportId?: SortOrderInput | SortOrder
    userId?: SortOrder
    bybitTransactionId?: SortOrder
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetOrderByWithRelationInput
    MatchViresReport?: MatchViresReportOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    ViresTransactionPayin?: ViresTransactionPayinOrderByWithRelationInput
  }

  export type ViresClipMatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ViresClipMatchWhereInput | ViresClipMatchWhereInput[]
    OR?: ViresClipMatchWhereInput[]
    NOT?: ViresClipMatchWhereInput | ViresClipMatchWhereInput[]
    viresTransactionId?: IntFilter<"ViresClipMatch"> | number
    timeDifference?: IntFilter<"ViresClipMatch"> | number
    grossExpense?: FloatFilter<"ViresClipMatch"> | number
    grossIncome?: FloatFilter<"ViresClipMatch"> | number
    grossProfit?: FloatFilter<"ViresClipMatch"> | number
    profitPercentage?: FloatFilter<"ViresClipMatch"> | number
    createdAt?: DateTimeFilter<"ViresClipMatch"> | Date | string
    updatedAt?: DateTimeFilter<"ViresClipMatch"> | Date | string
    matchViresReportId?: IntNullableFilter<"ViresClipMatch"> | number | null
    userId?: IntFilter<"ViresClipMatch"> | number
    bybitTransactionId?: IntFilter<"ViresClipMatch"> | number
    BybitTransactionFromCabinet?: XOR<BybitTransactionFromCabinetScalarRelationFilter, BybitTransactionFromCabinetWhereInput>
    MatchViresReport?: XOR<MatchViresReportNullableScalarRelationFilter, MatchViresReportWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    ViresTransactionPayin?: XOR<ViresTransactionPayinScalarRelationFilter, ViresTransactionPayinWhereInput>
  }, "id">

  export type ViresClipMatchOrderByWithAggregationInput = {
    id?: SortOrder
    viresTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchViresReportId?: SortOrderInput | SortOrder
    userId?: SortOrder
    bybitTransactionId?: SortOrder
    _count?: ViresClipMatchCountOrderByAggregateInput
    _avg?: ViresClipMatchAvgOrderByAggregateInput
    _max?: ViresClipMatchMaxOrderByAggregateInput
    _min?: ViresClipMatchMinOrderByAggregateInput
    _sum?: ViresClipMatchSumOrderByAggregateInput
  }

  export type ViresClipMatchScalarWhereWithAggregatesInput = {
    AND?: ViresClipMatchScalarWhereWithAggregatesInput | ViresClipMatchScalarWhereWithAggregatesInput[]
    OR?: ViresClipMatchScalarWhereWithAggregatesInput[]
    NOT?: ViresClipMatchScalarWhereWithAggregatesInput | ViresClipMatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ViresClipMatch"> | number
    viresTransactionId?: IntWithAggregatesFilter<"ViresClipMatch"> | number
    timeDifference?: IntWithAggregatesFilter<"ViresClipMatch"> | number
    grossExpense?: FloatWithAggregatesFilter<"ViresClipMatch"> | number
    grossIncome?: FloatWithAggregatesFilter<"ViresClipMatch"> | number
    grossProfit?: FloatWithAggregatesFilter<"ViresClipMatch"> | number
    profitPercentage?: FloatWithAggregatesFilter<"ViresClipMatch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ViresClipMatch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ViresClipMatch"> | Date | string
    matchViresReportId?: IntNullableWithAggregatesFilter<"ViresClipMatch"> | number | null
    userId?: IntWithAggregatesFilter<"ViresClipMatch"> | number
    bybitTransactionId?: IntWithAggregatesFilter<"ViresClipMatch"> | number
  }

  export type ViresTransactionPayinWhereInput = {
    AND?: ViresTransactionPayinWhereInput | ViresTransactionPayinWhereInput[]
    OR?: ViresTransactionPayinWhereInput[]
    NOT?: ViresTransactionPayinWhereInput | ViresTransactionPayinWhereInput[]
    id?: IntFilter<"ViresTransactionPayin"> | number
    cabinetId?: IntFilter<"ViresTransactionPayin"> | number
    createdAt?: DateTimeFilter<"ViresTransactionPayin"> | Date | string
    sum_rub?: FloatFilter<"ViresTransactionPayin"> | number
    sum_usdt?: FloatFilter<"ViresTransactionPayin"> | number
    card?: StringFilter<"ViresTransactionPayin"> | string
    fio?: StringFilter<"ViresTransactionPayin"> | string
    bank?: StringFilter<"ViresTransactionPayin"> | string
    uuid?: StringFilter<"ViresTransactionPayin"> | string
    ViresClipMatch?: ViresClipMatchListRelationFilter
    ViresCabinet?: XOR<ViresCabinetScalarRelationFilter, ViresCabinetWhereInput>
  }

  export type ViresTransactionPayinOrderByWithRelationInput = {
    id?: SortOrder
    cabinetId?: SortOrder
    createdAt?: SortOrder
    sum_rub?: SortOrder
    sum_usdt?: SortOrder
    card?: SortOrder
    fio?: SortOrder
    bank?: SortOrder
    uuid?: SortOrder
    ViresClipMatch?: ViresClipMatchOrderByRelationAggregateInput
    ViresCabinet?: ViresCabinetOrderByWithRelationInput
  }

  export type ViresTransactionPayinWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ViresTransactionPayinWhereInput | ViresTransactionPayinWhereInput[]
    OR?: ViresTransactionPayinWhereInput[]
    NOT?: ViresTransactionPayinWhereInput | ViresTransactionPayinWhereInput[]
    cabinetId?: IntFilter<"ViresTransactionPayin"> | number
    createdAt?: DateTimeFilter<"ViresTransactionPayin"> | Date | string
    sum_rub?: FloatFilter<"ViresTransactionPayin"> | number
    sum_usdt?: FloatFilter<"ViresTransactionPayin"> | number
    card?: StringFilter<"ViresTransactionPayin"> | string
    fio?: StringFilter<"ViresTransactionPayin"> | string
    bank?: StringFilter<"ViresTransactionPayin"> | string
    ViresClipMatch?: ViresClipMatchListRelationFilter
    ViresCabinet?: XOR<ViresCabinetScalarRelationFilter, ViresCabinetWhereInput>
  }, "id" | "uuid">

  export type ViresTransactionPayinOrderByWithAggregationInput = {
    id?: SortOrder
    cabinetId?: SortOrder
    createdAt?: SortOrder
    sum_rub?: SortOrder
    sum_usdt?: SortOrder
    card?: SortOrder
    fio?: SortOrder
    bank?: SortOrder
    uuid?: SortOrder
    _count?: ViresTransactionPayinCountOrderByAggregateInput
    _avg?: ViresTransactionPayinAvgOrderByAggregateInput
    _max?: ViresTransactionPayinMaxOrderByAggregateInput
    _min?: ViresTransactionPayinMinOrderByAggregateInput
    _sum?: ViresTransactionPayinSumOrderByAggregateInput
  }

  export type ViresTransactionPayinScalarWhereWithAggregatesInput = {
    AND?: ViresTransactionPayinScalarWhereWithAggregatesInput | ViresTransactionPayinScalarWhereWithAggregatesInput[]
    OR?: ViresTransactionPayinScalarWhereWithAggregatesInput[]
    NOT?: ViresTransactionPayinScalarWhereWithAggregatesInput | ViresTransactionPayinScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ViresTransactionPayin"> | number
    cabinetId?: IntWithAggregatesFilter<"ViresTransactionPayin"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ViresTransactionPayin"> | Date | string
    sum_rub?: FloatWithAggregatesFilter<"ViresTransactionPayin"> | number
    sum_usdt?: FloatWithAggregatesFilter<"ViresTransactionPayin"> | number
    card?: StringWithAggregatesFilter<"ViresTransactionPayin"> | string
    fio?: StringWithAggregatesFilter<"ViresTransactionPayin"> | string
    bank?: StringWithAggregatesFilter<"ViresTransactionPayin"> | string
    uuid?: StringWithAggregatesFilter<"ViresTransactionPayin"> | string
  }

  export type AdminCreateInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AdminUpdateInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    CardBalance?: CardBalanceCreateNestedOneWithoutAuditLogInput
    Card?: CardCreateNestedOneWithoutAuditLogInput
    CardPouring?: CardPouringCreateNestedOneWithoutAuditLogInput
    User: UserCreateNestedOneWithoutAuditLogInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    userId: number
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: number | null
    cardId?: number | null
    cardPouringId?: number | null
  }

  export type AuditLogUpdateInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    CardBalance?: CardBalanceUpdateOneWithoutAuditLogNestedInput
    Card?: CardUpdateOneWithoutAuditLogNestedInput
    CardPouring?: CardPouringUpdateOneWithoutAuditLogNestedInput
    User?: UserUpdateOneRequiredWithoutAuditLogNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: NullableIntFieldUpdateOperationsInput | number | null
    cardId?: NullableIntFieldUpdateOperationsInput | number | null
    cardPouringId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditLogCreateManyInput = {
    id?: number
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    userId: number
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: number | null
    cardId?: number | null
    cardPouringId?: number | null
  }

  export type AuditLogUpdateManyMutationInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: NullableIntFieldUpdateOperationsInput | number | null
    cardId?: NullableIntFieldUpdateOperationsInput | number | null
    cardPouringId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BalanceEntryCreateInput = {
    date: Date | string
    time: string
    amount: number
    currency?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    section?: $Enums.SalarySection
  }

  export type BalanceEntryUncheckedCreateInput = {
    id?: number
    date: Date | string
    time: string
    amount: number
    currency?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    section?: $Enums.SalarySection
  }

  export type BalanceEntryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type BalanceEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type BalanceEntryCreateManyInput = {
    id?: number
    date: Date | string
    time: string
    amount: number
    currency?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    section?: $Enums.SalarySection
  }

  export type BalanceEntryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type BalanceEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type BybitMatchCreateInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitTransaction: BybitTransactionCreateNestedOneWithoutBybitMatchInput
    IdexTransaction: IdexTransactionCreateNestedOneWithoutBybitMatchInput
  }

  export type BybitMatchUncheckedCreateInput = {
    id?: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BybitMatchUpdateInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitTransaction?: BybitTransactionUpdateOneRequiredWithoutBybitMatchNestedInput
    IdexTransaction?: IdexTransactionUpdateOneRequiredWithoutBybitMatchNestedInput
  }

  export type BybitMatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BybitMatchCreateManyInput = {
    id?: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BybitMatchUpdateManyMutationInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BybitMatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BybitOrderInfoCreateInput = {
    phoneNumbers?: BybitOrderInfoCreatephoneNumbersInput | string[]
    createdAt?: Date | string
    updatedAt: Date | string
    orderNo: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status: string
    type: string
    amount: number
    totalPrice: number
    processed?: boolean
    unitPrice: number
    cabinet: BybitCabinetCreateNestedOneWithoutBybitOrderInfoInput
  }

  export type BybitOrderInfoUncheckedCreateInput = {
    id?: number
    phoneNumbers?: BybitOrderInfoCreatephoneNumbersInput | string[]
    createdAt?: Date | string
    updatedAt: Date | string
    orderNo: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status: string
    type: string
    amount: number
    totalPrice: number
    processed?: boolean
    unitPrice: number
    bybitCabinetId: number
  }

  export type BybitOrderInfoUpdateInput = {
    phoneNumbers?: BybitOrderInfoUpdatephoneNumbersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNo?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: FloatFieldUpdateOperationsInput | number
    cabinet?: BybitCabinetUpdateOneRequiredWithoutBybitOrderInfoNestedInput
  }

  export type BybitOrderInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    phoneNumbers?: BybitOrderInfoUpdatephoneNumbersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNo?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: FloatFieldUpdateOperationsInput | number
    bybitCabinetId?: IntFieldUpdateOperationsInput | number
  }

  export type BybitOrderInfoCreateManyInput = {
    id?: number
    phoneNumbers?: BybitOrderInfoCreatephoneNumbersInput | string[]
    createdAt?: Date | string
    updatedAt: Date | string
    orderNo: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status: string
    type: string
    amount: number
    totalPrice: number
    processed?: boolean
    unitPrice: number
    bybitCabinetId: number
  }

  export type BybitOrderInfoUpdateManyMutationInput = {
    phoneNumbers?: BybitOrderInfoUpdatephoneNumbersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNo?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type BybitOrderInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    phoneNumbers?: BybitOrderInfoUpdatephoneNumbersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNo?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: FloatFieldUpdateOperationsInput | number
    bybitCabinetId?: IntFieldUpdateOperationsInput | number
  }

  export type BybitTransactionCreateInput = {
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    bybitMatch?: BybitMatchCreateNestedManyWithoutBybitTransactionInput
    user: UserCreateNestedOneWithoutBybitTransactionInput
  }

  export type BybitTransactionUncheckedCreateInput = {
    id?: number
    orderNo: string
    counterparty?: string | null
    status: string
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    bybitMatch?: BybitMatchUncheckedCreateNestedManyWithoutBybitTransactionInput
  }

  export type BybitTransactionUpdateInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    bybitMatch?: BybitMatchUpdateManyWithoutBybitTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutBybitTransactionNestedInput
  }

  export type BybitTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    bybitMatch?: BybitMatchUncheckedUpdateManyWithoutBybitTransactionNestedInput
  }

  export type BybitTransactionCreateManyInput = {
    id?: number
    orderNo: string
    counterparty?: string | null
    status: string
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
  }

  export type BybitTransactionUpdateManyMutationInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BybitTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardCreateInput = {
    externalId: number
    createdAt?: Date | string
    updatedAt: Date | string
    provider: string
    cardNumber: string
    bank: string
    phoneNumber: string
    appPin: number
    terminalPin: string
    comment?: string | null
    picachu?: string | null
    status?: $Enums.CardStatus
    cardPrice?: number | null
    isPaid?: boolean
    letterCode?: string | null
    actor?: string | null
    inWork?: boolean
    activePaymentMethod?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutCardInput
    CardBalance?: CardBalanceCreateNestedManyWithoutCardInput
    CardPouring?: CardPouringCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateInput = {
    id?: number
    externalId: number
    createdAt?: Date | string
    updatedAt: Date | string
    provider: string
    cardNumber: string
    bank: string
    phoneNumber: string
    appPin: number
    terminalPin: string
    comment?: string | null
    picachu?: string | null
    status?: $Enums.CardStatus
    cardPrice?: number | null
    isPaid?: boolean
    letterCode?: string | null
    actor?: string | null
    inWork?: boolean
    activePaymentMethod?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutCardInput
    CardBalance?: CardBalanceUncheckedCreateNestedManyWithoutCardInput
    CardPouring?: CardPouringUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardUpdateInput = {
    externalId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    appPin?: IntFieldUpdateOperationsInput | number
    terminalPin?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    picachu?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    cardPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    letterCode?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    inWork?: BoolFieldUpdateOperationsInput | boolean
    activePaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutCardNestedInput
    CardBalance?: CardBalanceUpdateManyWithoutCardNestedInput
    CardPouring?: CardPouringUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    appPin?: IntFieldUpdateOperationsInput | number
    terminalPin?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    picachu?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    cardPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    letterCode?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    inWork?: BoolFieldUpdateOperationsInput | boolean
    activePaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutCardNestedInput
    CardBalance?: CardBalanceUncheckedUpdateManyWithoutCardNestedInput
    CardPouring?: CardPouringUncheckedUpdateManyWithoutCardNestedInput
  }

  export type CardCreateManyInput = {
    id?: number
    externalId: number
    createdAt?: Date | string
    updatedAt: Date | string
    provider: string
    cardNumber: string
    bank: string
    phoneNumber: string
    appPin: number
    terminalPin: string
    comment?: string | null
    picachu?: string | null
    status?: $Enums.CardStatus
    cardPrice?: number | null
    isPaid?: boolean
    letterCode?: string | null
    actor?: string | null
    inWork?: boolean
    activePaymentMethod?: string | null
  }

  export type CardUpdateManyMutationInput = {
    externalId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    appPin?: IntFieldUpdateOperationsInput | number
    terminalPin?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    picachu?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    cardPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    letterCode?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    inWork?: BoolFieldUpdateOperationsInput | boolean
    activePaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    appPin?: IntFieldUpdateOperationsInput | number
    terminalPin?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    picachu?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    cardPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    letterCode?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    inWork?: BoolFieldUpdateOperationsInput | boolean
    activePaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardBalanceCreateInput = {
    date: Date | string
    startBalance: number
    endBalance: number
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutCardBalanceInput
    Card: CardCreateNestedOneWithoutCardBalanceInput
  }

  export type CardBalanceUncheckedCreateInput = {
    id?: number
    cardId: number
    date: Date | string
    startBalance: number
    endBalance: number
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutCardBalanceInput
  }

  export type CardBalanceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutCardBalanceNestedInput
    Card?: CardUpdateOneRequiredWithoutCardBalanceNestedInput
  }

  export type CardBalanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutCardBalanceNestedInput
  }

  export type CardBalanceCreateManyInput = {
    id?: number
    cardId: number
    date: Date | string
    startBalance: number
    endBalance: number
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
  }

  export type CardBalanceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardBalanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardPouringCreateInput = {
    pouringDate: Date | string
    initialAmount: number
    initialDate: Date | string
    finalAmount?: number | null
    finalDate?: Date | string | null
    pouringAmount: number
    withdrawalAmount?: number | null
    withdrawalDate?: Date | string | null
    collectorName?: string | null
    status?: $Enums.CardStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutCardPouringInput
    Card: CardCreateNestedOneWithoutCardPouringInput
  }

  export type CardPouringUncheckedCreateInput = {
    id?: number
    cardId: number
    pouringDate: Date | string
    initialAmount: number
    initialDate: Date | string
    finalAmount?: number | null
    finalDate?: Date | string | null
    pouringAmount: number
    withdrawalAmount?: number | null
    withdrawalDate?: Date | string | null
    collectorName?: string | null
    status?: $Enums.CardStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutCardPouringInput
  }

  export type CardPouringUpdateInput = {
    pouringDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: FloatFieldUpdateOperationsInput | number
    initialDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    finalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pouringAmount?: FloatFieldUpdateOperationsInput | number
    withdrawalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    withdrawalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutCardPouringNestedInput
    Card?: CardUpdateOneRequiredWithoutCardPouringNestedInput
  }

  export type CardPouringUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    pouringDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: FloatFieldUpdateOperationsInput | number
    initialDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    finalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pouringAmount?: FloatFieldUpdateOperationsInput | number
    withdrawalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    withdrawalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutCardPouringNestedInput
  }

  export type CardPouringCreateManyInput = {
    id?: number
    cardId: number
    pouringDate: Date | string
    initialAmount: number
    initialDate: Date | string
    finalAmount?: number | null
    finalDate?: Date | string | null
    pouringAmount: number
    withdrawalAmount?: number | null
    withdrawalDate?: Date | string | null
    collectorName?: string | null
    status?: $Enums.CardStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CardPouringUpdateManyMutationInput = {
    pouringDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: FloatFieldUpdateOperationsInput | number
    initialDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    finalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pouringAmount?: FloatFieldUpdateOperationsInput | number
    withdrawalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    withdrawalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardPouringUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    pouringDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: FloatFieldUpdateOperationsInput | number
    initialDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    finalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pouringAmount?: FloatFieldUpdateOperationsInput | number
    withdrawalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    withdrawalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CellCreateInput = {
    value?: string | null
    displayValue?: string | null
    calculatedValue?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Column: ColumnCreateNestedOneWithoutCellInput
    Row: RowCreateNestedOneWithoutCellInput
    Comment?: CommentCreateNestedManyWithoutCellInput
  }

  export type CellUncheckedCreateInput = {
    id?: number
    rowId: number
    columnId: number
    value?: string | null
    displayValue?: string | null
    calculatedValue?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Comment?: CommentUncheckedCreateNestedManyWithoutCellInput
  }

  export type CellUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUpdateOneRequiredWithoutCellNestedInput
    Row?: RowUpdateOneRequiredWithoutCellNestedInput
    Comment?: CommentUpdateManyWithoutCellNestedInput
  }

  export type CellUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rowId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUncheckedUpdateManyWithoutCellNestedInput
  }

  export type CellCreateManyInput = {
    id?: number
    rowId: number
    columnId: number
    value?: string | null
    displayValue?: string | null
    calculatedValue?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CellUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CellUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rowId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColumnCreateInput = {
    name: string
    type: $Enums.ColumnType
    width?: number | null
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: string | null
    format?: string | null
    order: number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    Cell?: CellCreateNestedManyWithoutColumnInput
    Table: TableCreateNestedOneWithoutColumnInput
    Filter?: FilterCreateNestedManyWithoutColumnInput
  }

  export type ColumnUncheckedCreateInput = {
    id?: number
    name: string
    type: $Enums.ColumnType
    tableId: number
    width?: number | null
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: string | null
    format?: string | null
    order: number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    Cell?: CellUncheckedCreateNestedManyWithoutColumnInput
    Filter?: FilterUncheckedCreateNestedManyWithoutColumnInput
  }

  export type ColumnUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    width?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    isSummable?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cell?: CellUpdateManyWithoutColumnNestedInput
    Table?: TableUpdateOneRequiredWithoutColumnNestedInput
    Filter?: FilterUpdateManyWithoutColumnNestedInput
  }

  export type ColumnUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    tableId?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    isSummable?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cell?: CellUncheckedUpdateManyWithoutColumnNestedInput
    Filter?: FilterUncheckedUpdateManyWithoutColumnNestedInput
  }

  export type ColumnCreateManyInput = {
    id?: number
    name: string
    type: $Enums.ColumnType
    tableId: number
    width?: number | null
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: string | null
    format?: string | null
    order: number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ColumnUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    width?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    isSummable?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColumnUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    tableId?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    isSummable?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    text: string
    author?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Cell: CellCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    cellId: number
    text: string
    author?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CommentUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cell?: CellUpdateOneRequiredWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cellId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: number
    cellId: number
    text: string
    author?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cellId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilterCreateInput = {
    name: string
    operator: $Enums.FilterOperator
    value?: string | null
    secondValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Column: ColumnCreateNestedOneWithoutFilterInput
    Table: TableCreateNestedOneWithoutFilterInput
  }

  export type FilterUncheckedCreateInput = {
    id?: number
    name: string
    tableId: number
    columnId: number
    operator: $Enums.FilterOperator
    value?: string | null
    secondValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type FilterUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    operator?: EnumFilterOperatorFieldUpdateOperationsInput | $Enums.FilterOperator
    value?: NullableStringFieldUpdateOperationsInput | string | null
    secondValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUpdateOneRequiredWithoutFilterNestedInput
    Table?: TableUpdateOneRequiredWithoutFilterNestedInput
  }

  export type FilterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    operator?: EnumFilterOperatorFieldUpdateOperationsInput | $Enums.FilterOperator
    value?: NullableStringFieldUpdateOperationsInput | string | null
    secondValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilterCreateManyInput = {
    id?: number
    name: string
    tableId: number
    columnId: number
    operator: $Enums.FilterOperator
    value?: string | null
    secondValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type FilterUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    operator?: EnumFilterOperatorFieldUpdateOperationsInput | $Enums.FilterOperator
    value?: NullableStringFieldUpdateOperationsInput | string | null
    secondValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    operator?: EnumFilterOperatorFieldUpdateOperationsInput | $Enums.FilterOperator
    value?: NullableStringFieldUpdateOperationsInput | string | null
    secondValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinRowCreateInput = {
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    usdtAmount?: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
    exchangeRate?: number | null
    Salary?: SalaryCreateNestedOneWithoutFinRowInput
    FinRowExpense?: FinRowExpenseCreateNestedManyWithoutFinRowInput
  }

  export type FinRowUncheckedCreateInput = {
    id?: number
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    employeeId?: number | null
    usdtAmount?: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
    exchangeRate?: number | null
    FinRowExpense?: FinRowExpenseUncheckedCreateNestedManyWithoutFinRowInput
  }

  export type FinRowUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Salary?: SalaryUpdateOneWithoutFinRowNestedInput
    FinRowExpense?: FinRowExpenseUpdateManyWithoutFinRowNestedInput
  }

  export type FinRowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    FinRowExpense?: FinRowExpenseUncheckedUpdateManyWithoutFinRowNestedInput
  }

  export type FinRowCreateManyInput = {
    id?: number
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    employeeId?: number | null
    usdtAmount?: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
    exchangeRate?: number | null
  }

  export type FinRowUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type FinRowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type FinRowExpenseCreateInput = {
    expenseType: string
    amount: number
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
    FinRow?: FinRowCreateNestedOneWithoutFinRowExpenseInput
  }

  export type FinRowExpenseUncheckedCreateInput = {
    id?: number
    finRowId?: number | null
    expenseType: string
    amount: number
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
  }

  export type FinRowExpenseUpdateInput = {
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    FinRow?: FinRowUpdateOneWithoutFinRowExpenseNestedInput
  }

  export type FinRowExpenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    finRowId?: NullableIntFieldUpdateOperationsInput | number | null
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type FinRowExpenseCreateManyInput = {
    id?: number
    finRowId?: number | null
    expenseType: string
    amount: number
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
  }

  export type FinRowExpenseUpdateManyMutationInput = {
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type FinRowExpenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    finRowId?: NullableIntFieldUpdateOperationsInput | number | null
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type IdexCabinetCreateInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    idexId: number
    login: string
    password: string
    IdexSyncOrder?: IdexSyncOrderCreateNestedManyWithoutIdexCabinetInput
    IdexTransaction?: IdexTransactionCreateNestedManyWithoutIdexCabinetInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetCreateNestedManyWithoutIdexCabinetInput
  }

  export type IdexCabinetUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    idexId: number
    login: string
    password: string
    IdexSyncOrder?: IdexSyncOrderUncheckedCreateNestedManyWithoutIdexCabinetInput
    IdexTransaction?: IdexTransactionUncheckedCreateNestedManyWithoutIdexCabinetInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUncheckedCreateNestedManyWithoutIdexCabinetInput
  }

  export type IdexCabinetUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idexId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    IdexSyncOrder?: IdexSyncOrderUpdateManyWithoutIdexCabinetNestedInput
    IdexTransaction?: IdexTransactionUpdateManyWithoutIdexCabinetNestedInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUpdateManyWithoutIdexCabinetNestedInput
  }

  export type IdexCabinetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idexId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    IdexSyncOrder?: IdexSyncOrderUncheckedUpdateManyWithoutIdexCabinetNestedInput
    IdexTransaction?: IdexTransactionUncheckedUpdateManyWithoutIdexCabinetNestedInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUncheckedUpdateManyWithoutIdexCabinetNestedInput
  }

  export type IdexCabinetCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    idexId: number
    login: string
    password: string
  }

  export type IdexCabinetUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idexId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type IdexCabinetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idexId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type IdexSyncOrderCreateInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    processed?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.IdexSyncOrderStatus
    startSyncAt?: Date | string | null
    endSyncAt?: Date | string | null
    pages?: IdexSyncOrderCreatepagesInput | number[]
    IdexCabinet?: IdexCabinetCreateNestedOneWithoutIdexSyncOrderInput
  }

  export type IdexSyncOrderUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    cabinetId?: number | null
    processed?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.IdexSyncOrderStatus
    startSyncAt?: Date | string | null
    endSyncAt?: Date | string | null
    pages?: IdexSyncOrderCreatepagesInput | number[]
  }

  export type IdexSyncOrderUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumIdexSyncOrderStatusFieldUpdateOperationsInput | $Enums.IdexSyncOrderStatus
    startSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: IdexSyncOrderUpdatepagesInput | number[]
    IdexCabinet?: IdexCabinetUpdateOneWithoutIdexSyncOrderNestedInput
  }

  export type IdexSyncOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinetId?: NullableIntFieldUpdateOperationsInput | number | null
    processed?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumIdexSyncOrderStatusFieldUpdateOperationsInput | $Enums.IdexSyncOrderStatus
    startSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: IdexSyncOrderUpdatepagesInput | number[]
  }

  export type IdexSyncOrderCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    cabinetId?: number | null
    processed?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.IdexSyncOrderStatus
    startSyncAt?: Date | string | null
    endSyncAt?: Date | string | null
    pages?: IdexSyncOrderCreatepagesInput | number[]
  }

  export type IdexSyncOrderUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumIdexSyncOrderStatusFieldUpdateOperationsInput | $Enums.IdexSyncOrderStatus
    startSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: IdexSyncOrderUpdatepagesInput | number[]
  }

  export type IdexSyncOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinetId?: NullableIntFieldUpdateOperationsInput | number | null
    processed?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumIdexSyncOrderStatusFieldUpdateOperationsInput | $Enums.IdexSyncOrderStatus
    startSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: IdexSyncOrderUpdatepagesInput | number[]
  }

  export type IdexTransactionCreateInput = {
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutIdexTransactionInput
    BybitMatch?: BybitMatchCreateNestedManyWithoutIdexTransactionInput
    IdexCabinet: IdexCabinetCreateNestedOneWithoutIdexTransactionInput
    Match?: MatchCreateNestedManyWithoutIdexTransactionInput
  }

  export type IdexTransactionUncheckedCreateInput = {
    id?: number
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    cabinetId: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutIdexTransactionInput
    BybitMatch?: BybitMatchUncheckedCreateNestedManyWithoutIdexTransactionInput
    Match?: MatchUncheckedCreateNestedManyWithoutIdexTransactionInput
  }

  export type IdexTransactionUpdateInput = {
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutIdexTransactionNestedInput
    BybitMatch?: BybitMatchUpdateManyWithoutIdexTransactionNestedInput
    IdexCabinet?: IdexCabinetUpdateOneRequiredWithoutIdexTransactionNestedInput
    Match?: MatchUpdateManyWithoutIdexTransactionNestedInput
  }

  export type IdexTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    cabinetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
    BybitMatch?: BybitMatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
    Match?: MatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
  }

  export type IdexTransactionCreateManyInput = {
    id?: number
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    cabinetId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type IdexTransactionUpdateManyMutationInput = {
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdexTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    cabinetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportExportCreateInput = {
    tableId: number
    name: string
    type: string
    mappings: JsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ImportExportUncheckedCreateInput = {
    id?: number
    tableId: number
    name: string
    type: string
    mappings: JsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ImportExportUpdateInput = {
    tableId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mappings?: JsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportExportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mappings?: JsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportExportCreateManyInput = {
    id?: number
    tableId: number
    name: string
    type: string
    mappings: JsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ImportExportUpdateManyMutationInput = {
    tableId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mappings?: JsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportExportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mappings?: JsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    IdexTransaction: IdexTransactionCreateNestedOneWithoutMatchInput
    Transaction: TransactionCreateNestedOneWithoutMatchInput
  }

  export type MatchUncheckedCreateInput = {
    id?: number
    idexTransactionId: number
    transactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MatchUpdateInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    IdexTransaction?: IdexTransactionUpdateOneRequiredWithoutMatchNestedInput
    Transaction?: TransactionUpdateOneRequiredWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateManyInput = {
    id?: number
    idexTransactionId: number
    transactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MatchUpdateManyMutationInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateInput = {
    settings: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationSettingsUncheckedCreateInput = {
    id?: number
    settings: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationSettingsUpdateInput = {
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateManyInput = {
    id?: number
    settings: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationSettingsUpdateManyMutationInput = {
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordCreateInput = {
    name: string
    login?: string | null
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    type?: $Enums.PasswordType | null
  }

  export type PasswordUncheckedCreateInput = {
    id?: number
    name: string
    login?: string | null
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    type?: $Enums.PasswordType | null
  }

  export type PasswordUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType | null
  }

  export type PasswordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType | null
  }

  export type PasswordCreateManyInput = {
    id?: number
    name: string
    login?: string | null
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    type?: $Enums.PasswordType | null
  }

  export type PasswordUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType | null
  }

  export type PasswordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType | null
  }

  export type ReportNotificationCreateInput = {
    notificationTime: Date | string
    reportReceived?: boolean
    reportTime?: Date | string | null
    adminNotified?: boolean
    adminNotifyTime?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User: UserCreateNestedOneWithoutReportNotificationInput
  }

  export type ReportNotificationUncheckedCreateInput = {
    id?: number
    notificationTime: Date | string
    reportReceived?: boolean
    reportTime?: Date | string | null
    adminNotified?: boolean
    adminNotifyTime?: Date | string | null
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ReportNotificationUpdateInput = {
    notificationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reportReceived?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotified?: BoolFieldUpdateOperationsInput | boolean
    adminNotifyTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutReportNotificationNestedInput
  }

  export type ReportNotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reportReceived?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotified?: BoolFieldUpdateOperationsInput | boolean
    adminNotifyTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportNotificationCreateManyInput = {
    id?: number
    notificationTime: Date | string
    reportReceived?: boolean
    reportTime?: Date | string | null
    adminNotified?: boolean
    adminNotifyTime?: Date | string | null
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ReportNotificationUpdateManyMutationInput = {
    notificationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reportReceived?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotified?: BoolFieldUpdateOperationsInput | boolean
    adminNotifyTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportNotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reportReceived?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotified?: BoolFieldUpdateOperationsInput | boolean
    adminNotifyTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RowCreateInput = {
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Cell?: CellCreateNestedManyWithoutRowInput
    Table: TableCreateNestedOneWithoutRowInput
  }

  export type RowUncheckedCreateInput = {
    id?: number
    tableId: number
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Cell?: CellUncheckedCreateNestedManyWithoutRowInput
  }

  export type RowUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cell?: CellUpdateManyWithoutRowNestedInput
    Table?: TableUpdateOneRequiredWithoutRowNestedInput
  }

  export type RowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cell?: CellUncheckedUpdateManyWithoutRowNestedInput
  }

  export type RowCreateManyInput = {
    id?: number
    tableId: number
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type RowUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryCreateInput = {
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    FinRow?: FinRowCreateNestedManyWithoutSalaryInput
    SalaryDebt?: SalaryDebtCreateNestedManyWithoutSalaryInput
    SalaryEarning?: SalaryEarningCreateNestedManyWithoutSalaryInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutSalaryInput
    ShiftReport?: ShiftReportCreateNestedManyWithoutSalaryInput
  }

  export type SalaryUncheckedCreateInput = {
    id?: number
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    FinRow?: FinRowUncheckedCreateNestedManyWithoutSalaryInput
    SalaryDebt?: SalaryDebtUncheckedCreateNestedManyWithoutSalaryInput
    SalaryEarning?: SalaryEarningUncheckedCreateNestedManyWithoutSalaryInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutSalaryInput
    ShiftReport?: ShiftReportUncheckedCreateNestedManyWithoutSalaryInput
  }

  export type SalaryUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    FinRow?: FinRowUpdateManyWithoutSalaryNestedInput
    SalaryDebt?: SalaryDebtUpdateManyWithoutSalaryNestedInput
    SalaryEarning?: SalaryEarningUpdateManyWithoutSalaryNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutSalaryNestedInput
    ShiftReport?: ShiftReportUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    FinRow?: FinRowUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryDebt?: SalaryDebtUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryEarning?: SalaryEarningUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutSalaryNestedInput
    ShiftReport?: ShiftReportUncheckedUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryCreateManyInput = {
    id?: number
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
  }

  export type SalaryUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type SalaryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type SalaryDebtCreateInput = {
    amount: number
    debtDate: Date | string
    description?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Salary: SalaryCreateNestedOneWithoutSalaryDebtInput
  }

  export type SalaryDebtUncheckedCreateInput = {
    id?: number
    salaryId: number
    amount: number
    debtDate: Date | string
    description?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SalaryDebtUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    debtDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: SalaryUpdateOneRequiredWithoutSalaryDebtNestedInput
  }

  export type SalaryDebtUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaryId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    debtDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryDebtCreateManyInput = {
    id?: number
    salaryId: number
    amount: number
    debtDate: Date | string
    description?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SalaryDebtUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    debtDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryDebtUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaryId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    debtDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryEarningCreateInput = {
    amount: number
    earningDate: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Salary: SalaryCreateNestedOneWithoutSalaryEarningInput
  }

  export type SalaryEarningUncheckedCreateInput = {
    id?: number
    amount: number
    earningDate: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    salaryId: number
  }

  export type SalaryEarningUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    earningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: SalaryUpdateOneRequiredWithoutSalaryEarningNestedInput
  }

  export type SalaryEarningUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    earningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryId?: IntFieldUpdateOperationsInput | number
  }

  export type SalaryEarningCreateManyInput = {
    id?: number
    amount: number
    earningDate: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    salaryId: number
  }

  export type SalaryEarningUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    earningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryEarningUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    earningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryId?: IntFieldUpdateOperationsInput | number
  }

  export type SalaryPaymentCreateInput = {
    amount: number
    paymentDate: Date | string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    Salary: SalaryCreateNestedOneWithoutSalaryPaymentInput
  }

  export type SalaryPaymentUncheckedCreateInput = {
    id?: number
    salaryId: number
    amount: number
    paymentDate: Date | string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
  }

  export type SalaryPaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    Salary?: SalaryUpdateOneRequiredWithoutSalaryPaymentNestedInput
  }

  export type SalaryPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaryId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type SalaryPaymentCreateManyInput = {
    id?: number
    salaryId: number
    amount: number
    paymentDate: Date | string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
  }

  export type SalaryPaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type SalaryPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaryId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type SectionCreateInput = {
    name: string
    description?: string | null
    slug: string
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Table?: TableCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Table?: TableUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Table?: TableUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Table?: TableUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SectionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftReportCreateInput = {
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    usdtAmount?: number
    currency?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Salary?: SalaryCreateNestedOneWithoutShiftReportInput
    ShiftReportExpense?: ShiftReportExpenseCreateNestedManyWithoutShiftReportInput
  }

  export type ShiftReportUncheckedCreateInput = {
    id?: number
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    employeeId?: number | null
    usdtAmount?: number
    currency?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ShiftReportExpense?: ShiftReportExpenseUncheckedCreateNestedManyWithoutShiftReportInput
  }

  export type ShiftReportUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: SalaryUpdateOneWithoutShiftReportNestedInput
    ShiftReportExpense?: ShiftReportExpenseUpdateManyWithoutShiftReportNestedInput
  }

  export type ShiftReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShiftReportExpense?: ShiftReportExpenseUncheckedUpdateManyWithoutShiftReportNestedInput
  }

  export type ShiftReportCreateManyInput = {
    id?: number
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    employeeId?: number | null
    usdtAmount?: number
    currency?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShiftReportUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftReportExpenseCreateInput = {
    expenseType: string
    amount: number
    currency?: string
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ShiftReport?: ShiftReportCreateNestedOneWithoutShiftReportExpenseInput
  }

  export type ShiftReportExpenseUncheckedCreateInput = {
    id?: number
    shiftReportId?: number | null
    expenseType: string
    amount: number
    currency?: string
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShiftReportExpenseUpdateInput = {
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShiftReport?: ShiftReportUpdateOneWithoutShiftReportExpenseNestedInput
  }

  export type ShiftReportExpenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shiftReportId?: NullableIntFieldUpdateOperationsInput | number | null
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftReportExpenseCreateManyInput = {
    id?: number
    shiftReportId?: number | null
    expenseType: string
    amount: number
    currency?: string
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShiftReportExpenseUpdateManyMutationInput = {
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftReportExpenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shiftReportId?: NullableIntFieldUpdateOperationsInput | number | null
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateInput = {
    reportReminderInterval?: number
    reportWaitTime?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: number
    reportReminderInterval?: number
    reportWaitTime?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SystemSettingsUpdateInput = {
    reportReminderInterval?: IntFieldUpdateOperationsInput | number
    reportWaitTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportReminderInterval?: IntFieldUpdateOperationsInput | number
    reportWaitTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateManyInput = {
    id?: number
    reportReminderInterval?: number
    reportWaitTime?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SystemSettingsUpdateManyMutationInput = {
    reportReminderInterval?: IntFieldUpdateOperationsInput | number
    reportWaitTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportReminderInterval?: IntFieldUpdateOperationsInput | number
    reportWaitTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableCreateInput = {
    name: string
    description?: string | null
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Column?: ColumnCreateNestedManyWithoutTableInput
    Filter?: FilterCreateNestedManyWithoutTableInput
    Row?: RowCreateNestedManyWithoutTableInput
    Section: SectionCreateNestedOneWithoutTableInput
  }

  export type TableUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    sectionId: number
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Column?: ColumnUncheckedCreateNestedManyWithoutTableInput
    Filter?: FilterUncheckedCreateNestedManyWithoutTableInput
    Row?: RowUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUpdateManyWithoutTableNestedInput
    Filter?: FilterUpdateManyWithoutTableNestedInput
    Row?: RowUpdateManyWithoutTableNestedInput
    Section?: SectionUpdateOneRequiredWithoutTableNestedInput
  }

  export type TableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sectionId?: IntFieldUpdateOperationsInput | number
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUncheckedUpdateManyWithoutTableNestedInput
    Filter?: FilterUncheckedUpdateManyWithoutTableNestedInput
    Row?: RowUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    sectionId: number
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sectionId?: IntFieldUpdateOperationsInput | number
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramAccountCreateInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User: UserCreateNestedOneWithoutTelegramAccountInput
  }

  export type TelegramAccountUncheckedCreateInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TelegramAccountUpdateInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutTelegramAccountNestedInput
  }

  export type TelegramAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramAccountCreateManyInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TelegramAccountUpdateManyMutationInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    externalId?: string | null
    orderNo?: string | null
    dateTime: Date | string
    type: string
    asset: string
    amount: number
    totalPrice: number
    unitPrice: number
    counterparty?: string | null
    status: string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    Match?: MatchCreateNestedManyWithoutTransactionInput
    User: UserCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    externalId?: string | null
    orderNo?: string | null
    dateTime: Date | string
    type: string
    asset: string
    amount: number
    totalPrice: number
    unitPrice: number
    counterparty?: string | null
    status: string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
    Match?: MatchUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    asset?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Match?: MatchUpdateManyWithoutTransactionNestedInput
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    asset?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Match?: MatchUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: number
    externalId?: string | null
    orderNo?: string | null
    dateTime: Date | string
    type: string
    asset: string
    amount: number
    totalPrice: number
    unitPrice: number
    counterparty?: string | null
    status: string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    asset?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    asset?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionUncheckedCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportUncheckedCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportUncheckedCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationUncheckedCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetUncheckedCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUncheckedUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUncheckedUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUncheckedUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUncheckedUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkSessionCreateInput = {
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    autoCompleted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    User: UserCreateNestedOneWithoutWorkSessionInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetCreateNestedManyWithoutWorkSessionInput
  }

  export type WorkSessionUncheckedCreateInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    autoCompleted?: boolean
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUncheckedCreateNestedManyWithoutWorkSessionInput
  }

  export type WorkSessionUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    autoCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutWorkSessionNestedInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUpdateManyWithoutWorkSessionNestedInput
  }

  export type WorkSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    autoCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUncheckedUpdateManyWithoutWorkSessionNestedInput
  }

  export type WorkSessionCreateManyInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    autoCompleted?: boolean
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
  }

  export type WorkSessionUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    autoCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    autoCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkSessionIdexCabinetCreateInput = {
    assignedAt?: Date | string
    IdexCabinet: IdexCabinetCreateNestedOneWithoutWorkSessionIdexCabinetInput
    WorkSession: WorkSessionCreateNestedOneWithoutWorkSessionIdexCabinetInput
  }

  export type WorkSessionIdexCabinetUncheckedCreateInput = {
    workSessionId: number
    idexCabinetId: number
    assignedAt?: Date | string
  }

  export type WorkSessionIdexCabinetUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    IdexCabinet?: IdexCabinetUpdateOneRequiredWithoutWorkSessionIdexCabinetNestedInput
    WorkSession?: WorkSessionUpdateOneRequiredWithoutWorkSessionIdexCabinetNestedInput
  }

  export type WorkSessionIdexCabinetUncheckedUpdateInput = {
    workSessionId?: IntFieldUpdateOperationsInput | number
    idexCabinetId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkSessionIdexCabinetCreateManyInput = {
    workSessionId: number
    idexCabinetId: number
    assignedAt?: Date | string
  }

  export type WorkSessionIdexCabinetUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkSessionIdexCabinetUncheckedUpdateManyInput = {
    workSessionId?: IntFieldUpdateOperationsInput | number
    idexCabinetId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BybitCabinetCreateInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    bybitEmail: string
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetCreateNestedManyWithoutBybitCabinetInput
    BybitOrderInfo?: BybitOrderInfoCreateNestedManyWithoutCabinetInput
  }

  export type BybitCabinetUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    bybitEmail: string
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUncheckedCreateNestedManyWithoutBybitCabinetInput
    BybitOrderInfo?: BybitOrderInfoUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type BybitCabinetUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bybitEmail?: StringFieldUpdateOperationsInput | string
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUpdateManyWithoutBybitCabinetNestedInput
    BybitOrderInfo?: BybitOrderInfoUpdateManyWithoutCabinetNestedInput
  }

  export type BybitCabinetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bybitEmail?: StringFieldUpdateOperationsInput | string
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUncheckedUpdateManyWithoutBybitCabinetNestedInput
    BybitOrderInfo?: BybitOrderInfoUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type BybitCabinetCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    bybitEmail: string
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
  }

  export type BybitCabinetUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bybitEmail?: StringFieldUpdateOperationsInput | string
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BybitCabinetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bybitEmail?: StringFieldUpdateOperationsInput | string
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BybitClipMatchCreateInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitTransactionFromCabinet: BybitTransactionFromCabinetCreateNestedOneWithoutBybitClipMatchInput
    IdexTransaction: IdexTransactionCreateNestedOneWithoutBybitClipMatchInput
    MatchBybitReport?: MatchBybitReportCreateNestedOneWithoutBybitClipMatchInput
    User: UserCreateNestedOneWithoutBybitClipMatchInput
  }

  export type BybitClipMatchUncheckedCreateInput = {
    id?: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchBybitReportId?: number | null
    userId: number
  }

  export type BybitClipMatchUpdateInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUpdateOneRequiredWithoutBybitClipMatchNestedInput
    IdexTransaction?: IdexTransactionUpdateOneRequiredWithoutBybitClipMatchNestedInput
    MatchBybitReport?: MatchBybitReportUpdateOneWithoutBybitClipMatchNestedInput
    User?: UserUpdateOneRequiredWithoutBybitClipMatchNestedInput
  }

  export type BybitClipMatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchBybitReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BybitClipMatchCreateManyInput = {
    id?: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchBybitReportId?: number | null
    userId: number
  }

  export type BybitClipMatchUpdateManyMutationInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BybitClipMatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchBybitReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BybitTransactionFromCabinetCreateInput = {
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionFromCabinetCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutBybitTransactionFromCabinetInput
    BybitCabinet: BybitCabinetCreateNestedOneWithoutBybitTransactionFromCabinetInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutBybitTransactionFromCabinetInput
  }

  export type BybitTransactionFromCabinetUncheckedCreateInput = {
    id?: number
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionFromCabinetCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    cabinetId: number
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutBybitTransactionFromCabinetInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutBybitTransactionFromCabinetInput
  }

  export type BybitTransactionFromCabinetUpdateInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionFromCabinetUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutBybitTransactionFromCabinetNestedInput
    BybitCabinet?: BybitCabinetUpdateOneRequiredWithoutBybitTransactionFromCabinetNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutBybitTransactionFromCabinetNestedInput
  }

  export type BybitTransactionFromCabinetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionFromCabinetUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    cabinetId?: IntFieldUpdateOperationsInput | number
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetNestedInput
  }

  export type BybitTransactionFromCabinetCreateManyInput = {
    id?: number
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionFromCabinetCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    cabinetId: number
  }

  export type BybitTransactionFromCabinetUpdateManyMutationInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionFromCabinetUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BybitTransactionFromCabinetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionFromCabinetUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    cabinetId?: IntFieldUpdateOperationsInput | number
  }

  export type MatchBybitReportCreateInput = {
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutMatchBybitReportInput
    User?: UserCreateNestedOneWithoutMatchBybitReportInput
  }

  export type MatchBybitReportUncheckedCreateInput = {
    id?: number
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    userId?: number
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutMatchBybitReportInput
  }

  export type MatchBybitReportUpdateInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutMatchBybitReportNestedInput
    User?: UserUpdateOneRequiredWithoutMatchBybitReportNestedInput
  }

  export type MatchBybitReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutMatchBybitReportNestedInput
  }

  export type MatchBybitReportCreateManyInput = {
    id?: number
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    userId?: number
  }

  export type MatchBybitReportUpdateManyMutationInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchBybitReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type MatchViresReportCreateInput = {
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedOneWithoutMatchViresReportInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutMatchViresReportInput
  }

  export type MatchViresReportUncheckedCreateInput = {
    id?: number
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    userId?: number
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutMatchViresReportInput
  }

  export type MatchViresReportUpdateInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutMatchViresReportNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutMatchViresReportNestedInput
  }

  export type MatchViresReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutMatchViresReportNestedInput
  }

  export type MatchViresReportCreateManyInput = {
    id?: number
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    userId?: number
  }

  export type MatchViresReportUpdateManyMutationInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchViresReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ViresCabinetCreateInput = {
    name?: string | null
    login: string
    password: string
    type: $Enums.PasswordType
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    lastUpdate: Date | string
    User: UserCreateNestedOneWithoutViresCabinetInput
    ViresTransactionPayin?: ViresTransactionPayinCreateNestedManyWithoutViresCabinetInput
  }

  export type ViresCabinetUncheckedCreateInput = {
    id?: number
    name?: string | null
    login: string
    password: string
    type: $Enums.PasswordType
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    userId: number
    lastUpdate: Date | string
    ViresTransactionPayin?: ViresTransactionPayinUncheckedCreateNestedManyWithoutViresCabinetInput
  }

  export type ViresCabinetUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutViresCabinetNestedInput
    ViresTransactionPayin?: ViresTransactionPayinUpdateManyWithoutViresCabinetNestedInput
  }

  export type ViresCabinetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    ViresTransactionPayin?: ViresTransactionPayinUncheckedUpdateManyWithoutViresCabinetNestedInput
  }

  export type ViresCabinetCreateManyInput = {
    id?: number
    name?: string | null
    login: string
    password: string
    type: $Enums.PasswordType
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    userId: number
    lastUpdate: Date | string
  }

  export type ViresCabinetUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViresCabinetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViresClipMatchCreateInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitTransactionFromCabinet: BybitTransactionFromCabinetCreateNestedOneWithoutViresClipMatchInput
    MatchViresReport?: MatchViresReportCreateNestedOneWithoutViresClipMatchInput
    User: UserCreateNestedOneWithoutViresClipMatchInput
    ViresTransactionPayin: ViresTransactionPayinCreateNestedOneWithoutViresClipMatchInput
  }

  export type ViresClipMatchUncheckedCreateInput = {
    id?: number
    viresTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchViresReportId?: number | null
    userId: number
    bybitTransactionId: number
  }

  export type ViresClipMatchUpdateInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUpdateOneRequiredWithoutViresClipMatchNestedInput
    MatchViresReport?: MatchViresReportUpdateOneWithoutViresClipMatchNestedInput
    User?: UserUpdateOneRequiredWithoutViresClipMatchNestedInput
    ViresTransactionPayin?: ViresTransactionPayinUpdateOneRequiredWithoutViresClipMatchNestedInput
  }

  export type ViresClipMatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    viresTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchViresReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
  }

  export type ViresClipMatchCreateManyInput = {
    id?: number
    viresTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchViresReportId?: number | null
    userId: number
    bybitTransactionId: number
  }

  export type ViresClipMatchUpdateManyMutationInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViresClipMatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    viresTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchViresReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
  }

  export type ViresTransactionPayinCreateInput = {
    createdAt: Date | string
    sum_rub: number
    sum_usdt: number
    card: string
    fio: string
    bank: string
    uuid: string
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutViresTransactionPayinInput
    ViresCabinet: ViresCabinetCreateNestedOneWithoutViresTransactionPayinInput
  }

  export type ViresTransactionPayinUncheckedCreateInput = {
    id?: number
    cabinetId: number
    createdAt: Date | string
    sum_rub: number
    sum_usdt: number
    card: string
    fio: string
    bank: string
    uuid: string
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutViresTransactionPayinInput
  }

  export type ViresTransactionPayinUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sum_rub?: FloatFieldUpdateOperationsInput | number
    sum_usdt?: FloatFieldUpdateOperationsInput | number
    card?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutViresTransactionPayinNestedInput
    ViresCabinet?: ViresCabinetUpdateOneRequiredWithoutViresTransactionPayinNestedInput
  }

  export type ViresTransactionPayinUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cabinetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sum_rub?: FloatFieldUpdateOperationsInput | number
    sum_usdt?: FloatFieldUpdateOperationsInput | number
    card?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutViresTransactionPayinNestedInput
  }

  export type ViresTransactionPayinCreateManyInput = {
    id?: number
    cabinetId: number
    createdAt: Date | string
    sum_rub: number
    sum_usdt: number
    card: string
    fio: string
    bank: string
    uuid: string
  }

  export type ViresTransactionPayinUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sum_rub?: FloatFieldUpdateOperationsInput | number
    sum_usdt?: FloatFieldUpdateOperationsInput | number
    card?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type ViresTransactionPayinUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cabinetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sum_rub?: FloatFieldUpdateOperationsInput | number
    sum_usdt?: FloatFieldUpdateOperationsInput | number
    card?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CardBalanceNullableScalarRelationFilter = {
    is?: CardBalanceWhereInput | null
    isNot?: CardBalanceWhereInput | null
  }

  export type CardNullableScalarRelationFilter = {
    is?: CardWhereInput | null
    isNot?: CardWhereInput | null
  }

  export type CardPouringNullableScalarRelationFilter = {
    is?: CardPouringWhereInput | null
    isNot?: CardPouringWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    cardBalanceId?: SortOrder
    cardId?: SortOrder
    cardPouringId?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    cardBalanceId?: SortOrder
    cardId?: SortOrder
    cardPouringId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    cardBalanceId?: SortOrder
    cardId?: SortOrder
    cardPouringId?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    cardBalanceId?: SortOrder
    cardId?: SortOrder
    cardPouringId?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    cardBalanceId?: SortOrder
    cardId?: SortOrder
    cardPouringId?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumSalarySectionFilter<$PrismaModel = never> = {
    equals?: $Enums.SalarySection | EnumSalarySectionFieldRefInput<$PrismaModel>
    in?: $Enums.SalarySection[] | ListEnumSalarySectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalarySection[] | ListEnumSalarySectionFieldRefInput<$PrismaModel>
    not?: NestedEnumSalarySectionFilter<$PrismaModel> | $Enums.SalarySection
  }

  export type BalanceEntryCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SortOrder
  }

  export type BalanceEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type BalanceEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SortOrder
  }

  export type BalanceEntryMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SortOrder
  }

  export type BalanceEntrySumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumSalarySectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalarySection | EnumSalarySectionFieldRefInput<$PrismaModel>
    in?: $Enums.SalarySection[] | ListEnumSalarySectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalarySection[] | ListEnumSalarySectionFieldRefInput<$PrismaModel>
    not?: NestedEnumSalarySectionWithAggregatesFilter<$PrismaModel> | $Enums.SalarySection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalarySectionFilter<$PrismaModel>
    _max?: NestedEnumSalarySectionFilter<$PrismaModel>
  }

  export type BybitTransactionScalarRelationFilter = {
    is?: BybitTransactionWhereInput
    isNot?: BybitTransactionWhereInput
  }

  export type IdexTransactionScalarRelationFilter = {
    is?: IdexTransactionWhereInput
    isNot?: IdexTransactionWhereInput
  }

  export type BybitMatchIdexTransactionIdBybitTransactionIdCompoundUniqueInput = {
    idexTransactionId: number
    bybitTransactionId: number
  }

  export type BybitMatchCountOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BybitMatchAvgOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
  }

  export type BybitMatchMaxOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BybitMatchMinOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BybitMatchSumOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BybitCabinetScalarRelationFilter = {
    is?: BybitCabinetWhereInput
    isNot?: BybitCabinetWhereInput
  }

  export type BybitOrderInfoOrderNoBybitCabinetIdCompoundUniqueInput = {
    orderNo: string
    bybitCabinetId: number
  }

  export type BybitOrderInfoCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumbers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNo?: SortOrder
    dateTime?: SortOrder
    originalData?: SortOrder
    status?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    processed?: SortOrder
    unitPrice?: SortOrder
    bybitCabinetId?: SortOrder
  }

  export type BybitOrderInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
    bybitCabinetId?: SortOrder
  }

  export type BybitOrderInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNo?: SortOrder
    dateTime?: SortOrder
    status?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    processed?: SortOrder
    unitPrice?: SortOrder
    bybitCabinetId?: SortOrder
  }

  export type BybitOrderInfoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNo?: SortOrder
    dateTime?: SortOrder
    status?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    processed?: SortOrder
    unitPrice?: SortOrder
    bybitCabinetId?: SortOrder
  }

  export type BybitOrderInfoSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
    bybitCabinetId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BybitMatchListRelationFilter = {
    every?: BybitMatchWhereInput
    some?: BybitMatchWhereInput
    none?: BybitMatchWhereInput
  }

  export type BybitMatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BybitTransactionOrderNoUserIdCompoundUniqueInput = {
    orderNo: string
    userId: number
  }

  export type BybitTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    counterparty?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    amount?: SortOrder
    asset?: SortOrder
    dateTime?: SortOrder
    originalData?: SortOrder
    totalPrice?: SortOrder
    type?: SortOrder
    unitPrice?: SortOrder
    processed?: SortOrder
    extractedPhones?: SortOrder
    lastAttemptError?: SortOrder
  }

  export type BybitTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
  }

  export type BybitTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    counterparty?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    amount?: SortOrder
    asset?: SortOrder
    dateTime?: SortOrder
    totalPrice?: SortOrder
    type?: SortOrder
    unitPrice?: SortOrder
    processed?: SortOrder
    lastAttemptError?: SortOrder
  }

  export type BybitTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    counterparty?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    amount?: SortOrder
    asset?: SortOrder
    dateTime?: SortOrder
    totalPrice?: SortOrder
    type?: SortOrder
    unitPrice?: SortOrder
    processed?: SortOrder
    lastAttemptError?: SortOrder
  }

  export type BybitTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
  }

  export type EnumCardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CardStatus | EnumCardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CardStatus[] | ListEnumCardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardStatus[] | ListEnumCardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCardStatusFilter<$PrismaModel> | $Enums.CardStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type CardBalanceListRelationFilter = {
    every?: CardBalanceWhereInput
    some?: CardBalanceWhereInput
    none?: CardBalanceWhereInput
  }

  export type CardPouringListRelationFilter = {
    every?: CardPouringWhereInput
    some?: CardPouringWhereInput
    none?: CardPouringWhereInput
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardPouringOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: SortOrder
    cardNumber?: SortOrder
    bank?: SortOrder
    phoneNumber?: SortOrder
    appPin?: SortOrder
    terminalPin?: SortOrder
    comment?: SortOrder
    picachu?: SortOrder
    status?: SortOrder
    cardPrice?: SortOrder
    isPaid?: SortOrder
    letterCode?: SortOrder
    actor?: SortOrder
    inWork?: SortOrder
    activePaymentMethod?: SortOrder
  }

  export type CardAvgOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    appPin?: SortOrder
    cardPrice?: SortOrder
  }

  export type CardMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: SortOrder
    cardNumber?: SortOrder
    bank?: SortOrder
    phoneNumber?: SortOrder
    appPin?: SortOrder
    terminalPin?: SortOrder
    comment?: SortOrder
    picachu?: SortOrder
    status?: SortOrder
    cardPrice?: SortOrder
    isPaid?: SortOrder
    letterCode?: SortOrder
    actor?: SortOrder
    inWork?: SortOrder
    activePaymentMethod?: SortOrder
  }

  export type CardMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: SortOrder
    cardNumber?: SortOrder
    bank?: SortOrder
    phoneNumber?: SortOrder
    appPin?: SortOrder
    terminalPin?: SortOrder
    comment?: SortOrder
    picachu?: SortOrder
    status?: SortOrder
    cardPrice?: SortOrder
    isPaid?: SortOrder
    letterCode?: SortOrder
    actor?: SortOrder
    inWork?: SortOrder
    activePaymentMethod?: SortOrder
  }

  export type CardSumOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    appPin?: SortOrder
    cardPrice?: SortOrder
  }

  export type EnumCardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardStatus | EnumCardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CardStatus[] | ListEnumCardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardStatus[] | ListEnumCardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCardStatusWithAggregatesFilter<$PrismaModel> | $Enums.CardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardStatusFilter<$PrismaModel>
    _max?: NestedEnumCardStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CardScalarRelationFilter = {
    is?: CardWhereInput
    isNot?: CardWhereInput
  }

  export type CardBalanceCardIdDateCompoundUniqueInput = {
    cardId: number
    date: Date | string
  }

  export type CardBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    date?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
  }

  export type CardBalanceAvgOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
  }

  export type CardBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    date?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
  }

  export type CardBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    date?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
  }

  export type CardBalanceSumOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CardPouringCountOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    pouringDate?: SortOrder
    initialAmount?: SortOrder
    initialDate?: SortOrder
    finalAmount?: SortOrder
    finalDate?: SortOrder
    pouringAmount?: SortOrder
    withdrawalAmount?: SortOrder
    withdrawalDate?: SortOrder
    collectorName?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardPouringAvgOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    initialAmount?: SortOrder
    finalAmount?: SortOrder
    pouringAmount?: SortOrder
    withdrawalAmount?: SortOrder
  }

  export type CardPouringMaxOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    pouringDate?: SortOrder
    initialAmount?: SortOrder
    initialDate?: SortOrder
    finalAmount?: SortOrder
    finalDate?: SortOrder
    pouringAmount?: SortOrder
    withdrawalAmount?: SortOrder
    withdrawalDate?: SortOrder
    collectorName?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardPouringMinOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    pouringDate?: SortOrder
    initialAmount?: SortOrder
    initialDate?: SortOrder
    finalAmount?: SortOrder
    finalDate?: SortOrder
    pouringAmount?: SortOrder
    withdrawalAmount?: SortOrder
    withdrawalDate?: SortOrder
    collectorName?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardPouringSumOrderByAggregateInput = {
    id?: SortOrder
    cardId?: SortOrder
    initialAmount?: SortOrder
    finalAmount?: SortOrder
    pouringAmount?: SortOrder
    withdrawalAmount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ColumnScalarRelationFilter = {
    is?: ColumnWhereInput
    isNot?: ColumnWhereInput
  }

  export type RowScalarRelationFilter = {
    is?: RowWhereInput
    isNot?: RowWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CellRowIdColumnIdCompoundUniqueInput = {
    rowId: number
    columnId: number
  }

  export type CellCountOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    value?: SortOrder
    displayValue?: SortOrder
    calculatedValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CellAvgOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
  }

  export type CellMaxOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    value?: SortOrder
    displayValue?: SortOrder
    calculatedValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CellMinOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    value?: SortOrder
    displayValue?: SortOrder
    calculatedValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CellSumOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
  }

  export type EnumColumnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ColumnType | EnumColumnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumColumnTypeFilter<$PrismaModel> | $Enums.ColumnType
  }

  export type CellListRelationFilter = {
    every?: CellWhereInput
    some?: CellWhereInput
    none?: CellWhereInput
  }

  export type TableScalarRelationFilter = {
    is?: TableWhereInput
    isNot?: TableWhereInput
  }

  export type FilterListRelationFilter = {
    every?: FilterWhereInput
    some?: FilterWhereInput
    none?: FilterWhereInput
  }

  export type CellOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FilterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ColumnCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tableId?: SortOrder
    width?: SortOrder
    isRequired?: SortOrder
    isFilterable?: SortOrder
    isSummable?: SortOrder
    defaultValue?: SortOrder
    format?: SortOrder
    order?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColumnAvgOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    width?: SortOrder
    order?: SortOrder
  }

  export type ColumnMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tableId?: SortOrder
    width?: SortOrder
    isRequired?: SortOrder
    isFilterable?: SortOrder
    isSummable?: SortOrder
    defaultValue?: SortOrder
    format?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColumnMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tableId?: SortOrder
    width?: SortOrder
    isRequired?: SortOrder
    isFilterable?: SortOrder
    isSummable?: SortOrder
    defaultValue?: SortOrder
    format?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColumnSumOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    width?: SortOrder
    order?: SortOrder
  }

  export type EnumColumnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ColumnType | EnumColumnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumColumnTypeWithAggregatesFilter<$PrismaModel> | $Enums.ColumnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumColumnTypeFilter<$PrismaModel>
    _max?: NestedEnumColumnTypeFilter<$PrismaModel>
  }

  export type CellScalarRelationFilter = {
    is?: CellWhereInput
    isNot?: CellWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    cellId?: SortOrder
    text?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    cellId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    cellId?: SortOrder
    text?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    cellId?: SortOrder
    text?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    cellId?: SortOrder
  }

  export type EnumFilterOperatorFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterOperator | EnumFilterOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.FilterOperator[] | ListEnumFilterOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterOperator[] | ListEnumFilterOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterOperatorFilter<$PrismaModel> | $Enums.FilterOperator
  }

  export type FilterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tableId?: SortOrder
    columnId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    secondValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FilterAvgOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    columnId?: SortOrder
  }

  export type FilterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tableId?: SortOrder
    columnId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    secondValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FilterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tableId?: SortOrder
    columnId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    secondValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FilterSumOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    columnId?: SortOrder
  }

  export type EnumFilterOperatorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterOperator | EnumFilterOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.FilterOperator[] | ListEnumFilterOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterOperator[] | ListEnumFilterOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterOperatorWithAggregatesFilter<$PrismaModel> | $Enums.FilterOperator
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFilterOperatorFilter<$PrismaModel>
    _max?: NestedEnumFilterOperatorFilter<$PrismaModel>
  }

  export type SalaryNullableScalarRelationFilter = {
    is?: SalaryWhereInput | null
    isNot?: SalaryWhereInput | null
  }

  export type FinRowExpenseListRelationFilter = {
    every?: FinRowExpenseWhereInput
    some?: FinRowExpenseWhereInput
    none?: FinRowExpenseWhereInput
  }

  export type FinRowExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinRowCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    shift?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrder
    usdtAmount?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    section?: SortOrder
    exchangeRate?: SortOrder
  }

  export type FinRowAvgOrderByAggregateInput = {
    id?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrder
    usdtAmount?: SortOrder
    exchangeRate?: SortOrder
  }

  export type FinRowMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    shift?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrder
    usdtAmount?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    section?: SortOrder
    exchangeRate?: SortOrder
  }

  export type FinRowMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    shift?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrder
    usdtAmount?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    section?: SortOrder
    exchangeRate?: SortOrder
  }

  export type FinRowSumOrderByAggregateInput = {
    id?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrder
    usdtAmount?: SortOrder
    exchangeRate?: SortOrder
  }

  export type FinRowNullableScalarRelationFilter = {
    is?: FinRowWhereInput | null
    isNot?: FinRowWhereInput | null
  }

  export type FinRowExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    finRowId?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    time?: SortOrder
    period?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    section?: SortOrder
  }

  export type FinRowExpenseAvgOrderByAggregateInput = {
    id?: SortOrder
    finRowId?: SortOrder
    amount?: SortOrder
  }

  export type FinRowExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    finRowId?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    time?: SortOrder
    period?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    section?: SortOrder
  }

  export type FinRowExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    finRowId?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    time?: SortOrder
    period?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    section?: SortOrder
  }

  export type FinRowExpenseSumOrderByAggregateInput = {
    id?: SortOrder
    finRowId?: SortOrder
    amount?: SortOrder
  }

  export type IdexSyncOrderListRelationFilter = {
    every?: IdexSyncOrderWhereInput
    some?: IdexSyncOrderWhereInput
    none?: IdexSyncOrderWhereInput
  }

  export type IdexTransactionListRelationFilter = {
    every?: IdexTransactionWhereInput
    some?: IdexTransactionWhereInput
    none?: IdexTransactionWhereInput
  }

  export type WorkSessionIdexCabinetListRelationFilter = {
    every?: WorkSessionIdexCabinetWhereInput
    some?: WorkSessionIdexCabinetWhereInput
    none?: WorkSessionIdexCabinetWhereInput
  }

  export type IdexSyncOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IdexTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkSessionIdexCabinetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IdexCabinetCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idexId?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type IdexCabinetAvgOrderByAggregateInput = {
    id?: SortOrder
    idexId?: SortOrder
  }

  export type IdexCabinetMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idexId?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type IdexCabinetMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idexId?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type IdexCabinetSumOrderByAggregateInput = {
    id?: SortOrder
    idexId?: SortOrder
  }

  export type EnumIdexSyncOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IdexSyncOrderStatus | EnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdexSyncOrderStatus[] | ListEnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdexSyncOrderStatus[] | ListEnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdexSyncOrderStatusFilter<$PrismaModel> | $Enums.IdexSyncOrderStatus
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IdexCabinetNullableScalarRelationFilter = {
    is?: IdexCabinetWhereInput | null
    isNot?: IdexCabinetWhereInput | null
  }

  export type IdexSyncOrderCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinetId?: SortOrder
    processed?: SortOrder
    status?: SortOrder
    startSyncAt?: SortOrder
    endSyncAt?: SortOrder
    pages?: SortOrder
  }

  export type IdexSyncOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    cabinetId?: SortOrder
    pages?: SortOrder
  }

  export type IdexSyncOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinetId?: SortOrder
    status?: SortOrder
    startSyncAt?: SortOrder
    endSyncAt?: SortOrder
  }

  export type IdexSyncOrderMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinetId?: SortOrder
    status?: SortOrder
    startSyncAt?: SortOrder
    endSyncAt?: SortOrder
  }

  export type IdexSyncOrderSumOrderByAggregateInput = {
    id?: SortOrder
    cabinetId?: SortOrder
    pages?: SortOrder
  }

  export type EnumIdexSyncOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdexSyncOrderStatus | EnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdexSyncOrderStatus[] | ListEnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdexSyncOrderStatus[] | ListEnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdexSyncOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.IdexSyncOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdexSyncOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumIdexSyncOrderStatusFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BybitClipMatchListRelationFilter = {
    every?: BybitClipMatchWhereInput
    some?: BybitClipMatchWhereInput
    none?: BybitClipMatchWhereInput
  }

  export type IdexCabinetScalarRelationFilter = {
    is?: IdexCabinetWhereInput
    isNot?: IdexCabinetWhereInput
  }

  export type MatchListRelationFilter = {
    every?: MatchWhereInput
    some?: MatchWhereInput
    none?: MatchWhereInput
  }

  export type BybitClipMatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IdexTransactionExternalIdCabinetIdCompoundUniqueInput = {
    externalId: bigint | number
    cabinetId: number
  }

  export type IdexTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    paymentMethodId?: SortOrder
    wallet?: SortOrder
    amount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrder
    expiredAt?: SortOrder
    createdAtExternal?: SortOrder
    updatedAtExternal?: SortOrder
    extraData?: SortOrder
    cabinetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdexTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    paymentMethodId?: SortOrder
    status?: SortOrder
    cabinetId?: SortOrder
  }

  export type IdexTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    paymentMethodId?: SortOrder
    wallet?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrder
    expiredAt?: SortOrder
    createdAtExternal?: SortOrder
    updatedAtExternal?: SortOrder
    cabinetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdexTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    paymentMethodId?: SortOrder
    wallet?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrder
    expiredAt?: SortOrder
    createdAtExternal?: SortOrder
    updatedAtExternal?: SortOrder
    cabinetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdexTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    paymentMethodId?: SortOrder
    status?: SortOrder
    cabinetId?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ImportExportCountOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mappings?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportExportAvgOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type ImportExportMaxOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportExportMinOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportExportSumOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type MatchIdexTransactionIdTransactionIdCompoundUniqueInput = {
    idexTransactionId: number
    transactionId: number
  }

  export type MatchCountOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    transactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchAvgOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    transactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
  }

  export type MatchMaxOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    transactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchMinOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    transactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchSumOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    transactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
  }

  export type NotificationSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPasswordTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordType | EnumPasswordTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPasswordTypeNullableFilter<$PrismaModel> | $Enums.PasswordType | null
  }

  export type PasswordCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    login?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    type?: SortOrder
  }

  export type PasswordAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PasswordMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    login?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    type?: SortOrder
  }

  export type PasswordMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    login?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    type?: SortOrder
  }

  export type PasswordSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPasswordTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordType | EnumPasswordTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPasswordTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PasswordType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPasswordTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPasswordTypeNullableFilter<$PrismaModel>
  }

  export type ReportNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    notificationTime?: SortOrder
    reportReceived?: SortOrder
    reportTime?: SortOrder
    adminNotified?: SortOrder
    adminNotifyTime?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportNotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ReportNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationTime?: SortOrder
    reportReceived?: SortOrder
    reportTime?: SortOrder
    adminNotified?: SortOrder
    adminNotifyTime?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    notificationTime?: SortOrder
    reportReceived?: SortOrder
    reportTime?: SortOrder
    adminNotified?: SortOrder
    adminNotifyTime?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportNotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RowCountOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RowAvgOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    order?: SortOrder
  }

  export type RowMaxOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RowMinOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RowSumOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    order?: SortOrder
  }

  export type EnumPeriodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PeriodType | EnumPeriodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PeriodType[] | ListEnumPeriodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PeriodType[] | ListEnumPeriodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPeriodTypeFilter<$PrismaModel> | $Enums.PeriodType
  }

  export type FinRowListRelationFilter = {
    every?: FinRowWhereInput
    some?: FinRowWhereInput
    none?: FinRowWhereInput
  }

  export type SalaryDebtListRelationFilter = {
    every?: SalaryDebtWhereInput
    some?: SalaryDebtWhereInput
    none?: SalaryDebtWhereInput
  }

  export type SalaryEarningListRelationFilter = {
    every?: SalaryEarningWhereInput
    some?: SalaryEarningWhereInput
    none?: SalaryEarningWhereInput
  }

  export type SalaryPaymentListRelationFilter = {
    every?: SalaryPaymentWhereInput
    some?: SalaryPaymentWhereInput
    none?: SalaryPaymentWhereInput
  }

  export type ShiftReportListRelationFilter = {
    every?: ShiftReportWhereInput
    some?: ShiftReportWhereInput
    none?: ShiftReportWhereInput
  }

  export type FinRowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryDebtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryEarningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    position?: SortOrder
    startDate?: SortOrder
    payday?: SortOrder
    paydayMonth?: SortOrder
    fixedSalary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    periodic?: SortOrder
    payday2?: SortOrder
    payday3?: SortOrder
    section?: SortOrder
  }

  export type SalaryAvgOrderByAggregateInput = {
    id?: SortOrder
    payday?: SortOrder
    paydayMonth?: SortOrder
    fixedSalary?: SortOrder
    payday2?: SortOrder
    payday3?: SortOrder
  }

  export type SalaryMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    position?: SortOrder
    startDate?: SortOrder
    payday?: SortOrder
    paydayMonth?: SortOrder
    fixedSalary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    periodic?: SortOrder
    payday2?: SortOrder
    payday3?: SortOrder
    section?: SortOrder
  }

  export type SalaryMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    position?: SortOrder
    startDate?: SortOrder
    payday?: SortOrder
    paydayMonth?: SortOrder
    fixedSalary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    periodic?: SortOrder
    payday2?: SortOrder
    payday3?: SortOrder
    section?: SortOrder
  }

  export type SalarySumOrderByAggregateInput = {
    id?: SortOrder
    payday?: SortOrder
    paydayMonth?: SortOrder
    fixedSalary?: SortOrder
    payday2?: SortOrder
    payday3?: SortOrder
  }

  export type EnumPeriodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PeriodType | EnumPeriodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PeriodType[] | ListEnumPeriodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PeriodType[] | ListEnumPeriodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPeriodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PeriodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPeriodTypeFilter<$PrismaModel>
    _max?: NestedEnumPeriodTypeFilter<$PrismaModel>
  }

  export type SalaryScalarRelationFilter = {
    is?: SalaryWhereInput
    isNot?: SalaryWhereInput
  }

  export type SalaryDebtCountOrderByAggregateInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    debtDate?: SortOrder
    description?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryDebtAvgOrderByAggregateInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
  }

  export type SalaryDebtMaxOrderByAggregateInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    debtDate?: SortOrder
    description?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryDebtMinOrderByAggregateInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    debtDate?: SortOrder
    description?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryDebtSumOrderByAggregateInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
  }

  export type SalaryEarningCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    earningDate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salaryId?: SortOrder
  }

  export type SalaryEarningAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    salaryId?: SortOrder
  }

  export type SalaryEarningMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    earningDate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salaryId?: SortOrder
  }

  export type SalaryEarningMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    earningDate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salaryId?: SortOrder
  }

  export type SalaryEarningSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    salaryId?: SortOrder
  }

  export type SalaryPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
  }

  export type SalaryPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
  }

  export type SalaryPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
  }

  export type SalaryPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
  }

  export type SalaryPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
  }

  export type TableListRelationFilter = {
    every?: TableWhereInput
    some?: TableWhereInput
    none?: TableWhereInput
  }

  export type TableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type ShiftReportExpenseListRelationFilter = {
    every?: ShiftReportExpenseWhereInput
    some?: ShiftReportExpenseWhereInput
    none?: ShiftReportExpenseWhereInput
  }

  export type ShiftReportExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftReportCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    shift?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrder
    usdtAmount?: SortOrder
    currency?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftReportAvgOrderByAggregateInput = {
    id?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrder
    usdtAmount?: SortOrder
  }

  export type ShiftReportMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    shift?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrder
    usdtAmount?: SortOrder
    currency?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftReportMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    shift?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrder
    usdtAmount?: SortOrder
    currency?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftReportSumOrderByAggregateInput = {
    id?: SortOrder
    startBalance?: SortOrder
    endBalance?: SortOrder
    employeeId?: SortOrder
    usdtAmount?: SortOrder
  }

  export type ShiftReportNullableScalarRelationFilter = {
    is?: ShiftReportWhereInput | null
    isNot?: ShiftReportWhereInput | null
  }

  export type ShiftReportExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    shiftReportId?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    time?: SortOrder
    period?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftReportExpenseAvgOrderByAggregateInput = {
    id?: SortOrder
    shiftReportId?: SortOrder
    amount?: SortOrder
  }

  export type ShiftReportExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    shiftReportId?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    time?: SortOrder
    period?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftReportExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    shiftReportId?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    time?: SortOrder
    period?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftReportExpenseSumOrderByAggregateInput = {
    id?: SortOrder
    shiftReportId?: SortOrder
    amount?: SortOrder
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    reportReminderInterval?: SortOrder
    reportWaitTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    reportReminderInterval?: SortOrder
    reportWaitTime?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    reportReminderInterval?: SortOrder
    reportWaitTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    reportReminderInterval?: SortOrder
    reportWaitTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsSumOrderByAggregateInput = {
    id?: SortOrder
    reportReminderInterval?: SortOrder
    reportWaitTime?: SortOrder
  }

  export type ColumnListRelationFilter = {
    every?: ColumnWhereInput
    some?: ColumnWhereInput
    none?: ColumnWhereInput
  }

  export type RowListRelationFilter = {
    every?: RowWhereInput
    some?: RowWhereInput
    none?: RowWhereInput
  }

  export type SectionScalarRelationFilter = {
    is?: SectionWhereInput
    isNot?: SectionWhereInput
  }

  export type ColumnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TableCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sectionId?: SortOrder
    isSearchable?: SortOrder
    hasPagination?: SortOrder
    pageSize?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableAvgOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    pageSize?: SortOrder
    order?: SortOrder
  }

  export type TableMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sectionId?: SortOrder
    isSearchable?: SortOrder
    hasPagination?: SortOrder
    pageSize?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sectionId?: SortOrder
    isSearchable?: SortOrder
    hasPagination?: SortOrder
    pageSize?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableSumOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    pageSize?: SortOrder
    order?: SortOrder
  }

  export type TelegramAccountCountOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TelegramAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramAccountMinOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramAccountSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TransactionExternalIdUserIdCompoundUniqueInput = {
    externalId: string
    userId: number
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    orderNo?: SortOrder
    dateTime?: SortOrder
    type?: SortOrder
    asset?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
    counterparty?: SortOrder
    status?: SortOrder
    originalData?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
    userId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    orderNo?: SortOrder
    dateTime?: SortOrder
    type?: SortOrder
    asset?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
    counterparty?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    orderNo?: SortOrder
    dateTime?: SortOrder
    type?: SortOrder
    asset?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
    counterparty?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
    userId?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BybitTransactionListRelationFilter = {
    every?: BybitTransactionWhereInput
    some?: BybitTransactionWhereInput
    none?: BybitTransactionWhereInput
  }

  export type MatchBybitReportListRelationFilter = {
    every?: MatchBybitReportWhereInput
    some?: MatchBybitReportWhereInput
    none?: MatchBybitReportWhereInput
  }

  export type MatchViresReportListRelationFilter = {
    every?: MatchViresReportWhereInput
    some?: MatchViresReportWhereInput
    none?: MatchViresReportWhereInput
  }

  export type ReportNotificationListRelationFilter = {
    every?: ReportNotificationWhereInput
    some?: ReportNotificationWhereInput
    none?: ReportNotificationWhereInput
  }

  export type TelegramAccountListRelationFilter = {
    every?: TelegramAccountWhereInput
    some?: TelegramAccountWhereInput
    none?: TelegramAccountWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type ViresCabinetListRelationFilter = {
    every?: ViresCabinetWhereInput
    some?: ViresCabinetWhereInput
    none?: ViresCabinetWhereInput
  }

  export type ViresClipMatchListRelationFilter = {
    every?: ViresClipMatchWhereInput
    some?: ViresClipMatchWhereInput
    none?: ViresClipMatchWhereInput
  }

  export type WorkSessionListRelationFilter = {
    every?: WorkSessionWhereInput
    some?: WorkSessionWhereInput
    none?: WorkSessionWhereInput
  }

  export type BybitTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchBybitReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchViresReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TelegramAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViresCabinetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViresClipMatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    passCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastNotification?: SortOrder
    role?: SortOrder
    bybitApiSecret?: SortOrder
    bybitApiToken?: SortOrder
    lastBybitSyncAt?: SortOrder
    lastBybitSyncStatus?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    passCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastNotification?: SortOrder
    role?: SortOrder
    bybitApiSecret?: SortOrder
    bybitApiToken?: SortOrder
    lastBybitSyncAt?: SortOrder
    lastBybitSyncStatus?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    passCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastNotification?: SortOrder
    role?: SortOrder
    bybitApiSecret?: SortOrder
    bybitApiToken?: SortOrder
    lastBybitSyncAt?: SortOrder
    lastBybitSyncStatus?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type WorkSessionCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    autoCompleted?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
  }

  export type WorkSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    userId?: SortOrder
  }

  export type WorkSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    autoCompleted?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
  }

  export type WorkSessionMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    autoCompleted?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
  }

  export type WorkSessionSumOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    userId?: SortOrder
  }

  export type WorkSessionScalarRelationFilter = {
    is?: WorkSessionWhereInput
    isNot?: WorkSessionWhereInput
  }

  export type WorkSessionIdexCabinetWorkSessionIdIdexCabinetIdCompoundUniqueInput = {
    workSessionId: number
    idexCabinetId: number
  }

  export type WorkSessionIdexCabinetCountOrderByAggregateInput = {
    workSessionId?: SortOrder
    idexCabinetId?: SortOrder
    assignedAt?: SortOrder
  }

  export type WorkSessionIdexCabinetAvgOrderByAggregateInput = {
    workSessionId?: SortOrder
    idexCabinetId?: SortOrder
  }

  export type WorkSessionIdexCabinetMaxOrderByAggregateInput = {
    workSessionId?: SortOrder
    idexCabinetId?: SortOrder
    assignedAt?: SortOrder
  }

  export type WorkSessionIdexCabinetMinOrderByAggregateInput = {
    workSessionId?: SortOrder
    idexCabinetId?: SortOrder
    assignedAt?: SortOrder
  }

  export type WorkSessionIdexCabinetSumOrderByAggregateInput = {
    workSessionId?: SortOrder
    idexCabinetId?: SortOrder
  }

  export type BybitTransactionFromCabinetListRelationFilter = {
    every?: BybitTransactionFromCabinetWhereInput
    some?: BybitTransactionFromCabinetWhereInput
    none?: BybitTransactionFromCabinetWhereInput
  }

  export type BybitOrderInfoListRelationFilter = {
    every?: BybitOrderInfoWhereInput
    some?: BybitOrderInfoWhereInput
    none?: BybitOrderInfoWhereInput
  }

  export type BybitTransactionFromCabinetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BybitOrderInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BybitCabinetCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bybitEmail?: SortOrder
    bybitApiSecret?: SortOrder
    bybitApiToken?: SortOrder
    lastBybitSyncAt?: SortOrder
    lastBybitSyncStatus?: SortOrder
  }

  export type BybitCabinetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BybitCabinetMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bybitEmail?: SortOrder
    bybitApiSecret?: SortOrder
    bybitApiToken?: SortOrder
    lastBybitSyncAt?: SortOrder
    lastBybitSyncStatus?: SortOrder
  }

  export type BybitCabinetMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bybitEmail?: SortOrder
    bybitApiSecret?: SortOrder
    bybitApiToken?: SortOrder
    lastBybitSyncAt?: SortOrder
    lastBybitSyncStatus?: SortOrder
  }

  export type BybitCabinetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BybitTransactionFromCabinetScalarRelationFilter = {
    is?: BybitTransactionFromCabinetWhereInput
    isNot?: BybitTransactionFromCabinetWhereInput
  }

  export type MatchBybitReportNullableScalarRelationFilter = {
    is?: MatchBybitReportWhereInput | null
    isNot?: MatchBybitReportWhereInput | null
  }

  export type BybitClipMatchCountOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchBybitReportId?: SortOrder
    userId?: SortOrder
  }

  export type BybitClipMatchAvgOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    matchBybitReportId?: SortOrder
    userId?: SortOrder
  }

  export type BybitClipMatchMaxOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchBybitReportId?: SortOrder
    userId?: SortOrder
  }

  export type BybitClipMatchMinOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchBybitReportId?: SortOrder
    userId?: SortOrder
  }

  export type BybitClipMatchSumOrderByAggregateInput = {
    id?: SortOrder
    idexTransactionId?: SortOrder
    bybitTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    matchBybitReportId?: SortOrder
    userId?: SortOrder
  }

  export type BybitTransactionFromCabinetCountOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    counterparty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    amount?: SortOrder
    asset?: SortOrder
    dateTime?: SortOrder
    originalData?: SortOrder
    totalPrice?: SortOrder
    type?: SortOrder
    unitPrice?: SortOrder
    processed?: SortOrder
    extractedPhones?: SortOrder
    lastAttemptError?: SortOrder
    cabinetId?: SortOrder
  }

  export type BybitTransactionFromCabinetAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
    cabinetId?: SortOrder
  }

  export type BybitTransactionFromCabinetMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    counterparty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    amount?: SortOrder
    asset?: SortOrder
    dateTime?: SortOrder
    totalPrice?: SortOrder
    type?: SortOrder
    unitPrice?: SortOrder
    processed?: SortOrder
    lastAttemptError?: SortOrder
    cabinetId?: SortOrder
  }

  export type BybitTransactionFromCabinetMinOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    counterparty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    amount?: SortOrder
    asset?: SortOrder
    dateTime?: SortOrder
    totalPrice?: SortOrder
    type?: SortOrder
    unitPrice?: SortOrder
    processed?: SortOrder
    lastAttemptError?: SortOrder
    cabinetId?: SortOrder
  }

  export type BybitTransactionFromCabinetSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    totalPrice?: SortOrder
    unitPrice?: SortOrder
    cabinetId?: SortOrder
  }

  export type MatchBybitReportCountOrderByAggregateInput = {
    id?: SortOrder
    reportDate?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    timeRangeStart?: SortOrder
    timeRangeEnd?: SortOrder
    notes?: SortOrder
    idexCabinets?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type MatchBybitReportAvgOrderByAggregateInput = {
    id?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    userId?: SortOrder
  }

  export type MatchBybitReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reportDate?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    timeRangeStart?: SortOrder
    timeRangeEnd?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type MatchBybitReportMinOrderByAggregateInput = {
    id?: SortOrder
    reportDate?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    timeRangeStart?: SortOrder
    timeRangeEnd?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type MatchBybitReportSumOrderByAggregateInput = {
    id?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    userId?: SortOrder
  }

  export type MatchViresReportCountOrderByAggregateInput = {
    id?: SortOrder
    reportDate?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    timeRangeStart?: SortOrder
    timeRangeEnd?: SortOrder
    notes?: SortOrder
    idexCabinets?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type MatchViresReportAvgOrderByAggregateInput = {
    id?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    userId?: SortOrder
  }

  export type MatchViresReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reportDate?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    timeRangeStart?: SortOrder
    timeRangeEnd?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type MatchViresReportMinOrderByAggregateInput = {
    id?: SortOrder
    reportDate?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    timeRangeStart?: SortOrder
    timeRangeEnd?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type MatchViresReportSumOrderByAggregateInput = {
    id?: SortOrder
    totalMatches?: SortOrder
    totalProfit?: SortOrder
    averageProfit?: SortOrder
    successRate?: SortOrder
    userId?: SortOrder
  }

  export type EnumPasswordTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordType | EnumPasswordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordTypeFilter<$PrismaModel> | $Enums.PasswordType
  }

  export type ViresTransactionPayinListRelationFilter = {
    every?: ViresTransactionPayinWhereInput
    some?: ViresTransactionPayinWhereInput
    none?: ViresTransactionPayinWhereInput
  }

  export type ViresTransactionPayinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViresCabinetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    login?: SortOrder
    password?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    userId?: SortOrder
    lastUpdate?: SortOrder
  }

  export type ViresCabinetAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ViresCabinetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    login?: SortOrder
    password?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    userId?: SortOrder
    lastUpdate?: SortOrder
  }

  export type ViresCabinetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    login?: SortOrder
    password?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    userId?: SortOrder
    lastUpdate?: SortOrder
  }

  export type ViresCabinetSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumPasswordTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordType | EnumPasswordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordTypeWithAggregatesFilter<$PrismaModel> | $Enums.PasswordType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPasswordTypeFilter<$PrismaModel>
    _max?: NestedEnumPasswordTypeFilter<$PrismaModel>
  }

  export type MatchViresReportNullableScalarRelationFilter = {
    is?: MatchViresReportWhereInput | null
    isNot?: MatchViresReportWhereInput | null
  }

  export type ViresTransactionPayinScalarRelationFilter = {
    is?: ViresTransactionPayinWhereInput
    isNot?: ViresTransactionPayinWhereInput
  }

  export type ViresClipMatchCountOrderByAggregateInput = {
    id?: SortOrder
    viresTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchViresReportId?: SortOrder
    userId?: SortOrder
    bybitTransactionId?: SortOrder
  }

  export type ViresClipMatchAvgOrderByAggregateInput = {
    id?: SortOrder
    viresTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    matchViresReportId?: SortOrder
    userId?: SortOrder
    bybitTransactionId?: SortOrder
  }

  export type ViresClipMatchMaxOrderByAggregateInput = {
    id?: SortOrder
    viresTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchViresReportId?: SortOrder
    userId?: SortOrder
    bybitTransactionId?: SortOrder
  }

  export type ViresClipMatchMinOrderByAggregateInput = {
    id?: SortOrder
    viresTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matchViresReportId?: SortOrder
    userId?: SortOrder
    bybitTransactionId?: SortOrder
  }

  export type ViresClipMatchSumOrderByAggregateInput = {
    id?: SortOrder
    viresTransactionId?: SortOrder
    timeDifference?: SortOrder
    grossExpense?: SortOrder
    grossIncome?: SortOrder
    grossProfit?: SortOrder
    profitPercentage?: SortOrder
    matchViresReportId?: SortOrder
    userId?: SortOrder
    bybitTransactionId?: SortOrder
  }

  export type ViresCabinetScalarRelationFilter = {
    is?: ViresCabinetWhereInput
    isNot?: ViresCabinetWhereInput
  }

  export type ViresTransactionPayinCountOrderByAggregateInput = {
    id?: SortOrder
    cabinetId?: SortOrder
    createdAt?: SortOrder
    sum_rub?: SortOrder
    sum_usdt?: SortOrder
    card?: SortOrder
    fio?: SortOrder
    bank?: SortOrder
    uuid?: SortOrder
  }

  export type ViresTransactionPayinAvgOrderByAggregateInput = {
    id?: SortOrder
    cabinetId?: SortOrder
    sum_rub?: SortOrder
    sum_usdt?: SortOrder
  }

  export type ViresTransactionPayinMaxOrderByAggregateInput = {
    id?: SortOrder
    cabinetId?: SortOrder
    createdAt?: SortOrder
    sum_rub?: SortOrder
    sum_usdt?: SortOrder
    card?: SortOrder
    fio?: SortOrder
    bank?: SortOrder
    uuid?: SortOrder
  }

  export type ViresTransactionPayinMinOrderByAggregateInput = {
    id?: SortOrder
    cabinetId?: SortOrder
    createdAt?: SortOrder
    sum_rub?: SortOrder
    sum_usdt?: SortOrder
    card?: SortOrder
    fio?: SortOrder
    bank?: SortOrder
    uuid?: SortOrder
  }

  export type ViresTransactionPayinSumOrderByAggregateInput = {
    id?: SortOrder
    cabinetId?: SortOrder
    sum_rub?: SortOrder
    sum_usdt?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CardBalanceCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<CardBalanceCreateWithoutAuditLogInput, CardBalanceUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: CardBalanceCreateOrConnectWithoutAuditLogInput
    connect?: CardBalanceWhereUniqueInput
  }

  export type CardCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<CardCreateWithoutAuditLogInput, CardUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: CardCreateOrConnectWithoutAuditLogInput
    connect?: CardWhereUniqueInput
  }

  export type CardPouringCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<CardPouringCreateWithoutAuditLogInput, CardPouringUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: CardPouringCreateOrConnectWithoutAuditLogInput
    connect?: CardPouringWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type CardBalanceUpdateOneWithoutAuditLogNestedInput = {
    create?: XOR<CardBalanceCreateWithoutAuditLogInput, CardBalanceUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: CardBalanceCreateOrConnectWithoutAuditLogInput
    upsert?: CardBalanceUpsertWithoutAuditLogInput
    disconnect?: CardBalanceWhereInput | boolean
    delete?: CardBalanceWhereInput | boolean
    connect?: CardBalanceWhereUniqueInput
    update?: XOR<XOR<CardBalanceUpdateToOneWithWhereWithoutAuditLogInput, CardBalanceUpdateWithoutAuditLogInput>, CardBalanceUncheckedUpdateWithoutAuditLogInput>
  }

  export type CardUpdateOneWithoutAuditLogNestedInput = {
    create?: XOR<CardCreateWithoutAuditLogInput, CardUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: CardCreateOrConnectWithoutAuditLogInput
    upsert?: CardUpsertWithoutAuditLogInput
    disconnect?: CardWhereInput | boolean
    delete?: CardWhereInput | boolean
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutAuditLogInput, CardUpdateWithoutAuditLogInput>, CardUncheckedUpdateWithoutAuditLogInput>
  }

  export type CardPouringUpdateOneWithoutAuditLogNestedInput = {
    create?: XOR<CardPouringCreateWithoutAuditLogInput, CardPouringUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: CardPouringCreateOrConnectWithoutAuditLogInput
    upsert?: CardPouringUpsertWithoutAuditLogInput
    disconnect?: CardPouringWhereInput | boolean
    delete?: CardPouringWhereInput | boolean
    connect?: CardPouringWhereUniqueInput
    update?: XOR<XOR<CardPouringUpdateToOneWithWhereWithoutAuditLogInput, CardPouringUpdateWithoutAuditLogInput>, CardPouringUncheckedUpdateWithoutAuditLogInput>
  }

  export type UserUpdateOneRequiredWithoutAuditLogNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    upsert?: UserUpsertWithoutAuditLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogInput, UserUpdateWithoutAuditLogInput>, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumSalarySectionFieldUpdateOperationsInput = {
    set?: $Enums.SalarySection
  }

  export type BybitTransactionCreateNestedOneWithoutBybitMatchInput = {
    create?: XOR<BybitTransactionCreateWithoutBybitMatchInput, BybitTransactionUncheckedCreateWithoutBybitMatchInput>
    connectOrCreate?: BybitTransactionCreateOrConnectWithoutBybitMatchInput
    connect?: BybitTransactionWhereUniqueInput
  }

  export type IdexTransactionCreateNestedOneWithoutBybitMatchInput = {
    create?: XOR<IdexTransactionCreateWithoutBybitMatchInput, IdexTransactionUncheckedCreateWithoutBybitMatchInput>
    connectOrCreate?: IdexTransactionCreateOrConnectWithoutBybitMatchInput
    connect?: IdexTransactionWhereUniqueInput
  }

  export type BybitTransactionUpdateOneRequiredWithoutBybitMatchNestedInput = {
    create?: XOR<BybitTransactionCreateWithoutBybitMatchInput, BybitTransactionUncheckedCreateWithoutBybitMatchInput>
    connectOrCreate?: BybitTransactionCreateOrConnectWithoutBybitMatchInput
    upsert?: BybitTransactionUpsertWithoutBybitMatchInput
    connect?: BybitTransactionWhereUniqueInput
    update?: XOR<XOR<BybitTransactionUpdateToOneWithWhereWithoutBybitMatchInput, BybitTransactionUpdateWithoutBybitMatchInput>, BybitTransactionUncheckedUpdateWithoutBybitMatchInput>
  }

  export type IdexTransactionUpdateOneRequiredWithoutBybitMatchNestedInput = {
    create?: XOR<IdexTransactionCreateWithoutBybitMatchInput, IdexTransactionUncheckedCreateWithoutBybitMatchInput>
    connectOrCreate?: IdexTransactionCreateOrConnectWithoutBybitMatchInput
    upsert?: IdexTransactionUpsertWithoutBybitMatchInput
    connect?: IdexTransactionWhereUniqueInput
    update?: XOR<XOR<IdexTransactionUpdateToOneWithWhereWithoutBybitMatchInput, IdexTransactionUpdateWithoutBybitMatchInput>, IdexTransactionUncheckedUpdateWithoutBybitMatchInput>
  }

  export type BybitOrderInfoCreatephoneNumbersInput = {
    set: string[]
  }

  export type BybitCabinetCreateNestedOneWithoutBybitOrderInfoInput = {
    create?: XOR<BybitCabinetCreateWithoutBybitOrderInfoInput, BybitCabinetUncheckedCreateWithoutBybitOrderInfoInput>
    connectOrCreate?: BybitCabinetCreateOrConnectWithoutBybitOrderInfoInput
    connect?: BybitCabinetWhereUniqueInput
  }

  export type BybitOrderInfoUpdatephoneNumbersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BybitCabinetUpdateOneRequiredWithoutBybitOrderInfoNestedInput = {
    create?: XOR<BybitCabinetCreateWithoutBybitOrderInfoInput, BybitCabinetUncheckedCreateWithoutBybitOrderInfoInput>
    connectOrCreate?: BybitCabinetCreateOrConnectWithoutBybitOrderInfoInput
    upsert?: BybitCabinetUpsertWithoutBybitOrderInfoInput
    connect?: BybitCabinetWhereUniqueInput
    update?: XOR<XOR<BybitCabinetUpdateToOneWithWhereWithoutBybitOrderInfoInput, BybitCabinetUpdateWithoutBybitOrderInfoInput>, BybitCabinetUncheckedUpdateWithoutBybitOrderInfoInput>
  }

  export type BybitTransactionCreateextractedPhonesInput = {
    set: string[]
  }

  export type BybitMatchCreateNestedManyWithoutBybitTransactionInput = {
    create?: XOR<BybitMatchCreateWithoutBybitTransactionInput, BybitMatchUncheckedCreateWithoutBybitTransactionInput> | BybitMatchCreateWithoutBybitTransactionInput[] | BybitMatchUncheckedCreateWithoutBybitTransactionInput[]
    connectOrCreate?: BybitMatchCreateOrConnectWithoutBybitTransactionInput | BybitMatchCreateOrConnectWithoutBybitTransactionInput[]
    createMany?: BybitMatchCreateManyBybitTransactionInputEnvelope
    connect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutBybitTransactionInput = {
    create?: XOR<UserCreateWithoutBybitTransactionInput, UserUncheckedCreateWithoutBybitTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutBybitTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type BybitMatchUncheckedCreateNestedManyWithoutBybitTransactionInput = {
    create?: XOR<BybitMatchCreateWithoutBybitTransactionInput, BybitMatchUncheckedCreateWithoutBybitTransactionInput> | BybitMatchCreateWithoutBybitTransactionInput[] | BybitMatchUncheckedCreateWithoutBybitTransactionInput[]
    connectOrCreate?: BybitMatchCreateOrConnectWithoutBybitTransactionInput | BybitMatchCreateOrConnectWithoutBybitTransactionInput[]
    createMany?: BybitMatchCreateManyBybitTransactionInputEnvelope
    connect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
  }

  export type BybitTransactionUpdateextractedPhonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BybitMatchUpdateManyWithoutBybitTransactionNestedInput = {
    create?: XOR<BybitMatchCreateWithoutBybitTransactionInput, BybitMatchUncheckedCreateWithoutBybitTransactionInput> | BybitMatchCreateWithoutBybitTransactionInput[] | BybitMatchUncheckedCreateWithoutBybitTransactionInput[]
    connectOrCreate?: BybitMatchCreateOrConnectWithoutBybitTransactionInput | BybitMatchCreateOrConnectWithoutBybitTransactionInput[]
    upsert?: BybitMatchUpsertWithWhereUniqueWithoutBybitTransactionInput | BybitMatchUpsertWithWhereUniqueWithoutBybitTransactionInput[]
    createMany?: BybitMatchCreateManyBybitTransactionInputEnvelope
    set?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    disconnect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    delete?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    connect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    update?: BybitMatchUpdateWithWhereUniqueWithoutBybitTransactionInput | BybitMatchUpdateWithWhereUniqueWithoutBybitTransactionInput[]
    updateMany?: BybitMatchUpdateManyWithWhereWithoutBybitTransactionInput | BybitMatchUpdateManyWithWhereWithoutBybitTransactionInput[]
    deleteMany?: BybitMatchScalarWhereInput | BybitMatchScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutBybitTransactionNestedInput = {
    create?: XOR<UserCreateWithoutBybitTransactionInput, UserUncheckedCreateWithoutBybitTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutBybitTransactionInput
    upsert?: UserUpsertWithoutBybitTransactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBybitTransactionInput, UserUpdateWithoutBybitTransactionInput>, UserUncheckedUpdateWithoutBybitTransactionInput>
  }

  export type BybitMatchUncheckedUpdateManyWithoutBybitTransactionNestedInput = {
    create?: XOR<BybitMatchCreateWithoutBybitTransactionInput, BybitMatchUncheckedCreateWithoutBybitTransactionInput> | BybitMatchCreateWithoutBybitTransactionInput[] | BybitMatchUncheckedCreateWithoutBybitTransactionInput[]
    connectOrCreate?: BybitMatchCreateOrConnectWithoutBybitTransactionInput | BybitMatchCreateOrConnectWithoutBybitTransactionInput[]
    upsert?: BybitMatchUpsertWithWhereUniqueWithoutBybitTransactionInput | BybitMatchUpsertWithWhereUniqueWithoutBybitTransactionInput[]
    createMany?: BybitMatchCreateManyBybitTransactionInputEnvelope
    set?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    disconnect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    delete?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    connect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    update?: BybitMatchUpdateWithWhereUniqueWithoutBybitTransactionInput | BybitMatchUpdateWithWhereUniqueWithoutBybitTransactionInput[]
    updateMany?: BybitMatchUpdateManyWithWhereWithoutBybitTransactionInput | BybitMatchUpdateManyWithWhereWithoutBybitTransactionInput[]
    deleteMany?: BybitMatchScalarWhereInput | BybitMatchScalarWhereInput[]
  }

  export type AuditLogCreateNestedManyWithoutCardInput = {
    create?: XOR<AuditLogCreateWithoutCardInput, AuditLogUncheckedCreateWithoutCardInput> | AuditLogCreateWithoutCardInput[] | AuditLogUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardInput | AuditLogCreateOrConnectWithoutCardInput[]
    createMany?: AuditLogCreateManyCardInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CardBalanceCreateNestedManyWithoutCardInput = {
    create?: XOR<CardBalanceCreateWithoutCardInput, CardBalanceUncheckedCreateWithoutCardInput> | CardBalanceCreateWithoutCardInput[] | CardBalanceUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardBalanceCreateOrConnectWithoutCardInput | CardBalanceCreateOrConnectWithoutCardInput[]
    createMany?: CardBalanceCreateManyCardInputEnvelope
    connect?: CardBalanceWhereUniqueInput | CardBalanceWhereUniqueInput[]
  }

  export type CardPouringCreateNestedManyWithoutCardInput = {
    create?: XOR<CardPouringCreateWithoutCardInput, CardPouringUncheckedCreateWithoutCardInput> | CardPouringCreateWithoutCardInput[] | CardPouringUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardPouringCreateOrConnectWithoutCardInput | CardPouringCreateOrConnectWithoutCardInput[]
    createMany?: CardPouringCreateManyCardInputEnvelope
    connect?: CardPouringWhereUniqueInput | CardPouringWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<AuditLogCreateWithoutCardInput, AuditLogUncheckedCreateWithoutCardInput> | AuditLogCreateWithoutCardInput[] | AuditLogUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardInput | AuditLogCreateOrConnectWithoutCardInput[]
    createMany?: AuditLogCreateManyCardInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CardBalanceUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<CardBalanceCreateWithoutCardInput, CardBalanceUncheckedCreateWithoutCardInput> | CardBalanceCreateWithoutCardInput[] | CardBalanceUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardBalanceCreateOrConnectWithoutCardInput | CardBalanceCreateOrConnectWithoutCardInput[]
    createMany?: CardBalanceCreateManyCardInputEnvelope
    connect?: CardBalanceWhereUniqueInput | CardBalanceWhereUniqueInput[]
  }

  export type CardPouringUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<CardPouringCreateWithoutCardInput, CardPouringUncheckedCreateWithoutCardInput> | CardPouringCreateWithoutCardInput[] | CardPouringUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardPouringCreateOrConnectWithoutCardInput | CardPouringCreateOrConnectWithoutCardInput[]
    createMany?: CardPouringCreateManyCardInputEnvelope
    connect?: CardPouringWhereUniqueInput | CardPouringWhereUniqueInput[]
  }

  export type EnumCardStatusFieldUpdateOperationsInput = {
    set?: $Enums.CardStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AuditLogUpdateManyWithoutCardNestedInput = {
    create?: XOR<AuditLogCreateWithoutCardInput, AuditLogUncheckedCreateWithoutCardInput> | AuditLogCreateWithoutCardInput[] | AuditLogUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardInput | AuditLogCreateOrConnectWithoutCardInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCardInput | AuditLogUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: AuditLogCreateManyCardInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCardInput | AuditLogUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCardInput | AuditLogUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CardBalanceUpdateManyWithoutCardNestedInput = {
    create?: XOR<CardBalanceCreateWithoutCardInput, CardBalanceUncheckedCreateWithoutCardInput> | CardBalanceCreateWithoutCardInput[] | CardBalanceUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardBalanceCreateOrConnectWithoutCardInput | CardBalanceCreateOrConnectWithoutCardInput[]
    upsert?: CardBalanceUpsertWithWhereUniqueWithoutCardInput | CardBalanceUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: CardBalanceCreateManyCardInputEnvelope
    set?: CardBalanceWhereUniqueInput | CardBalanceWhereUniqueInput[]
    disconnect?: CardBalanceWhereUniqueInput | CardBalanceWhereUniqueInput[]
    delete?: CardBalanceWhereUniqueInput | CardBalanceWhereUniqueInput[]
    connect?: CardBalanceWhereUniqueInput | CardBalanceWhereUniqueInput[]
    update?: CardBalanceUpdateWithWhereUniqueWithoutCardInput | CardBalanceUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: CardBalanceUpdateManyWithWhereWithoutCardInput | CardBalanceUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: CardBalanceScalarWhereInput | CardBalanceScalarWhereInput[]
  }

  export type CardPouringUpdateManyWithoutCardNestedInput = {
    create?: XOR<CardPouringCreateWithoutCardInput, CardPouringUncheckedCreateWithoutCardInput> | CardPouringCreateWithoutCardInput[] | CardPouringUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardPouringCreateOrConnectWithoutCardInput | CardPouringCreateOrConnectWithoutCardInput[]
    upsert?: CardPouringUpsertWithWhereUniqueWithoutCardInput | CardPouringUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: CardPouringCreateManyCardInputEnvelope
    set?: CardPouringWhereUniqueInput | CardPouringWhereUniqueInput[]
    disconnect?: CardPouringWhereUniqueInput | CardPouringWhereUniqueInput[]
    delete?: CardPouringWhereUniqueInput | CardPouringWhereUniqueInput[]
    connect?: CardPouringWhereUniqueInput | CardPouringWhereUniqueInput[]
    update?: CardPouringUpdateWithWhereUniqueWithoutCardInput | CardPouringUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: CardPouringUpdateManyWithWhereWithoutCardInput | CardPouringUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: CardPouringScalarWhereInput | CardPouringScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<AuditLogCreateWithoutCardInput, AuditLogUncheckedCreateWithoutCardInput> | AuditLogCreateWithoutCardInput[] | AuditLogUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardInput | AuditLogCreateOrConnectWithoutCardInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCardInput | AuditLogUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: AuditLogCreateManyCardInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCardInput | AuditLogUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCardInput | AuditLogUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CardBalanceUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<CardBalanceCreateWithoutCardInput, CardBalanceUncheckedCreateWithoutCardInput> | CardBalanceCreateWithoutCardInput[] | CardBalanceUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardBalanceCreateOrConnectWithoutCardInput | CardBalanceCreateOrConnectWithoutCardInput[]
    upsert?: CardBalanceUpsertWithWhereUniqueWithoutCardInput | CardBalanceUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: CardBalanceCreateManyCardInputEnvelope
    set?: CardBalanceWhereUniqueInput | CardBalanceWhereUniqueInput[]
    disconnect?: CardBalanceWhereUniqueInput | CardBalanceWhereUniqueInput[]
    delete?: CardBalanceWhereUniqueInput | CardBalanceWhereUniqueInput[]
    connect?: CardBalanceWhereUniqueInput | CardBalanceWhereUniqueInput[]
    update?: CardBalanceUpdateWithWhereUniqueWithoutCardInput | CardBalanceUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: CardBalanceUpdateManyWithWhereWithoutCardInput | CardBalanceUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: CardBalanceScalarWhereInput | CardBalanceScalarWhereInput[]
  }

  export type CardPouringUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<CardPouringCreateWithoutCardInput, CardPouringUncheckedCreateWithoutCardInput> | CardPouringCreateWithoutCardInput[] | CardPouringUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardPouringCreateOrConnectWithoutCardInput | CardPouringCreateOrConnectWithoutCardInput[]
    upsert?: CardPouringUpsertWithWhereUniqueWithoutCardInput | CardPouringUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: CardPouringCreateManyCardInputEnvelope
    set?: CardPouringWhereUniqueInput | CardPouringWhereUniqueInput[]
    disconnect?: CardPouringWhereUniqueInput | CardPouringWhereUniqueInput[]
    delete?: CardPouringWhereUniqueInput | CardPouringWhereUniqueInput[]
    connect?: CardPouringWhereUniqueInput | CardPouringWhereUniqueInput[]
    update?: CardPouringUpdateWithWhereUniqueWithoutCardInput | CardPouringUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: CardPouringUpdateManyWithWhereWithoutCardInput | CardPouringUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: CardPouringScalarWhereInput | CardPouringScalarWhereInput[]
  }

  export type AuditLogCreateNestedManyWithoutCardBalanceInput = {
    create?: XOR<AuditLogCreateWithoutCardBalanceInput, AuditLogUncheckedCreateWithoutCardBalanceInput> | AuditLogCreateWithoutCardBalanceInput[] | AuditLogUncheckedCreateWithoutCardBalanceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardBalanceInput | AuditLogCreateOrConnectWithoutCardBalanceInput[]
    createMany?: AuditLogCreateManyCardBalanceInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CardCreateNestedOneWithoutCardBalanceInput = {
    create?: XOR<CardCreateWithoutCardBalanceInput, CardUncheckedCreateWithoutCardBalanceInput>
    connectOrCreate?: CardCreateOrConnectWithoutCardBalanceInput
    connect?: CardWhereUniqueInput
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCardBalanceInput = {
    create?: XOR<AuditLogCreateWithoutCardBalanceInput, AuditLogUncheckedCreateWithoutCardBalanceInput> | AuditLogCreateWithoutCardBalanceInput[] | AuditLogUncheckedCreateWithoutCardBalanceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardBalanceInput | AuditLogCreateOrConnectWithoutCardBalanceInput[]
    createMany?: AuditLogCreateManyCardBalanceInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AuditLogUpdateManyWithoutCardBalanceNestedInput = {
    create?: XOR<AuditLogCreateWithoutCardBalanceInput, AuditLogUncheckedCreateWithoutCardBalanceInput> | AuditLogCreateWithoutCardBalanceInput[] | AuditLogUncheckedCreateWithoutCardBalanceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardBalanceInput | AuditLogCreateOrConnectWithoutCardBalanceInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCardBalanceInput | AuditLogUpsertWithWhereUniqueWithoutCardBalanceInput[]
    createMany?: AuditLogCreateManyCardBalanceInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCardBalanceInput | AuditLogUpdateWithWhereUniqueWithoutCardBalanceInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCardBalanceInput | AuditLogUpdateManyWithWhereWithoutCardBalanceInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CardUpdateOneRequiredWithoutCardBalanceNestedInput = {
    create?: XOR<CardCreateWithoutCardBalanceInput, CardUncheckedCreateWithoutCardBalanceInput>
    connectOrCreate?: CardCreateOrConnectWithoutCardBalanceInput
    upsert?: CardUpsertWithoutCardBalanceInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutCardBalanceInput, CardUpdateWithoutCardBalanceInput>, CardUncheckedUpdateWithoutCardBalanceInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutCardBalanceNestedInput = {
    create?: XOR<AuditLogCreateWithoutCardBalanceInput, AuditLogUncheckedCreateWithoutCardBalanceInput> | AuditLogCreateWithoutCardBalanceInput[] | AuditLogUncheckedCreateWithoutCardBalanceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardBalanceInput | AuditLogCreateOrConnectWithoutCardBalanceInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCardBalanceInput | AuditLogUpsertWithWhereUniqueWithoutCardBalanceInput[]
    createMany?: AuditLogCreateManyCardBalanceInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCardBalanceInput | AuditLogUpdateWithWhereUniqueWithoutCardBalanceInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCardBalanceInput | AuditLogUpdateManyWithWhereWithoutCardBalanceInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AuditLogCreateNestedManyWithoutCardPouringInput = {
    create?: XOR<AuditLogCreateWithoutCardPouringInput, AuditLogUncheckedCreateWithoutCardPouringInput> | AuditLogCreateWithoutCardPouringInput[] | AuditLogUncheckedCreateWithoutCardPouringInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardPouringInput | AuditLogCreateOrConnectWithoutCardPouringInput[]
    createMany?: AuditLogCreateManyCardPouringInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CardCreateNestedOneWithoutCardPouringInput = {
    create?: XOR<CardCreateWithoutCardPouringInput, CardUncheckedCreateWithoutCardPouringInput>
    connectOrCreate?: CardCreateOrConnectWithoutCardPouringInput
    connect?: CardWhereUniqueInput
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCardPouringInput = {
    create?: XOR<AuditLogCreateWithoutCardPouringInput, AuditLogUncheckedCreateWithoutCardPouringInput> | AuditLogCreateWithoutCardPouringInput[] | AuditLogUncheckedCreateWithoutCardPouringInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardPouringInput | AuditLogCreateOrConnectWithoutCardPouringInput[]
    createMany?: AuditLogCreateManyCardPouringInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AuditLogUpdateManyWithoutCardPouringNestedInput = {
    create?: XOR<AuditLogCreateWithoutCardPouringInput, AuditLogUncheckedCreateWithoutCardPouringInput> | AuditLogCreateWithoutCardPouringInput[] | AuditLogUncheckedCreateWithoutCardPouringInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardPouringInput | AuditLogCreateOrConnectWithoutCardPouringInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCardPouringInput | AuditLogUpsertWithWhereUniqueWithoutCardPouringInput[]
    createMany?: AuditLogCreateManyCardPouringInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCardPouringInput | AuditLogUpdateWithWhereUniqueWithoutCardPouringInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCardPouringInput | AuditLogUpdateManyWithWhereWithoutCardPouringInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CardUpdateOneRequiredWithoutCardPouringNestedInput = {
    create?: XOR<CardCreateWithoutCardPouringInput, CardUncheckedCreateWithoutCardPouringInput>
    connectOrCreate?: CardCreateOrConnectWithoutCardPouringInput
    upsert?: CardUpsertWithoutCardPouringInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutCardPouringInput, CardUpdateWithoutCardPouringInput>, CardUncheckedUpdateWithoutCardPouringInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutCardPouringNestedInput = {
    create?: XOR<AuditLogCreateWithoutCardPouringInput, AuditLogUncheckedCreateWithoutCardPouringInput> | AuditLogCreateWithoutCardPouringInput[] | AuditLogUncheckedCreateWithoutCardPouringInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCardPouringInput | AuditLogCreateOrConnectWithoutCardPouringInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCardPouringInput | AuditLogUpsertWithWhereUniqueWithoutCardPouringInput[]
    createMany?: AuditLogCreateManyCardPouringInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCardPouringInput | AuditLogUpdateWithWhereUniqueWithoutCardPouringInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCardPouringInput | AuditLogUpdateManyWithWhereWithoutCardPouringInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ColumnCreateNestedOneWithoutCellInput = {
    create?: XOR<ColumnCreateWithoutCellInput, ColumnUncheckedCreateWithoutCellInput>
    connectOrCreate?: ColumnCreateOrConnectWithoutCellInput
    connect?: ColumnWhereUniqueInput
  }

  export type RowCreateNestedOneWithoutCellInput = {
    create?: XOR<RowCreateWithoutCellInput, RowUncheckedCreateWithoutCellInput>
    connectOrCreate?: RowCreateOrConnectWithoutCellInput
    connect?: RowWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutCellInput = {
    create?: XOR<CommentCreateWithoutCellInput, CommentUncheckedCreateWithoutCellInput> | CommentCreateWithoutCellInput[] | CommentUncheckedCreateWithoutCellInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCellInput | CommentCreateOrConnectWithoutCellInput[]
    createMany?: CommentCreateManyCellInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutCellInput = {
    create?: XOR<CommentCreateWithoutCellInput, CommentUncheckedCreateWithoutCellInput> | CommentCreateWithoutCellInput[] | CommentUncheckedCreateWithoutCellInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCellInput | CommentCreateOrConnectWithoutCellInput[]
    createMany?: CommentCreateManyCellInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ColumnUpdateOneRequiredWithoutCellNestedInput = {
    create?: XOR<ColumnCreateWithoutCellInput, ColumnUncheckedCreateWithoutCellInput>
    connectOrCreate?: ColumnCreateOrConnectWithoutCellInput
    upsert?: ColumnUpsertWithoutCellInput
    connect?: ColumnWhereUniqueInput
    update?: XOR<XOR<ColumnUpdateToOneWithWhereWithoutCellInput, ColumnUpdateWithoutCellInput>, ColumnUncheckedUpdateWithoutCellInput>
  }

  export type RowUpdateOneRequiredWithoutCellNestedInput = {
    create?: XOR<RowCreateWithoutCellInput, RowUncheckedCreateWithoutCellInput>
    connectOrCreate?: RowCreateOrConnectWithoutCellInput
    upsert?: RowUpsertWithoutCellInput
    connect?: RowWhereUniqueInput
    update?: XOR<XOR<RowUpdateToOneWithWhereWithoutCellInput, RowUpdateWithoutCellInput>, RowUncheckedUpdateWithoutCellInput>
  }

  export type CommentUpdateManyWithoutCellNestedInput = {
    create?: XOR<CommentCreateWithoutCellInput, CommentUncheckedCreateWithoutCellInput> | CommentCreateWithoutCellInput[] | CommentUncheckedCreateWithoutCellInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCellInput | CommentCreateOrConnectWithoutCellInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCellInput | CommentUpsertWithWhereUniqueWithoutCellInput[]
    createMany?: CommentCreateManyCellInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCellInput | CommentUpdateWithWhereUniqueWithoutCellInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCellInput | CommentUpdateManyWithWhereWithoutCellInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutCellNestedInput = {
    create?: XOR<CommentCreateWithoutCellInput, CommentUncheckedCreateWithoutCellInput> | CommentCreateWithoutCellInput[] | CommentUncheckedCreateWithoutCellInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCellInput | CommentCreateOrConnectWithoutCellInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCellInput | CommentUpsertWithWhereUniqueWithoutCellInput[]
    createMany?: CommentCreateManyCellInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCellInput | CommentUpdateWithWhereUniqueWithoutCellInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCellInput | CommentUpdateManyWithWhereWithoutCellInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CellCreateNestedManyWithoutColumnInput = {
    create?: XOR<CellCreateWithoutColumnInput, CellUncheckedCreateWithoutColumnInput> | CellCreateWithoutColumnInput[] | CellUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: CellCreateOrConnectWithoutColumnInput | CellCreateOrConnectWithoutColumnInput[]
    createMany?: CellCreateManyColumnInputEnvelope
    connect?: CellWhereUniqueInput | CellWhereUniqueInput[]
  }

  export type TableCreateNestedOneWithoutColumnInput = {
    create?: XOR<TableCreateWithoutColumnInput, TableUncheckedCreateWithoutColumnInput>
    connectOrCreate?: TableCreateOrConnectWithoutColumnInput
    connect?: TableWhereUniqueInput
  }

  export type FilterCreateNestedManyWithoutColumnInput = {
    create?: XOR<FilterCreateWithoutColumnInput, FilterUncheckedCreateWithoutColumnInput> | FilterCreateWithoutColumnInput[] | FilterUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: FilterCreateOrConnectWithoutColumnInput | FilterCreateOrConnectWithoutColumnInput[]
    createMany?: FilterCreateManyColumnInputEnvelope
    connect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
  }

  export type CellUncheckedCreateNestedManyWithoutColumnInput = {
    create?: XOR<CellCreateWithoutColumnInput, CellUncheckedCreateWithoutColumnInput> | CellCreateWithoutColumnInput[] | CellUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: CellCreateOrConnectWithoutColumnInput | CellCreateOrConnectWithoutColumnInput[]
    createMany?: CellCreateManyColumnInputEnvelope
    connect?: CellWhereUniqueInput | CellWhereUniqueInput[]
  }

  export type FilterUncheckedCreateNestedManyWithoutColumnInput = {
    create?: XOR<FilterCreateWithoutColumnInput, FilterUncheckedCreateWithoutColumnInput> | FilterCreateWithoutColumnInput[] | FilterUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: FilterCreateOrConnectWithoutColumnInput | FilterCreateOrConnectWithoutColumnInput[]
    createMany?: FilterCreateManyColumnInputEnvelope
    connect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
  }

  export type EnumColumnTypeFieldUpdateOperationsInput = {
    set?: $Enums.ColumnType
  }

  export type CellUpdateManyWithoutColumnNestedInput = {
    create?: XOR<CellCreateWithoutColumnInput, CellUncheckedCreateWithoutColumnInput> | CellCreateWithoutColumnInput[] | CellUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: CellCreateOrConnectWithoutColumnInput | CellCreateOrConnectWithoutColumnInput[]
    upsert?: CellUpsertWithWhereUniqueWithoutColumnInput | CellUpsertWithWhereUniqueWithoutColumnInput[]
    createMany?: CellCreateManyColumnInputEnvelope
    set?: CellWhereUniqueInput | CellWhereUniqueInput[]
    disconnect?: CellWhereUniqueInput | CellWhereUniqueInput[]
    delete?: CellWhereUniqueInput | CellWhereUniqueInput[]
    connect?: CellWhereUniqueInput | CellWhereUniqueInput[]
    update?: CellUpdateWithWhereUniqueWithoutColumnInput | CellUpdateWithWhereUniqueWithoutColumnInput[]
    updateMany?: CellUpdateManyWithWhereWithoutColumnInput | CellUpdateManyWithWhereWithoutColumnInput[]
    deleteMany?: CellScalarWhereInput | CellScalarWhereInput[]
  }

  export type TableUpdateOneRequiredWithoutColumnNestedInput = {
    create?: XOR<TableCreateWithoutColumnInput, TableUncheckedCreateWithoutColumnInput>
    connectOrCreate?: TableCreateOrConnectWithoutColumnInput
    upsert?: TableUpsertWithoutColumnInput
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutColumnInput, TableUpdateWithoutColumnInput>, TableUncheckedUpdateWithoutColumnInput>
  }

  export type FilterUpdateManyWithoutColumnNestedInput = {
    create?: XOR<FilterCreateWithoutColumnInput, FilterUncheckedCreateWithoutColumnInput> | FilterCreateWithoutColumnInput[] | FilterUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: FilterCreateOrConnectWithoutColumnInput | FilterCreateOrConnectWithoutColumnInput[]
    upsert?: FilterUpsertWithWhereUniqueWithoutColumnInput | FilterUpsertWithWhereUniqueWithoutColumnInput[]
    createMany?: FilterCreateManyColumnInputEnvelope
    set?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    disconnect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    delete?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    connect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    update?: FilterUpdateWithWhereUniqueWithoutColumnInput | FilterUpdateWithWhereUniqueWithoutColumnInput[]
    updateMany?: FilterUpdateManyWithWhereWithoutColumnInput | FilterUpdateManyWithWhereWithoutColumnInput[]
    deleteMany?: FilterScalarWhereInput | FilterScalarWhereInput[]
  }

  export type CellUncheckedUpdateManyWithoutColumnNestedInput = {
    create?: XOR<CellCreateWithoutColumnInput, CellUncheckedCreateWithoutColumnInput> | CellCreateWithoutColumnInput[] | CellUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: CellCreateOrConnectWithoutColumnInput | CellCreateOrConnectWithoutColumnInput[]
    upsert?: CellUpsertWithWhereUniqueWithoutColumnInput | CellUpsertWithWhereUniqueWithoutColumnInput[]
    createMany?: CellCreateManyColumnInputEnvelope
    set?: CellWhereUniqueInput | CellWhereUniqueInput[]
    disconnect?: CellWhereUniqueInput | CellWhereUniqueInput[]
    delete?: CellWhereUniqueInput | CellWhereUniqueInput[]
    connect?: CellWhereUniqueInput | CellWhereUniqueInput[]
    update?: CellUpdateWithWhereUniqueWithoutColumnInput | CellUpdateWithWhereUniqueWithoutColumnInput[]
    updateMany?: CellUpdateManyWithWhereWithoutColumnInput | CellUpdateManyWithWhereWithoutColumnInput[]
    deleteMany?: CellScalarWhereInput | CellScalarWhereInput[]
  }

  export type FilterUncheckedUpdateManyWithoutColumnNestedInput = {
    create?: XOR<FilterCreateWithoutColumnInput, FilterUncheckedCreateWithoutColumnInput> | FilterCreateWithoutColumnInput[] | FilterUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: FilterCreateOrConnectWithoutColumnInput | FilterCreateOrConnectWithoutColumnInput[]
    upsert?: FilterUpsertWithWhereUniqueWithoutColumnInput | FilterUpsertWithWhereUniqueWithoutColumnInput[]
    createMany?: FilterCreateManyColumnInputEnvelope
    set?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    disconnect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    delete?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    connect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    update?: FilterUpdateWithWhereUniqueWithoutColumnInput | FilterUpdateWithWhereUniqueWithoutColumnInput[]
    updateMany?: FilterUpdateManyWithWhereWithoutColumnInput | FilterUpdateManyWithWhereWithoutColumnInput[]
    deleteMany?: FilterScalarWhereInput | FilterScalarWhereInput[]
  }

  export type CellCreateNestedOneWithoutCommentInput = {
    create?: XOR<CellCreateWithoutCommentInput, CellUncheckedCreateWithoutCommentInput>
    connectOrCreate?: CellCreateOrConnectWithoutCommentInput
    connect?: CellWhereUniqueInput
  }

  export type CellUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<CellCreateWithoutCommentInput, CellUncheckedCreateWithoutCommentInput>
    connectOrCreate?: CellCreateOrConnectWithoutCommentInput
    upsert?: CellUpsertWithoutCommentInput
    connect?: CellWhereUniqueInput
    update?: XOR<XOR<CellUpdateToOneWithWhereWithoutCommentInput, CellUpdateWithoutCommentInput>, CellUncheckedUpdateWithoutCommentInput>
  }

  export type ColumnCreateNestedOneWithoutFilterInput = {
    create?: XOR<ColumnCreateWithoutFilterInput, ColumnUncheckedCreateWithoutFilterInput>
    connectOrCreate?: ColumnCreateOrConnectWithoutFilterInput
    connect?: ColumnWhereUniqueInput
  }

  export type TableCreateNestedOneWithoutFilterInput = {
    create?: XOR<TableCreateWithoutFilterInput, TableUncheckedCreateWithoutFilterInput>
    connectOrCreate?: TableCreateOrConnectWithoutFilterInput
    connect?: TableWhereUniqueInput
  }

  export type EnumFilterOperatorFieldUpdateOperationsInput = {
    set?: $Enums.FilterOperator
  }

  export type ColumnUpdateOneRequiredWithoutFilterNestedInput = {
    create?: XOR<ColumnCreateWithoutFilterInput, ColumnUncheckedCreateWithoutFilterInput>
    connectOrCreate?: ColumnCreateOrConnectWithoutFilterInput
    upsert?: ColumnUpsertWithoutFilterInput
    connect?: ColumnWhereUniqueInput
    update?: XOR<XOR<ColumnUpdateToOneWithWhereWithoutFilterInput, ColumnUpdateWithoutFilterInput>, ColumnUncheckedUpdateWithoutFilterInput>
  }

  export type TableUpdateOneRequiredWithoutFilterNestedInput = {
    create?: XOR<TableCreateWithoutFilterInput, TableUncheckedCreateWithoutFilterInput>
    connectOrCreate?: TableCreateOrConnectWithoutFilterInput
    upsert?: TableUpsertWithoutFilterInput
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutFilterInput, TableUpdateWithoutFilterInput>, TableUncheckedUpdateWithoutFilterInput>
  }

  export type SalaryCreateNestedOneWithoutFinRowInput = {
    create?: XOR<SalaryCreateWithoutFinRowInput, SalaryUncheckedCreateWithoutFinRowInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutFinRowInput
    connect?: SalaryWhereUniqueInput
  }

  export type FinRowExpenseCreateNestedManyWithoutFinRowInput = {
    create?: XOR<FinRowExpenseCreateWithoutFinRowInput, FinRowExpenseUncheckedCreateWithoutFinRowInput> | FinRowExpenseCreateWithoutFinRowInput[] | FinRowExpenseUncheckedCreateWithoutFinRowInput[]
    connectOrCreate?: FinRowExpenseCreateOrConnectWithoutFinRowInput | FinRowExpenseCreateOrConnectWithoutFinRowInput[]
    createMany?: FinRowExpenseCreateManyFinRowInputEnvelope
    connect?: FinRowExpenseWhereUniqueInput | FinRowExpenseWhereUniqueInput[]
  }

  export type FinRowExpenseUncheckedCreateNestedManyWithoutFinRowInput = {
    create?: XOR<FinRowExpenseCreateWithoutFinRowInput, FinRowExpenseUncheckedCreateWithoutFinRowInput> | FinRowExpenseCreateWithoutFinRowInput[] | FinRowExpenseUncheckedCreateWithoutFinRowInput[]
    connectOrCreate?: FinRowExpenseCreateOrConnectWithoutFinRowInput | FinRowExpenseCreateOrConnectWithoutFinRowInput[]
    createMany?: FinRowExpenseCreateManyFinRowInputEnvelope
    connect?: FinRowExpenseWhereUniqueInput | FinRowExpenseWhereUniqueInput[]
  }

  export type SalaryUpdateOneWithoutFinRowNestedInput = {
    create?: XOR<SalaryCreateWithoutFinRowInput, SalaryUncheckedCreateWithoutFinRowInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutFinRowInput
    upsert?: SalaryUpsertWithoutFinRowInput
    disconnect?: SalaryWhereInput | boolean
    delete?: SalaryWhereInput | boolean
    connect?: SalaryWhereUniqueInput
    update?: XOR<XOR<SalaryUpdateToOneWithWhereWithoutFinRowInput, SalaryUpdateWithoutFinRowInput>, SalaryUncheckedUpdateWithoutFinRowInput>
  }

  export type FinRowExpenseUpdateManyWithoutFinRowNestedInput = {
    create?: XOR<FinRowExpenseCreateWithoutFinRowInput, FinRowExpenseUncheckedCreateWithoutFinRowInput> | FinRowExpenseCreateWithoutFinRowInput[] | FinRowExpenseUncheckedCreateWithoutFinRowInput[]
    connectOrCreate?: FinRowExpenseCreateOrConnectWithoutFinRowInput | FinRowExpenseCreateOrConnectWithoutFinRowInput[]
    upsert?: FinRowExpenseUpsertWithWhereUniqueWithoutFinRowInput | FinRowExpenseUpsertWithWhereUniqueWithoutFinRowInput[]
    createMany?: FinRowExpenseCreateManyFinRowInputEnvelope
    set?: FinRowExpenseWhereUniqueInput | FinRowExpenseWhereUniqueInput[]
    disconnect?: FinRowExpenseWhereUniqueInput | FinRowExpenseWhereUniqueInput[]
    delete?: FinRowExpenseWhereUniqueInput | FinRowExpenseWhereUniqueInput[]
    connect?: FinRowExpenseWhereUniqueInput | FinRowExpenseWhereUniqueInput[]
    update?: FinRowExpenseUpdateWithWhereUniqueWithoutFinRowInput | FinRowExpenseUpdateWithWhereUniqueWithoutFinRowInput[]
    updateMany?: FinRowExpenseUpdateManyWithWhereWithoutFinRowInput | FinRowExpenseUpdateManyWithWhereWithoutFinRowInput[]
    deleteMany?: FinRowExpenseScalarWhereInput | FinRowExpenseScalarWhereInput[]
  }

  export type FinRowExpenseUncheckedUpdateManyWithoutFinRowNestedInput = {
    create?: XOR<FinRowExpenseCreateWithoutFinRowInput, FinRowExpenseUncheckedCreateWithoutFinRowInput> | FinRowExpenseCreateWithoutFinRowInput[] | FinRowExpenseUncheckedCreateWithoutFinRowInput[]
    connectOrCreate?: FinRowExpenseCreateOrConnectWithoutFinRowInput | FinRowExpenseCreateOrConnectWithoutFinRowInput[]
    upsert?: FinRowExpenseUpsertWithWhereUniqueWithoutFinRowInput | FinRowExpenseUpsertWithWhereUniqueWithoutFinRowInput[]
    createMany?: FinRowExpenseCreateManyFinRowInputEnvelope
    set?: FinRowExpenseWhereUniqueInput | FinRowExpenseWhereUniqueInput[]
    disconnect?: FinRowExpenseWhereUniqueInput | FinRowExpenseWhereUniqueInput[]
    delete?: FinRowExpenseWhereUniqueInput | FinRowExpenseWhereUniqueInput[]
    connect?: FinRowExpenseWhereUniqueInput | FinRowExpenseWhereUniqueInput[]
    update?: FinRowExpenseUpdateWithWhereUniqueWithoutFinRowInput | FinRowExpenseUpdateWithWhereUniqueWithoutFinRowInput[]
    updateMany?: FinRowExpenseUpdateManyWithWhereWithoutFinRowInput | FinRowExpenseUpdateManyWithWhereWithoutFinRowInput[]
    deleteMany?: FinRowExpenseScalarWhereInput | FinRowExpenseScalarWhereInput[]
  }

  export type FinRowCreateNestedOneWithoutFinRowExpenseInput = {
    create?: XOR<FinRowCreateWithoutFinRowExpenseInput, FinRowUncheckedCreateWithoutFinRowExpenseInput>
    connectOrCreate?: FinRowCreateOrConnectWithoutFinRowExpenseInput
    connect?: FinRowWhereUniqueInput
  }

  export type FinRowUpdateOneWithoutFinRowExpenseNestedInput = {
    create?: XOR<FinRowCreateWithoutFinRowExpenseInput, FinRowUncheckedCreateWithoutFinRowExpenseInput>
    connectOrCreate?: FinRowCreateOrConnectWithoutFinRowExpenseInput
    upsert?: FinRowUpsertWithoutFinRowExpenseInput
    disconnect?: FinRowWhereInput | boolean
    delete?: FinRowWhereInput | boolean
    connect?: FinRowWhereUniqueInput
    update?: XOR<XOR<FinRowUpdateToOneWithWhereWithoutFinRowExpenseInput, FinRowUpdateWithoutFinRowExpenseInput>, FinRowUncheckedUpdateWithoutFinRowExpenseInput>
  }

  export type IdexSyncOrderCreateNestedManyWithoutIdexCabinetInput = {
    create?: XOR<IdexSyncOrderCreateWithoutIdexCabinetInput, IdexSyncOrderUncheckedCreateWithoutIdexCabinetInput> | IdexSyncOrderCreateWithoutIdexCabinetInput[] | IdexSyncOrderUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: IdexSyncOrderCreateOrConnectWithoutIdexCabinetInput | IdexSyncOrderCreateOrConnectWithoutIdexCabinetInput[]
    createMany?: IdexSyncOrderCreateManyIdexCabinetInputEnvelope
    connect?: IdexSyncOrderWhereUniqueInput | IdexSyncOrderWhereUniqueInput[]
  }

  export type IdexTransactionCreateNestedManyWithoutIdexCabinetInput = {
    create?: XOR<IdexTransactionCreateWithoutIdexCabinetInput, IdexTransactionUncheckedCreateWithoutIdexCabinetInput> | IdexTransactionCreateWithoutIdexCabinetInput[] | IdexTransactionUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: IdexTransactionCreateOrConnectWithoutIdexCabinetInput | IdexTransactionCreateOrConnectWithoutIdexCabinetInput[]
    createMany?: IdexTransactionCreateManyIdexCabinetInputEnvelope
    connect?: IdexTransactionWhereUniqueInput | IdexTransactionWhereUniqueInput[]
  }

  export type WorkSessionIdexCabinetCreateNestedManyWithoutIdexCabinetInput = {
    create?: XOR<WorkSessionIdexCabinetCreateWithoutIdexCabinetInput, WorkSessionIdexCabinetUncheckedCreateWithoutIdexCabinetInput> | WorkSessionIdexCabinetCreateWithoutIdexCabinetInput[] | WorkSessionIdexCabinetUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: WorkSessionIdexCabinetCreateOrConnectWithoutIdexCabinetInput | WorkSessionIdexCabinetCreateOrConnectWithoutIdexCabinetInput[]
    createMany?: WorkSessionIdexCabinetCreateManyIdexCabinetInputEnvelope
    connect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
  }

  export type IdexSyncOrderUncheckedCreateNestedManyWithoutIdexCabinetInput = {
    create?: XOR<IdexSyncOrderCreateWithoutIdexCabinetInput, IdexSyncOrderUncheckedCreateWithoutIdexCabinetInput> | IdexSyncOrderCreateWithoutIdexCabinetInput[] | IdexSyncOrderUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: IdexSyncOrderCreateOrConnectWithoutIdexCabinetInput | IdexSyncOrderCreateOrConnectWithoutIdexCabinetInput[]
    createMany?: IdexSyncOrderCreateManyIdexCabinetInputEnvelope
    connect?: IdexSyncOrderWhereUniqueInput | IdexSyncOrderWhereUniqueInput[]
  }

  export type IdexTransactionUncheckedCreateNestedManyWithoutIdexCabinetInput = {
    create?: XOR<IdexTransactionCreateWithoutIdexCabinetInput, IdexTransactionUncheckedCreateWithoutIdexCabinetInput> | IdexTransactionCreateWithoutIdexCabinetInput[] | IdexTransactionUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: IdexTransactionCreateOrConnectWithoutIdexCabinetInput | IdexTransactionCreateOrConnectWithoutIdexCabinetInput[]
    createMany?: IdexTransactionCreateManyIdexCabinetInputEnvelope
    connect?: IdexTransactionWhereUniqueInput | IdexTransactionWhereUniqueInput[]
  }

  export type WorkSessionIdexCabinetUncheckedCreateNestedManyWithoutIdexCabinetInput = {
    create?: XOR<WorkSessionIdexCabinetCreateWithoutIdexCabinetInput, WorkSessionIdexCabinetUncheckedCreateWithoutIdexCabinetInput> | WorkSessionIdexCabinetCreateWithoutIdexCabinetInput[] | WorkSessionIdexCabinetUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: WorkSessionIdexCabinetCreateOrConnectWithoutIdexCabinetInput | WorkSessionIdexCabinetCreateOrConnectWithoutIdexCabinetInput[]
    createMany?: WorkSessionIdexCabinetCreateManyIdexCabinetInputEnvelope
    connect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
  }

  export type IdexSyncOrderUpdateManyWithoutIdexCabinetNestedInput = {
    create?: XOR<IdexSyncOrderCreateWithoutIdexCabinetInput, IdexSyncOrderUncheckedCreateWithoutIdexCabinetInput> | IdexSyncOrderCreateWithoutIdexCabinetInput[] | IdexSyncOrderUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: IdexSyncOrderCreateOrConnectWithoutIdexCabinetInput | IdexSyncOrderCreateOrConnectWithoutIdexCabinetInput[]
    upsert?: IdexSyncOrderUpsertWithWhereUniqueWithoutIdexCabinetInput | IdexSyncOrderUpsertWithWhereUniqueWithoutIdexCabinetInput[]
    createMany?: IdexSyncOrderCreateManyIdexCabinetInputEnvelope
    set?: IdexSyncOrderWhereUniqueInput | IdexSyncOrderWhereUniqueInput[]
    disconnect?: IdexSyncOrderWhereUniqueInput | IdexSyncOrderWhereUniqueInput[]
    delete?: IdexSyncOrderWhereUniqueInput | IdexSyncOrderWhereUniqueInput[]
    connect?: IdexSyncOrderWhereUniqueInput | IdexSyncOrderWhereUniqueInput[]
    update?: IdexSyncOrderUpdateWithWhereUniqueWithoutIdexCabinetInput | IdexSyncOrderUpdateWithWhereUniqueWithoutIdexCabinetInput[]
    updateMany?: IdexSyncOrderUpdateManyWithWhereWithoutIdexCabinetInput | IdexSyncOrderUpdateManyWithWhereWithoutIdexCabinetInput[]
    deleteMany?: IdexSyncOrderScalarWhereInput | IdexSyncOrderScalarWhereInput[]
  }

  export type IdexTransactionUpdateManyWithoutIdexCabinetNestedInput = {
    create?: XOR<IdexTransactionCreateWithoutIdexCabinetInput, IdexTransactionUncheckedCreateWithoutIdexCabinetInput> | IdexTransactionCreateWithoutIdexCabinetInput[] | IdexTransactionUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: IdexTransactionCreateOrConnectWithoutIdexCabinetInput | IdexTransactionCreateOrConnectWithoutIdexCabinetInput[]
    upsert?: IdexTransactionUpsertWithWhereUniqueWithoutIdexCabinetInput | IdexTransactionUpsertWithWhereUniqueWithoutIdexCabinetInput[]
    createMany?: IdexTransactionCreateManyIdexCabinetInputEnvelope
    set?: IdexTransactionWhereUniqueInput | IdexTransactionWhereUniqueInput[]
    disconnect?: IdexTransactionWhereUniqueInput | IdexTransactionWhereUniqueInput[]
    delete?: IdexTransactionWhereUniqueInput | IdexTransactionWhereUniqueInput[]
    connect?: IdexTransactionWhereUniqueInput | IdexTransactionWhereUniqueInput[]
    update?: IdexTransactionUpdateWithWhereUniqueWithoutIdexCabinetInput | IdexTransactionUpdateWithWhereUniqueWithoutIdexCabinetInput[]
    updateMany?: IdexTransactionUpdateManyWithWhereWithoutIdexCabinetInput | IdexTransactionUpdateManyWithWhereWithoutIdexCabinetInput[]
    deleteMany?: IdexTransactionScalarWhereInput | IdexTransactionScalarWhereInput[]
  }

  export type WorkSessionIdexCabinetUpdateManyWithoutIdexCabinetNestedInput = {
    create?: XOR<WorkSessionIdexCabinetCreateWithoutIdexCabinetInput, WorkSessionIdexCabinetUncheckedCreateWithoutIdexCabinetInput> | WorkSessionIdexCabinetCreateWithoutIdexCabinetInput[] | WorkSessionIdexCabinetUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: WorkSessionIdexCabinetCreateOrConnectWithoutIdexCabinetInput | WorkSessionIdexCabinetCreateOrConnectWithoutIdexCabinetInput[]
    upsert?: WorkSessionIdexCabinetUpsertWithWhereUniqueWithoutIdexCabinetInput | WorkSessionIdexCabinetUpsertWithWhereUniqueWithoutIdexCabinetInput[]
    createMany?: WorkSessionIdexCabinetCreateManyIdexCabinetInputEnvelope
    set?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    disconnect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    delete?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    connect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    update?: WorkSessionIdexCabinetUpdateWithWhereUniqueWithoutIdexCabinetInput | WorkSessionIdexCabinetUpdateWithWhereUniqueWithoutIdexCabinetInput[]
    updateMany?: WorkSessionIdexCabinetUpdateManyWithWhereWithoutIdexCabinetInput | WorkSessionIdexCabinetUpdateManyWithWhereWithoutIdexCabinetInput[]
    deleteMany?: WorkSessionIdexCabinetScalarWhereInput | WorkSessionIdexCabinetScalarWhereInput[]
  }

  export type IdexSyncOrderUncheckedUpdateManyWithoutIdexCabinetNestedInput = {
    create?: XOR<IdexSyncOrderCreateWithoutIdexCabinetInput, IdexSyncOrderUncheckedCreateWithoutIdexCabinetInput> | IdexSyncOrderCreateWithoutIdexCabinetInput[] | IdexSyncOrderUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: IdexSyncOrderCreateOrConnectWithoutIdexCabinetInput | IdexSyncOrderCreateOrConnectWithoutIdexCabinetInput[]
    upsert?: IdexSyncOrderUpsertWithWhereUniqueWithoutIdexCabinetInput | IdexSyncOrderUpsertWithWhereUniqueWithoutIdexCabinetInput[]
    createMany?: IdexSyncOrderCreateManyIdexCabinetInputEnvelope
    set?: IdexSyncOrderWhereUniqueInput | IdexSyncOrderWhereUniqueInput[]
    disconnect?: IdexSyncOrderWhereUniqueInput | IdexSyncOrderWhereUniqueInput[]
    delete?: IdexSyncOrderWhereUniqueInput | IdexSyncOrderWhereUniqueInput[]
    connect?: IdexSyncOrderWhereUniqueInput | IdexSyncOrderWhereUniqueInput[]
    update?: IdexSyncOrderUpdateWithWhereUniqueWithoutIdexCabinetInput | IdexSyncOrderUpdateWithWhereUniqueWithoutIdexCabinetInput[]
    updateMany?: IdexSyncOrderUpdateManyWithWhereWithoutIdexCabinetInput | IdexSyncOrderUpdateManyWithWhereWithoutIdexCabinetInput[]
    deleteMany?: IdexSyncOrderScalarWhereInput | IdexSyncOrderScalarWhereInput[]
  }

  export type IdexTransactionUncheckedUpdateManyWithoutIdexCabinetNestedInput = {
    create?: XOR<IdexTransactionCreateWithoutIdexCabinetInput, IdexTransactionUncheckedCreateWithoutIdexCabinetInput> | IdexTransactionCreateWithoutIdexCabinetInput[] | IdexTransactionUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: IdexTransactionCreateOrConnectWithoutIdexCabinetInput | IdexTransactionCreateOrConnectWithoutIdexCabinetInput[]
    upsert?: IdexTransactionUpsertWithWhereUniqueWithoutIdexCabinetInput | IdexTransactionUpsertWithWhereUniqueWithoutIdexCabinetInput[]
    createMany?: IdexTransactionCreateManyIdexCabinetInputEnvelope
    set?: IdexTransactionWhereUniqueInput | IdexTransactionWhereUniqueInput[]
    disconnect?: IdexTransactionWhereUniqueInput | IdexTransactionWhereUniqueInput[]
    delete?: IdexTransactionWhereUniqueInput | IdexTransactionWhereUniqueInput[]
    connect?: IdexTransactionWhereUniqueInput | IdexTransactionWhereUniqueInput[]
    update?: IdexTransactionUpdateWithWhereUniqueWithoutIdexCabinetInput | IdexTransactionUpdateWithWhereUniqueWithoutIdexCabinetInput[]
    updateMany?: IdexTransactionUpdateManyWithWhereWithoutIdexCabinetInput | IdexTransactionUpdateManyWithWhereWithoutIdexCabinetInput[]
    deleteMany?: IdexTransactionScalarWhereInput | IdexTransactionScalarWhereInput[]
  }

  export type WorkSessionIdexCabinetUncheckedUpdateManyWithoutIdexCabinetNestedInput = {
    create?: XOR<WorkSessionIdexCabinetCreateWithoutIdexCabinetInput, WorkSessionIdexCabinetUncheckedCreateWithoutIdexCabinetInput> | WorkSessionIdexCabinetCreateWithoutIdexCabinetInput[] | WorkSessionIdexCabinetUncheckedCreateWithoutIdexCabinetInput[]
    connectOrCreate?: WorkSessionIdexCabinetCreateOrConnectWithoutIdexCabinetInput | WorkSessionIdexCabinetCreateOrConnectWithoutIdexCabinetInput[]
    upsert?: WorkSessionIdexCabinetUpsertWithWhereUniqueWithoutIdexCabinetInput | WorkSessionIdexCabinetUpsertWithWhereUniqueWithoutIdexCabinetInput[]
    createMany?: WorkSessionIdexCabinetCreateManyIdexCabinetInputEnvelope
    set?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    disconnect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    delete?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    connect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    update?: WorkSessionIdexCabinetUpdateWithWhereUniqueWithoutIdexCabinetInput | WorkSessionIdexCabinetUpdateWithWhereUniqueWithoutIdexCabinetInput[]
    updateMany?: WorkSessionIdexCabinetUpdateManyWithWhereWithoutIdexCabinetInput | WorkSessionIdexCabinetUpdateManyWithWhereWithoutIdexCabinetInput[]
    deleteMany?: WorkSessionIdexCabinetScalarWhereInput | WorkSessionIdexCabinetScalarWhereInput[]
  }

  export type IdexSyncOrderCreatepagesInput = {
    set: number[]
  }

  export type IdexCabinetCreateNestedOneWithoutIdexSyncOrderInput = {
    create?: XOR<IdexCabinetCreateWithoutIdexSyncOrderInput, IdexCabinetUncheckedCreateWithoutIdexSyncOrderInput>
    connectOrCreate?: IdexCabinetCreateOrConnectWithoutIdexSyncOrderInput
    connect?: IdexCabinetWhereUniqueInput
  }

  export type EnumIdexSyncOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.IdexSyncOrderStatus
  }

  export type IdexSyncOrderUpdatepagesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type IdexCabinetUpdateOneWithoutIdexSyncOrderNestedInput = {
    create?: XOR<IdexCabinetCreateWithoutIdexSyncOrderInput, IdexCabinetUncheckedCreateWithoutIdexSyncOrderInput>
    connectOrCreate?: IdexCabinetCreateOrConnectWithoutIdexSyncOrderInput
    upsert?: IdexCabinetUpsertWithoutIdexSyncOrderInput
    disconnect?: IdexCabinetWhereInput | boolean
    delete?: IdexCabinetWhereInput | boolean
    connect?: IdexCabinetWhereUniqueInput
    update?: XOR<XOR<IdexCabinetUpdateToOneWithWhereWithoutIdexSyncOrderInput, IdexCabinetUpdateWithoutIdexSyncOrderInput>, IdexCabinetUncheckedUpdateWithoutIdexSyncOrderInput>
  }

  export type BybitClipMatchCreateNestedManyWithoutIdexTransactionInput = {
    create?: XOR<BybitClipMatchCreateWithoutIdexTransactionInput, BybitClipMatchUncheckedCreateWithoutIdexTransactionInput> | BybitClipMatchCreateWithoutIdexTransactionInput[] | BybitClipMatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutIdexTransactionInput | BybitClipMatchCreateOrConnectWithoutIdexTransactionInput[]
    createMany?: BybitClipMatchCreateManyIdexTransactionInputEnvelope
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
  }

  export type BybitMatchCreateNestedManyWithoutIdexTransactionInput = {
    create?: XOR<BybitMatchCreateWithoutIdexTransactionInput, BybitMatchUncheckedCreateWithoutIdexTransactionInput> | BybitMatchCreateWithoutIdexTransactionInput[] | BybitMatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: BybitMatchCreateOrConnectWithoutIdexTransactionInput | BybitMatchCreateOrConnectWithoutIdexTransactionInput[]
    createMany?: BybitMatchCreateManyIdexTransactionInputEnvelope
    connect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
  }

  export type IdexCabinetCreateNestedOneWithoutIdexTransactionInput = {
    create?: XOR<IdexCabinetCreateWithoutIdexTransactionInput, IdexCabinetUncheckedCreateWithoutIdexTransactionInput>
    connectOrCreate?: IdexCabinetCreateOrConnectWithoutIdexTransactionInput
    connect?: IdexCabinetWhereUniqueInput
  }

  export type MatchCreateNestedManyWithoutIdexTransactionInput = {
    create?: XOR<MatchCreateWithoutIdexTransactionInput, MatchUncheckedCreateWithoutIdexTransactionInput> | MatchCreateWithoutIdexTransactionInput[] | MatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutIdexTransactionInput | MatchCreateOrConnectWithoutIdexTransactionInput[]
    createMany?: MatchCreateManyIdexTransactionInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type BybitClipMatchUncheckedCreateNestedManyWithoutIdexTransactionInput = {
    create?: XOR<BybitClipMatchCreateWithoutIdexTransactionInput, BybitClipMatchUncheckedCreateWithoutIdexTransactionInput> | BybitClipMatchCreateWithoutIdexTransactionInput[] | BybitClipMatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutIdexTransactionInput | BybitClipMatchCreateOrConnectWithoutIdexTransactionInput[]
    createMany?: BybitClipMatchCreateManyIdexTransactionInputEnvelope
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
  }

  export type BybitMatchUncheckedCreateNestedManyWithoutIdexTransactionInput = {
    create?: XOR<BybitMatchCreateWithoutIdexTransactionInput, BybitMatchUncheckedCreateWithoutIdexTransactionInput> | BybitMatchCreateWithoutIdexTransactionInput[] | BybitMatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: BybitMatchCreateOrConnectWithoutIdexTransactionInput | BybitMatchCreateOrConnectWithoutIdexTransactionInput[]
    createMany?: BybitMatchCreateManyIdexTransactionInputEnvelope
    connect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutIdexTransactionInput = {
    create?: XOR<MatchCreateWithoutIdexTransactionInput, MatchUncheckedCreateWithoutIdexTransactionInput> | MatchCreateWithoutIdexTransactionInput[] | MatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutIdexTransactionInput | MatchCreateOrConnectWithoutIdexTransactionInput[]
    createMany?: MatchCreateManyIdexTransactionInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BybitClipMatchUpdateManyWithoutIdexTransactionNestedInput = {
    create?: XOR<BybitClipMatchCreateWithoutIdexTransactionInput, BybitClipMatchUncheckedCreateWithoutIdexTransactionInput> | BybitClipMatchCreateWithoutIdexTransactionInput[] | BybitClipMatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutIdexTransactionInput | BybitClipMatchCreateOrConnectWithoutIdexTransactionInput[]
    upsert?: BybitClipMatchUpsertWithWhereUniqueWithoutIdexTransactionInput | BybitClipMatchUpsertWithWhereUniqueWithoutIdexTransactionInput[]
    createMany?: BybitClipMatchCreateManyIdexTransactionInputEnvelope
    set?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    disconnect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    delete?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    update?: BybitClipMatchUpdateWithWhereUniqueWithoutIdexTransactionInput | BybitClipMatchUpdateWithWhereUniqueWithoutIdexTransactionInput[]
    updateMany?: BybitClipMatchUpdateManyWithWhereWithoutIdexTransactionInput | BybitClipMatchUpdateManyWithWhereWithoutIdexTransactionInput[]
    deleteMany?: BybitClipMatchScalarWhereInput | BybitClipMatchScalarWhereInput[]
  }

  export type BybitMatchUpdateManyWithoutIdexTransactionNestedInput = {
    create?: XOR<BybitMatchCreateWithoutIdexTransactionInput, BybitMatchUncheckedCreateWithoutIdexTransactionInput> | BybitMatchCreateWithoutIdexTransactionInput[] | BybitMatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: BybitMatchCreateOrConnectWithoutIdexTransactionInput | BybitMatchCreateOrConnectWithoutIdexTransactionInput[]
    upsert?: BybitMatchUpsertWithWhereUniqueWithoutIdexTransactionInput | BybitMatchUpsertWithWhereUniqueWithoutIdexTransactionInput[]
    createMany?: BybitMatchCreateManyIdexTransactionInputEnvelope
    set?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    disconnect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    delete?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    connect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    update?: BybitMatchUpdateWithWhereUniqueWithoutIdexTransactionInput | BybitMatchUpdateWithWhereUniqueWithoutIdexTransactionInput[]
    updateMany?: BybitMatchUpdateManyWithWhereWithoutIdexTransactionInput | BybitMatchUpdateManyWithWhereWithoutIdexTransactionInput[]
    deleteMany?: BybitMatchScalarWhereInput | BybitMatchScalarWhereInput[]
  }

  export type IdexCabinetUpdateOneRequiredWithoutIdexTransactionNestedInput = {
    create?: XOR<IdexCabinetCreateWithoutIdexTransactionInput, IdexCabinetUncheckedCreateWithoutIdexTransactionInput>
    connectOrCreate?: IdexCabinetCreateOrConnectWithoutIdexTransactionInput
    upsert?: IdexCabinetUpsertWithoutIdexTransactionInput
    connect?: IdexCabinetWhereUniqueInput
    update?: XOR<XOR<IdexCabinetUpdateToOneWithWhereWithoutIdexTransactionInput, IdexCabinetUpdateWithoutIdexTransactionInput>, IdexCabinetUncheckedUpdateWithoutIdexTransactionInput>
  }

  export type MatchUpdateManyWithoutIdexTransactionNestedInput = {
    create?: XOR<MatchCreateWithoutIdexTransactionInput, MatchUncheckedCreateWithoutIdexTransactionInput> | MatchCreateWithoutIdexTransactionInput[] | MatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutIdexTransactionInput | MatchCreateOrConnectWithoutIdexTransactionInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutIdexTransactionInput | MatchUpsertWithWhereUniqueWithoutIdexTransactionInput[]
    createMany?: MatchCreateManyIdexTransactionInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutIdexTransactionInput | MatchUpdateWithWhereUniqueWithoutIdexTransactionInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutIdexTransactionInput | MatchUpdateManyWithWhereWithoutIdexTransactionInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type BybitClipMatchUncheckedUpdateManyWithoutIdexTransactionNestedInput = {
    create?: XOR<BybitClipMatchCreateWithoutIdexTransactionInput, BybitClipMatchUncheckedCreateWithoutIdexTransactionInput> | BybitClipMatchCreateWithoutIdexTransactionInput[] | BybitClipMatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutIdexTransactionInput | BybitClipMatchCreateOrConnectWithoutIdexTransactionInput[]
    upsert?: BybitClipMatchUpsertWithWhereUniqueWithoutIdexTransactionInput | BybitClipMatchUpsertWithWhereUniqueWithoutIdexTransactionInput[]
    createMany?: BybitClipMatchCreateManyIdexTransactionInputEnvelope
    set?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    disconnect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    delete?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    update?: BybitClipMatchUpdateWithWhereUniqueWithoutIdexTransactionInput | BybitClipMatchUpdateWithWhereUniqueWithoutIdexTransactionInput[]
    updateMany?: BybitClipMatchUpdateManyWithWhereWithoutIdexTransactionInput | BybitClipMatchUpdateManyWithWhereWithoutIdexTransactionInput[]
    deleteMany?: BybitClipMatchScalarWhereInput | BybitClipMatchScalarWhereInput[]
  }

  export type BybitMatchUncheckedUpdateManyWithoutIdexTransactionNestedInput = {
    create?: XOR<BybitMatchCreateWithoutIdexTransactionInput, BybitMatchUncheckedCreateWithoutIdexTransactionInput> | BybitMatchCreateWithoutIdexTransactionInput[] | BybitMatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: BybitMatchCreateOrConnectWithoutIdexTransactionInput | BybitMatchCreateOrConnectWithoutIdexTransactionInput[]
    upsert?: BybitMatchUpsertWithWhereUniqueWithoutIdexTransactionInput | BybitMatchUpsertWithWhereUniqueWithoutIdexTransactionInput[]
    createMany?: BybitMatchCreateManyIdexTransactionInputEnvelope
    set?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    disconnect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    delete?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    connect?: BybitMatchWhereUniqueInput | BybitMatchWhereUniqueInput[]
    update?: BybitMatchUpdateWithWhereUniqueWithoutIdexTransactionInput | BybitMatchUpdateWithWhereUniqueWithoutIdexTransactionInput[]
    updateMany?: BybitMatchUpdateManyWithWhereWithoutIdexTransactionInput | BybitMatchUpdateManyWithWhereWithoutIdexTransactionInput[]
    deleteMany?: BybitMatchScalarWhereInput | BybitMatchScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutIdexTransactionNestedInput = {
    create?: XOR<MatchCreateWithoutIdexTransactionInput, MatchUncheckedCreateWithoutIdexTransactionInput> | MatchCreateWithoutIdexTransactionInput[] | MatchUncheckedCreateWithoutIdexTransactionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutIdexTransactionInput | MatchCreateOrConnectWithoutIdexTransactionInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutIdexTransactionInput | MatchUpsertWithWhereUniqueWithoutIdexTransactionInput[]
    createMany?: MatchCreateManyIdexTransactionInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutIdexTransactionInput | MatchUpdateWithWhereUniqueWithoutIdexTransactionInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutIdexTransactionInput | MatchUpdateManyWithWhereWithoutIdexTransactionInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type IdexTransactionCreateNestedOneWithoutMatchInput = {
    create?: XOR<IdexTransactionCreateWithoutMatchInput, IdexTransactionUncheckedCreateWithoutMatchInput>
    connectOrCreate?: IdexTransactionCreateOrConnectWithoutMatchInput
    connect?: IdexTransactionWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutMatchInput = {
    create?: XOR<TransactionCreateWithoutMatchInput, TransactionUncheckedCreateWithoutMatchInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutMatchInput
    connect?: TransactionWhereUniqueInput
  }

  export type IdexTransactionUpdateOneRequiredWithoutMatchNestedInput = {
    create?: XOR<IdexTransactionCreateWithoutMatchInput, IdexTransactionUncheckedCreateWithoutMatchInput>
    connectOrCreate?: IdexTransactionCreateOrConnectWithoutMatchInput
    upsert?: IdexTransactionUpsertWithoutMatchInput
    connect?: IdexTransactionWhereUniqueInput
    update?: XOR<XOR<IdexTransactionUpdateToOneWithWhereWithoutMatchInput, IdexTransactionUpdateWithoutMatchInput>, IdexTransactionUncheckedUpdateWithoutMatchInput>
  }

  export type TransactionUpdateOneRequiredWithoutMatchNestedInput = {
    create?: XOR<TransactionCreateWithoutMatchInput, TransactionUncheckedCreateWithoutMatchInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutMatchInput
    upsert?: TransactionUpsertWithoutMatchInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutMatchInput, TransactionUpdateWithoutMatchInput>, TransactionUncheckedUpdateWithoutMatchInput>
  }

  export type NullableEnumPasswordTypeFieldUpdateOperationsInput = {
    set?: $Enums.PasswordType | null
  }

  export type UserCreateNestedOneWithoutReportNotificationInput = {
    create?: XOR<UserCreateWithoutReportNotificationInput, UserUncheckedCreateWithoutReportNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReportNotificationNestedInput = {
    create?: XOR<UserCreateWithoutReportNotificationInput, UserUncheckedCreateWithoutReportNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportNotificationInput
    upsert?: UserUpsertWithoutReportNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportNotificationInput, UserUpdateWithoutReportNotificationInput>, UserUncheckedUpdateWithoutReportNotificationInput>
  }

  export type CellCreateNestedManyWithoutRowInput = {
    create?: XOR<CellCreateWithoutRowInput, CellUncheckedCreateWithoutRowInput> | CellCreateWithoutRowInput[] | CellUncheckedCreateWithoutRowInput[]
    connectOrCreate?: CellCreateOrConnectWithoutRowInput | CellCreateOrConnectWithoutRowInput[]
    createMany?: CellCreateManyRowInputEnvelope
    connect?: CellWhereUniqueInput | CellWhereUniqueInput[]
  }

  export type TableCreateNestedOneWithoutRowInput = {
    create?: XOR<TableCreateWithoutRowInput, TableUncheckedCreateWithoutRowInput>
    connectOrCreate?: TableCreateOrConnectWithoutRowInput
    connect?: TableWhereUniqueInput
  }

  export type CellUncheckedCreateNestedManyWithoutRowInput = {
    create?: XOR<CellCreateWithoutRowInput, CellUncheckedCreateWithoutRowInput> | CellCreateWithoutRowInput[] | CellUncheckedCreateWithoutRowInput[]
    connectOrCreate?: CellCreateOrConnectWithoutRowInput | CellCreateOrConnectWithoutRowInput[]
    createMany?: CellCreateManyRowInputEnvelope
    connect?: CellWhereUniqueInput | CellWhereUniqueInput[]
  }

  export type CellUpdateManyWithoutRowNestedInput = {
    create?: XOR<CellCreateWithoutRowInput, CellUncheckedCreateWithoutRowInput> | CellCreateWithoutRowInput[] | CellUncheckedCreateWithoutRowInput[]
    connectOrCreate?: CellCreateOrConnectWithoutRowInput | CellCreateOrConnectWithoutRowInput[]
    upsert?: CellUpsertWithWhereUniqueWithoutRowInput | CellUpsertWithWhereUniqueWithoutRowInput[]
    createMany?: CellCreateManyRowInputEnvelope
    set?: CellWhereUniqueInput | CellWhereUniqueInput[]
    disconnect?: CellWhereUniqueInput | CellWhereUniqueInput[]
    delete?: CellWhereUniqueInput | CellWhereUniqueInput[]
    connect?: CellWhereUniqueInput | CellWhereUniqueInput[]
    update?: CellUpdateWithWhereUniqueWithoutRowInput | CellUpdateWithWhereUniqueWithoutRowInput[]
    updateMany?: CellUpdateManyWithWhereWithoutRowInput | CellUpdateManyWithWhereWithoutRowInput[]
    deleteMany?: CellScalarWhereInput | CellScalarWhereInput[]
  }

  export type TableUpdateOneRequiredWithoutRowNestedInput = {
    create?: XOR<TableCreateWithoutRowInput, TableUncheckedCreateWithoutRowInput>
    connectOrCreate?: TableCreateOrConnectWithoutRowInput
    upsert?: TableUpsertWithoutRowInput
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutRowInput, TableUpdateWithoutRowInput>, TableUncheckedUpdateWithoutRowInput>
  }

  export type CellUncheckedUpdateManyWithoutRowNestedInput = {
    create?: XOR<CellCreateWithoutRowInput, CellUncheckedCreateWithoutRowInput> | CellCreateWithoutRowInput[] | CellUncheckedCreateWithoutRowInput[]
    connectOrCreate?: CellCreateOrConnectWithoutRowInput | CellCreateOrConnectWithoutRowInput[]
    upsert?: CellUpsertWithWhereUniqueWithoutRowInput | CellUpsertWithWhereUniqueWithoutRowInput[]
    createMany?: CellCreateManyRowInputEnvelope
    set?: CellWhereUniqueInput | CellWhereUniqueInput[]
    disconnect?: CellWhereUniqueInput | CellWhereUniqueInput[]
    delete?: CellWhereUniqueInput | CellWhereUniqueInput[]
    connect?: CellWhereUniqueInput | CellWhereUniqueInput[]
    update?: CellUpdateWithWhereUniqueWithoutRowInput | CellUpdateWithWhereUniqueWithoutRowInput[]
    updateMany?: CellUpdateManyWithWhereWithoutRowInput | CellUpdateManyWithWhereWithoutRowInput[]
    deleteMany?: CellScalarWhereInput | CellScalarWhereInput[]
  }

  export type FinRowCreateNestedManyWithoutSalaryInput = {
    create?: XOR<FinRowCreateWithoutSalaryInput, FinRowUncheckedCreateWithoutSalaryInput> | FinRowCreateWithoutSalaryInput[] | FinRowUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: FinRowCreateOrConnectWithoutSalaryInput | FinRowCreateOrConnectWithoutSalaryInput[]
    createMany?: FinRowCreateManySalaryInputEnvelope
    connect?: FinRowWhereUniqueInput | FinRowWhereUniqueInput[]
  }

  export type SalaryDebtCreateNestedManyWithoutSalaryInput = {
    create?: XOR<SalaryDebtCreateWithoutSalaryInput, SalaryDebtUncheckedCreateWithoutSalaryInput> | SalaryDebtCreateWithoutSalaryInput[] | SalaryDebtUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryDebtCreateOrConnectWithoutSalaryInput | SalaryDebtCreateOrConnectWithoutSalaryInput[]
    createMany?: SalaryDebtCreateManySalaryInputEnvelope
    connect?: SalaryDebtWhereUniqueInput | SalaryDebtWhereUniqueInput[]
  }

  export type SalaryEarningCreateNestedManyWithoutSalaryInput = {
    create?: XOR<SalaryEarningCreateWithoutSalaryInput, SalaryEarningUncheckedCreateWithoutSalaryInput> | SalaryEarningCreateWithoutSalaryInput[] | SalaryEarningUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryEarningCreateOrConnectWithoutSalaryInput | SalaryEarningCreateOrConnectWithoutSalaryInput[]
    createMany?: SalaryEarningCreateManySalaryInputEnvelope
    connect?: SalaryEarningWhereUniqueInput | SalaryEarningWhereUniqueInput[]
  }

  export type SalaryPaymentCreateNestedManyWithoutSalaryInput = {
    create?: XOR<SalaryPaymentCreateWithoutSalaryInput, SalaryPaymentUncheckedCreateWithoutSalaryInput> | SalaryPaymentCreateWithoutSalaryInput[] | SalaryPaymentUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutSalaryInput | SalaryPaymentCreateOrConnectWithoutSalaryInput[]
    createMany?: SalaryPaymentCreateManySalaryInputEnvelope
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
  }

  export type ShiftReportCreateNestedManyWithoutSalaryInput = {
    create?: XOR<ShiftReportCreateWithoutSalaryInput, ShiftReportUncheckedCreateWithoutSalaryInput> | ShiftReportCreateWithoutSalaryInput[] | ShiftReportUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: ShiftReportCreateOrConnectWithoutSalaryInput | ShiftReportCreateOrConnectWithoutSalaryInput[]
    createMany?: ShiftReportCreateManySalaryInputEnvelope
    connect?: ShiftReportWhereUniqueInput | ShiftReportWhereUniqueInput[]
  }

  export type FinRowUncheckedCreateNestedManyWithoutSalaryInput = {
    create?: XOR<FinRowCreateWithoutSalaryInput, FinRowUncheckedCreateWithoutSalaryInput> | FinRowCreateWithoutSalaryInput[] | FinRowUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: FinRowCreateOrConnectWithoutSalaryInput | FinRowCreateOrConnectWithoutSalaryInput[]
    createMany?: FinRowCreateManySalaryInputEnvelope
    connect?: FinRowWhereUniqueInput | FinRowWhereUniqueInput[]
  }

  export type SalaryDebtUncheckedCreateNestedManyWithoutSalaryInput = {
    create?: XOR<SalaryDebtCreateWithoutSalaryInput, SalaryDebtUncheckedCreateWithoutSalaryInput> | SalaryDebtCreateWithoutSalaryInput[] | SalaryDebtUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryDebtCreateOrConnectWithoutSalaryInput | SalaryDebtCreateOrConnectWithoutSalaryInput[]
    createMany?: SalaryDebtCreateManySalaryInputEnvelope
    connect?: SalaryDebtWhereUniqueInput | SalaryDebtWhereUniqueInput[]
  }

  export type SalaryEarningUncheckedCreateNestedManyWithoutSalaryInput = {
    create?: XOR<SalaryEarningCreateWithoutSalaryInput, SalaryEarningUncheckedCreateWithoutSalaryInput> | SalaryEarningCreateWithoutSalaryInput[] | SalaryEarningUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryEarningCreateOrConnectWithoutSalaryInput | SalaryEarningCreateOrConnectWithoutSalaryInput[]
    createMany?: SalaryEarningCreateManySalaryInputEnvelope
    connect?: SalaryEarningWhereUniqueInput | SalaryEarningWhereUniqueInput[]
  }

  export type SalaryPaymentUncheckedCreateNestedManyWithoutSalaryInput = {
    create?: XOR<SalaryPaymentCreateWithoutSalaryInput, SalaryPaymentUncheckedCreateWithoutSalaryInput> | SalaryPaymentCreateWithoutSalaryInput[] | SalaryPaymentUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutSalaryInput | SalaryPaymentCreateOrConnectWithoutSalaryInput[]
    createMany?: SalaryPaymentCreateManySalaryInputEnvelope
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
  }

  export type ShiftReportUncheckedCreateNestedManyWithoutSalaryInput = {
    create?: XOR<ShiftReportCreateWithoutSalaryInput, ShiftReportUncheckedCreateWithoutSalaryInput> | ShiftReportCreateWithoutSalaryInput[] | ShiftReportUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: ShiftReportCreateOrConnectWithoutSalaryInput | ShiftReportCreateOrConnectWithoutSalaryInput[]
    createMany?: ShiftReportCreateManySalaryInputEnvelope
    connect?: ShiftReportWhereUniqueInput | ShiftReportWhereUniqueInput[]
  }

  export type EnumPeriodTypeFieldUpdateOperationsInput = {
    set?: $Enums.PeriodType
  }

  export type FinRowUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<FinRowCreateWithoutSalaryInput, FinRowUncheckedCreateWithoutSalaryInput> | FinRowCreateWithoutSalaryInput[] | FinRowUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: FinRowCreateOrConnectWithoutSalaryInput | FinRowCreateOrConnectWithoutSalaryInput[]
    upsert?: FinRowUpsertWithWhereUniqueWithoutSalaryInput | FinRowUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: FinRowCreateManySalaryInputEnvelope
    set?: FinRowWhereUniqueInput | FinRowWhereUniqueInput[]
    disconnect?: FinRowWhereUniqueInput | FinRowWhereUniqueInput[]
    delete?: FinRowWhereUniqueInput | FinRowWhereUniqueInput[]
    connect?: FinRowWhereUniqueInput | FinRowWhereUniqueInput[]
    update?: FinRowUpdateWithWhereUniqueWithoutSalaryInput | FinRowUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: FinRowUpdateManyWithWhereWithoutSalaryInput | FinRowUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: FinRowScalarWhereInput | FinRowScalarWhereInput[]
  }

  export type SalaryDebtUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<SalaryDebtCreateWithoutSalaryInput, SalaryDebtUncheckedCreateWithoutSalaryInput> | SalaryDebtCreateWithoutSalaryInput[] | SalaryDebtUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryDebtCreateOrConnectWithoutSalaryInput | SalaryDebtCreateOrConnectWithoutSalaryInput[]
    upsert?: SalaryDebtUpsertWithWhereUniqueWithoutSalaryInput | SalaryDebtUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: SalaryDebtCreateManySalaryInputEnvelope
    set?: SalaryDebtWhereUniqueInput | SalaryDebtWhereUniqueInput[]
    disconnect?: SalaryDebtWhereUniqueInput | SalaryDebtWhereUniqueInput[]
    delete?: SalaryDebtWhereUniqueInput | SalaryDebtWhereUniqueInput[]
    connect?: SalaryDebtWhereUniqueInput | SalaryDebtWhereUniqueInput[]
    update?: SalaryDebtUpdateWithWhereUniqueWithoutSalaryInput | SalaryDebtUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: SalaryDebtUpdateManyWithWhereWithoutSalaryInput | SalaryDebtUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: SalaryDebtScalarWhereInput | SalaryDebtScalarWhereInput[]
  }

  export type SalaryEarningUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<SalaryEarningCreateWithoutSalaryInput, SalaryEarningUncheckedCreateWithoutSalaryInput> | SalaryEarningCreateWithoutSalaryInput[] | SalaryEarningUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryEarningCreateOrConnectWithoutSalaryInput | SalaryEarningCreateOrConnectWithoutSalaryInput[]
    upsert?: SalaryEarningUpsertWithWhereUniqueWithoutSalaryInput | SalaryEarningUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: SalaryEarningCreateManySalaryInputEnvelope
    set?: SalaryEarningWhereUniqueInput | SalaryEarningWhereUniqueInput[]
    disconnect?: SalaryEarningWhereUniqueInput | SalaryEarningWhereUniqueInput[]
    delete?: SalaryEarningWhereUniqueInput | SalaryEarningWhereUniqueInput[]
    connect?: SalaryEarningWhereUniqueInput | SalaryEarningWhereUniqueInput[]
    update?: SalaryEarningUpdateWithWhereUniqueWithoutSalaryInput | SalaryEarningUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: SalaryEarningUpdateManyWithWhereWithoutSalaryInput | SalaryEarningUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: SalaryEarningScalarWhereInput | SalaryEarningScalarWhereInput[]
  }

  export type SalaryPaymentUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutSalaryInput, SalaryPaymentUncheckedCreateWithoutSalaryInput> | SalaryPaymentCreateWithoutSalaryInput[] | SalaryPaymentUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutSalaryInput | SalaryPaymentCreateOrConnectWithoutSalaryInput[]
    upsert?: SalaryPaymentUpsertWithWhereUniqueWithoutSalaryInput | SalaryPaymentUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: SalaryPaymentCreateManySalaryInputEnvelope
    set?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    disconnect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    delete?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    update?: SalaryPaymentUpdateWithWhereUniqueWithoutSalaryInput | SalaryPaymentUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: SalaryPaymentUpdateManyWithWhereWithoutSalaryInput | SalaryPaymentUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
  }

  export type ShiftReportUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<ShiftReportCreateWithoutSalaryInput, ShiftReportUncheckedCreateWithoutSalaryInput> | ShiftReportCreateWithoutSalaryInput[] | ShiftReportUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: ShiftReportCreateOrConnectWithoutSalaryInput | ShiftReportCreateOrConnectWithoutSalaryInput[]
    upsert?: ShiftReportUpsertWithWhereUniqueWithoutSalaryInput | ShiftReportUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: ShiftReportCreateManySalaryInputEnvelope
    set?: ShiftReportWhereUniqueInput | ShiftReportWhereUniqueInput[]
    disconnect?: ShiftReportWhereUniqueInput | ShiftReportWhereUniqueInput[]
    delete?: ShiftReportWhereUniqueInput | ShiftReportWhereUniqueInput[]
    connect?: ShiftReportWhereUniqueInput | ShiftReportWhereUniqueInput[]
    update?: ShiftReportUpdateWithWhereUniqueWithoutSalaryInput | ShiftReportUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: ShiftReportUpdateManyWithWhereWithoutSalaryInput | ShiftReportUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: ShiftReportScalarWhereInput | ShiftReportScalarWhereInput[]
  }

  export type FinRowUncheckedUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<FinRowCreateWithoutSalaryInput, FinRowUncheckedCreateWithoutSalaryInput> | FinRowCreateWithoutSalaryInput[] | FinRowUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: FinRowCreateOrConnectWithoutSalaryInput | FinRowCreateOrConnectWithoutSalaryInput[]
    upsert?: FinRowUpsertWithWhereUniqueWithoutSalaryInput | FinRowUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: FinRowCreateManySalaryInputEnvelope
    set?: FinRowWhereUniqueInput | FinRowWhereUniqueInput[]
    disconnect?: FinRowWhereUniqueInput | FinRowWhereUniqueInput[]
    delete?: FinRowWhereUniqueInput | FinRowWhereUniqueInput[]
    connect?: FinRowWhereUniqueInput | FinRowWhereUniqueInput[]
    update?: FinRowUpdateWithWhereUniqueWithoutSalaryInput | FinRowUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: FinRowUpdateManyWithWhereWithoutSalaryInput | FinRowUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: FinRowScalarWhereInput | FinRowScalarWhereInput[]
  }

  export type SalaryDebtUncheckedUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<SalaryDebtCreateWithoutSalaryInput, SalaryDebtUncheckedCreateWithoutSalaryInput> | SalaryDebtCreateWithoutSalaryInput[] | SalaryDebtUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryDebtCreateOrConnectWithoutSalaryInput | SalaryDebtCreateOrConnectWithoutSalaryInput[]
    upsert?: SalaryDebtUpsertWithWhereUniqueWithoutSalaryInput | SalaryDebtUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: SalaryDebtCreateManySalaryInputEnvelope
    set?: SalaryDebtWhereUniqueInput | SalaryDebtWhereUniqueInput[]
    disconnect?: SalaryDebtWhereUniqueInput | SalaryDebtWhereUniqueInput[]
    delete?: SalaryDebtWhereUniqueInput | SalaryDebtWhereUniqueInput[]
    connect?: SalaryDebtWhereUniqueInput | SalaryDebtWhereUniqueInput[]
    update?: SalaryDebtUpdateWithWhereUniqueWithoutSalaryInput | SalaryDebtUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: SalaryDebtUpdateManyWithWhereWithoutSalaryInput | SalaryDebtUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: SalaryDebtScalarWhereInput | SalaryDebtScalarWhereInput[]
  }

  export type SalaryEarningUncheckedUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<SalaryEarningCreateWithoutSalaryInput, SalaryEarningUncheckedCreateWithoutSalaryInput> | SalaryEarningCreateWithoutSalaryInput[] | SalaryEarningUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryEarningCreateOrConnectWithoutSalaryInput | SalaryEarningCreateOrConnectWithoutSalaryInput[]
    upsert?: SalaryEarningUpsertWithWhereUniqueWithoutSalaryInput | SalaryEarningUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: SalaryEarningCreateManySalaryInputEnvelope
    set?: SalaryEarningWhereUniqueInput | SalaryEarningWhereUniqueInput[]
    disconnect?: SalaryEarningWhereUniqueInput | SalaryEarningWhereUniqueInput[]
    delete?: SalaryEarningWhereUniqueInput | SalaryEarningWhereUniqueInput[]
    connect?: SalaryEarningWhereUniqueInput | SalaryEarningWhereUniqueInput[]
    update?: SalaryEarningUpdateWithWhereUniqueWithoutSalaryInput | SalaryEarningUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: SalaryEarningUpdateManyWithWhereWithoutSalaryInput | SalaryEarningUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: SalaryEarningScalarWhereInput | SalaryEarningScalarWhereInput[]
  }

  export type SalaryPaymentUncheckedUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutSalaryInput, SalaryPaymentUncheckedCreateWithoutSalaryInput> | SalaryPaymentCreateWithoutSalaryInput[] | SalaryPaymentUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutSalaryInput | SalaryPaymentCreateOrConnectWithoutSalaryInput[]
    upsert?: SalaryPaymentUpsertWithWhereUniqueWithoutSalaryInput | SalaryPaymentUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: SalaryPaymentCreateManySalaryInputEnvelope
    set?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    disconnect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    delete?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    update?: SalaryPaymentUpdateWithWhereUniqueWithoutSalaryInput | SalaryPaymentUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: SalaryPaymentUpdateManyWithWhereWithoutSalaryInput | SalaryPaymentUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
  }

  export type ShiftReportUncheckedUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<ShiftReportCreateWithoutSalaryInput, ShiftReportUncheckedCreateWithoutSalaryInput> | ShiftReportCreateWithoutSalaryInput[] | ShiftReportUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: ShiftReportCreateOrConnectWithoutSalaryInput | ShiftReportCreateOrConnectWithoutSalaryInput[]
    upsert?: ShiftReportUpsertWithWhereUniqueWithoutSalaryInput | ShiftReportUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: ShiftReportCreateManySalaryInputEnvelope
    set?: ShiftReportWhereUniqueInput | ShiftReportWhereUniqueInput[]
    disconnect?: ShiftReportWhereUniqueInput | ShiftReportWhereUniqueInput[]
    delete?: ShiftReportWhereUniqueInput | ShiftReportWhereUniqueInput[]
    connect?: ShiftReportWhereUniqueInput | ShiftReportWhereUniqueInput[]
    update?: ShiftReportUpdateWithWhereUniqueWithoutSalaryInput | ShiftReportUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: ShiftReportUpdateManyWithWhereWithoutSalaryInput | ShiftReportUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: ShiftReportScalarWhereInput | ShiftReportScalarWhereInput[]
  }

  export type SalaryCreateNestedOneWithoutSalaryDebtInput = {
    create?: XOR<SalaryCreateWithoutSalaryDebtInput, SalaryUncheckedCreateWithoutSalaryDebtInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutSalaryDebtInput
    connect?: SalaryWhereUniqueInput
  }

  export type SalaryUpdateOneRequiredWithoutSalaryDebtNestedInput = {
    create?: XOR<SalaryCreateWithoutSalaryDebtInput, SalaryUncheckedCreateWithoutSalaryDebtInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutSalaryDebtInput
    upsert?: SalaryUpsertWithoutSalaryDebtInput
    connect?: SalaryWhereUniqueInput
    update?: XOR<XOR<SalaryUpdateToOneWithWhereWithoutSalaryDebtInput, SalaryUpdateWithoutSalaryDebtInput>, SalaryUncheckedUpdateWithoutSalaryDebtInput>
  }

  export type SalaryCreateNestedOneWithoutSalaryEarningInput = {
    create?: XOR<SalaryCreateWithoutSalaryEarningInput, SalaryUncheckedCreateWithoutSalaryEarningInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutSalaryEarningInput
    connect?: SalaryWhereUniqueInput
  }

  export type SalaryUpdateOneRequiredWithoutSalaryEarningNestedInput = {
    create?: XOR<SalaryCreateWithoutSalaryEarningInput, SalaryUncheckedCreateWithoutSalaryEarningInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutSalaryEarningInput
    upsert?: SalaryUpsertWithoutSalaryEarningInput
    connect?: SalaryWhereUniqueInput
    update?: XOR<XOR<SalaryUpdateToOneWithWhereWithoutSalaryEarningInput, SalaryUpdateWithoutSalaryEarningInput>, SalaryUncheckedUpdateWithoutSalaryEarningInput>
  }

  export type SalaryCreateNestedOneWithoutSalaryPaymentInput = {
    create?: XOR<SalaryCreateWithoutSalaryPaymentInput, SalaryUncheckedCreateWithoutSalaryPaymentInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutSalaryPaymentInput
    connect?: SalaryWhereUniqueInput
  }

  export type SalaryUpdateOneRequiredWithoutSalaryPaymentNestedInput = {
    create?: XOR<SalaryCreateWithoutSalaryPaymentInput, SalaryUncheckedCreateWithoutSalaryPaymentInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutSalaryPaymentInput
    upsert?: SalaryUpsertWithoutSalaryPaymentInput
    connect?: SalaryWhereUniqueInput
    update?: XOR<XOR<SalaryUpdateToOneWithWhereWithoutSalaryPaymentInput, SalaryUpdateWithoutSalaryPaymentInput>, SalaryUncheckedUpdateWithoutSalaryPaymentInput>
  }

  export type TableCreateNestedManyWithoutSectionInput = {
    create?: XOR<TableCreateWithoutSectionInput, TableUncheckedCreateWithoutSectionInput> | TableCreateWithoutSectionInput[] | TableUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TableCreateOrConnectWithoutSectionInput | TableCreateOrConnectWithoutSectionInput[]
    createMany?: TableCreateManySectionInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TableUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<TableCreateWithoutSectionInput, TableUncheckedCreateWithoutSectionInput> | TableCreateWithoutSectionInput[] | TableUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TableCreateOrConnectWithoutSectionInput | TableCreateOrConnectWithoutSectionInput[]
    createMany?: TableCreateManySectionInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TableUpdateManyWithoutSectionNestedInput = {
    create?: XOR<TableCreateWithoutSectionInput, TableUncheckedCreateWithoutSectionInput> | TableCreateWithoutSectionInput[] | TableUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TableCreateOrConnectWithoutSectionInput | TableCreateOrConnectWithoutSectionInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutSectionInput | TableUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: TableCreateManySectionInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutSectionInput | TableUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: TableUpdateManyWithWhereWithoutSectionInput | TableUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type TableUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<TableCreateWithoutSectionInput, TableUncheckedCreateWithoutSectionInput> | TableCreateWithoutSectionInput[] | TableUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TableCreateOrConnectWithoutSectionInput | TableCreateOrConnectWithoutSectionInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutSectionInput | TableUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: TableCreateManySectionInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutSectionInput | TableUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: TableUpdateManyWithWhereWithoutSectionInput | TableUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type SalaryCreateNestedOneWithoutShiftReportInput = {
    create?: XOR<SalaryCreateWithoutShiftReportInput, SalaryUncheckedCreateWithoutShiftReportInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutShiftReportInput
    connect?: SalaryWhereUniqueInput
  }

  export type ShiftReportExpenseCreateNestedManyWithoutShiftReportInput = {
    create?: XOR<ShiftReportExpenseCreateWithoutShiftReportInput, ShiftReportExpenseUncheckedCreateWithoutShiftReportInput> | ShiftReportExpenseCreateWithoutShiftReportInput[] | ShiftReportExpenseUncheckedCreateWithoutShiftReportInput[]
    connectOrCreate?: ShiftReportExpenseCreateOrConnectWithoutShiftReportInput | ShiftReportExpenseCreateOrConnectWithoutShiftReportInput[]
    createMany?: ShiftReportExpenseCreateManyShiftReportInputEnvelope
    connect?: ShiftReportExpenseWhereUniqueInput | ShiftReportExpenseWhereUniqueInput[]
  }

  export type ShiftReportExpenseUncheckedCreateNestedManyWithoutShiftReportInput = {
    create?: XOR<ShiftReportExpenseCreateWithoutShiftReportInput, ShiftReportExpenseUncheckedCreateWithoutShiftReportInput> | ShiftReportExpenseCreateWithoutShiftReportInput[] | ShiftReportExpenseUncheckedCreateWithoutShiftReportInput[]
    connectOrCreate?: ShiftReportExpenseCreateOrConnectWithoutShiftReportInput | ShiftReportExpenseCreateOrConnectWithoutShiftReportInput[]
    createMany?: ShiftReportExpenseCreateManyShiftReportInputEnvelope
    connect?: ShiftReportExpenseWhereUniqueInput | ShiftReportExpenseWhereUniqueInput[]
  }

  export type SalaryUpdateOneWithoutShiftReportNestedInput = {
    create?: XOR<SalaryCreateWithoutShiftReportInput, SalaryUncheckedCreateWithoutShiftReportInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutShiftReportInput
    upsert?: SalaryUpsertWithoutShiftReportInput
    disconnect?: SalaryWhereInput | boolean
    delete?: SalaryWhereInput | boolean
    connect?: SalaryWhereUniqueInput
    update?: XOR<XOR<SalaryUpdateToOneWithWhereWithoutShiftReportInput, SalaryUpdateWithoutShiftReportInput>, SalaryUncheckedUpdateWithoutShiftReportInput>
  }

  export type ShiftReportExpenseUpdateManyWithoutShiftReportNestedInput = {
    create?: XOR<ShiftReportExpenseCreateWithoutShiftReportInput, ShiftReportExpenseUncheckedCreateWithoutShiftReportInput> | ShiftReportExpenseCreateWithoutShiftReportInput[] | ShiftReportExpenseUncheckedCreateWithoutShiftReportInput[]
    connectOrCreate?: ShiftReportExpenseCreateOrConnectWithoutShiftReportInput | ShiftReportExpenseCreateOrConnectWithoutShiftReportInput[]
    upsert?: ShiftReportExpenseUpsertWithWhereUniqueWithoutShiftReportInput | ShiftReportExpenseUpsertWithWhereUniqueWithoutShiftReportInput[]
    createMany?: ShiftReportExpenseCreateManyShiftReportInputEnvelope
    set?: ShiftReportExpenseWhereUniqueInput | ShiftReportExpenseWhereUniqueInput[]
    disconnect?: ShiftReportExpenseWhereUniqueInput | ShiftReportExpenseWhereUniqueInput[]
    delete?: ShiftReportExpenseWhereUniqueInput | ShiftReportExpenseWhereUniqueInput[]
    connect?: ShiftReportExpenseWhereUniqueInput | ShiftReportExpenseWhereUniqueInput[]
    update?: ShiftReportExpenseUpdateWithWhereUniqueWithoutShiftReportInput | ShiftReportExpenseUpdateWithWhereUniqueWithoutShiftReportInput[]
    updateMany?: ShiftReportExpenseUpdateManyWithWhereWithoutShiftReportInput | ShiftReportExpenseUpdateManyWithWhereWithoutShiftReportInput[]
    deleteMany?: ShiftReportExpenseScalarWhereInput | ShiftReportExpenseScalarWhereInput[]
  }

  export type ShiftReportExpenseUncheckedUpdateManyWithoutShiftReportNestedInput = {
    create?: XOR<ShiftReportExpenseCreateWithoutShiftReportInput, ShiftReportExpenseUncheckedCreateWithoutShiftReportInput> | ShiftReportExpenseCreateWithoutShiftReportInput[] | ShiftReportExpenseUncheckedCreateWithoutShiftReportInput[]
    connectOrCreate?: ShiftReportExpenseCreateOrConnectWithoutShiftReportInput | ShiftReportExpenseCreateOrConnectWithoutShiftReportInput[]
    upsert?: ShiftReportExpenseUpsertWithWhereUniqueWithoutShiftReportInput | ShiftReportExpenseUpsertWithWhereUniqueWithoutShiftReportInput[]
    createMany?: ShiftReportExpenseCreateManyShiftReportInputEnvelope
    set?: ShiftReportExpenseWhereUniqueInput | ShiftReportExpenseWhereUniqueInput[]
    disconnect?: ShiftReportExpenseWhereUniqueInput | ShiftReportExpenseWhereUniqueInput[]
    delete?: ShiftReportExpenseWhereUniqueInput | ShiftReportExpenseWhereUniqueInput[]
    connect?: ShiftReportExpenseWhereUniqueInput | ShiftReportExpenseWhereUniqueInput[]
    update?: ShiftReportExpenseUpdateWithWhereUniqueWithoutShiftReportInput | ShiftReportExpenseUpdateWithWhereUniqueWithoutShiftReportInput[]
    updateMany?: ShiftReportExpenseUpdateManyWithWhereWithoutShiftReportInput | ShiftReportExpenseUpdateManyWithWhereWithoutShiftReportInput[]
    deleteMany?: ShiftReportExpenseScalarWhereInput | ShiftReportExpenseScalarWhereInput[]
  }

  export type ShiftReportCreateNestedOneWithoutShiftReportExpenseInput = {
    create?: XOR<ShiftReportCreateWithoutShiftReportExpenseInput, ShiftReportUncheckedCreateWithoutShiftReportExpenseInput>
    connectOrCreate?: ShiftReportCreateOrConnectWithoutShiftReportExpenseInput
    connect?: ShiftReportWhereUniqueInput
  }

  export type ShiftReportUpdateOneWithoutShiftReportExpenseNestedInput = {
    create?: XOR<ShiftReportCreateWithoutShiftReportExpenseInput, ShiftReportUncheckedCreateWithoutShiftReportExpenseInput>
    connectOrCreate?: ShiftReportCreateOrConnectWithoutShiftReportExpenseInput
    upsert?: ShiftReportUpsertWithoutShiftReportExpenseInput
    disconnect?: ShiftReportWhereInput | boolean
    delete?: ShiftReportWhereInput | boolean
    connect?: ShiftReportWhereUniqueInput
    update?: XOR<XOR<ShiftReportUpdateToOneWithWhereWithoutShiftReportExpenseInput, ShiftReportUpdateWithoutShiftReportExpenseInput>, ShiftReportUncheckedUpdateWithoutShiftReportExpenseInput>
  }

  export type ColumnCreateNestedManyWithoutTableInput = {
    create?: XOR<ColumnCreateWithoutTableInput, ColumnUncheckedCreateWithoutTableInput> | ColumnCreateWithoutTableInput[] | ColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutTableInput | ColumnCreateOrConnectWithoutTableInput[]
    createMany?: ColumnCreateManyTableInputEnvelope
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
  }

  export type FilterCreateNestedManyWithoutTableInput = {
    create?: XOR<FilterCreateWithoutTableInput, FilterUncheckedCreateWithoutTableInput> | FilterCreateWithoutTableInput[] | FilterUncheckedCreateWithoutTableInput[]
    connectOrCreate?: FilterCreateOrConnectWithoutTableInput | FilterCreateOrConnectWithoutTableInput[]
    createMany?: FilterCreateManyTableInputEnvelope
    connect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
  }

  export type RowCreateNestedManyWithoutTableInput = {
    create?: XOR<RowCreateWithoutTableInput, RowUncheckedCreateWithoutTableInput> | RowCreateWithoutTableInput[] | RowUncheckedCreateWithoutTableInput[]
    connectOrCreate?: RowCreateOrConnectWithoutTableInput | RowCreateOrConnectWithoutTableInput[]
    createMany?: RowCreateManyTableInputEnvelope
    connect?: RowWhereUniqueInput | RowWhereUniqueInput[]
  }

  export type SectionCreateNestedOneWithoutTableInput = {
    create?: XOR<SectionCreateWithoutTableInput, SectionUncheckedCreateWithoutTableInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTableInput
    connect?: SectionWhereUniqueInput
  }

  export type ColumnUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<ColumnCreateWithoutTableInput, ColumnUncheckedCreateWithoutTableInput> | ColumnCreateWithoutTableInput[] | ColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutTableInput | ColumnCreateOrConnectWithoutTableInput[]
    createMany?: ColumnCreateManyTableInputEnvelope
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
  }

  export type FilterUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<FilterCreateWithoutTableInput, FilterUncheckedCreateWithoutTableInput> | FilterCreateWithoutTableInput[] | FilterUncheckedCreateWithoutTableInput[]
    connectOrCreate?: FilterCreateOrConnectWithoutTableInput | FilterCreateOrConnectWithoutTableInput[]
    createMany?: FilterCreateManyTableInputEnvelope
    connect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
  }

  export type RowUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<RowCreateWithoutTableInput, RowUncheckedCreateWithoutTableInput> | RowCreateWithoutTableInput[] | RowUncheckedCreateWithoutTableInput[]
    connectOrCreate?: RowCreateOrConnectWithoutTableInput | RowCreateOrConnectWithoutTableInput[]
    createMany?: RowCreateManyTableInputEnvelope
    connect?: RowWhereUniqueInput | RowWhereUniqueInput[]
  }

  export type ColumnUpdateManyWithoutTableNestedInput = {
    create?: XOR<ColumnCreateWithoutTableInput, ColumnUncheckedCreateWithoutTableInput> | ColumnCreateWithoutTableInput[] | ColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutTableInput | ColumnCreateOrConnectWithoutTableInput[]
    upsert?: ColumnUpsertWithWhereUniqueWithoutTableInput | ColumnUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: ColumnCreateManyTableInputEnvelope
    set?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    disconnect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    delete?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    update?: ColumnUpdateWithWhereUniqueWithoutTableInput | ColumnUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: ColumnUpdateManyWithWhereWithoutTableInput | ColumnUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
  }

  export type FilterUpdateManyWithoutTableNestedInput = {
    create?: XOR<FilterCreateWithoutTableInput, FilterUncheckedCreateWithoutTableInput> | FilterCreateWithoutTableInput[] | FilterUncheckedCreateWithoutTableInput[]
    connectOrCreate?: FilterCreateOrConnectWithoutTableInput | FilterCreateOrConnectWithoutTableInput[]
    upsert?: FilterUpsertWithWhereUniqueWithoutTableInput | FilterUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: FilterCreateManyTableInputEnvelope
    set?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    disconnect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    delete?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    connect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    update?: FilterUpdateWithWhereUniqueWithoutTableInput | FilterUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: FilterUpdateManyWithWhereWithoutTableInput | FilterUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: FilterScalarWhereInput | FilterScalarWhereInput[]
  }

  export type RowUpdateManyWithoutTableNestedInput = {
    create?: XOR<RowCreateWithoutTableInput, RowUncheckedCreateWithoutTableInput> | RowCreateWithoutTableInput[] | RowUncheckedCreateWithoutTableInput[]
    connectOrCreate?: RowCreateOrConnectWithoutTableInput | RowCreateOrConnectWithoutTableInput[]
    upsert?: RowUpsertWithWhereUniqueWithoutTableInput | RowUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: RowCreateManyTableInputEnvelope
    set?: RowWhereUniqueInput | RowWhereUniqueInput[]
    disconnect?: RowWhereUniqueInput | RowWhereUniqueInput[]
    delete?: RowWhereUniqueInput | RowWhereUniqueInput[]
    connect?: RowWhereUniqueInput | RowWhereUniqueInput[]
    update?: RowUpdateWithWhereUniqueWithoutTableInput | RowUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: RowUpdateManyWithWhereWithoutTableInput | RowUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: RowScalarWhereInput | RowScalarWhereInput[]
  }

  export type SectionUpdateOneRequiredWithoutTableNestedInput = {
    create?: XOR<SectionCreateWithoutTableInput, SectionUncheckedCreateWithoutTableInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTableInput
    upsert?: SectionUpsertWithoutTableInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutTableInput, SectionUpdateWithoutTableInput>, SectionUncheckedUpdateWithoutTableInput>
  }

  export type ColumnUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<ColumnCreateWithoutTableInput, ColumnUncheckedCreateWithoutTableInput> | ColumnCreateWithoutTableInput[] | ColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutTableInput | ColumnCreateOrConnectWithoutTableInput[]
    upsert?: ColumnUpsertWithWhereUniqueWithoutTableInput | ColumnUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: ColumnCreateManyTableInputEnvelope
    set?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    disconnect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    delete?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    update?: ColumnUpdateWithWhereUniqueWithoutTableInput | ColumnUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: ColumnUpdateManyWithWhereWithoutTableInput | ColumnUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
  }

  export type FilterUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<FilterCreateWithoutTableInput, FilterUncheckedCreateWithoutTableInput> | FilterCreateWithoutTableInput[] | FilterUncheckedCreateWithoutTableInput[]
    connectOrCreate?: FilterCreateOrConnectWithoutTableInput | FilterCreateOrConnectWithoutTableInput[]
    upsert?: FilterUpsertWithWhereUniqueWithoutTableInput | FilterUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: FilterCreateManyTableInputEnvelope
    set?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    disconnect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    delete?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    connect?: FilterWhereUniqueInput | FilterWhereUniqueInput[]
    update?: FilterUpdateWithWhereUniqueWithoutTableInput | FilterUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: FilterUpdateManyWithWhereWithoutTableInput | FilterUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: FilterScalarWhereInput | FilterScalarWhereInput[]
  }

  export type RowUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<RowCreateWithoutTableInput, RowUncheckedCreateWithoutTableInput> | RowCreateWithoutTableInput[] | RowUncheckedCreateWithoutTableInput[]
    connectOrCreate?: RowCreateOrConnectWithoutTableInput | RowCreateOrConnectWithoutTableInput[]
    upsert?: RowUpsertWithWhereUniqueWithoutTableInput | RowUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: RowCreateManyTableInputEnvelope
    set?: RowWhereUniqueInput | RowWhereUniqueInput[]
    disconnect?: RowWhereUniqueInput | RowWhereUniqueInput[]
    delete?: RowWhereUniqueInput | RowWhereUniqueInput[]
    connect?: RowWhereUniqueInput | RowWhereUniqueInput[]
    update?: RowUpdateWithWhereUniqueWithoutTableInput | RowUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: RowUpdateManyWithWhereWithoutTableInput | RowUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: RowScalarWhereInput | RowScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTelegramAccountInput = {
    create?: XOR<UserCreateWithoutTelegramAccountInput, UserUncheckedCreateWithoutTelegramAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutTelegramAccountInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTelegramAccountNestedInput = {
    create?: XOR<UserCreateWithoutTelegramAccountInput, UserUncheckedCreateWithoutTelegramAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutTelegramAccountInput
    upsert?: UserUpsertWithoutTelegramAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTelegramAccountInput, UserUpdateWithoutTelegramAccountInput>, UserUncheckedUpdateWithoutTelegramAccountInput>
  }

  export type MatchCreateNestedManyWithoutTransactionInput = {
    create?: XOR<MatchCreateWithoutTransactionInput, MatchUncheckedCreateWithoutTransactionInput> | MatchCreateWithoutTransactionInput[] | MatchUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTransactionInput | MatchCreateOrConnectWithoutTransactionInput[]
    createMany?: MatchCreateManyTransactionInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutTransactionInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type MatchUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<MatchCreateWithoutTransactionInput, MatchUncheckedCreateWithoutTransactionInput> | MatchCreateWithoutTransactionInput[] | MatchUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTransactionInput | MatchCreateOrConnectWithoutTransactionInput[]
    createMany?: MatchCreateManyTransactionInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<MatchCreateWithoutTransactionInput, MatchUncheckedCreateWithoutTransactionInput> | MatchCreateWithoutTransactionInput[] | MatchUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTransactionInput | MatchCreateOrConnectWithoutTransactionInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutTransactionInput | MatchUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: MatchCreateManyTransactionInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutTransactionInput | MatchUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutTransactionInput | MatchUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    upsert?: UserUpsertWithoutTransactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionInput, UserUpdateWithoutTransactionInput>, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type MatchUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<MatchCreateWithoutTransactionInput, MatchUncheckedCreateWithoutTransactionInput> | MatchCreateWithoutTransactionInput[] | MatchUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTransactionInput | MatchCreateOrConnectWithoutTransactionInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutTransactionInput | MatchUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: MatchCreateManyTransactionInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutTransactionInput | MatchUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutTransactionInput | MatchUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BybitClipMatchCreateNestedManyWithoutUserInput = {
    create?: XOR<BybitClipMatchCreateWithoutUserInput, BybitClipMatchUncheckedCreateWithoutUserInput> | BybitClipMatchCreateWithoutUserInput[] | BybitClipMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutUserInput | BybitClipMatchCreateOrConnectWithoutUserInput[]
    createMany?: BybitClipMatchCreateManyUserInputEnvelope
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
  }

  export type BybitTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<BybitTransactionCreateWithoutUserInput, BybitTransactionUncheckedCreateWithoutUserInput> | BybitTransactionCreateWithoutUserInput[] | BybitTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BybitTransactionCreateOrConnectWithoutUserInput | BybitTransactionCreateOrConnectWithoutUserInput[]
    createMany?: BybitTransactionCreateManyUserInputEnvelope
    connect?: BybitTransactionWhereUniqueInput | BybitTransactionWhereUniqueInput[]
  }

  export type MatchBybitReportCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchBybitReportCreateWithoutUserInput, MatchBybitReportUncheckedCreateWithoutUserInput> | MatchBybitReportCreateWithoutUserInput[] | MatchBybitReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchBybitReportCreateOrConnectWithoutUserInput | MatchBybitReportCreateOrConnectWithoutUserInput[]
    createMany?: MatchBybitReportCreateManyUserInputEnvelope
    connect?: MatchBybitReportWhereUniqueInput | MatchBybitReportWhereUniqueInput[]
  }

  export type MatchViresReportCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchViresReportCreateWithoutUserInput, MatchViresReportUncheckedCreateWithoutUserInput> | MatchViresReportCreateWithoutUserInput[] | MatchViresReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchViresReportCreateOrConnectWithoutUserInput | MatchViresReportCreateOrConnectWithoutUserInput[]
    createMany?: MatchViresReportCreateManyUserInputEnvelope
    connect?: MatchViresReportWhereUniqueInput | MatchViresReportWhereUniqueInput[]
  }

  export type ReportNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportNotificationCreateWithoutUserInput, ReportNotificationUncheckedCreateWithoutUserInput> | ReportNotificationCreateWithoutUserInput[] | ReportNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportNotificationCreateOrConnectWithoutUserInput | ReportNotificationCreateOrConnectWithoutUserInput[]
    createMany?: ReportNotificationCreateManyUserInputEnvelope
    connect?: ReportNotificationWhereUniqueInput | ReportNotificationWhereUniqueInput[]
  }

  export type TelegramAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<TelegramAccountCreateWithoutUserInput, TelegramAccountUncheckedCreateWithoutUserInput> | TelegramAccountCreateWithoutUserInput[] | TelegramAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramAccountCreateOrConnectWithoutUserInput | TelegramAccountCreateOrConnectWithoutUserInput[]
    createMany?: TelegramAccountCreateManyUserInputEnvelope
    connect?: TelegramAccountWhereUniqueInput | TelegramAccountWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ViresCabinetCreateNestedManyWithoutUserInput = {
    create?: XOR<ViresCabinetCreateWithoutUserInput, ViresCabinetUncheckedCreateWithoutUserInput> | ViresCabinetCreateWithoutUserInput[] | ViresCabinetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViresCabinetCreateOrConnectWithoutUserInput | ViresCabinetCreateOrConnectWithoutUserInput[]
    createMany?: ViresCabinetCreateManyUserInputEnvelope
    connect?: ViresCabinetWhereUniqueInput | ViresCabinetWhereUniqueInput[]
  }

  export type ViresClipMatchCreateNestedManyWithoutUserInput = {
    create?: XOR<ViresClipMatchCreateWithoutUserInput, ViresClipMatchUncheckedCreateWithoutUserInput> | ViresClipMatchCreateWithoutUserInput[] | ViresClipMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutUserInput | ViresClipMatchCreateOrConnectWithoutUserInput[]
    createMany?: ViresClipMatchCreateManyUserInputEnvelope
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
  }

  export type WorkSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkSessionCreateWithoutUserInput, WorkSessionUncheckedCreateWithoutUserInput> | WorkSessionCreateWithoutUserInput[] | WorkSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkSessionCreateOrConnectWithoutUserInput | WorkSessionCreateOrConnectWithoutUserInput[]
    createMany?: WorkSessionCreateManyUserInputEnvelope
    connect?: WorkSessionWhereUniqueInput | WorkSessionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BybitClipMatchUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BybitClipMatchCreateWithoutUserInput, BybitClipMatchUncheckedCreateWithoutUserInput> | BybitClipMatchCreateWithoutUserInput[] | BybitClipMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutUserInput | BybitClipMatchCreateOrConnectWithoutUserInput[]
    createMany?: BybitClipMatchCreateManyUserInputEnvelope
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
  }

  export type BybitTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BybitTransactionCreateWithoutUserInput, BybitTransactionUncheckedCreateWithoutUserInput> | BybitTransactionCreateWithoutUserInput[] | BybitTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BybitTransactionCreateOrConnectWithoutUserInput | BybitTransactionCreateOrConnectWithoutUserInput[]
    createMany?: BybitTransactionCreateManyUserInputEnvelope
    connect?: BybitTransactionWhereUniqueInput | BybitTransactionWhereUniqueInput[]
  }

  export type MatchBybitReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchBybitReportCreateWithoutUserInput, MatchBybitReportUncheckedCreateWithoutUserInput> | MatchBybitReportCreateWithoutUserInput[] | MatchBybitReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchBybitReportCreateOrConnectWithoutUserInput | MatchBybitReportCreateOrConnectWithoutUserInput[]
    createMany?: MatchBybitReportCreateManyUserInputEnvelope
    connect?: MatchBybitReportWhereUniqueInput | MatchBybitReportWhereUniqueInput[]
  }

  export type MatchViresReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchViresReportCreateWithoutUserInput, MatchViresReportUncheckedCreateWithoutUserInput> | MatchViresReportCreateWithoutUserInput[] | MatchViresReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchViresReportCreateOrConnectWithoutUserInput | MatchViresReportCreateOrConnectWithoutUserInput[]
    createMany?: MatchViresReportCreateManyUserInputEnvelope
    connect?: MatchViresReportWhereUniqueInput | MatchViresReportWhereUniqueInput[]
  }

  export type ReportNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportNotificationCreateWithoutUserInput, ReportNotificationUncheckedCreateWithoutUserInput> | ReportNotificationCreateWithoutUserInput[] | ReportNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportNotificationCreateOrConnectWithoutUserInput | ReportNotificationCreateOrConnectWithoutUserInput[]
    createMany?: ReportNotificationCreateManyUserInputEnvelope
    connect?: ReportNotificationWhereUniqueInput | ReportNotificationWhereUniqueInput[]
  }

  export type TelegramAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TelegramAccountCreateWithoutUserInput, TelegramAccountUncheckedCreateWithoutUserInput> | TelegramAccountCreateWithoutUserInput[] | TelegramAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramAccountCreateOrConnectWithoutUserInput | TelegramAccountCreateOrConnectWithoutUserInput[]
    createMany?: TelegramAccountCreateManyUserInputEnvelope
    connect?: TelegramAccountWhereUniqueInput | TelegramAccountWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ViresCabinetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ViresCabinetCreateWithoutUserInput, ViresCabinetUncheckedCreateWithoutUserInput> | ViresCabinetCreateWithoutUserInput[] | ViresCabinetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViresCabinetCreateOrConnectWithoutUserInput | ViresCabinetCreateOrConnectWithoutUserInput[]
    createMany?: ViresCabinetCreateManyUserInputEnvelope
    connect?: ViresCabinetWhereUniqueInput | ViresCabinetWhereUniqueInput[]
  }

  export type ViresClipMatchUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ViresClipMatchCreateWithoutUserInput, ViresClipMatchUncheckedCreateWithoutUserInput> | ViresClipMatchCreateWithoutUserInput[] | ViresClipMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutUserInput | ViresClipMatchCreateOrConnectWithoutUserInput[]
    createMany?: ViresClipMatchCreateManyUserInputEnvelope
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
  }

  export type WorkSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkSessionCreateWithoutUserInput, WorkSessionUncheckedCreateWithoutUserInput> | WorkSessionCreateWithoutUserInput[] | WorkSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkSessionCreateOrConnectWithoutUserInput | WorkSessionCreateOrConnectWithoutUserInput[]
    createMany?: WorkSessionCreateManyUserInputEnvelope
    connect?: WorkSessionWhereUniqueInput | WorkSessionWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BybitClipMatchUpdateManyWithoutUserNestedInput = {
    create?: XOR<BybitClipMatchCreateWithoutUserInput, BybitClipMatchUncheckedCreateWithoutUserInput> | BybitClipMatchCreateWithoutUserInput[] | BybitClipMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutUserInput | BybitClipMatchCreateOrConnectWithoutUserInput[]
    upsert?: BybitClipMatchUpsertWithWhereUniqueWithoutUserInput | BybitClipMatchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BybitClipMatchCreateManyUserInputEnvelope
    set?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    disconnect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    delete?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    update?: BybitClipMatchUpdateWithWhereUniqueWithoutUserInput | BybitClipMatchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BybitClipMatchUpdateManyWithWhereWithoutUserInput | BybitClipMatchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BybitClipMatchScalarWhereInput | BybitClipMatchScalarWhereInput[]
  }

  export type BybitTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<BybitTransactionCreateWithoutUserInput, BybitTransactionUncheckedCreateWithoutUserInput> | BybitTransactionCreateWithoutUserInput[] | BybitTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BybitTransactionCreateOrConnectWithoutUserInput | BybitTransactionCreateOrConnectWithoutUserInput[]
    upsert?: BybitTransactionUpsertWithWhereUniqueWithoutUserInput | BybitTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BybitTransactionCreateManyUserInputEnvelope
    set?: BybitTransactionWhereUniqueInput | BybitTransactionWhereUniqueInput[]
    disconnect?: BybitTransactionWhereUniqueInput | BybitTransactionWhereUniqueInput[]
    delete?: BybitTransactionWhereUniqueInput | BybitTransactionWhereUniqueInput[]
    connect?: BybitTransactionWhereUniqueInput | BybitTransactionWhereUniqueInput[]
    update?: BybitTransactionUpdateWithWhereUniqueWithoutUserInput | BybitTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BybitTransactionUpdateManyWithWhereWithoutUserInput | BybitTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BybitTransactionScalarWhereInput | BybitTransactionScalarWhereInput[]
  }

  export type MatchBybitReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchBybitReportCreateWithoutUserInput, MatchBybitReportUncheckedCreateWithoutUserInput> | MatchBybitReportCreateWithoutUserInput[] | MatchBybitReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchBybitReportCreateOrConnectWithoutUserInput | MatchBybitReportCreateOrConnectWithoutUserInput[]
    upsert?: MatchBybitReportUpsertWithWhereUniqueWithoutUserInput | MatchBybitReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchBybitReportCreateManyUserInputEnvelope
    set?: MatchBybitReportWhereUniqueInput | MatchBybitReportWhereUniqueInput[]
    disconnect?: MatchBybitReportWhereUniqueInput | MatchBybitReportWhereUniqueInput[]
    delete?: MatchBybitReportWhereUniqueInput | MatchBybitReportWhereUniqueInput[]
    connect?: MatchBybitReportWhereUniqueInput | MatchBybitReportWhereUniqueInput[]
    update?: MatchBybitReportUpdateWithWhereUniqueWithoutUserInput | MatchBybitReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchBybitReportUpdateManyWithWhereWithoutUserInput | MatchBybitReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchBybitReportScalarWhereInput | MatchBybitReportScalarWhereInput[]
  }

  export type MatchViresReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchViresReportCreateWithoutUserInput, MatchViresReportUncheckedCreateWithoutUserInput> | MatchViresReportCreateWithoutUserInput[] | MatchViresReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchViresReportCreateOrConnectWithoutUserInput | MatchViresReportCreateOrConnectWithoutUserInput[]
    upsert?: MatchViresReportUpsertWithWhereUniqueWithoutUserInput | MatchViresReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchViresReportCreateManyUserInputEnvelope
    set?: MatchViresReportWhereUniqueInput | MatchViresReportWhereUniqueInput[]
    disconnect?: MatchViresReportWhereUniqueInput | MatchViresReportWhereUniqueInput[]
    delete?: MatchViresReportWhereUniqueInput | MatchViresReportWhereUniqueInput[]
    connect?: MatchViresReportWhereUniqueInput | MatchViresReportWhereUniqueInput[]
    update?: MatchViresReportUpdateWithWhereUniqueWithoutUserInput | MatchViresReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchViresReportUpdateManyWithWhereWithoutUserInput | MatchViresReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchViresReportScalarWhereInput | MatchViresReportScalarWhereInput[]
  }

  export type ReportNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportNotificationCreateWithoutUserInput, ReportNotificationUncheckedCreateWithoutUserInput> | ReportNotificationCreateWithoutUserInput[] | ReportNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportNotificationCreateOrConnectWithoutUserInput | ReportNotificationCreateOrConnectWithoutUserInput[]
    upsert?: ReportNotificationUpsertWithWhereUniqueWithoutUserInput | ReportNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportNotificationCreateManyUserInputEnvelope
    set?: ReportNotificationWhereUniqueInput | ReportNotificationWhereUniqueInput[]
    disconnect?: ReportNotificationWhereUniqueInput | ReportNotificationWhereUniqueInput[]
    delete?: ReportNotificationWhereUniqueInput | ReportNotificationWhereUniqueInput[]
    connect?: ReportNotificationWhereUniqueInput | ReportNotificationWhereUniqueInput[]
    update?: ReportNotificationUpdateWithWhereUniqueWithoutUserInput | ReportNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportNotificationUpdateManyWithWhereWithoutUserInput | ReportNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportNotificationScalarWhereInput | ReportNotificationScalarWhereInput[]
  }

  export type TelegramAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<TelegramAccountCreateWithoutUserInput, TelegramAccountUncheckedCreateWithoutUserInput> | TelegramAccountCreateWithoutUserInput[] | TelegramAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramAccountCreateOrConnectWithoutUserInput | TelegramAccountCreateOrConnectWithoutUserInput[]
    upsert?: TelegramAccountUpsertWithWhereUniqueWithoutUserInput | TelegramAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TelegramAccountCreateManyUserInputEnvelope
    set?: TelegramAccountWhereUniqueInput | TelegramAccountWhereUniqueInput[]
    disconnect?: TelegramAccountWhereUniqueInput | TelegramAccountWhereUniqueInput[]
    delete?: TelegramAccountWhereUniqueInput | TelegramAccountWhereUniqueInput[]
    connect?: TelegramAccountWhereUniqueInput | TelegramAccountWhereUniqueInput[]
    update?: TelegramAccountUpdateWithWhereUniqueWithoutUserInput | TelegramAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TelegramAccountUpdateManyWithWhereWithoutUserInput | TelegramAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TelegramAccountScalarWhereInput | TelegramAccountScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ViresCabinetUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViresCabinetCreateWithoutUserInput, ViresCabinetUncheckedCreateWithoutUserInput> | ViresCabinetCreateWithoutUserInput[] | ViresCabinetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViresCabinetCreateOrConnectWithoutUserInput | ViresCabinetCreateOrConnectWithoutUserInput[]
    upsert?: ViresCabinetUpsertWithWhereUniqueWithoutUserInput | ViresCabinetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViresCabinetCreateManyUserInputEnvelope
    set?: ViresCabinetWhereUniqueInput | ViresCabinetWhereUniqueInput[]
    disconnect?: ViresCabinetWhereUniqueInput | ViresCabinetWhereUniqueInput[]
    delete?: ViresCabinetWhereUniqueInput | ViresCabinetWhereUniqueInput[]
    connect?: ViresCabinetWhereUniqueInput | ViresCabinetWhereUniqueInput[]
    update?: ViresCabinetUpdateWithWhereUniqueWithoutUserInput | ViresCabinetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViresCabinetUpdateManyWithWhereWithoutUserInput | ViresCabinetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViresCabinetScalarWhereInput | ViresCabinetScalarWhereInput[]
  }

  export type ViresClipMatchUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViresClipMatchCreateWithoutUserInput, ViresClipMatchUncheckedCreateWithoutUserInput> | ViresClipMatchCreateWithoutUserInput[] | ViresClipMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutUserInput | ViresClipMatchCreateOrConnectWithoutUserInput[]
    upsert?: ViresClipMatchUpsertWithWhereUniqueWithoutUserInput | ViresClipMatchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViresClipMatchCreateManyUserInputEnvelope
    set?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    disconnect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    delete?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    update?: ViresClipMatchUpdateWithWhereUniqueWithoutUserInput | ViresClipMatchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViresClipMatchUpdateManyWithWhereWithoutUserInput | ViresClipMatchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViresClipMatchScalarWhereInput | ViresClipMatchScalarWhereInput[]
  }

  export type WorkSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkSessionCreateWithoutUserInput, WorkSessionUncheckedCreateWithoutUserInput> | WorkSessionCreateWithoutUserInput[] | WorkSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkSessionCreateOrConnectWithoutUserInput | WorkSessionCreateOrConnectWithoutUserInput[]
    upsert?: WorkSessionUpsertWithWhereUniqueWithoutUserInput | WorkSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkSessionCreateManyUserInputEnvelope
    set?: WorkSessionWhereUniqueInput | WorkSessionWhereUniqueInput[]
    disconnect?: WorkSessionWhereUniqueInput | WorkSessionWhereUniqueInput[]
    delete?: WorkSessionWhereUniqueInput | WorkSessionWhereUniqueInput[]
    connect?: WorkSessionWhereUniqueInput | WorkSessionWhereUniqueInput[]
    update?: WorkSessionUpdateWithWhereUniqueWithoutUserInput | WorkSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkSessionUpdateManyWithWhereWithoutUserInput | WorkSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkSessionScalarWhereInput | WorkSessionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BybitClipMatchCreateWithoutUserInput, BybitClipMatchUncheckedCreateWithoutUserInput> | BybitClipMatchCreateWithoutUserInput[] | BybitClipMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutUserInput | BybitClipMatchCreateOrConnectWithoutUserInput[]
    upsert?: BybitClipMatchUpsertWithWhereUniqueWithoutUserInput | BybitClipMatchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BybitClipMatchCreateManyUserInputEnvelope
    set?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    disconnect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    delete?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    update?: BybitClipMatchUpdateWithWhereUniqueWithoutUserInput | BybitClipMatchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BybitClipMatchUpdateManyWithWhereWithoutUserInput | BybitClipMatchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BybitClipMatchScalarWhereInput | BybitClipMatchScalarWhereInput[]
  }

  export type BybitTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BybitTransactionCreateWithoutUserInput, BybitTransactionUncheckedCreateWithoutUserInput> | BybitTransactionCreateWithoutUserInput[] | BybitTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BybitTransactionCreateOrConnectWithoutUserInput | BybitTransactionCreateOrConnectWithoutUserInput[]
    upsert?: BybitTransactionUpsertWithWhereUniqueWithoutUserInput | BybitTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BybitTransactionCreateManyUserInputEnvelope
    set?: BybitTransactionWhereUniqueInput | BybitTransactionWhereUniqueInput[]
    disconnect?: BybitTransactionWhereUniqueInput | BybitTransactionWhereUniqueInput[]
    delete?: BybitTransactionWhereUniqueInput | BybitTransactionWhereUniqueInput[]
    connect?: BybitTransactionWhereUniqueInput | BybitTransactionWhereUniqueInput[]
    update?: BybitTransactionUpdateWithWhereUniqueWithoutUserInput | BybitTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BybitTransactionUpdateManyWithWhereWithoutUserInput | BybitTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BybitTransactionScalarWhereInput | BybitTransactionScalarWhereInput[]
  }

  export type MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchBybitReportCreateWithoutUserInput, MatchBybitReportUncheckedCreateWithoutUserInput> | MatchBybitReportCreateWithoutUserInput[] | MatchBybitReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchBybitReportCreateOrConnectWithoutUserInput | MatchBybitReportCreateOrConnectWithoutUserInput[]
    upsert?: MatchBybitReportUpsertWithWhereUniqueWithoutUserInput | MatchBybitReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchBybitReportCreateManyUserInputEnvelope
    set?: MatchBybitReportWhereUniqueInput | MatchBybitReportWhereUniqueInput[]
    disconnect?: MatchBybitReportWhereUniqueInput | MatchBybitReportWhereUniqueInput[]
    delete?: MatchBybitReportWhereUniqueInput | MatchBybitReportWhereUniqueInput[]
    connect?: MatchBybitReportWhereUniqueInput | MatchBybitReportWhereUniqueInput[]
    update?: MatchBybitReportUpdateWithWhereUniqueWithoutUserInput | MatchBybitReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchBybitReportUpdateManyWithWhereWithoutUserInput | MatchBybitReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchBybitReportScalarWhereInput | MatchBybitReportScalarWhereInput[]
  }

  export type MatchViresReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchViresReportCreateWithoutUserInput, MatchViresReportUncheckedCreateWithoutUserInput> | MatchViresReportCreateWithoutUserInput[] | MatchViresReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchViresReportCreateOrConnectWithoutUserInput | MatchViresReportCreateOrConnectWithoutUserInput[]
    upsert?: MatchViresReportUpsertWithWhereUniqueWithoutUserInput | MatchViresReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchViresReportCreateManyUserInputEnvelope
    set?: MatchViresReportWhereUniqueInput | MatchViresReportWhereUniqueInput[]
    disconnect?: MatchViresReportWhereUniqueInput | MatchViresReportWhereUniqueInput[]
    delete?: MatchViresReportWhereUniqueInput | MatchViresReportWhereUniqueInput[]
    connect?: MatchViresReportWhereUniqueInput | MatchViresReportWhereUniqueInput[]
    update?: MatchViresReportUpdateWithWhereUniqueWithoutUserInput | MatchViresReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchViresReportUpdateManyWithWhereWithoutUserInput | MatchViresReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchViresReportScalarWhereInput | MatchViresReportScalarWhereInput[]
  }

  export type ReportNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportNotificationCreateWithoutUserInput, ReportNotificationUncheckedCreateWithoutUserInput> | ReportNotificationCreateWithoutUserInput[] | ReportNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportNotificationCreateOrConnectWithoutUserInput | ReportNotificationCreateOrConnectWithoutUserInput[]
    upsert?: ReportNotificationUpsertWithWhereUniqueWithoutUserInput | ReportNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportNotificationCreateManyUserInputEnvelope
    set?: ReportNotificationWhereUniqueInput | ReportNotificationWhereUniqueInput[]
    disconnect?: ReportNotificationWhereUniqueInput | ReportNotificationWhereUniqueInput[]
    delete?: ReportNotificationWhereUniqueInput | ReportNotificationWhereUniqueInput[]
    connect?: ReportNotificationWhereUniqueInput | ReportNotificationWhereUniqueInput[]
    update?: ReportNotificationUpdateWithWhereUniqueWithoutUserInput | ReportNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportNotificationUpdateManyWithWhereWithoutUserInput | ReportNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportNotificationScalarWhereInput | ReportNotificationScalarWhereInput[]
  }

  export type TelegramAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TelegramAccountCreateWithoutUserInput, TelegramAccountUncheckedCreateWithoutUserInput> | TelegramAccountCreateWithoutUserInput[] | TelegramAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramAccountCreateOrConnectWithoutUserInput | TelegramAccountCreateOrConnectWithoutUserInput[]
    upsert?: TelegramAccountUpsertWithWhereUniqueWithoutUserInput | TelegramAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TelegramAccountCreateManyUserInputEnvelope
    set?: TelegramAccountWhereUniqueInput | TelegramAccountWhereUniqueInput[]
    disconnect?: TelegramAccountWhereUniqueInput | TelegramAccountWhereUniqueInput[]
    delete?: TelegramAccountWhereUniqueInput | TelegramAccountWhereUniqueInput[]
    connect?: TelegramAccountWhereUniqueInput | TelegramAccountWhereUniqueInput[]
    update?: TelegramAccountUpdateWithWhereUniqueWithoutUserInput | TelegramAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TelegramAccountUpdateManyWithWhereWithoutUserInput | TelegramAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TelegramAccountScalarWhereInput | TelegramAccountScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ViresCabinetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViresCabinetCreateWithoutUserInput, ViresCabinetUncheckedCreateWithoutUserInput> | ViresCabinetCreateWithoutUserInput[] | ViresCabinetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViresCabinetCreateOrConnectWithoutUserInput | ViresCabinetCreateOrConnectWithoutUserInput[]
    upsert?: ViresCabinetUpsertWithWhereUniqueWithoutUserInput | ViresCabinetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViresCabinetCreateManyUserInputEnvelope
    set?: ViresCabinetWhereUniqueInput | ViresCabinetWhereUniqueInput[]
    disconnect?: ViresCabinetWhereUniqueInput | ViresCabinetWhereUniqueInput[]
    delete?: ViresCabinetWhereUniqueInput | ViresCabinetWhereUniqueInput[]
    connect?: ViresCabinetWhereUniqueInput | ViresCabinetWhereUniqueInput[]
    update?: ViresCabinetUpdateWithWhereUniqueWithoutUserInput | ViresCabinetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViresCabinetUpdateManyWithWhereWithoutUserInput | ViresCabinetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViresCabinetScalarWhereInput | ViresCabinetScalarWhereInput[]
  }

  export type ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViresClipMatchCreateWithoutUserInput, ViresClipMatchUncheckedCreateWithoutUserInput> | ViresClipMatchCreateWithoutUserInput[] | ViresClipMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutUserInput | ViresClipMatchCreateOrConnectWithoutUserInput[]
    upsert?: ViresClipMatchUpsertWithWhereUniqueWithoutUserInput | ViresClipMatchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViresClipMatchCreateManyUserInputEnvelope
    set?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    disconnect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    delete?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    update?: ViresClipMatchUpdateWithWhereUniqueWithoutUserInput | ViresClipMatchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViresClipMatchUpdateManyWithWhereWithoutUserInput | ViresClipMatchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViresClipMatchScalarWhereInput | ViresClipMatchScalarWhereInput[]
  }

  export type WorkSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkSessionCreateWithoutUserInput, WorkSessionUncheckedCreateWithoutUserInput> | WorkSessionCreateWithoutUserInput[] | WorkSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkSessionCreateOrConnectWithoutUserInput | WorkSessionCreateOrConnectWithoutUserInput[]
    upsert?: WorkSessionUpsertWithWhereUniqueWithoutUserInput | WorkSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkSessionCreateManyUserInputEnvelope
    set?: WorkSessionWhereUniqueInput | WorkSessionWhereUniqueInput[]
    disconnect?: WorkSessionWhereUniqueInput | WorkSessionWhereUniqueInput[]
    delete?: WorkSessionWhereUniqueInput | WorkSessionWhereUniqueInput[]
    connect?: WorkSessionWhereUniqueInput | WorkSessionWhereUniqueInput[]
    update?: WorkSessionUpdateWithWhereUniqueWithoutUserInput | WorkSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkSessionUpdateManyWithWhereWithoutUserInput | WorkSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkSessionScalarWhereInput | WorkSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWorkSessionInput = {
    create?: XOR<UserCreateWithoutWorkSessionInput, UserUncheckedCreateWithoutWorkSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkSessionInput
    connect?: UserWhereUniqueInput
  }

  export type WorkSessionIdexCabinetCreateNestedManyWithoutWorkSessionInput = {
    create?: XOR<WorkSessionIdexCabinetCreateWithoutWorkSessionInput, WorkSessionIdexCabinetUncheckedCreateWithoutWorkSessionInput> | WorkSessionIdexCabinetCreateWithoutWorkSessionInput[] | WorkSessionIdexCabinetUncheckedCreateWithoutWorkSessionInput[]
    connectOrCreate?: WorkSessionIdexCabinetCreateOrConnectWithoutWorkSessionInput | WorkSessionIdexCabinetCreateOrConnectWithoutWorkSessionInput[]
    createMany?: WorkSessionIdexCabinetCreateManyWorkSessionInputEnvelope
    connect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
  }

  export type WorkSessionIdexCabinetUncheckedCreateNestedManyWithoutWorkSessionInput = {
    create?: XOR<WorkSessionIdexCabinetCreateWithoutWorkSessionInput, WorkSessionIdexCabinetUncheckedCreateWithoutWorkSessionInput> | WorkSessionIdexCabinetCreateWithoutWorkSessionInput[] | WorkSessionIdexCabinetUncheckedCreateWithoutWorkSessionInput[]
    connectOrCreate?: WorkSessionIdexCabinetCreateOrConnectWithoutWorkSessionInput | WorkSessionIdexCabinetCreateOrConnectWithoutWorkSessionInput[]
    createMany?: WorkSessionIdexCabinetCreateManyWorkSessionInputEnvelope
    connect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWorkSessionNestedInput = {
    create?: XOR<UserCreateWithoutWorkSessionInput, UserUncheckedCreateWithoutWorkSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkSessionInput
    upsert?: UserUpsertWithoutWorkSessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkSessionInput, UserUpdateWithoutWorkSessionInput>, UserUncheckedUpdateWithoutWorkSessionInput>
  }

  export type WorkSessionIdexCabinetUpdateManyWithoutWorkSessionNestedInput = {
    create?: XOR<WorkSessionIdexCabinetCreateWithoutWorkSessionInput, WorkSessionIdexCabinetUncheckedCreateWithoutWorkSessionInput> | WorkSessionIdexCabinetCreateWithoutWorkSessionInput[] | WorkSessionIdexCabinetUncheckedCreateWithoutWorkSessionInput[]
    connectOrCreate?: WorkSessionIdexCabinetCreateOrConnectWithoutWorkSessionInput | WorkSessionIdexCabinetCreateOrConnectWithoutWorkSessionInput[]
    upsert?: WorkSessionIdexCabinetUpsertWithWhereUniqueWithoutWorkSessionInput | WorkSessionIdexCabinetUpsertWithWhereUniqueWithoutWorkSessionInput[]
    createMany?: WorkSessionIdexCabinetCreateManyWorkSessionInputEnvelope
    set?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    disconnect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    delete?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    connect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    update?: WorkSessionIdexCabinetUpdateWithWhereUniqueWithoutWorkSessionInput | WorkSessionIdexCabinetUpdateWithWhereUniqueWithoutWorkSessionInput[]
    updateMany?: WorkSessionIdexCabinetUpdateManyWithWhereWithoutWorkSessionInput | WorkSessionIdexCabinetUpdateManyWithWhereWithoutWorkSessionInput[]
    deleteMany?: WorkSessionIdexCabinetScalarWhereInput | WorkSessionIdexCabinetScalarWhereInput[]
  }

  export type WorkSessionIdexCabinetUncheckedUpdateManyWithoutWorkSessionNestedInput = {
    create?: XOR<WorkSessionIdexCabinetCreateWithoutWorkSessionInput, WorkSessionIdexCabinetUncheckedCreateWithoutWorkSessionInput> | WorkSessionIdexCabinetCreateWithoutWorkSessionInput[] | WorkSessionIdexCabinetUncheckedCreateWithoutWorkSessionInput[]
    connectOrCreate?: WorkSessionIdexCabinetCreateOrConnectWithoutWorkSessionInput | WorkSessionIdexCabinetCreateOrConnectWithoutWorkSessionInput[]
    upsert?: WorkSessionIdexCabinetUpsertWithWhereUniqueWithoutWorkSessionInput | WorkSessionIdexCabinetUpsertWithWhereUniqueWithoutWorkSessionInput[]
    createMany?: WorkSessionIdexCabinetCreateManyWorkSessionInputEnvelope
    set?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    disconnect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    delete?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    connect?: WorkSessionIdexCabinetWhereUniqueInput | WorkSessionIdexCabinetWhereUniqueInput[]
    update?: WorkSessionIdexCabinetUpdateWithWhereUniqueWithoutWorkSessionInput | WorkSessionIdexCabinetUpdateWithWhereUniqueWithoutWorkSessionInput[]
    updateMany?: WorkSessionIdexCabinetUpdateManyWithWhereWithoutWorkSessionInput | WorkSessionIdexCabinetUpdateManyWithWhereWithoutWorkSessionInput[]
    deleteMany?: WorkSessionIdexCabinetScalarWhereInput | WorkSessionIdexCabinetScalarWhereInput[]
  }

  export type IdexCabinetCreateNestedOneWithoutWorkSessionIdexCabinetInput = {
    create?: XOR<IdexCabinetCreateWithoutWorkSessionIdexCabinetInput, IdexCabinetUncheckedCreateWithoutWorkSessionIdexCabinetInput>
    connectOrCreate?: IdexCabinetCreateOrConnectWithoutWorkSessionIdexCabinetInput
    connect?: IdexCabinetWhereUniqueInput
  }

  export type WorkSessionCreateNestedOneWithoutWorkSessionIdexCabinetInput = {
    create?: XOR<WorkSessionCreateWithoutWorkSessionIdexCabinetInput, WorkSessionUncheckedCreateWithoutWorkSessionIdexCabinetInput>
    connectOrCreate?: WorkSessionCreateOrConnectWithoutWorkSessionIdexCabinetInput
    connect?: WorkSessionWhereUniqueInput
  }

  export type IdexCabinetUpdateOneRequiredWithoutWorkSessionIdexCabinetNestedInput = {
    create?: XOR<IdexCabinetCreateWithoutWorkSessionIdexCabinetInput, IdexCabinetUncheckedCreateWithoutWorkSessionIdexCabinetInput>
    connectOrCreate?: IdexCabinetCreateOrConnectWithoutWorkSessionIdexCabinetInput
    upsert?: IdexCabinetUpsertWithoutWorkSessionIdexCabinetInput
    connect?: IdexCabinetWhereUniqueInput
    update?: XOR<XOR<IdexCabinetUpdateToOneWithWhereWithoutWorkSessionIdexCabinetInput, IdexCabinetUpdateWithoutWorkSessionIdexCabinetInput>, IdexCabinetUncheckedUpdateWithoutWorkSessionIdexCabinetInput>
  }

  export type WorkSessionUpdateOneRequiredWithoutWorkSessionIdexCabinetNestedInput = {
    create?: XOR<WorkSessionCreateWithoutWorkSessionIdexCabinetInput, WorkSessionUncheckedCreateWithoutWorkSessionIdexCabinetInput>
    connectOrCreate?: WorkSessionCreateOrConnectWithoutWorkSessionIdexCabinetInput
    upsert?: WorkSessionUpsertWithoutWorkSessionIdexCabinetInput
    connect?: WorkSessionWhereUniqueInput
    update?: XOR<XOR<WorkSessionUpdateToOneWithWhereWithoutWorkSessionIdexCabinetInput, WorkSessionUpdateWithoutWorkSessionIdexCabinetInput>, WorkSessionUncheckedUpdateWithoutWorkSessionIdexCabinetInput>
  }

  export type BybitTransactionFromCabinetCreateNestedManyWithoutBybitCabinetInput = {
    create?: XOR<BybitTransactionFromCabinetCreateWithoutBybitCabinetInput, BybitTransactionFromCabinetUncheckedCreateWithoutBybitCabinetInput> | BybitTransactionFromCabinetCreateWithoutBybitCabinetInput[] | BybitTransactionFromCabinetUncheckedCreateWithoutBybitCabinetInput[]
    connectOrCreate?: BybitTransactionFromCabinetCreateOrConnectWithoutBybitCabinetInput | BybitTransactionFromCabinetCreateOrConnectWithoutBybitCabinetInput[]
    createMany?: BybitTransactionFromCabinetCreateManyBybitCabinetInputEnvelope
    connect?: BybitTransactionFromCabinetWhereUniqueInput | BybitTransactionFromCabinetWhereUniqueInput[]
  }

  export type BybitOrderInfoCreateNestedManyWithoutCabinetInput = {
    create?: XOR<BybitOrderInfoCreateWithoutCabinetInput, BybitOrderInfoUncheckedCreateWithoutCabinetInput> | BybitOrderInfoCreateWithoutCabinetInput[] | BybitOrderInfoUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: BybitOrderInfoCreateOrConnectWithoutCabinetInput | BybitOrderInfoCreateOrConnectWithoutCabinetInput[]
    createMany?: BybitOrderInfoCreateManyCabinetInputEnvelope
    connect?: BybitOrderInfoWhereUniqueInput | BybitOrderInfoWhereUniqueInput[]
  }

  export type BybitTransactionFromCabinetUncheckedCreateNestedManyWithoutBybitCabinetInput = {
    create?: XOR<BybitTransactionFromCabinetCreateWithoutBybitCabinetInput, BybitTransactionFromCabinetUncheckedCreateWithoutBybitCabinetInput> | BybitTransactionFromCabinetCreateWithoutBybitCabinetInput[] | BybitTransactionFromCabinetUncheckedCreateWithoutBybitCabinetInput[]
    connectOrCreate?: BybitTransactionFromCabinetCreateOrConnectWithoutBybitCabinetInput | BybitTransactionFromCabinetCreateOrConnectWithoutBybitCabinetInput[]
    createMany?: BybitTransactionFromCabinetCreateManyBybitCabinetInputEnvelope
    connect?: BybitTransactionFromCabinetWhereUniqueInput | BybitTransactionFromCabinetWhereUniqueInput[]
  }

  export type BybitOrderInfoUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<BybitOrderInfoCreateWithoutCabinetInput, BybitOrderInfoUncheckedCreateWithoutCabinetInput> | BybitOrderInfoCreateWithoutCabinetInput[] | BybitOrderInfoUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: BybitOrderInfoCreateOrConnectWithoutCabinetInput | BybitOrderInfoCreateOrConnectWithoutCabinetInput[]
    createMany?: BybitOrderInfoCreateManyCabinetInputEnvelope
    connect?: BybitOrderInfoWhereUniqueInput | BybitOrderInfoWhereUniqueInput[]
  }

  export type BybitTransactionFromCabinetUpdateManyWithoutBybitCabinetNestedInput = {
    create?: XOR<BybitTransactionFromCabinetCreateWithoutBybitCabinetInput, BybitTransactionFromCabinetUncheckedCreateWithoutBybitCabinetInput> | BybitTransactionFromCabinetCreateWithoutBybitCabinetInput[] | BybitTransactionFromCabinetUncheckedCreateWithoutBybitCabinetInput[]
    connectOrCreate?: BybitTransactionFromCabinetCreateOrConnectWithoutBybitCabinetInput | BybitTransactionFromCabinetCreateOrConnectWithoutBybitCabinetInput[]
    upsert?: BybitTransactionFromCabinetUpsertWithWhereUniqueWithoutBybitCabinetInput | BybitTransactionFromCabinetUpsertWithWhereUniqueWithoutBybitCabinetInput[]
    createMany?: BybitTransactionFromCabinetCreateManyBybitCabinetInputEnvelope
    set?: BybitTransactionFromCabinetWhereUniqueInput | BybitTransactionFromCabinetWhereUniqueInput[]
    disconnect?: BybitTransactionFromCabinetWhereUniqueInput | BybitTransactionFromCabinetWhereUniqueInput[]
    delete?: BybitTransactionFromCabinetWhereUniqueInput | BybitTransactionFromCabinetWhereUniqueInput[]
    connect?: BybitTransactionFromCabinetWhereUniqueInput | BybitTransactionFromCabinetWhereUniqueInput[]
    update?: BybitTransactionFromCabinetUpdateWithWhereUniqueWithoutBybitCabinetInput | BybitTransactionFromCabinetUpdateWithWhereUniqueWithoutBybitCabinetInput[]
    updateMany?: BybitTransactionFromCabinetUpdateManyWithWhereWithoutBybitCabinetInput | BybitTransactionFromCabinetUpdateManyWithWhereWithoutBybitCabinetInput[]
    deleteMany?: BybitTransactionFromCabinetScalarWhereInput | BybitTransactionFromCabinetScalarWhereInput[]
  }

  export type BybitOrderInfoUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<BybitOrderInfoCreateWithoutCabinetInput, BybitOrderInfoUncheckedCreateWithoutCabinetInput> | BybitOrderInfoCreateWithoutCabinetInput[] | BybitOrderInfoUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: BybitOrderInfoCreateOrConnectWithoutCabinetInput | BybitOrderInfoCreateOrConnectWithoutCabinetInput[]
    upsert?: BybitOrderInfoUpsertWithWhereUniqueWithoutCabinetInput | BybitOrderInfoUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: BybitOrderInfoCreateManyCabinetInputEnvelope
    set?: BybitOrderInfoWhereUniqueInput | BybitOrderInfoWhereUniqueInput[]
    disconnect?: BybitOrderInfoWhereUniqueInput | BybitOrderInfoWhereUniqueInput[]
    delete?: BybitOrderInfoWhereUniqueInput | BybitOrderInfoWhereUniqueInput[]
    connect?: BybitOrderInfoWhereUniqueInput | BybitOrderInfoWhereUniqueInput[]
    update?: BybitOrderInfoUpdateWithWhereUniqueWithoutCabinetInput | BybitOrderInfoUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: BybitOrderInfoUpdateManyWithWhereWithoutCabinetInput | BybitOrderInfoUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: BybitOrderInfoScalarWhereInput | BybitOrderInfoScalarWhereInput[]
  }

  export type BybitTransactionFromCabinetUncheckedUpdateManyWithoutBybitCabinetNestedInput = {
    create?: XOR<BybitTransactionFromCabinetCreateWithoutBybitCabinetInput, BybitTransactionFromCabinetUncheckedCreateWithoutBybitCabinetInput> | BybitTransactionFromCabinetCreateWithoutBybitCabinetInput[] | BybitTransactionFromCabinetUncheckedCreateWithoutBybitCabinetInput[]
    connectOrCreate?: BybitTransactionFromCabinetCreateOrConnectWithoutBybitCabinetInput | BybitTransactionFromCabinetCreateOrConnectWithoutBybitCabinetInput[]
    upsert?: BybitTransactionFromCabinetUpsertWithWhereUniqueWithoutBybitCabinetInput | BybitTransactionFromCabinetUpsertWithWhereUniqueWithoutBybitCabinetInput[]
    createMany?: BybitTransactionFromCabinetCreateManyBybitCabinetInputEnvelope
    set?: BybitTransactionFromCabinetWhereUniqueInput | BybitTransactionFromCabinetWhereUniqueInput[]
    disconnect?: BybitTransactionFromCabinetWhereUniqueInput | BybitTransactionFromCabinetWhereUniqueInput[]
    delete?: BybitTransactionFromCabinetWhereUniqueInput | BybitTransactionFromCabinetWhereUniqueInput[]
    connect?: BybitTransactionFromCabinetWhereUniqueInput | BybitTransactionFromCabinetWhereUniqueInput[]
    update?: BybitTransactionFromCabinetUpdateWithWhereUniqueWithoutBybitCabinetInput | BybitTransactionFromCabinetUpdateWithWhereUniqueWithoutBybitCabinetInput[]
    updateMany?: BybitTransactionFromCabinetUpdateManyWithWhereWithoutBybitCabinetInput | BybitTransactionFromCabinetUpdateManyWithWhereWithoutBybitCabinetInput[]
    deleteMany?: BybitTransactionFromCabinetScalarWhereInput | BybitTransactionFromCabinetScalarWhereInput[]
  }

  export type BybitOrderInfoUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<BybitOrderInfoCreateWithoutCabinetInput, BybitOrderInfoUncheckedCreateWithoutCabinetInput> | BybitOrderInfoCreateWithoutCabinetInput[] | BybitOrderInfoUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: BybitOrderInfoCreateOrConnectWithoutCabinetInput | BybitOrderInfoCreateOrConnectWithoutCabinetInput[]
    upsert?: BybitOrderInfoUpsertWithWhereUniqueWithoutCabinetInput | BybitOrderInfoUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: BybitOrderInfoCreateManyCabinetInputEnvelope
    set?: BybitOrderInfoWhereUniqueInput | BybitOrderInfoWhereUniqueInput[]
    disconnect?: BybitOrderInfoWhereUniqueInput | BybitOrderInfoWhereUniqueInput[]
    delete?: BybitOrderInfoWhereUniqueInput | BybitOrderInfoWhereUniqueInput[]
    connect?: BybitOrderInfoWhereUniqueInput | BybitOrderInfoWhereUniqueInput[]
    update?: BybitOrderInfoUpdateWithWhereUniqueWithoutCabinetInput | BybitOrderInfoUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: BybitOrderInfoUpdateManyWithWhereWithoutCabinetInput | BybitOrderInfoUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: BybitOrderInfoScalarWhereInput | BybitOrderInfoScalarWhereInput[]
  }

  export type BybitTransactionFromCabinetCreateNestedOneWithoutBybitClipMatchInput = {
    create?: XOR<BybitTransactionFromCabinetCreateWithoutBybitClipMatchInput, BybitTransactionFromCabinetUncheckedCreateWithoutBybitClipMatchInput>
    connectOrCreate?: BybitTransactionFromCabinetCreateOrConnectWithoutBybitClipMatchInput
    connect?: BybitTransactionFromCabinetWhereUniqueInput
  }

  export type IdexTransactionCreateNestedOneWithoutBybitClipMatchInput = {
    create?: XOR<IdexTransactionCreateWithoutBybitClipMatchInput, IdexTransactionUncheckedCreateWithoutBybitClipMatchInput>
    connectOrCreate?: IdexTransactionCreateOrConnectWithoutBybitClipMatchInput
    connect?: IdexTransactionWhereUniqueInput
  }

  export type MatchBybitReportCreateNestedOneWithoutBybitClipMatchInput = {
    create?: XOR<MatchBybitReportCreateWithoutBybitClipMatchInput, MatchBybitReportUncheckedCreateWithoutBybitClipMatchInput>
    connectOrCreate?: MatchBybitReportCreateOrConnectWithoutBybitClipMatchInput
    connect?: MatchBybitReportWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBybitClipMatchInput = {
    create?: XOR<UserCreateWithoutBybitClipMatchInput, UserUncheckedCreateWithoutBybitClipMatchInput>
    connectOrCreate?: UserCreateOrConnectWithoutBybitClipMatchInput
    connect?: UserWhereUniqueInput
  }

  export type BybitTransactionFromCabinetUpdateOneRequiredWithoutBybitClipMatchNestedInput = {
    create?: XOR<BybitTransactionFromCabinetCreateWithoutBybitClipMatchInput, BybitTransactionFromCabinetUncheckedCreateWithoutBybitClipMatchInput>
    connectOrCreate?: BybitTransactionFromCabinetCreateOrConnectWithoutBybitClipMatchInput
    upsert?: BybitTransactionFromCabinetUpsertWithoutBybitClipMatchInput
    connect?: BybitTransactionFromCabinetWhereUniqueInput
    update?: XOR<XOR<BybitTransactionFromCabinetUpdateToOneWithWhereWithoutBybitClipMatchInput, BybitTransactionFromCabinetUpdateWithoutBybitClipMatchInput>, BybitTransactionFromCabinetUncheckedUpdateWithoutBybitClipMatchInput>
  }

  export type IdexTransactionUpdateOneRequiredWithoutBybitClipMatchNestedInput = {
    create?: XOR<IdexTransactionCreateWithoutBybitClipMatchInput, IdexTransactionUncheckedCreateWithoutBybitClipMatchInput>
    connectOrCreate?: IdexTransactionCreateOrConnectWithoutBybitClipMatchInput
    upsert?: IdexTransactionUpsertWithoutBybitClipMatchInput
    connect?: IdexTransactionWhereUniqueInput
    update?: XOR<XOR<IdexTransactionUpdateToOneWithWhereWithoutBybitClipMatchInput, IdexTransactionUpdateWithoutBybitClipMatchInput>, IdexTransactionUncheckedUpdateWithoutBybitClipMatchInput>
  }

  export type MatchBybitReportUpdateOneWithoutBybitClipMatchNestedInput = {
    create?: XOR<MatchBybitReportCreateWithoutBybitClipMatchInput, MatchBybitReportUncheckedCreateWithoutBybitClipMatchInput>
    connectOrCreate?: MatchBybitReportCreateOrConnectWithoutBybitClipMatchInput
    upsert?: MatchBybitReportUpsertWithoutBybitClipMatchInput
    disconnect?: MatchBybitReportWhereInput | boolean
    delete?: MatchBybitReportWhereInput | boolean
    connect?: MatchBybitReportWhereUniqueInput
    update?: XOR<XOR<MatchBybitReportUpdateToOneWithWhereWithoutBybitClipMatchInput, MatchBybitReportUpdateWithoutBybitClipMatchInput>, MatchBybitReportUncheckedUpdateWithoutBybitClipMatchInput>
  }

  export type UserUpdateOneRequiredWithoutBybitClipMatchNestedInput = {
    create?: XOR<UserCreateWithoutBybitClipMatchInput, UserUncheckedCreateWithoutBybitClipMatchInput>
    connectOrCreate?: UserCreateOrConnectWithoutBybitClipMatchInput
    upsert?: UserUpsertWithoutBybitClipMatchInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBybitClipMatchInput, UserUpdateWithoutBybitClipMatchInput>, UserUncheckedUpdateWithoutBybitClipMatchInput>
  }

  export type BybitTransactionFromCabinetCreateextractedPhonesInput = {
    set: string[]
  }

  export type BybitClipMatchCreateNestedManyWithoutBybitTransactionFromCabinetInput = {
    create?: XOR<BybitClipMatchCreateWithoutBybitTransactionFromCabinetInput, BybitClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput> | BybitClipMatchCreateWithoutBybitTransactionFromCabinetInput[] | BybitClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput | BybitClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput[]
    createMany?: BybitClipMatchCreateManyBybitTransactionFromCabinetInputEnvelope
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
  }

  export type BybitCabinetCreateNestedOneWithoutBybitTransactionFromCabinetInput = {
    create?: XOR<BybitCabinetCreateWithoutBybitTransactionFromCabinetInput, BybitCabinetUncheckedCreateWithoutBybitTransactionFromCabinetInput>
    connectOrCreate?: BybitCabinetCreateOrConnectWithoutBybitTransactionFromCabinetInput
    connect?: BybitCabinetWhereUniqueInput
  }

  export type ViresClipMatchCreateNestedManyWithoutBybitTransactionFromCabinetInput = {
    create?: XOR<ViresClipMatchCreateWithoutBybitTransactionFromCabinetInput, ViresClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput> | ViresClipMatchCreateWithoutBybitTransactionFromCabinetInput[] | ViresClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput | ViresClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput[]
    createMany?: ViresClipMatchCreateManyBybitTransactionFromCabinetInputEnvelope
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
  }

  export type BybitClipMatchUncheckedCreateNestedManyWithoutBybitTransactionFromCabinetInput = {
    create?: XOR<BybitClipMatchCreateWithoutBybitTransactionFromCabinetInput, BybitClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput> | BybitClipMatchCreateWithoutBybitTransactionFromCabinetInput[] | BybitClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput | BybitClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput[]
    createMany?: BybitClipMatchCreateManyBybitTransactionFromCabinetInputEnvelope
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
  }

  export type ViresClipMatchUncheckedCreateNestedManyWithoutBybitTransactionFromCabinetInput = {
    create?: XOR<ViresClipMatchCreateWithoutBybitTransactionFromCabinetInput, ViresClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput> | ViresClipMatchCreateWithoutBybitTransactionFromCabinetInput[] | ViresClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput | ViresClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput[]
    createMany?: ViresClipMatchCreateManyBybitTransactionFromCabinetInputEnvelope
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
  }

  export type BybitTransactionFromCabinetUpdateextractedPhonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BybitClipMatchUpdateManyWithoutBybitTransactionFromCabinetNestedInput = {
    create?: XOR<BybitClipMatchCreateWithoutBybitTransactionFromCabinetInput, BybitClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput> | BybitClipMatchCreateWithoutBybitTransactionFromCabinetInput[] | BybitClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput | BybitClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput[]
    upsert?: BybitClipMatchUpsertWithWhereUniqueWithoutBybitTransactionFromCabinetInput | BybitClipMatchUpsertWithWhereUniqueWithoutBybitTransactionFromCabinetInput[]
    createMany?: BybitClipMatchCreateManyBybitTransactionFromCabinetInputEnvelope
    set?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    disconnect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    delete?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    update?: BybitClipMatchUpdateWithWhereUniqueWithoutBybitTransactionFromCabinetInput | BybitClipMatchUpdateWithWhereUniqueWithoutBybitTransactionFromCabinetInput[]
    updateMany?: BybitClipMatchUpdateManyWithWhereWithoutBybitTransactionFromCabinetInput | BybitClipMatchUpdateManyWithWhereWithoutBybitTransactionFromCabinetInput[]
    deleteMany?: BybitClipMatchScalarWhereInput | BybitClipMatchScalarWhereInput[]
  }

  export type BybitCabinetUpdateOneRequiredWithoutBybitTransactionFromCabinetNestedInput = {
    create?: XOR<BybitCabinetCreateWithoutBybitTransactionFromCabinetInput, BybitCabinetUncheckedCreateWithoutBybitTransactionFromCabinetInput>
    connectOrCreate?: BybitCabinetCreateOrConnectWithoutBybitTransactionFromCabinetInput
    upsert?: BybitCabinetUpsertWithoutBybitTransactionFromCabinetInput
    connect?: BybitCabinetWhereUniqueInput
    update?: XOR<XOR<BybitCabinetUpdateToOneWithWhereWithoutBybitTransactionFromCabinetInput, BybitCabinetUpdateWithoutBybitTransactionFromCabinetInput>, BybitCabinetUncheckedUpdateWithoutBybitTransactionFromCabinetInput>
  }

  export type ViresClipMatchUpdateManyWithoutBybitTransactionFromCabinetNestedInput = {
    create?: XOR<ViresClipMatchCreateWithoutBybitTransactionFromCabinetInput, ViresClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput> | ViresClipMatchCreateWithoutBybitTransactionFromCabinetInput[] | ViresClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput | ViresClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput[]
    upsert?: ViresClipMatchUpsertWithWhereUniqueWithoutBybitTransactionFromCabinetInput | ViresClipMatchUpsertWithWhereUniqueWithoutBybitTransactionFromCabinetInput[]
    createMany?: ViresClipMatchCreateManyBybitTransactionFromCabinetInputEnvelope
    set?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    disconnect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    delete?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    update?: ViresClipMatchUpdateWithWhereUniqueWithoutBybitTransactionFromCabinetInput | ViresClipMatchUpdateWithWhereUniqueWithoutBybitTransactionFromCabinetInput[]
    updateMany?: ViresClipMatchUpdateManyWithWhereWithoutBybitTransactionFromCabinetInput | ViresClipMatchUpdateManyWithWhereWithoutBybitTransactionFromCabinetInput[]
    deleteMany?: ViresClipMatchScalarWhereInput | ViresClipMatchScalarWhereInput[]
  }

  export type BybitClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetNestedInput = {
    create?: XOR<BybitClipMatchCreateWithoutBybitTransactionFromCabinetInput, BybitClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput> | BybitClipMatchCreateWithoutBybitTransactionFromCabinetInput[] | BybitClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput | BybitClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput[]
    upsert?: BybitClipMatchUpsertWithWhereUniqueWithoutBybitTransactionFromCabinetInput | BybitClipMatchUpsertWithWhereUniqueWithoutBybitTransactionFromCabinetInput[]
    createMany?: BybitClipMatchCreateManyBybitTransactionFromCabinetInputEnvelope
    set?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    disconnect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    delete?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    update?: BybitClipMatchUpdateWithWhereUniqueWithoutBybitTransactionFromCabinetInput | BybitClipMatchUpdateWithWhereUniqueWithoutBybitTransactionFromCabinetInput[]
    updateMany?: BybitClipMatchUpdateManyWithWhereWithoutBybitTransactionFromCabinetInput | BybitClipMatchUpdateManyWithWhereWithoutBybitTransactionFromCabinetInput[]
    deleteMany?: BybitClipMatchScalarWhereInput | BybitClipMatchScalarWhereInput[]
  }

  export type ViresClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetNestedInput = {
    create?: XOR<ViresClipMatchCreateWithoutBybitTransactionFromCabinetInput, ViresClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput> | ViresClipMatchCreateWithoutBybitTransactionFromCabinetInput[] | ViresClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput | ViresClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput[]
    upsert?: ViresClipMatchUpsertWithWhereUniqueWithoutBybitTransactionFromCabinetInput | ViresClipMatchUpsertWithWhereUniqueWithoutBybitTransactionFromCabinetInput[]
    createMany?: ViresClipMatchCreateManyBybitTransactionFromCabinetInputEnvelope
    set?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    disconnect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    delete?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    update?: ViresClipMatchUpdateWithWhereUniqueWithoutBybitTransactionFromCabinetInput | ViresClipMatchUpdateWithWhereUniqueWithoutBybitTransactionFromCabinetInput[]
    updateMany?: ViresClipMatchUpdateManyWithWhereWithoutBybitTransactionFromCabinetInput | ViresClipMatchUpdateManyWithWhereWithoutBybitTransactionFromCabinetInput[]
    deleteMany?: ViresClipMatchScalarWhereInput | ViresClipMatchScalarWhereInput[]
  }

  export type BybitClipMatchCreateNestedManyWithoutMatchBybitReportInput = {
    create?: XOR<BybitClipMatchCreateWithoutMatchBybitReportInput, BybitClipMatchUncheckedCreateWithoutMatchBybitReportInput> | BybitClipMatchCreateWithoutMatchBybitReportInput[] | BybitClipMatchUncheckedCreateWithoutMatchBybitReportInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutMatchBybitReportInput | BybitClipMatchCreateOrConnectWithoutMatchBybitReportInput[]
    createMany?: BybitClipMatchCreateManyMatchBybitReportInputEnvelope
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutMatchBybitReportInput = {
    create?: XOR<UserCreateWithoutMatchBybitReportInput, UserUncheckedCreateWithoutMatchBybitReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchBybitReportInput
    connect?: UserWhereUniqueInput
  }

  export type BybitClipMatchUncheckedCreateNestedManyWithoutMatchBybitReportInput = {
    create?: XOR<BybitClipMatchCreateWithoutMatchBybitReportInput, BybitClipMatchUncheckedCreateWithoutMatchBybitReportInput> | BybitClipMatchCreateWithoutMatchBybitReportInput[] | BybitClipMatchUncheckedCreateWithoutMatchBybitReportInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutMatchBybitReportInput | BybitClipMatchCreateOrConnectWithoutMatchBybitReportInput[]
    createMany?: BybitClipMatchCreateManyMatchBybitReportInputEnvelope
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
  }

  export type BybitClipMatchUpdateManyWithoutMatchBybitReportNestedInput = {
    create?: XOR<BybitClipMatchCreateWithoutMatchBybitReportInput, BybitClipMatchUncheckedCreateWithoutMatchBybitReportInput> | BybitClipMatchCreateWithoutMatchBybitReportInput[] | BybitClipMatchUncheckedCreateWithoutMatchBybitReportInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutMatchBybitReportInput | BybitClipMatchCreateOrConnectWithoutMatchBybitReportInput[]
    upsert?: BybitClipMatchUpsertWithWhereUniqueWithoutMatchBybitReportInput | BybitClipMatchUpsertWithWhereUniqueWithoutMatchBybitReportInput[]
    createMany?: BybitClipMatchCreateManyMatchBybitReportInputEnvelope
    set?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    disconnect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    delete?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    update?: BybitClipMatchUpdateWithWhereUniqueWithoutMatchBybitReportInput | BybitClipMatchUpdateWithWhereUniqueWithoutMatchBybitReportInput[]
    updateMany?: BybitClipMatchUpdateManyWithWhereWithoutMatchBybitReportInput | BybitClipMatchUpdateManyWithWhereWithoutMatchBybitReportInput[]
    deleteMany?: BybitClipMatchScalarWhereInput | BybitClipMatchScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutMatchBybitReportNestedInput = {
    create?: XOR<UserCreateWithoutMatchBybitReportInput, UserUncheckedCreateWithoutMatchBybitReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchBybitReportInput
    upsert?: UserUpsertWithoutMatchBybitReportInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchBybitReportInput, UserUpdateWithoutMatchBybitReportInput>, UserUncheckedUpdateWithoutMatchBybitReportInput>
  }

  export type BybitClipMatchUncheckedUpdateManyWithoutMatchBybitReportNestedInput = {
    create?: XOR<BybitClipMatchCreateWithoutMatchBybitReportInput, BybitClipMatchUncheckedCreateWithoutMatchBybitReportInput> | BybitClipMatchCreateWithoutMatchBybitReportInput[] | BybitClipMatchUncheckedCreateWithoutMatchBybitReportInput[]
    connectOrCreate?: BybitClipMatchCreateOrConnectWithoutMatchBybitReportInput | BybitClipMatchCreateOrConnectWithoutMatchBybitReportInput[]
    upsert?: BybitClipMatchUpsertWithWhereUniqueWithoutMatchBybitReportInput | BybitClipMatchUpsertWithWhereUniqueWithoutMatchBybitReportInput[]
    createMany?: BybitClipMatchCreateManyMatchBybitReportInputEnvelope
    set?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    disconnect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    delete?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    connect?: BybitClipMatchWhereUniqueInput | BybitClipMatchWhereUniqueInput[]
    update?: BybitClipMatchUpdateWithWhereUniqueWithoutMatchBybitReportInput | BybitClipMatchUpdateWithWhereUniqueWithoutMatchBybitReportInput[]
    updateMany?: BybitClipMatchUpdateManyWithWhereWithoutMatchBybitReportInput | BybitClipMatchUpdateManyWithWhereWithoutMatchBybitReportInput[]
    deleteMany?: BybitClipMatchScalarWhereInput | BybitClipMatchScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMatchViresReportInput = {
    create?: XOR<UserCreateWithoutMatchViresReportInput, UserUncheckedCreateWithoutMatchViresReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchViresReportInput
    connect?: UserWhereUniqueInput
  }

  export type ViresClipMatchCreateNestedManyWithoutMatchViresReportInput = {
    create?: XOR<ViresClipMatchCreateWithoutMatchViresReportInput, ViresClipMatchUncheckedCreateWithoutMatchViresReportInput> | ViresClipMatchCreateWithoutMatchViresReportInput[] | ViresClipMatchUncheckedCreateWithoutMatchViresReportInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutMatchViresReportInput | ViresClipMatchCreateOrConnectWithoutMatchViresReportInput[]
    createMany?: ViresClipMatchCreateManyMatchViresReportInputEnvelope
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
  }

  export type ViresClipMatchUncheckedCreateNestedManyWithoutMatchViresReportInput = {
    create?: XOR<ViresClipMatchCreateWithoutMatchViresReportInput, ViresClipMatchUncheckedCreateWithoutMatchViresReportInput> | ViresClipMatchCreateWithoutMatchViresReportInput[] | ViresClipMatchUncheckedCreateWithoutMatchViresReportInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutMatchViresReportInput | ViresClipMatchCreateOrConnectWithoutMatchViresReportInput[]
    createMany?: ViresClipMatchCreateManyMatchViresReportInputEnvelope
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMatchViresReportNestedInput = {
    create?: XOR<UserCreateWithoutMatchViresReportInput, UserUncheckedCreateWithoutMatchViresReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchViresReportInput
    upsert?: UserUpsertWithoutMatchViresReportInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchViresReportInput, UserUpdateWithoutMatchViresReportInput>, UserUncheckedUpdateWithoutMatchViresReportInput>
  }

  export type ViresClipMatchUpdateManyWithoutMatchViresReportNestedInput = {
    create?: XOR<ViresClipMatchCreateWithoutMatchViresReportInput, ViresClipMatchUncheckedCreateWithoutMatchViresReportInput> | ViresClipMatchCreateWithoutMatchViresReportInput[] | ViresClipMatchUncheckedCreateWithoutMatchViresReportInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutMatchViresReportInput | ViresClipMatchCreateOrConnectWithoutMatchViresReportInput[]
    upsert?: ViresClipMatchUpsertWithWhereUniqueWithoutMatchViresReportInput | ViresClipMatchUpsertWithWhereUniqueWithoutMatchViresReportInput[]
    createMany?: ViresClipMatchCreateManyMatchViresReportInputEnvelope
    set?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    disconnect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    delete?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    update?: ViresClipMatchUpdateWithWhereUniqueWithoutMatchViresReportInput | ViresClipMatchUpdateWithWhereUniqueWithoutMatchViresReportInput[]
    updateMany?: ViresClipMatchUpdateManyWithWhereWithoutMatchViresReportInput | ViresClipMatchUpdateManyWithWhereWithoutMatchViresReportInput[]
    deleteMany?: ViresClipMatchScalarWhereInput | ViresClipMatchScalarWhereInput[]
  }

  export type ViresClipMatchUncheckedUpdateManyWithoutMatchViresReportNestedInput = {
    create?: XOR<ViresClipMatchCreateWithoutMatchViresReportInput, ViresClipMatchUncheckedCreateWithoutMatchViresReportInput> | ViresClipMatchCreateWithoutMatchViresReportInput[] | ViresClipMatchUncheckedCreateWithoutMatchViresReportInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutMatchViresReportInput | ViresClipMatchCreateOrConnectWithoutMatchViresReportInput[]
    upsert?: ViresClipMatchUpsertWithWhereUniqueWithoutMatchViresReportInput | ViresClipMatchUpsertWithWhereUniqueWithoutMatchViresReportInput[]
    createMany?: ViresClipMatchCreateManyMatchViresReportInputEnvelope
    set?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    disconnect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    delete?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    update?: ViresClipMatchUpdateWithWhereUniqueWithoutMatchViresReportInput | ViresClipMatchUpdateWithWhereUniqueWithoutMatchViresReportInput[]
    updateMany?: ViresClipMatchUpdateManyWithWhereWithoutMatchViresReportInput | ViresClipMatchUpdateManyWithWhereWithoutMatchViresReportInput[]
    deleteMany?: ViresClipMatchScalarWhereInput | ViresClipMatchScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutViresCabinetInput = {
    create?: XOR<UserCreateWithoutViresCabinetInput, UserUncheckedCreateWithoutViresCabinetInput>
    connectOrCreate?: UserCreateOrConnectWithoutViresCabinetInput
    connect?: UserWhereUniqueInput
  }

  export type ViresTransactionPayinCreateNestedManyWithoutViresCabinetInput = {
    create?: XOR<ViresTransactionPayinCreateWithoutViresCabinetInput, ViresTransactionPayinUncheckedCreateWithoutViresCabinetInput> | ViresTransactionPayinCreateWithoutViresCabinetInput[] | ViresTransactionPayinUncheckedCreateWithoutViresCabinetInput[]
    connectOrCreate?: ViresTransactionPayinCreateOrConnectWithoutViresCabinetInput | ViresTransactionPayinCreateOrConnectWithoutViresCabinetInput[]
    createMany?: ViresTransactionPayinCreateManyViresCabinetInputEnvelope
    connect?: ViresTransactionPayinWhereUniqueInput | ViresTransactionPayinWhereUniqueInput[]
  }

  export type ViresTransactionPayinUncheckedCreateNestedManyWithoutViresCabinetInput = {
    create?: XOR<ViresTransactionPayinCreateWithoutViresCabinetInput, ViresTransactionPayinUncheckedCreateWithoutViresCabinetInput> | ViresTransactionPayinCreateWithoutViresCabinetInput[] | ViresTransactionPayinUncheckedCreateWithoutViresCabinetInput[]
    connectOrCreate?: ViresTransactionPayinCreateOrConnectWithoutViresCabinetInput | ViresTransactionPayinCreateOrConnectWithoutViresCabinetInput[]
    createMany?: ViresTransactionPayinCreateManyViresCabinetInputEnvelope
    connect?: ViresTransactionPayinWhereUniqueInput | ViresTransactionPayinWhereUniqueInput[]
  }

  export type EnumPasswordTypeFieldUpdateOperationsInput = {
    set?: $Enums.PasswordType
  }

  export type UserUpdateOneRequiredWithoutViresCabinetNestedInput = {
    create?: XOR<UserCreateWithoutViresCabinetInput, UserUncheckedCreateWithoutViresCabinetInput>
    connectOrCreate?: UserCreateOrConnectWithoutViresCabinetInput
    upsert?: UserUpsertWithoutViresCabinetInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutViresCabinetInput, UserUpdateWithoutViresCabinetInput>, UserUncheckedUpdateWithoutViresCabinetInput>
  }

  export type ViresTransactionPayinUpdateManyWithoutViresCabinetNestedInput = {
    create?: XOR<ViresTransactionPayinCreateWithoutViresCabinetInput, ViresTransactionPayinUncheckedCreateWithoutViresCabinetInput> | ViresTransactionPayinCreateWithoutViresCabinetInput[] | ViresTransactionPayinUncheckedCreateWithoutViresCabinetInput[]
    connectOrCreate?: ViresTransactionPayinCreateOrConnectWithoutViresCabinetInput | ViresTransactionPayinCreateOrConnectWithoutViresCabinetInput[]
    upsert?: ViresTransactionPayinUpsertWithWhereUniqueWithoutViresCabinetInput | ViresTransactionPayinUpsertWithWhereUniqueWithoutViresCabinetInput[]
    createMany?: ViresTransactionPayinCreateManyViresCabinetInputEnvelope
    set?: ViresTransactionPayinWhereUniqueInput | ViresTransactionPayinWhereUniqueInput[]
    disconnect?: ViresTransactionPayinWhereUniqueInput | ViresTransactionPayinWhereUniqueInput[]
    delete?: ViresTransactionPayinWhereUniqueInput | ViresTransactionPayinWhereUniqueInput[]
    connect?: ViresTransactionPayinWhereUniqueInput | ViresTransactionPayinWhereUniqueInput[]
    update?: ViresTransactionPayinUpdateWithWhereUniqueWithoutViresCabinetInput | ViresTransactionPayinUpdateWithWhereUniqueWithoutViresCabinetInput[]
    updateMany?: ViresTransactionPayinUpdateManyWithWhereWithoutViresCabinetInput | ViresTransactionPayinUpdateManyWithWhereWithoutViresCabinetInput[]
    deleteMany?: ViresTransactionPayinScalarWhereInput | ViresTransactionPayinScalarWhereInput[]
  }

  export type ViresTransactionPayinUncheckedUpdateManyWithoutViresCabinetNestedInput = {
    create?: XOR<ViresTransactionPayinCreateWithoutViresCabinetInput, ViresTransactionPayinUncheckedCreateWithoutViresCabinetInput> | ViresTransactionPayinCreateWithoutViresCabinetInput[] | ViresTransactionPayinUncheckedCreateWithoutViresCabinetInput[]
    connectOrCreate?: ViresTransactionPayinCreateOrConnectWithoutViresCabinetInput | ViresTransactionPayinCreateOrConnectWithoutViresCabinetInput[]
    upsert?: ViresTransactionPayinUpsertWithWhereUniqueWithoutViresCabinetInput | ViresTransactionPayinUpsertWithWhereUniqueWithoutViresCabinetInput[]
    createMany?: ViresTransactionPayinCreateManyViresCabinetInputEnvelope
    set?: ViresTransactionPayinWhereUniqueInput | ViresTransactionPayinWhereUniqueInput[]
    disconnect?: ViresTransactionPayinWhereUniqueInput | ViresTransactionPayinWhereUniqueInput[]
    delete?: ViresTransactionPayinWhereUniqueInput | ViresTransactionPayinWhereUniqueInput[]
    connect?: ViresTransactionPayinWhereUniqueInput | ViresTransactionPayinWhereUniqueInput[]
    update?: ViresTransactionPayinUpdateWithWhereUniqueWithoutViresCabinetInput | ViresTransactionPayinUpdateWithWhereUniqueWithoutViresCabinetInput[]
    updateMany?: ViresTransactionPayinUpdateManyWithWhereWithoutViresCabinetInput | ViresTransactionPayinUpdateManyWithWhereWithoutViresCabinetInput[]
    deleteMany?: ViresTransactionPayinScalarWhereInput | ViresTransactionPayinScalarWhereInput[]
  }

  export type BybitTransactionFromCabinetCreateNestedOneWithoutViresClipMatchInput = {
    create?: XOR<BybitTransactionFromCabinetCreateWithoutViresClipMatchInput, BybitTransactionFromCabinetUncheckedCreateWithoutViresClipMatchInput>
    connectOrCreate?: BybitTransactionFromCabinetCreateOrConnectWithoutViresClipMatchInput
    connect?: BybitTransactionFromCabinetWhereUniqueInput
  }

  export type MatchViresReportCreateNestedOneWithoutViresClipMatchInput = {
    create?: XOR<MatchViresReportCreateWithoutViresClipMatchInput, MatchViresReportUncheckedCreateWithoutViresClipMatchInput>
    connectOrCreate?: MatchViresReportCreateOrConnectWithoutViresClipMatchInput
    connect?: MatchViresReportWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutViresClipMatchInput = {
    create?: XOR<UserCreateWithoutViresClipMatchInput, UserUncheckedCreateWithoutViresClipMatchInput>
    connectOrCreate?: UserCreateOrConnectWithoutViresClipMatchInput
    connect?: UserWhereUniqueInput
  }

  export type ViresTransactionPayinCreateNestedOneWithoutViresClipMatchInput = {
    create?: XOR<ViresTransactionPayinCreateWithoutViresClipMatchInput, ViresTransactionPayinUncheckedCreateWithoutViresClipMatchInput>
    connectOrCreate?: ViresTransactionPayinCreateOrConnectWithoutViresClipMatchInput
    connect?: ViresTransactionPayinWhereUniqueInput
  }

  export type BybitTransactionFromCabinetUpdateOneRequiredWithoutViresClipMatchNestedInput = {
    create?: XOR<BybitTransactionFromCabinetCreateWithoutViresClipMatchInput, BybitTransactionFromCabinetUncheckedCreateWithoutViresClipMatchInput>
    connectOrCreate?: BybitTransactionFromCabinetCreateOrConnectWithoutViresClipMatchInput
    upsert?: BybitTransactionFromCabinetUpsertWithoutViresClipMatchInput
    connect?: BybitTransactionFromCabinetWhereUniqueInput
    update?: XOR<XOR<BybitTransactionFromCabinetUpdateToOneWithWhereWithoutViresClipMatchInput, BybitTransactionFromCabinetUpdateWithoutViresClipMatchInput>, BybitTransactionFromCabinetUncheckedUpdateWithoutViresClipMatchInput>
  }

  export type MatchViresReportUpdateOneWithoutViresClipMatchNestedInput = {
    create?: XOR<MatchViresReportCreateWithoutViresClipMatchInput, MatchViresReportUncheckedCreateWithoutViresClipMatchInput>
    connectOrCreate?: MatchViresReportCreateOrConnectWithoutViresClipMatchInput
    upsert?: MatchViresReportUpsertWithoutViresClipMatchInput
    disconnect?: MatchViresReportWhereInput | boolean
    delete?: MatchViresReportWhereInput | boolean
    connect?: MatchViresReportWhereUniqueInput
    update?: XOR<XOR<MatchViresReportUpdateToOneWithWhereWithoutViresClipMatchInput, MatchViresReportUpdateWithoutViresClipMatchInput>, MatchViresReportUncheckedUpdateWithoutViresClipMatchInput>
  }

  export type UserUpdateOneRequiredWithoutViresClipMatchNestedInput = {
    create?: XOR<UserCreateWithoutViresClipMatchInput, UserUncheckedCreateWithoutViresClipMatchInput>
    connectOrCreate?: UserCreateOrConnectWithoutViresClipMatchInput
    upsert?: UserUpsertWithoutViresClipMatchInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutViresClipMatchInput, UserUpdateWithoutViresClipMatchInput>, UserUncheckedUpdateWithoutViresClipMatchInput>
  }

  export type ViresTransactionPayinUpdateOneRequiredWithoutViresClipMatchNestedInput = {
    create?: XOR<ViresTransactionPayinCreateWithoutViresClipMatchInput, ViresTransactionPayinUncheckedCreateWithoutViresClipMatchInput>
    connectOrCreate?: ViresTransactionPayinCreateOrConnectWithoutViresClipMatchInput
    upsert?: ViresTransactionPayinUpsertWithoutViresClipMatchInput
    connect?: ViresTransactionPayinWhereUniqueInput
    update?: XOR<XOR<ViresTransactionPayinUpdateToOneWithWhereWithoutViresClipMatchInput, ViresTransactionPayinUpdateWithoutViresClipMatchInput>, ViresTransactionPayinUncheckedUpdateWithoutViresClipMatchInput>
  }

  export type ViresClipMatchCreateNestedManyWithoutViresTransactionPayinInput = {
    create?: XOR<ViresClipMatchCreateWithoutViresTransactionPayinInput, ViresClipMatchUncheckedCreateWithoutViresTransactionPayinInput> | ViresClipMatchCreateWithoutViresTransactionPayinInput[] | ViresClipMatchUncheckedCreateWithoutViresTransactionPayinInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutViresTransactionPayinInput | ViresClipMatchCreateOrConnectWithoutViresTransactionPayinInput[]
    createMany?: ViresClipMatchCreateManyViresTransactionPayinInputEnvelope
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
  }

  export type ViresCabinetCreateNestedOneWithoutViresTransactionPayinInput = {
    create?: XOR<ViresCabinetCreateWithoutViresTransactionPayinInput, ViresCabinetUncheckedCreateWithoutViresTransactionPayinInput>
    connectOrCreate?: ViresCabinetCreateOrConnectWithoutViresTransactionPayinInput
    connect?: ViresCabinetWhereUniqueInput
  }

  export type ViresClipMatchUncheckedCreateNestedManyWithoutViresTransactionPayinInput = {
    create?: XOR<ViresClipMatchCreateWithoutViresTransactionPayinInput, ViresClipMatchUncheckedCreateWithoutViresTransactionPayinInput> | ViresClipMatchCreateWithoutViresTransactionPayinInput[] | ViresClipMatchUncheckedCreateWithoutViresTransactionPayinInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutViresTransactionPayinInput | ViresClipMatchCreateOrConnectWithoutViresTransactionPayinInput[]
    createMany?: ViresClipMatchCreateManyViresTransactionPayinInputEnvelope
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
  }

  export type ViresClipMatchUpdateManyWithoutViresTransactionPayinNestedInput = {
    create?: XOR<ViresClipMatchCreateWithoutViresTransactionPayinInput, ViresClipMatchUncheckedCreateWithoutViresTransactionPayinInput> | ViresClipMatchCreateWithoutViresTransactionPayinInput[] | ViresClipMatchUncheckedCreateWithoutViresTransactionPayinInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutViresTransactionPayinInput | ViresClipMatchCreateOrConnectWithoutViresTransactionPayinInput[]
    upsert?: ViresClipMatchUpsertWithWhereUniqueWithoutViresTransactionPayinInput | ViresClipMatchUpsertWithWhereUniqueWithoutViresTransactionPayinInput[]
    createMany?: ViresClipMatchCreateManyViresTransactionPayinInputEnvelope
    set?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    disconnect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    delete?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    update?: ViresClipMatchUpdateWithWhereUniqueWithoutViresTransactionPayinInput | ViresClipMatchUpdateWithWhereUniqueWithoutViresTransactionPayinInput[]
    updateMany?: ViresClipMatchUpdateManyWithWhereWithoutViresTransactionPayinInput | ViresClipMatchUpdateManyWithWhereWithoutViresTransactionPayinInput[]
    deleteMany?: ViresClipMatchScalarWhereInput | ViresClipMatchScalarWhereInput[]
  }

  export type ViresCabinetUpdateOneRequiredWithoutViresTransactionPayinNestedInput = {
    create?: XOR<ViresCabinetCreateWithoutViresTransactionPayinInput, ViresCabinetUncheckedCreateWithoutViresTransactionPayinInput>
    connectOrCreate?: ViresCabinetCreateOrConnectWithoutViresTransactionPayinInput
    upsert?: ViresCabinetUpsertWithoutViresTransactionPayinInput
    connect?: ViresCabinetWhereUniqueInput
    update?: XOR<XOR<ViresCabinetUpdateToOneWithWhereWithoutViresTransactionPayinInput, ViresCabinetUpdateWithoutViresTransactionPayinInput>, ViresCabinetUncheckedUpdateWithoutViresTransactionPayinInput>
  }

  export type ViresClipMatchUncheckedUpdateManyWithoutViresTransactionPayinNestedInput = {
    create?: XOR<ViresClipMatchCreateWithoutViresTransactionPayinInput, ViresClipMatchUncheckedCreateWithoutViresTransactionPayinInput> | ViresClipMatchCreateWithoutViresTransactionPayinInput[] | ViresClipMatchUncheckedCreateWithoutViresTransactionPayinInput[]
    connectOrCreate?: ViresClipMatchCreateOrConnectWithoutViresTransactionPayinInput | ViresClipMatchCreateOrConnectWithoutViresTransactionPayinInput[]
    upsert?: ViresClipMatchUpsertWithWhereUniqueWithoutViresTransactionPayinInput | ViresClipMatchUpsertWithWhereUniqueWithoutViresTransactionPayinInput[]
    createMany?: ViresClipMatchCreateManyViresTransactionPayinInputEnvelope
    set?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    disconnect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    delete?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    connect?: ViresClipMatchWhereUniqueInput | ViresClipMatchWhereUniqueInput[]
    update?: ViresClipMatchUpdateWithWhereUniqueWithoutViresTransactionPayinInput | ViresClipMatchUpdateWithWhereUniqueWithoutViresTransactionPayinInput[]
    updateMany?: ViresClipMatchUpdateManyWithWhereWithoutViresTransactionPayinInput | ViresClipMatchUpdateManyWithWhereWithoutViresTransactionPayinInput[]
    deleteMany?: ViresClipMatchScalarWhereInput | ViresClipMatchScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSalarySectionFilter<$PrismaModel = never> = {
    equals?: $Enums.SalarySection | EnumSalarySectionFieldRefInput<$PrismaModel>
    in?: $Enums.SalarySection[] | ListEnumSalarySectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalarySection[] | ListEnumSalarySectionFieldRefInput<$PrismaModel>
    not?: NestedEnumSalarySectionFilter<$PrismaModel> | $Enums.SalarySection
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumSalarySectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalarySection | EnumSalarySectionFieldRefInput<$PrismaModel>
    in?: $Enums.SalarySection[] | ListEnumSalarySectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalarySection[] | ListEnumSalarySectionFieldRefInput<$PrismaModel>
    not?: NestedEnumSalarySectionWithAggregatesFilter<$PrismaModel> | $Enums.SalarySection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalarySectionFilter<$PrismaModel>
    _max?: NestedEnumSalarySectionFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CardStatus | EnumCardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CardStatus[] | ListEnumCardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardStatus[] | ListEnumCardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCardStatusFilter<$PrismaModel> | $Enums.CardStatus
  }

  export type NestedEnumCardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardStatus | EnumCardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CardStatus[] | ListEnumCardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardStatus[] | ListEnumCardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCardStatusWithAggregatesFilter<$PrismaModel> | $Enums.CardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardStatusFilter<$PrismaModel>
    _max?: NestedEnumCardStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumColumnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ColumnType | EnumColumnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumColumnTypeFilter<$PrismaModel> | $Enums.ColumnType
  }

  export type NestedEnumColumnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ColumnType | EnumColumnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumColumnTypeWithAggregatesFilter<$PrismaModel> | $Enums.ColumnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumColumnTypeFilter<$PrismaModel>
    _max?: NestedEnumColumnTypeFilter<$PrismaModel>
  }

  export type NestedEnumFilterOperatorFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterOperator | EnumFilterOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.FilterOperator[] | ListEnumFilterOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterOperator[] | ListEnumFilterOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterOperatorFilter<$PrismaModel> | $Enums.FilterOperator
  }

  export type NestedEnumFilterOperatorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterOperator | EnumFilterOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.FilterOperator[] | ListEnumFilterOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterOperator[] | ListEnumFilterOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterOperatorWithAggregatesFilter<$PrismaModel> | $Enums.FilterOperator
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFilterOperatorFilter<$PrismaModel>
    _max?: NestedEnumFilterOperatorFilter<$PrismaModel>
  }

  export type NestedEnumIdexSyncOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IdexSyncOrderStatus | EnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdexSyncOrderStatus[] | ListEnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdexSyncOrderStatus[] | ListEnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdexSyncOrderStatusFilter<$PrismaModel> | $Enums.IdexSyncOrderStatus
  }

  export type NestedEnumIdexSyncOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdexSyncOrderStatus | EnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdexSyncOrderStatus[] | ListEnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdexSyncOrderStatus[] | ListEnumIdexSyncOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdexSyncOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.IdexSyncOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdexSyncOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumIdexSyncOrderStatusFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPasswordTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordType | EnumPasswordTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPasswordTypeNullableFilter<$PrismaModel> | $Enums.PasswordType | null
  }

  export type NestedEnumPasswordTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordType | EnumPasswordTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPasswordTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PasswordType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPasswordTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPasswordTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPeriodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PeriodType | EnumPeriodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PeriodType[] | ListEnumPeriodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PeriodType[] | ListEnumPeriodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPeriodTypeFilter<$PrismaModel> | $Enums.PeriodType
  }

  export type NestedEnumPeriodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PeriodType | EnumPeriodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PeriodType[] | ListEnumPeriodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PeriodType[] | ListEnumPeriodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPeriodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PeriodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPeriodTypeFilter<$PrismaModel>
    _max?: NestedEnumPeriodTypeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumPasswordTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordType | EnumPasswordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordTypeFilter<$PrismaModel> | $Enums.PasswordType
  }

  export type NestedEnumPasswordTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordType | EnumPasswordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordType[] | ListEnumPasswordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordTypeWithAggregatesFilter<$PrismaModel> | $Enums.PasswordType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPasswordTypeFilter<$PrismaModel>
    _max?: NestedEnumPasswordTypeFilter<$PrismaModel>
  }

  export type CardBalanceCreateWithoutAuditLogInput = {
    date: Date | string
    startBalance: number
    endBalance: number
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    Card: CardCreateNestedOneWithoutCardBalanceInput
  }

  export type CardBalanceUncheckedCreateWithoutAuditLogInput = {
    id?: number
    cardId: number
    date: Date | string
    startBalance: number
    endBalance: number
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
  }

  export type CardBalanceCreateOrConnectWithoutAuditLogInput = {
    where: CardBalanceWhereUniqueInput
    create: XOR<CardBalanceCreateWithoutAuditLogInput, CardBalanceUncheckedCreateWithoutAuditLogInput>
  }

  export type CardCreateWithoutAuditLogInput = {
    externalId: number
    createdAt?: Date | string
    updatedAt: Date | string
    provider: string
    cardNumber: string
    bank: string
    phoneNumber: string
    appPin: number
    terminalPin: string
    comment?: string | null
    picachu?: string | null
    status?: $Enums.CardStatus
    cardPrice?: number | null
    isPaid?: boolean
    letterCode?: string | null
    actor?: string | null
    inWork?: boolean
    activePaymentMethod?: string | null
    CardBalance?: CardBalanceCreateNestedManyWithoutCardInput
    CardPouring?: CardPouringCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateWithoutAuditLogInput = {
    id?: number
    externalId: number
    createdAt?: Date | string
    updatedAt: Date | string
    provider: string
    cardNumber: string
    bank: string
    phoneNumber: string
    appPin: number
    terminalPin: string
    comment?: string | null
    picachu?: string | null
    status?: $Enums.CardStatus
    cardPrice?: number | null
    isPaid?: boolean
    letterCode?: string | null
    actor?: string | null
    inWork?: boolean
    activePaymentMethod?: string | null
    CardBalance?: CardBalanceUncheckedCreateNestedManyWithoutCardInput
    CardPouring?: CardPouringUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardCreateOrConnectWithoutAuditLogInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutAuditLogInput, CardUncheckedCreateWithoutAuditLogInput>
  }

  export type CardPouringCreateWithoutAuditLogInput = {
    pouringDate: Date | string
    initialAmount: number
    initialDate: Date | string
    finalAmount?: number | null
    finalDate?: Date | string | null
    pouringAmount: number
    withdrawalAmount?: number | null
    withdrawalDate?: Date | string | null
    collectorName?: string | null
    status?: $Enums.CardStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Card: CardCreateNestedOneWithoutCardPouringInput
  }

  export type CardPouringUncheckedCreateWithoutAuditLogInput = {
    id?: number
    cardId: number
    pouringDate: Date | string
    initialAmount: number
    initialDate: Date | string
    finalAmount?: number | null
    finalDate?: Date | string | null
    pouringAmount: number
    withdrawalAmount?: number | null
    withdrawalDate?: Date | string | null
    collectorName?: string | null
    status?: $Enums.CardStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CardPouringCreateOrConnectWithoutAuditLogInput = {
    where: CardPouringWhereUniqueInput
    create: XOR<CardPouringCreateWithoutAuditLogInput, CardPouringUncheckedCreateWithoutAuditLogInput>
  }

  export type UserCreateWithoutAuditLogInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionUncheckedCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportUncheckedCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportUncheckedCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationUncheckedCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetUncheckedCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
  }

  export type CardBalanceUpsertWithoutAuditLogInput = {
    update: XOR<CardBalanceUpdateWithoutAuditLogInput, CardBalanceUncheckedUpdateWithoutAuditLogInput>
    create: XOR<CardBalanceCreateWithoutAuditLogInput, CardBalanceUncheckedCreateWithoutAuditLogInput>
    where?: CardBalanceWhereInput
  }

  export type CardBalanceUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: CardBalanceWhereInput
    data: XOR<CardBalanceUpdateWithoutAuditLogInput, CardBalanceUncheckedUpdateWithoutAuditLogInput>
  }

  export type CardBalanceUpdateWithoutAuditLogInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    Card?: CardUpdateOneRequiredWithoutCardBalanceNestedInput
  }

  export type CardBalanceUncheckedUpdateWithoutAuditLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardUpsertWithoutAuditLogInput = {
    update: XOR<CardUpdateWithoutAuditLogInput, CardUncheckedUpdateWithoutAuditLogInput>
    create: XOR<CardCreateWithoutAuditLogInput, CardUncheckedCreateWithoutAuditLogInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutAuditLogInput, CardUncheckedUpdateWithoutAuditLogInput>
  }

  export type CardUpdateWithoutAuditLogInput = {
    externalId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    appPin?: IntFieldUpdateOperationsInput | number
    terminalPin?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    picachu?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    cardPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    letterCode?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    inWork?: BoolFieldUpdateOperationsInput | boolean
    activePaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    CardBalance?: CardBalanceUpdateManyWithoutCardNestedInput
    CardPouring?: CardPouringUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateWithoutAuditLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    appPin?: IntFieldUpdateOperationsInput | number
    terminalPin?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    picachu?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    cardPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    letterCode?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    inWork?: BoolFieldUpdateOperationsInput | boolean
    activePaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    CardBalance?: CardBalanceUncheckedUpdateManyWithoutCardNestedInput
    CardPouring?: CardPouringUncheckedUpdateManyWithoutCardNestedInput
  }

  export type CardPouringUpsertWithoutAuditLogInput = {
    update: XOR<CardPouringUpdateWithoutAuditLogInput, CardPouringUncheckedUpdateWithoutAuditLogInput>
    create: XOR<CardPouringCreateWithoutAuditLogInput, CardPouringUncheckedCreateWithoutAuditLogInput>
    where?: CardPouringWhereInput
  }

  export type CardPouringUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: CardPouringWhereInput
    data: XOR<CardPouringUpdateWithoutAuditLogInput, CardPouringUncheckedUpdateWithoutAuditLogInput>
  }

  export type CardPouringUpdateWithoutAuditLogInput = {
    pouringDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: FloatFieldUpdateOperationsInput | number
    initialDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    finalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pouringAmount?: FloatFieldUpdateOperationsInput | number
    withdrawalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    withdrawalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Card?: CardUpdateOneRequiredWithoutCardPouringNestedInput
  }

  export type CardPouringUncheckedUpdateWithoutAuditLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    pouringDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: FloatFieldUpdateOperationsInput | number
    initialDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    finalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pouringAmount?: FloatFieldUpdateOperationsInput | number
    withdrawalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    withdrawalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAuditLogInput = {
    update: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type UserUpdateWithoutAuditLogInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUncheckedUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUncheckedUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUncheckedUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUncheckedUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BybitTransactionCreateWithoutBybitMatchInput = {
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    user: UserCreateNestedOneWithoutBybitTransactionInput
  }

  export type BybitTransactionUncheckedCreateWithoutBybitMatchInput = {
    id?: number
    orderNo: string
    counterparty?: string | null
    status: string
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
  }

  export type BybitTransactionCreateOrConnectWithoutBybitMatchInput = {
    where: BybitTransactionWhereUniqueInput
    create: XOR<BybitTransactionCreateWithoutBybitMatchInput, BybitTransactionUncheckedCreateWithoutBybitMatchInput>
  }

  export type IdexTransactionCreateWithoutBybitMatchInput = {
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutIdexTransactionInput
    IdexCabinet: IdexCabinetCreateNestedOneWithoutIdexTransactionInput
    Match?: MatchCreateNestedManyWithoutIdexTransactionInput
  }

  export type IdexTransactionUncheckedCreateWithoutBybitMatchInput = {
    id?: number
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    cabinetId: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutIdexTransactionInput
    Match?: MatchUncheckedCreateNestedManyWithoutIdexTransactionInput
  }

  export type IdexTransactionCreateOrConnectWithoutBybitMatchInput = {
    where: IdexTransactionWhereUniqueInput
    create: XOR<IdexTransactionCreateWithoutBybitMatchInput, IdexTransactionUncheckedCreateWithoutBybitMatchInput>
  }

  export type BybitTransactionUpsertWithoutBybitMatchInput = {
    update: XOR<BybitTransactionUpdateWithoutBybitMatchInput, BybitTransactionUncheckedUpdateWithoutBybitMatchInput>
    create: XOR<BybitTransactionCreateWithoutBybitMatchInput, BybitTransactionUncheckedCreateWithoutBybitMatchInput>
    where?: BybitTransactionWhereInput
  }

  export type BybitTransactionUpdateToOneWithWhereWithoutBybitMatchInput = {
    where?: BybitTransactionWhereInput
    data: XOR<BybitTransactionUpdateWithoutBybitMatchInput, BybitTransactionUncheckedUpdateWithoutBybitMatchInput>
  }

  export type BybitTransactionUpdateWithoutBybitMatchInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBybitTransactionNestedInput
  }

  export type BybitTransactionUncheckedUpdateWithoutBybitMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IdexTransactionUpsertWithoutBybitMatchInput = {
    update: XOR<IdexTransactionUpdateWithoutBybitMatchInput, IdexTransactionUncheckedUpdateWithoutBybitMatchInput>
    create: XOR<IdexTransactionCreateWithoutBybitMatchInput, IdexTransactionUncheckedCreateWithoutBybitMatchInput>
    where?: IdexTransactionWhereInput
  }

  export type IdexTransactionUpdateToOneWithWhereWithoutBybitMatchInput = {
    where?: IdexTransactionWhereInput
    data: XOR<IdexTransactionUpdateWithoutBybitMatchInput, IdexTransactionUncheckedUpdateWithoutBybitMatchInput>
  }

  export type IdexTransactionUpdateWithoutBybitMatchInput = {
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutIdexTransactionNestedInput
    IdexCabinet?: IdexCabinetUpdateOneRequiredWithoutIdexTransactionNestedInput
    Match?: MatchUpdateManyWithoutIdexTransactionNestedInput
  }

  export type IdexTransactionUncheckedUpdateWithoutBybitMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    cabinetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
    Match?: MatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
  }

  export type BybitCabinetCreateWithoutBybitOrderInfoInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    bybitEmail: string
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetCreateNestedManyWithoutBybitCabinetInput
  }

  export type BybitCabinetUncheckedCreateWithoutBybitOrderInfoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    bybitEmail: string
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUncheckedCreateNestedManyWithoutBybitCabinetInput
  }

  export type BybitCabinetCreateOrConnectWithoutBybitOrderInfoInput = {
    where: BybitCabinetWhereUniqueInput
    create: XOR<BybitCabinetCreateWithoutBybitOrderInfoInput, BybitCabinetUncheckedCreateWithoutBybitOrderInfoInput>
  }

  export type BybitCabinetUpsertWithoutBybitOrderInfoInput = {
    update: XOR<BybitCabinetUpdateWithoutBybitOrderInfoInput, BybitCabinetUncheckedUpdateWithoutBybitOrderInfoInput>
    create: XOR<BybitCabinetCreateWithoutBybitOrderInfoInput, BybitCabinetUncheckedCreateWithoutBybitOrderInfoInput>
    where?: BybitCabinetWhereInput
  }

  export type BybitCabinetUpdateToOneWithWhereWithoutBybitOrderInfoInput = {
    where?: BybitCabinetWhereInput
    data: XOR<BybitCabinetUpdateWithoutBybitOrderInfoInput, BybitCabinetUncheckedUpdateWithoutBybitOrderInfoInput>
  }

  export type BybitCabinetUpdateWithoutBybitOrderInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bybitEmail?: StringFieldUpdateOperationsInput | string
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUpdateManyWithoutBybitCabinetNestedInput
  }

  export type BybitCabinetUncheckedUpdateWithoutBybitOrderInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bybitEmail?: StringFieldUpdateOperationsInput | string
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUncheckedUpdateManyWithoutBybitCabinetNestedInput
  }

  export type BybitMatchCreateWithoutBybitTransactionInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    IdexTransaction: IdexTransactionCreateNestedOneWithoutBybitMatchInput
  }

  export type BybitMatchUncheckedCreateWithoutBybitTransactionInput = {
    id?: number
    idexTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BybitMatchCreateOrConnectWithoutBybitTransactionInput = {
    where: BybitMatchWhereUniqueInput
    create: XOR<BybitMatchCreateWithoutBybitTransactionInput, BybitMatchUncheckedCreateWithoutBybitTransactionInput>
  }

  export type BybitMatchCreateManyBybitTransactionInputEnvelope = {
    data: BybitMatchCreateManyBybitTransactionInput | BybitMatchCreateManyBybitTransactionInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBybitTransactionInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBybitTransactionInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportUncheckedCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportUncheckedCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationUncheckedCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetUncheckedCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBybitTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBybitTransactionInput, UserUncheckedCreateWithoutBybitTransactionInput>
  }

  export type BybitMatchUpsertWithWhereUniqueWithoutBybitTransactionInput = {
    where: BybitMatchWhereUniqueInput
    update: XOR<BybitMatchUpdateWithoutBybitTransactionInput, BybitMatchUncheckedUpdateWithoutBybitTransactionInput>
    create: XOR<BybitMatchCreateWithoutBybitTransactionInput, BybitMatchUncheckedCreateWithoutBybitTransactionInput>
  }

  export type BybitMatchUpdateWithWhereUniqueWithoutBybitTransactionInput = {
    where: BybitMatchWhereUniqueInput
    data: XOR<BybitMatchUpdateWithoutBybitTransactionInput, BybitMatchUncheckedUpdateWithoutBybitTransactionInput>
  }

  export type BybitMatchUpdateManyWithWhereWithoutBybitTransactionInput = {
    where: BybitMatchScalarWhereInput
    data: XOR<BybitMatchUpdateManyMutationInput, BybitMatchUncheckedUpdateManyWithoutBybitTransactionInput>
  }

  export type BybitMatchScalarWhereInput = {
    AND?: BybitMatchScalarWhereInput | BybitMatchScalarWhereInput[]
    OR?: BybitMatchScalarWhereInput[]
    NOT?: BybitMatchScalarWhereInput | BybitMatchScalarWhereInput[]
    id?: IntFilter<"BybitMatch"> | number
    idexTransactionId?: IntFilter<"BybitMatch"> | number
    bybitTransactionId?: IntFilter<"BybitMatch"> | number
    timeDifference?: IntFilter<"BybitMatch"> | number
    grossExpense?: FloatFilter<"BybitMatch"> | number
    grossIncome?: FloatFilter<"BybitMatch"> | number
    grossProfit?: FloatFilter<"BybitMatch"> | number
    profitPercentage?: FloatFilter<"BybitMatch"> | number
    createdAt?: DateTimeFilter<"BybitMatch"> | Date | string
    updatedAt?: DateTimeFilter<"BybitMatch"> | Date | string
  }

  export type UserUpsertWithoutBybitTransactionInput = {
    update: XOR<UserUpdateWithoutBybitTransactionInput, UserUncheckedUpdateWithoutBybitTransactionInput>
    create: XOR<UserCreateWithoutBybitTransactionInput, UserUncheckedCreateWithoutBybitTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBybitTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBybitTransactionInput, UserUncheckedUpdateWithoutBybitTransactionInput>
  }

  export type UserUpdateWithoutBybitTransactionInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBybitTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUncheckedUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUncheckedUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUncheckedUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AuditLogCreateWithoutCardInput = {
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    CardBalance?: CardBalanceCreateNestedOneWithoutAuditLogInput
    CardPouring?: CardPouringCreateNestedOneWithoutAuditLogInput
    User: UserCreateNestedOneWithoutAuditLogInput
  }

  export type AuditLogUncheckedCreateWithoutCardInput = {
    id?: number
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    userId: number
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: number | null
    cardPouringId?: number | null
  }

  export type AuditLogCreateOrConnectWithoutCardInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCardInput, AuditLogUncheckedCreateWithoutCardInput>
  }

  export type AuditLogCreateManyCardInputEnvelope = {
    data: AuditLogCreateManyCardInput | AuditLogCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type CardBalanceCreateWithoutCardInput = {
    date: Date | string
    startBalance: number
    endBalance: number
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutCardBalanceInput
  }

  export type CardBalanceUncheckedCreateWithoutCardInput = {
    id?: number
    date: Date | string
    startBalance: number
    endBalance: number
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutCardBalanceInput
  }

  export type CardBalanceCreateOrConnectWithoutCardInput = {
    where: CardBalanceWhereUniqueInput
    create: XOR<CardBalanceCreateWithoutCardInput, CardBalanceUncheckedCreateWithoutCardInput>
  }

  export type CardBalanceCreateManyCardInputEnvelope = {
    data: CardBalanceCreateManyCardInput | CardBalanceCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type CardPouringCreateWithoutCardInput = {
    pouringDate: Date | string
    initialAmount: number
    initialDate: Date | string
    finalAmount?: number | null
    finalDate?: Date | string | null
    pouringAmount: number
    withdrawalAmount?: number | null
    withdrawalDate?: Date | string | null
    collectorName?: string | null
    status?: $Enums.CardStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutCardPouringInput
  }

  export type CardPouringUncheckedCreateWithoutCardInput = {
    id?: number
    pouringDate: Date | string
    initialAmount: number
    initialDate: Date | string
    finalAmount?: number | null
    finalDate?: Date | string | null
    pouringAmount: number
    withdrawalAmount?: number | null
    withdrawalDate?: Date | string | null
    collectorName?: string | null
    status?: $Enums.CardStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutCardPouringInput
  }

  export type CardPouringCreateOrConnectWithoutCardInput = {
    where: CardPouringWhereUniqueInput
    create: XOR<CardPouringCreateWithoutCardInput, CardPouringUncheckedCreateWithoutCardInput>
  }

  export type CardPouringCreateManyCardInputEnvelope = {
    data: CardPouringCreateManyCardInput | CardPouringCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCardInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCardInput, AuditLogUncheckedUpdateWithoutCardInput>
    create: XOR<AuditLogCreateWithoutCardInput, AuditLogUncheckedCreateWithoutCardInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCardInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCardInput, AuditLogUncheckedUpdateWithoutCardInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCardInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCardInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: IntFilter<"AuditLog"> | number
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    userId?: IntFilter<"AuditLog"> | number
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    cardBalanceId?: IntNullableFilter<"AuditLog"> | number | null
    cardId?: IntNullableFilter<"AuditLog"> | number | null
    cardPouringId?: IntNullableFilter<"AuditLog"> | number | null
  }

  export type CardBalanceUpsertWithWhereUniqueWithoutCardInput = {
    where: CardBalanceWhereUniqueInput
    update: XOR<CardBalanceUpdateWithoutCardInput, CardBalanceUncheckedUpdateWithoutCardInput>
    create: XOR<CardBalanceCreateWithoutCardInput, CardBalanceUncheckedCreateWithoutCardInput>
  }

  export type CardBalanceUpdateWithWhereUniqueWithoutCardInput = {
    where: CardBalanceWhereUniqueInput
    data: XOR<CardBalanceUpdateWithoutCardInput, CardBalanceUncheckedUpdateWithoutCardInput>
  }

  export type CardBalanceUpdateManyWithWhereWithoutCardInput = {
    where: CardBalanceScalarWhereInput
    data: XOR<CardBalanceUpdateManyMutationInput, CardBalanceUncheckedUpdateManyWithoutCardInput>
  }

  export type CardBalanceScalarWhereInput = {
    AND?: CardBalanceScalarWhereInput | CardBalanceScalarWhereInput[]
    OR?: CardBalanceScalarWhereInput[]
    NOT?: CardBalanceScalarWhereInput | CardBalanceScalarWhereInput[]
    id?: IntFilter<"CardBalance"> | number
    cardId?: IntFilter<"CardBalance"> | number
    date?: DateTimeFilter<"CardBalance"> | Date | string
    startBalance?: FloatFilter<"CardBalance"> | number
    endBalance?: FloatFilter<"CardBalance"> | number
    createdAt?: DateTimeFilter<"CardBalance"> | Date | string
    updatedAt?: DateTimeFilter<"CardBalance"> | Date | string
    comment?: StringNullableFilter<"CardBalance"> | string | null
  }

  export type CardPouringUpsertWithWhereUniqueWithoutCardInput = {
    where: CardPouringWhereUniqueInput
    update: XOR<CardPouringUpdateWithoutCardInput, CardPouringUncheckedUpdateWithoutCardInput>
    create: XOR<CardPouringCreateWithoutCardInput, CardPouringUncheckedCreateWithoutCardInput>
  }

  export type CardPouringUpdateWithWhereUniqueWithoutCardInput = {
    where: CardPouringWhereUniqueInput
    data: XOR<CardPouringUpdateWithoutCardInput, CardPouringUncheckedUpdateWithoutCardInput>
  }

  export type CardPouringUpdateManyWithWhereWithoutCardInput = {
    where: CardPouringScalarWhereInput
    data: XOR<CardPouringUpdateManyMutationInput, CardPouringUncheckedUpdateManyWithoutCardInput>
  }

  export type CardPouringScalarWhereInput = {
    AND?: CardPouringScalarWhereInput | CardPouringScalarWhereInput[]
    OR?: CardPouringScalarWhereInput[]
    NOT?: CardPouringScalarWhereInput | CardPouringScalarWhereInput[]
    id?: IntFilter<"CardPouring"> | number
    cardId?: IntFilter<"CardPouring"> | number
    pouringDate?: DateTimeFilter<"CardPouring"> | Date | string
    initialAmount?: FloatFilter<"CardPouring"> | number
    initialDate?: DateTimeFilter<"CardPouring"> | Date | string
    finalAmount?: FloatNullableFilter<"CardPouring"> | number | null
    finalDate?: DateTimeNullableFilter<"CardPouring"> | Date | string | null
    pouringAmount?: FloatFilter<"CardPouring"> | number
    withdrawalAmount?: FloatNullableFilter<"CardPouring"> | number | null
    withdrawalDate?: DateTimeNullableFilter<"CardPouring"> | Date | string | null
    collectorName?: StringNullableFilter<"CardPouring"> | string | null
    status?: EnumCardStatusFilter<"CardPouring"> | $Enums.CardStatus
    comment?: StringNullableFilter<"CardPouring"> | string | null
    createdAt?: DateTimeFilter<"CardPouring"> | Date | string
    updatedAt?: DateTimeFilter<"CardPouring"> | Date | string
  }

  export type AuditLogCreateWithoutCardBalanceInput = {
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    Card?: CardCreateNestedOneWithoutAuditLogInput
    CardPouring?: CardPouringCreateNestedOneWithoutAuditLogInput
    User: UserCreateNestedOneWithoutAuditLogInput
  }

  export type AuditLogUncheckedCreateWithoutCardBalanceInput = {
    id?: number
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    userId: number
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardId?: number | null
    cardPouringId?: number | null
  }

  export type AuditLogCreateOrConnectWithoutCardBalanceInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCardBalanceInput, AuditLogUncheckedCreateWithoutCardBalanceInput>
  }

  export type AuditLogCreateManyCardBalanceInputEnvelope = {
    data: AuditLogCreateManyCardBalanceInput | AuditLogCreateManyCardBalanceInput[]
    skipDuplicates?: boolean
  }

  export type CardCreateWithoutCardBalanceInput = {
    externalId: number
    createdAt?: Date | string
    updatedAt: Date | string
    provider: string
    cardNumber: string
    bank: string
    phoneNumber: string
    appPin: number
    terminalPin: string
    comment?: string | null
    picachu?: string | null
    status?: $Enums.CardStatus
    cardPrice?: number | null
    isPaid?: boolean
    letterCode?: string | null
    actor?: string | null
    inWork?: boolean
    activePaymentMethod?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutCardInput
    CardPouring?: CardPouringCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateWithoutCardBalanceInput = {
    id?: number
    externalId: number
    createdAt?: Date | string
    updatedAt: Date | string
    provider: string
    cardNumber: string
    bank: string
    phoneNumber: string
    appPin: number
    terminalPin: string
    comment?: string | null
    picachu?: string | null
    status?: $Enums.CardStatus
    cardPrice?: number | null
    isPaid?: boolean
    letterCode?: string | null
    actor?: string | null
    inWork?: boolean
    activePaymentMethod?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutCardInput
    CardPouring?: CardPouringUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardCreateOrConnectWithoutCardBalanceInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutCardBalanceInput, CardUncheckedCreateWithoutCardBalanceInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCardBalanceInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCardBalanceInput, AuditLogUncheckedUpdateWithoutCardBalanceInput>
    create: XOR<AuditLogCreateWithoutCardBalanceInput, AuditLogUncheckedCreateWithoutCardBalanceInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCardBalanceInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCardBalanceInput, AuditLogUncheckedUpdateWithoutCardBalanceInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCardBalanceInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCardBalanceInput>
  }

  export type CardUpsertWithoutCardBalanceInput = {
    update: XOR<CardUpdateWithoutCardBalanceInput, CardUncheckedUpdateWithoutCardBalanceInput>
    create: XOR<CardCreateWithoutCardBalanceInput, CardUncheckedCreateWithoutCardBalanceInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutCardBalanceInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutCardBalanceInput, CardUncheckedUpdateWithoutCardBalanceInput>
  }

  export type CardUpdateWithoutCardBalanceInput = {
    externalId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    appPin?: IntFieldUpdateOperationsInput | number
    terminalPin?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    picachu?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    cardPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    letterCode?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    inWork?: BoolFieldUpdateOperationsInput | boolean
    activePaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutCardNestedInput
    CardPouring?: CardPouringUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateWithoutCardBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    appPin?: IntFieldUpdateOperationsInput | number
    terminalPin?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    picachu?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    cardPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    letterCode?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    inWork?: BoolFieldUpdateOperationsInput | boolean
    activePaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutCardNestedInput
    CardPouring?: CardPouringUncheckedUpdateManyWithoutCardNestedInput
  }

  export type AuditLogCreateWithoutCardPouringInput = {
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    CardBalance?: CardBalanceCreateNestedOneWithoutAuditLogInput
    Card?: CardCreateNestedOneWithoutAuditLogInput
    User: UserCreateNestedOneWithoutAuditLogInput
  }

  export type AuditLogUncheckedCreateWithoutCardPouringInput = {
    id?: number
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    userId: number
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: number | null
    cardId?: number | null
  }

  export type AuditLogCreateOrConnectWithoutCardPouringInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCardPouringInput, AuditLogUncheckedCreateWithoutCardPouringInput>
  }

  export type AuditLogCreateManyCardPouringInputEnvelope = {
    data: AuditLogCreateManyCardPouringInput | AuditLogCreateManyCardPouringInput[]
    skipDuplicates?: boolean
  }

  export type CardCreateWithoutCardPouringInput = {
    externalId: number
    createdAt?: Date | string
    updatedAt: Date | string
    provider: string
    cardNumber: string
    bank: string
    phoneNumber: string
    appPin: number
    terminalPin: string
    comment?: string | null
    picachu?: string | null
    status?: $Enums.CardStatus
    cardPrice?: number | null
    isPaid?: boolean
    letterCode?: string | null
    actor?: string | null
    inWork?: boolean
    activePaymentMethod?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutCardInput
    CardBalance?: CardBalanceCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateWithoutCardPouringInput = {
    id?: number
    externalId: number
    createdAt?: Date | string
    updatedAt: Date | string
    provider: string
    cardNumber: string
    bank: string
    phoneNumber: string
    appPin: number
    terminalPin: string
    comment?: string | null
    picachu?: string | null
    status?: $Enums.CardStatus
    cardPrice?: number | null
    isPaid?: boolean
    letterCode?: string | null
    actor?: string | null
    inWork?: boolean
    activePaymentMethod?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutCardInput
    CardBalance?: CardBalanceUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardCreateOrConnectWithoutCardPouringInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutCardPouringInput, CardUncheckedCreateWithoutCardPouringInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCardPouringInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCardPouringInput, AuditLogUncheckedUpdateWithoutCardPouringInput>
    create: XOR<AuditLogCreateWithoutCardPouringInput, AuditLogUncheckedCreateWithoutCardPouringInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCardPouringInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCardPouringInput, AuditLogUncheckedUpdateWithoutCardPouringInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCardPouringInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCardPouringInput>
  }

  export type CardUpsertWithoutCardPouringInput = {
    update: XOR<CardUpdateWithoutCardPouringInput, CardUncheckedUpdateWithoutCardPouringInput>
    create: XOR<CardCreateWithoutCardPouringInput, CardUncheckedCreateWithoutCardPouringInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutCardPouringInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutCardPouringInput, CardUncheckedUpdateWithoutCardPouringInput>
  }

  export type CardUpdateWithoutCardPouringInput = {
    externalId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    appPin?: IntFieldUpdateOperationsInput | number
    terminalPin?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    picachu?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    cardPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    letterCode?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    inWork?: BoolFieldUpdateOperationsInput | boolean
    activePaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutCardNestedInput
    CardBalance?: CardBalanceUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateWithoutCardPouringInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    appPin?: IntFieldUpdateOperationsInput | number
    terminalPin?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    picachu?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    cardPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    letterCode?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    inWork?: BoolFieldUpdateOperationsInput | boolean
    activePaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutCardNestedInput
    CardBalance?: CardBalanceUncheckedUpdateManyWithoutCardNestedInput
  }

  export type ColumnCreateWithoutCellInput = {
    name: string
    type: $Enums.ColumnType
    width?: number | null
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: string | null
    format?: string | null
    order: number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    Table: TableCreateNestedOneWithoutColumnInput
    Filter?: FilterCreateNestedManyWithoutColumnInput
  }

  export type ColumnUncheckedCreateWithoutCellInput = {
    id?: number
    name: string
    type: $Enums.ColumnType
    tableId: number
    width?: number | null
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: string | null
    format?: string | null
    order: number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    Filter?: FilterUncheckedCreateNestedManyWithoutColumnInput
  }

  export type ColumnCreateOrConnectWithoutCellInput = {
    where: ColumnWhereUniqueInput
    create: XOR<ColumnCreateWithoutCellInput, ColumnUncheckedCreateWithoutCellInput>
  }

  export type RowCreateWithoutCellInput = {
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Table: TableCreateNestedOneWithoutRowInput
  }

  export type RowUncheckedCreateWithoutCellInput = {
    id?: number
    tableId: number
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type RowCreateOrConnectWithoutCellInput = {
    where: RowWhereUniqueInput
    create: XOR<RowCreateWithoutCellInput, RowUncheckedCreateWithoutCellInput>
  }

  export type CommentCreateWithoutCellInput = {
    text: string
    author?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CommentUncheckedCreateWithoutCellInput = {
    id?: number
    text: string
    author?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CommentCreateOrConnectWithoutCellInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCellInput, CommentUncheckedCreateWithoutCellInput>
  }

  export type CommentCreateManyCellInputEnvelope = {
    data: CommentCreateManyCellInput | CommentCreateManyCellInput[]
    skipDuplicates?: boolean
  }

  export type ColumnUpsertWithoutCellInput = {
    update: XOR<ColumnUpdateWithoutCellInput, ColumnUncheckedUpdateWithoutCellInput>
    create: XOR<ColumnCreateWithoutCellInput, ColumnUncheckedCreateWithoutCellInput>
    where?: ColumnWhereInput
  }

  export type ColumnUpdateToOneWithWhereWithoutCellInput = {
    where?: ColumnWhereInput
    data: XOR<ColumnUpdateWithoutCellInput, ColumnUncheckedUpdateWithoutCellInput>
  }

  export type ColumnUpdateWithoutCellInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    width?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    isSummable?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Table?: TableUpdateOneRequiredWithoutColumnNestedInput
    Filter?: FilterUpdateManyWithoutColumnNestedInput
  }

  export type ColumnUncheckedUpdateWithoutCellInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    tableId?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    isSummable?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Filter?: FilterUncheckedUpdateManyWithoutColumnNestedInput
  }

  export type RowUpsertWithoutCellInput = {
    update: XOR<RowUpdateWithoutCellInput, RowUncheckedUpdateWithoutCellInput>
    create: XOR<RowCreateWithoutCellInput, RowUncheckedCreateWithoutCellInput>
    where?: RowWhereInput
  }

  export type RowUpdateToOneWithWhereWithoutCellInput = {
    where?: RowWhereInput
    data: XOR<RowUpdateWithoutCellInput, RowUncheckedUpdateWithoutCellInput>
  }

  export type RowUpdateWithoutCellInput = {
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Table?: TableUpdateOneRequiredWithoutRowNestedInput
  }

  export type RowUncheckedUpdateWithoutCellInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutCellInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCellInput, CommentUncheckedUpdateWithoutCellInput>
    create: XOR<CommentCreateWithoutCellInput, CommentUncheckedCreateWithoutCellInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCellInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCellInput, CommentUncheckedUpdateWithoutCellInput>
  }

  export type CommentUpdateManyWithWhereWithoutCellInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCellInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    cellId?: IntFilter<"Comment"> | number
    text?: StringFilter<"Comment"> | string
    author?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type CellCreateWithoutColumnInput = {
    value?: string | null
    displayValue?: string | null
    calculatedValue?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Row: RowCreateNestedOneWithoutCellInput
    Comment?: CommentCreateNestedManyWithoutCellInput
  }

  export type CellUncheckedCreateWithoutColumnInput = {
    id?: number
    rowId: number
    value?: string | null
    displayValue?: string | null
    calculatedValue?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Comment?: CommentUncheckedCreateNestedManyWithoutCellInput
  }

  export type CellCreateOrConnectWithoutColumnInput = {
    where: CellWhereUniqueInput
    create: XOR<CellCreateWithoutColumnInput, CellUncheckedCreateWithoutColumnInput>
  }

  export type CellCreateManyColumnInputEnvelope = {
    data: CellCreateManyColumnInput | CellCreateManyColumnInput[]
    skipDuplicates?: boolean
  }

  export type TableCreateWithoutColumnInput = {
    name: string
    description?: string | null
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Filter?: FilterCreateNestedManyWithoutTableInput
    Row?: RowCreateNestedManyWithoutTableInput
    Section: SectionCreateNestedOneWithoutTableInput
  }

  export type TableUncheckedCreateWithoutColumnInput = {
    id?: number
    name: string
    description?: string | null
    sectionId: number
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Filter?: FilterUncheckedCreateNestedManyWithoutTableInput
    Row?: RowUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutColumnInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutColumnInput, TableUncheckedCreateWithoutColumnInput>
  }

  export type FilterCreateWithoutColumnInput = {
    name: string
    operator: $Enums.FilterOperator
    value?: string | null
    secondValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Table: TableCreateNestedOneWithoutFilterInput
  }

  export type FilterUncheckedCreateWithoutColumnInput = {
    id?: number
    name: string
    tableId: number
    operator: $Enums.FilterOperator
    value?: string | null
    secondValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type FilterCreateOrConnectWithoutColumnInput = {
    where: FilterWhereUniqueInput
    create: XOR<FilterCreateWithoutColumnInput, FilterUncheckedCreateWithoutColumnInput>
  }

  export type FilterCreateManyColumnInputEnvelope = {
    data: FilterCreateManyColumnInput | FilterCreateManyColumnInput[]
    skipDuplicates?: boolean
  }

  export type CellUpsertWithWhereUniqueWithoutColumnInput = {
    where: CellWhereUniqueInput
    update: XOR<CellUpdateWithoutColumnInput, CellUncheckedUpdateWithoutColumnInput>
    create: XOR<CellCreateWithoutColumnInput, CellUncheckedCreateWithoutColumnInput>
  }

  export type CellUpdateWithWhereUniqueWithoutColumnInput = {
    where: CellWhereUniqueInput
    data: XOR<CellUpdateWithoutColumnInput, CellUncheckedUpdateWithoutColumnInput>
  }

  export type CellUpdateManyWithWhereWithoutColumnInput = {
    where: CellScalarWhereInput
    data: XOR<CellUpdateManyMutationInput, CellUncheckedUpdateManyWithoutColumnInput>
  }

  export type CellScalarWhereInput = {
    AND?: CellScalarWhereInput | CellScalarWhereInput[]
    OR?: CellScalarWhereInput[]
    NOT?: CellScalarWhereInput | CellScalarWhereInput[]
    id?: IntFilter<"Cell"> | number
    rowId?: IntFilter<"Cell"> | number
    columnId?: IntFilter<"Cell"> | number
    value?: StringNullableFilter<"Cell"> | string | null
    displayValue?: StringNullableFilter<"Cell"> | string | null
    calculatedValue?: StringNullableFilter<"Cell"> | string | null
    createdAt?: DateTimeFilter<"Cell"> | Date | string
    updatedAt?: DateTimeFilter<"Cell"> | Date | string
  }

  export type TableUpsertWithoutColumnInput = {
    update: XOR<TableUpdateWithoutColumnInput, TableUncheckedUpdateWithoutColumnInput>
    create: XOR<TableCreateWithoutColumnInput, TableUncheckedCreateWithoutColumnInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutColumnInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutColumnInput, TableUncheckedUpdateWithoutColumnInput>
  }

  export type TableUpdateWithoutColumnInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Filter?: FilterUpdateManyWithoutTableNestedInput
    Row?: RowUpdateManyWithoutTableNestedInput
    Section?: SectionUpdateOneRequiredWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutColumnInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sectionId?: IntFieldUpdateOperationsInput | number
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Filter?: FilterUncheckedUpdateManyWithoutTableNestedInput
    Row?: RowUncheckedUpdateManyWithoutTableNestedInput
  }

  export type FilterUpsertWithWhereUniqueWithoutColumnInput = {
    where: FilterWhereUniqueInput
    update: XOR<FilterUpdateWithoutColumnInput, FilterUncheckedUpdateWithoutColumnInput>
    create: XOR<FilterCreateWithoutColumnInput, FilterUncheckedCreateWithoutColumnInput>
  }

  export type FilterUpdateWithWhereUniqueWithoutColumnInput = {
    where: FilterWhereUniqueInput
    data: XOR<FilterUpdateWithoutColumnInput, FilterUncheckedUpdateWithoutColumnInput>
  }

  export type FilterUpdateManyWithWhereWithoutColumnInput = {
    where: FilterScalarWhereInput
    data: XOR<FilterUpdateManyMutationInput, FilterUncheckedUpdateManyWithoutColumnInput>
  }

  export type FilterScalarWhereInput = {
    AND?: FilterScalarWhereInput | FilterScalarWhereInput[]
    OR?: FilterScalarWhereInput[]
    NOT?: FilterScalarWhereInput | FilterScalarWhereInput[]
    id?: IntFilter<"Filter"> | number
    name?: StringFilter<"Filter"> | string
    tableId?: IntFilter<"Filter"> | number
    columnId?: IntFilter<"Filter"> | number
    operator?: EnumFilterOperatorFilter<"Filter"> | $Enums.FilterOperator
    value?: StringNullableFilter<"Filter"> | string | null
    secondValue?: StringNullableFilter<"Filter"> | string | null
    isActive?: BoolFilter<"Filter"> | boolean
    createdAt?: DateTimeFilter<"Filter"> | Date | string
    updatedAt?: DateTimeFilter<"Filter"> | Date | string
  }

  export type CellCreateWithoutCommentInput = {
    value?: string | null
    displayValue?: string | null
    calculatedValue?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Column: ColumnCreateNestedOneWithoutCellInput
    Row: RowCreateNestedOneWithoutCellInput
  }

  export type CellUncheckedCreateWithoutCommentInput = {
    id?: number
    rowId: number
    columnId: number
    value?: string | null
    displayValue?: string | null
    calculatedValue?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CellCreateOrConnectWithoutCommentInput = {
    where: CellWhereUniqueInput
    create: XOR<CellCreateWithoutCommentInput, CellUncheckedCreateWithoutCommentInput>
  }

  export type CellUpsertWithoutCommentInput = {
    update: XOR<CellUpdateWithoutCommentInput, CellUncheckedUpdateWithoutCommentInput>
    create: XOR<CellCreateWithoutCommentInput, CellUncheckedCreateWithoutCommentInput>
    where?: CellWhereInput
  }

  export type CellUpdateToOneWithWhereWithoutCommentInput = {
    where?: CellWhereInput
    data: XOR<CellUpdateWithoutCommentInput, CellUncheckedUpdateWithoutCommentInput>
  }

  export type CellUpdateWithoutCommentInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUpdateOneRequiredWithoutCellNestedInput
    Row?: RowUpdateOneRequiredWithoutCellNestedInput
  }

  export type CellUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    rowId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColumnCreateWithoutFilterInput = {
    name: string
    type: $Enums.ColumnType
    width?: number | null
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: string | null
    format?: string | null
    order: number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    Cell?: CellCreateNestedManyWithoutColumnInput
    Table: TableCreateNestedOneWithoutColumnInput
  }

  export type ColumnUncheckedCreateWithoutFilterInput = {
    id?: number
    name: string
    type: $Enums.ColumnType
    tableId: number
    width?: number | null
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: string | null
    format?: string | null
    order: number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    Cell?: CellUncheckedCreateNestedManyWithoutColumnInput
  }

  export type ColumnCreateOrConnectWithoutFilterInput = {
    where: ColumnWhereUniqueInput
    create: XOR<ColumnCreateWithoutFilterInput, ColumnUncheckedCreateWithoutFilterInput>
  }

  export type TableCreateWithoutFilterInput = {
    name: string
    description?: string | null
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Column?: ColumnCreateNestedManyWithoutTableInput
    Row?: RowCreateNestedManyWithoutTableInput
    Section: SectionCreateNestedOneWithoutTableInput
  }

  export type TableUncheckedCreateWithoutFilterInput = {
    id?: number
    name: string
    description?: string | null
    sectionId: number
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Column?: ColumnUncheckedCreateNestedManyWithoutTableInput
    Row?: RowUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutFilterInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutFilterInput, TableUncheckedCreateWithoutFilterInput>
  }

  export type ColumnUpsertWithoutFilterInput = {
    update: XOR<ColumnUpdateWithoutFilterInput, ColumnUncheckedUpdateWithoutFilterInput>
    create: XOR<ColumnCreateWithoutFilterInput, ColumnUncheckedCreateWithoutFilterInput>
    where?: ColumnWhereInput
  }

  export type ColumnUpdateToOneWithWhereWithoutFilterInput = {
    where?: ColumnWhereInput
    data: XOR<ColumnUpdateWithoutFilterInput, ColumnUncheckedUpdateWithoutFilterInput>
  }

  export type ColumnUpdateWithoutFilterInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    width?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    isSummable?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cell?: CellUpdateManyWithoutColumnNestedInput
    Table?: TableUpdateOneRequiredWithoutColumnNestedInput
  }

  export type ColumnUncheckedUpdateWithoutFilterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    tableId?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    isSummable?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cell?: CellUncheckedUpdateManyWithoutColumnNestedInput
  }

  export type TableUpsertWithoutFilterInput = {
    update: XOR<TableUpdateWithoutFilterInput, TableUncheckedUpdateWithoutFilterInput>
    create: XOR<TableCreateWithoutFilterInput, TableUncheckedCreateWithoutFilterInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutFilterInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutFilterInput, TableUncheckedUpdateWithoutFilterInput>
  }

  export type TableUpdateWithoutFilterInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUpdateManyWithoutTableNestedInput
    Row?: RowUpdateManyWithoutTableNestedInput
    Section?: SectionUpdateOneRequiredWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutFilterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sectionId?: IntFieldUpdateOperationsInput | number
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUncheckedUpdateManyWithoutTableNestedInput
    Row?: RowUncheckedUpdateManyWithoutTableNestedInput
  }

  export type SalaryCreateWithoutFinRowInput = {
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    SalaryDebt?: SalaryDebtCreateNestedManyWithoutSalaryInput
    SalaryEarning?: SalaryEarningCreateNestedManyWithoutSalaryInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutSalaryInput
    ShiftReport?: ShiftReportCreateNestedManyWithoutSalaryInput
  }

  export type SalaryUncheckedCreateWithoutFinRowInput = {
    id?: number
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    SalaryDebt?: SalaryDebtUncheckedCreateNestedManyWithoutSalaryInput
    SalaryEarning?: SalaryEarningUncheckedCreateNestedManyWithoutSalaryInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutSalaryInput
    ShiftReport?: ShiftReportUncheckedCreateNestedManyWithoutSalaryInput
  }

  export type SalaryCreateOrConnectWithoutFinRowInput = {
    where: SalaryWhereUniqueInput
    create: XOR<SalaryCreateWithoutFinRowInput, SalaryUncheckedCreateWithoutFinRowInput>
  }

  export type FinRowExpenseCreateWithoutFinRowInput = {
    expenseType: string
    amount: number
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
  }

  export type FinRowExpenseUncheckedCreateWithoutFinRowInput = {
    id?: number
    expenseType: string
    amount: number
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
  }

  export type FinRowExpenseCreateOrConnectWithoutFinRowInput = {
    where: FinRowExpenseWhereUniqueInput
    create: XOR<FinRowExpenseCreateWithoutFinRowInput, FinRowExpenseUncheckedCreateWithoutFinRowInput>
  }

  export type FinRowExpenseCreateManyFinRowInputEnvelope = {
    data: FinRowExpenseCreateManyFinRowInput | FinRowExpenseCreateManyFinRowInput[]
    skipDuplicates?: boolean
  }

  export type SalaryUpsertWithoutFinRowInput = {
    update: XOR<SalaryUpdateWithoutFinRowInput, SalaryUncheckedUpdateWithoutFinRowInput>
    create: XOR<SalaryCreateWithoutFinRowInput, SalaryUncheckedCreateWithoutFinRowInput>
    where?: SalaryWhereInput
  }

  export type SalaryUpdateToOneWithWhereWithoutFinRowInput = {
    where?: SalaryWhereInput
    data: XOR<SalaryUpdateWithoutFinRowInput, SalaryUncheckedUpdateWithoutFinRowInput>
  }

  export type SalaryUpdateWithoutFinRowInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    SalaryDebt?: SalaryDebtUpdateManyWithoutSalaryNestedInput
    SalaryEarning?: SalaryEarningUpdateManyWithoutSalaryNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutSalaryNestedInput
    ShiftReport?: ShiftReportUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryUncheckedUpdateWithoutFinRowInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    SalaryDebt?: SalaryDebtUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryEarning?: SalaryEarningUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutSalaryNestedInput
    ShiftReport?: ShiftReportUncheckedUpdateManyWithoutSalaryNestedInput
  }

  export type FinRowExpenseUpsertWithWhereUniqueWithoutFinRowInput = {
    where: FinRowExpenseWhereUniqueInput
    update: XOR<FinRowExpenseUpdateWithoutFinRowInput, FinRowExpenseUncheckedUpdateWithoutFinRowInput>
    create: XOR<FinRowExpenseCreateWithoutFinRowInput, FinRowExpenseUncheckedCreateWithoutFinRowInput>
  }

  export type FinRowExpenseUpdateWithWhereUniqueWithoutFinRowInput = {
    where: FinRowExpenseWhereUniqueInput
    data: XOR<FinRowExpenseUpdateWithoutFinRowInput, FinRowExpenseUncheckedUpdateWithoutFinRowInput>
  }

  export type FinRowExpenseUpdateManyWithWhereWithoutFinRowInput = {
    where: FinRowExpenseScalarWhereInput
    data: XOR<FinRowExpenseUpdateManyMutationInput, FinRowExpenseUncheckedUpdateManyWithoutFinRowInput>
  }

  export type FinRowExpenseScalarWhereInput = {
    AND?: FinRowExpenseScalarWhereInput | FinRowExpenseScalarWhereInput[]
    OR?: FinRowExpenseScalarWhereInput[]
    NOT?: FinRowExpenseScalarWhereInput | FinRowExpenseScalarWhereInput[]
    id?: IntFilter<"FinRowExpense"> | number
    finRowId?: IntNullableFilter<"FinRowExpense"> | number | null
    expenseType?: StringFilter<"FinRowExpense"> | string
    amount?: FloatFilter<"FinRowExpense"> | number
    date?: DateTimeFilter<"FinRowExpense"> | Date | string
    time?: StringFilter<"FinRowExpense"> | string
    period?: StringNullableFilter<"FinRowExpense"> | string | null
    description?: StringNullableFilter<"FinRowExpense"> | string | null
    createdAt?: DateTimeFilter<"FinRowExpense"> | Date | string
    updatedAt?: DateTimeFilter<"FinRowExpense"> | Date | string
    currency?: StringFilter<"FinRowExpense"> | string
    section?: EnumSalarySectionFilter<"FinRowExpense"> | $Enums.SalarySection
  }

  export type FinRowCreateWithoutFinRowExpenseInput = {
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    usdtAmount?: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
    exchangeRate?: number | null
    Salary?: SalaryCreateNestedOneWithoutFinRowInput
  }

  export type FinRowUncheckedCreateWithoutFinRowExpenseInput = {
    id?: number
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    employeeId?: number | null
    usdtAmount?: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
    exchangeRate?: number | null
  }

  export type FinRowCreateOrConnectWithoutFinRowExpenseInput = {
    where: FinRowWhereUniqueInput
    create: XOR<FinRowCreateWithoutFinRowExpenseInput, FinRowUncheckedCreateWithoutFinRowExpenseInput>
  }

  export type FinRowUpsertWithoutFinRowExpenseInput = {
    update: XOR<FinRowUpdateWithoutFinRowExpenseInput, FinRowUncheckedUpdateWithoutFinRowExpenseInput>
    create: XOR<FinRowCreateWithoutFinRowExpenseInput, FinRowUncheckedCreateWithoutFinRowExpenseInput>
    where?: FinRowWhereInput
  }

  export type FinRowUpdateToOneWithWhereWithoutFinRowExpenseInput = {
    where?: FinRowWhereInput
    data: XOR<FinRowUpdateWithoutFinRowExpenseInput, FinRowUncheckedUpdateWithoutFinRowExpenseInput>
  }

  export type FinRowUpdateWithoutFinRowExpenseInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Salary?: SalaryUpdateOneWithoutFinRowNestedInput
  }

  export type FinRowUncheckedUpdateWithoutFinRowExpenseInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IdexSyncOrderCreateWithoutIdexCabinetInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    processed?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.IdexSyncOrderStatus
    startSyncAt?: Date | string | null
    endSyncAt?: Date | string | null
    pages?: IdexSyncOrderCreatepagesInput | number[]
  }

  export type IdexSyncOrderUncheckedCreateWithoutIdexCabinetInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    processed?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.IdexSyncOrderStatus
    startSyncAt?: Date | string | null
    endSyncAt?: Date | string | null
    pages?: IdexSyncOrderCreatepagesInput | number[]
  }

  export type IdexSyncOrderCreateOrConnectWithoutIdexCabinetInput = {
    where: IdexSyncOrderWhereUniqueInput
    create: XOR<IdexSyncOrderCreateWithoutIdexCabinetInput, IdexSyncOrderUncheckedCreateWithoutIdexCabinetInput>
  }

  export type IdexSyncOrderCreateManyIdexCabinetInputEnvelope = {
    data: IdexSyncOrderCreateManyIdexCabinetInput | IdexSyncOrderCreateManyIdexCabinetInput[]
    skipDuplicates?: boolean
  }

  export type IdexTransactionCreateWithoutIdexCabinetInput = {
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutIdexTransactionInput
    BybitMatch?: BybitMatchCreateNestedManyWithoutIdexTransactionInput
    Match?: MatchCreateNestedManyWithoutIdexTransactionInput
  }

  export type IdexTransactionUncheckedCreateWithoutIdexCabinetInput = {
    id?: number
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutIdexTransactionInput
    BybitMatch?: BybitMatchUncheckedCreateNestedManyWithoutIdexTransactionInput
    Match?: MatchUncheckedCreateNestedManyWithoutIdexTransactionInput
  }

  export type IdexTransactionCreateOrConnectWithoutIdexCabinetInput = {
    where: IdexTransactionWhereUniqueInput
    create: XOR<IdexTransactionCreateWithoutIdexCabinetInput, IdexTransactionUncheckedCreateWithoutIdexCabinetInput>
  }

  export type IdexTransactionCreateManyIdexCabinetInputEnvelope = {
    data: IdexTransactionCreateManyIdexCabinetInput | IdexTransactionCreateManyIdexCabinetInput[]
    skipDuplicates?: boolean
  }

  export type WorkSessionIdexCabinetCreateWithoutIdexCabinetInput = {
    assignedAt?: Date | string
    WorkSession: WorkSessionCreateNestedOneWithoutWorkSessionIdexCabinetInput
  }

  export type WorkSessionIdexCabinetUncheckedCreateWithoutIdexCabinetInput = {
    workSessionId: number
    assignedAt?: Date | string
  }

  export type WorkSessionIdexCabinetCreateOrConnectWithoutIdexCabinetInput = {
    where: WorkSessionIdexCabinetWhereUniqueInput
    create: XOR<WorkSessionIdexCabinetCreateWithoutIdexCabinetInput, WorkSessionIdexCabinetUncheckedCreateWithoutIdexCabinetInput>
  }

  export type WorkSessionIdexCabinetCreateManyIdexCabinetInputEnvelope = {
    data: WorkSessionIdexCabinetCreateManyIdexCabinetInput | WorkSessionIdexCabinetCreateManyIdexCabinetInput[]
    skipDuplicates?: boolean
  }

  export type IdexSyncOrderUpsertWithWhereUniqueWithoutIdexCabinetInput = {
    where: IdexSyncOrderWhereUniqueInput
    update: XOR<IdexSyncOrderUpdateWithoutIdexCabinetInput, IdexSyncOrderUncheckedUpdateWithoutIdexCabinetInput>
    create: XOR<IdexSyncOrderCreateWithoutIdexCabinetInput, IdexSyncOrderUncheckedCreateWithoutIdexCabinetInput>
  }

  export type IdexSyncOrderUpdateWithWhereUniqueWithoutIdexCabinetInput = {
    where: IdexSyncOrderWhereUniqueInput
    data: XOR<IdexSyncOrderUpdateWithoutIdexCabinetInput, IdexSyncOrderUncheckedUpdateWithoutIdexCabinetInput>
  }

  export type IdexSyncOrderUpdateManyWithWhereWithoutIdexCabinetInput = {
    where: IdexSyncOrderScalarWhereInput
    data: XOR<IdexSyncOrderUpdateManyMutationInput, IdexSyncOrderUncheckedUpdateManyWithoutIdexCabinetInput>
  }

  export type IdexSyncOrderScalarWhereInput = {
    AND?: IdexSyncOrderScalarWhereInput | IdexSyncOrderScalarWhereInput[]
    OR?: IdexSyncOrderScalarWhereInput[]
    NOT?: IdexSyncOrderScalarWhereInput | IdexSyncOrderScalarWhereInput[]
    id?: IntFilter<"IdexSyncOrder"> | number
    createdAt?: DateTimeFilter<"IdexSyncOrder"> | Date | string
    updatedAt?: DateTimeFilter<"IdexSyncOrder"> | Date | string
    cabinetId?: IntNullableFilter<"IdexSyncOrder"> | number | null
    processed?: JsonNullableFilter<"IdexSyncOrder">
    status?: EnumIdexSyncOrderStatusFilter<"IdexSyncOrder"> | $Enums.IdexSyncOrderStatus
    startSyncAt?: DateTimeNullableFilter<"IdexSyncOrder"> | Date | string | null
    endSyncAt?: DateTimeNullableFilter<"IdexSyncOrder"> | Date | string | null
    pages?: IntNullableListFilter<"IdexSyncOrder">
  }

  export type IdexTransactionUpsertWithWhereUniqueWithoutIdexCabinetInput = {
    where: IdexTransactionWhereUniqueInput
    update: XOR<IdexTransactionUpdateWithoutIdexCabinetInput, IdexTransactionUncheckedUpdateWithoutIdexCabinetInput>
    create: XOR<IdexTransactionCreateWithoutIdexCabinetInput, IdexTransactionUncheckedCreateWithoutIdexCabinetInput>
  }

  export type IdexTransactionUpdateWithWhereUniqueWithoutIdexCabinetInput = {
    where: IdexTransactionWhereUniqueInput
    data: XOR<IdexTransactionUpdateWithoutIdexCabinetInput, IdexTransactionUncheckedUpdateWithoutIdexCabinetInput>
  }

  export type IdexTransactionUpdateManyWithWhereWithoutIdexCabinetInput = {
    where: IdexTransactionScalarWhereInput
    data: XOR<IdexTransactionUpdateManyMutationInput, IdexTransactionUncheckedUpdateManyWithoutIdexCabinetInput>
  }

  export type IdexTransactionScalarWhereInput = {
    AND?: IdexTransactionScalarWhereInput | IdexTransactionScalarWhereInput[]
    OR?: IdexTransactionScalarWhereInput[]
    NOT?: IdexTransactionScalarWhereInput | IdexTransactionScalarWhereInput[]
    id?: IntFilter<"IdexTransaction"> | number
    externalId?: BigIntFilter<"IdexTransaction"> | bigint | number
    paymentMethodId?: BigIntFilter<"IdexTransaction"> | bigint | number
    wallet?: StringFilter<"IdexTransaction"> | string
    amount?: JsonFilter<"IdexTransaction">
    total?: JsonFilter<"IdexTransaction">
    status?: IntFilter<"IdexTransaction"> | number
    approvedAt?: StringNullableFilter<"IdexTransaction"> | string | null
    expiredAt?: StringNullableFilter<"IdexTransaction"> | string | null
    createdAtExternal?: StringFilter<"IdexTransaction"> | string
    updatedAtExternal?: StringFilter<"IdexTransaction"> | string
    extraData?: JsonFilter<"IdexTransaction">
    cabinetId?: IntFilter<"IdexTransaction"> | number
    createdAt?: DateTimeFilter<"IdexTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"IdexTransaction"> | Date | string
  }

  export type WorkSessionIdexCabinetUpsertWithWhereUniqueWithoutIdexCabinetInput = {
    where: WorkSessionIdexCabinetWhereUniqueInput
    update: XOR<WorkSessionIdexCabinetUpdateWithoutIdexCabinetInput, WorkSessionIdexCabinetUncheckedUpdateWithoutIdexCabinetInput>
    create: XOR<WorkSessionIdexCabinetCreateWithoutIdexCabinetInput, WorkSessionIdexCabinetUncheckedCreateWithoutIdexCabinetInput>
  }

  export type WorkSessionIdexCabinetUpdateWithWhereUniqueWithoutIdexCabinetInput = {
    where: WorkSessionIdexCabinetWhereUniqueInput
    data: XOR<WorkSessionIdexCabinetUpdateWithoutIdexCabinetInput, WorkSessionIdexCabinetUncheckedUpdateWithoutIdexCabinetInput>
  }

  export type WorkSessionIdexCabinetUpdateManyWithWhereWithoutIdexCabinetInput = {
    where: WorkSessionIdexCabinetScalarWhereInput
    data: XOR<WorkSessionIdexCabinetUpdateManyMutationInput, WorkSessionIdexCabinetUncheckedUpdateManyWithoutIdexCabinetInput>
  }

  export type WorkSessionIdexCabinetScalarWhereInput = {
    AND?: WorkSessionIdexCabinetScalarWhereInput | WorkSessionIdexCabinetScalarWhereInput[]
    OR?: WorkSessionIdexCabinetScalarWhereInput[]
    NOT?: WorkSessionIdexCabinetScalarWhereInput | WorkSessionIdexCabinetScalarWhereInput[]
    workSessionId?: IntFilter<"WorkSessionIdexCabinet"> | number
    idexCabinetId?: IntFilter<"WorkSessionIdexCabinet"> | number
    assignedAt?: DateTimeFilter<"WorkSessionIdexCabinet"> | Date | string
  }

  export type IdexCabinetCreateWithoutIdexSyncOrderInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    idexId: number
    login: string
    password: string
    IdexTransaction?: IdexTransactionCreateNestedManyWithoutIdexCabinetInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetCreateNestedManyWithoutIdexCabinetInput
  }

  export type IdexCabinetUncheckedCreateWithoutIdexSyncOrderInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    idexId: number
    login: string
    password: string
    IdexTransaction?: IdexTransactionUncheckedCreateNestedManyWithoutIdexCabinetInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUncheckedCreateNestedManyWithoutIdexCabinetInput
  }

  export type IdexCabinetCreateOrConnectWithoutIdexSyncOrderInput = {
    where: IdexCabinetWhereUniqueInput
    create: XOR<IdexCabinetCreateWithoutIdexSyncOrderInput, IdexCabinetUncheckedCreateWithoutIdexSyncOrderInput>
  }

  export type IdexCabinetUpsertWithoutIdexSyncOrderInput = {
    update: XOR<IdexCabinetUpdateWithoutIdexSyncOrderInput, IdexCabinetUncheckedUpdateWithoutIdexSyncOrderInput>
    create: XOR<IdexCabinetCreateWithoutIdexSyncOrderInput, IdexCabinetUncheckedCreateWithoutIdexSyncOrderInput>
    where?: IdexCabinetWhereInput
  }

  export type IdexCabinetUpdateToOneWithWhereWithoutIdexSyncOrderInput = {
    where?: IdexCabinetWhereInput
    data: XOR<IdexCabinetUpdateWithoutIdexSyncOrderInput, IdexCabinetUncheckedUpdateWithoutIdexSyncOrderInput>
  }

  export type IdexCabinetUpdateWithoutIdexSyncOrderInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idexId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    IdexTransaction?: IdexTransactionUpdateManyWithoutIdexCabinetNestedInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUpdateManyWithoutIdexCabinetNestedInput
  }

  export type IdexCabinetUncheckedUpdateWithoutIdexSyncOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idexId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    IdexTransaction?: IdexTransactionUncheckedUpdateManyWithoutIdexCabinetNestedInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUncheckedUpdateManyWithoutIdexCabinetNestedInput
  }

  export type BybitClipMatchCreateWithoutIdexTransactionInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitTransactionFromCabinet: BybitTransactionFromCabinetCreateNestedOneWithoutBybitClipMatchInput
    MatchBybitReport?: MatchBybitReportCreateNestedOneWithoutBybitClipMatchInput
    User: UserCreateNestedOneWithoutBybitClipMatchInput
  }

  export type BybitClipMatchUncheckedCreateWithoutIdexTransactionInput = {
    id?: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchBybitReportId?: number | null
    userId: number
  }

  export type BybitClipMatchCreateOrConnectWithoutIdexTransactionInput = {
    where: BybitClipMatchWhereUniqueInput
    create: XOR<BybitClipMatchCreateWithoutIdexTransactionInput, BybitClipMatchUncheckedCreateWithoutIdexTransactionInput>
  }

  export type BybitClipMatchCreateManyIdexTransactionInputEnvelope = {
    data: BybitClipMatchCreateManyIdexTransactionInput | BybitClipMatchCreateManyIdexTransactionInput[]
    skipDuplicates?: boolean
  }

  export type BybitMatchCreateWithoutIdexTransactionInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitTransaction: BybitTransactionCreateNestedOneWithoutBybitMatchInput
  }

  export type BybitMatchUncheckedCreateWithoutIdexTransactionInput = {
    id?: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BybitMatchCreateOrConnectWithoutIdexTransactionInput = {
    where: BybitMatchWhereUniqueInput
    create: XOR<BybitMatchCreateWithoutIdexTransactionInput, BybitMatchUncheckedCreateWithoutIdexTransactionInput>
  }

  export type BybitMatchCreateManyIdexTransactionInputEnvelope = {
    data: BybitMatchCreateManyIdexTransactionInput | BybitMatchCreateManyIdexTransactionInput[]
    skipDuplicates?: boolean
  }

  export type IdexCabinetCreateWithoutIdexTransactionInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    idexId: number
    login: string
    password: string
    IdexSyncOrder?: IdexSyncOrderCreateNestedManyWithoutIdexCabinetInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetCreateNestedManyWithoutIdexCabinetInput
  }

  export type IdexCabinetUncheckedCreateWithoutIdexTransactionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    idexId: number
    login: string
    password: string
    IdexSyncOrder?: IdexSyncOrderUncheckedCreateNestedManyWithoutIdexCabinetInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUncheckedCreateNestedManyWithoutIdexCabinetInput
  }

  export type IdexCabinetCreateOrConnectWithoutIdexTransactionInput = {
    where: IdexCabinetWhereUniqueInput
    create: XOR<IdexCabinetCreateWithoutIdexTransactionInput, IdexCabinetUncheckedCreateWithoutIdexTransactionInput>
  }

  export type MatchCreateWithoutIdexTransactionInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    Transaction: TransactionCreateNestedOneWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutIdexTransactionInput = {
    id?: number
    transactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MatchCreateOrConnectWithoutIdexTransactionInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutIdexTransactionInput, MatchUncheckedCreateWithoutIdexTransactionInput>
  }

  export type MatchCreateManyIdexTransactionInputEnvelope = {
    data: MatchCreateManyIdexTransactionInput | MatchCreateManyIdexTransactionInput[]
    skipDuplicates?: boolean
  }

  export type BybitClipMatchUpsertWithWhereUniqueWithoutIdexTransactionInput = {
    where: BybitClipMatchWhereUniqueInput
    update: XOR<BybitClipMatchUpdateWithoutIdexTransactionInput, BybitClipMatchUncheckedUpdateWithoutIdexTransactionInput>
    create: XOR<BybitClipMatchCreateWithoutIdexTransactionInput, BybitClipMatchUncheckedCreateWithoutIdexTransactionInput>
  }

  export type BybitClipMatchUpdateWithWhereUniqueWithoutIdexTransactionInput = {
    where: BybitClipMatchWhereUniqueInput
    data: XOR<BybitClipMatchUpdateWithoutIdexTransactionInput, BybitClipMatchUncheckedUpdateWithoutIdexTransactionInput>
  }

  export type BybitClipMatchUpdateManyWithWhereWithoutIdexTransactionInput = {
    where: BybitClipMatchScalarWhereInput
    data: XOR<BybitClipMatchUpdateManyMutationInput, BybitClipMatchUncheckedUpdateManyWithoutIdexTransactionInput>
  }

  export type BybitClipMatchScalarWhereInput = {
    AND?: BybitClipMatchScalarWhereInput | BybitClipMatchScalarWhereInput[]
    OR?: BybitClipMatchScalarWhereInput[]
    NOT?: BybitClipMatchScalarWhereInput | BybitClipMatchScalarWhereInput[]
    id?: IntFilter<"BybitClipMatch"> | number
    idexTransactionId?: IntFilter<"BybitClipMatch"> | number
    bybitTransactionId?: IntFilter<"BybitClipMatch"> | number
    timeDifference?: IntFilter<"BybitClipMatch"> | number
    grossExpense?: FloatFilter<"BybitClipMatch"> | number
    grossIncome?: FloatFilter<"BybitClipMatch"> | number
    grossProfit?: FloatFilter<"BybitClipMatch"> | number
    profitPercentage?: FloatFilter<"BybitClipMatch"> | number
    createdAt?: DateTimeFilter<"BybitClipMatch"> | Date | string
    updatedAt?: DateTimeFilter<"BybitClipMatch"> | Date | string
    matchBybitReportId?: IntNullableFilter<"BybitClipMatch"> | number | null
    userId?: IntFilter<"BybitClipMatch"> | number
  }

  export type BybitMatchUpsertWithWhereUniqueWithoutIdexTransactionInput = {
    where: BybitMatchWhereUniqueInput
    update: XOR<BybitMatchUpdateWithoutIdexTransactionInput, BybitMatchUncheckedUpdateWithoutIdexTransactionInput>
    create: XOR<BybitMatchCreateWithoutIdexTransactionInput, BybitMatchUncheckedCreateWithoutIdexTransactionInput>
  }

  export type BybitMatchUpdateWithWhereUniqueWithoutIdexTransactionInput = {
    where: BybitMatchWhereUniqueInput
    data: XOR<BybitMatchUpdateWithoutIdexTransactionInput, BybitMatchUncheckedUpdateWithoutIdexTransactionInput>
  }

  export type BybitMatchUpdateManyWithWhereWithoutIdexTransactionInput = {
    where: BybitMatchScalarWhereInput
    data: XOR<BybitMatchUpdateManyMutationInput, BybitMatchUncheckedUpdateManyWithoutIdexTransactionInput>
  }

  export type IdexCabinetUpsertWithoutIdexTransactionInput = {
    update: XOR<IdexCabinetUpdateWithoutIdexTransactionInput, IdexCabinetUncheckedUpdateWithoutIdexTransactionInput>
    create: XOR<IdexCabinetCreateWithoutIdexTransactionInput, IdexCabinetUncheckedCreateWithoutIdexTransactionInput>
    where?: IdexCabinetWhereInput
  }

  export type IdexCabinetUpdateToOneWithWhereWithoutIdexTransactionInput = {
    where?: IdexCabinetWhereInput
    data: XOR<IdexCabinetUpdateWithoutIdexTransactionInput, IdexCabinetUncheckedUpdateWithoutIdexTransactionInput>
  }

  export type IdexCabinetUpdateWithoutIdexTransactionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idexId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    IdexSyncOrder?: IdexSyncOrderUpdateManyWithoutIdexCabinetNestedInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUpdateManyWithoutIdexCabinetNestedInput
  }

  export type IdexCabinetUncheckedUpdateWithoutIdexTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idexId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    IdexSyncOrder?: IdexSyncOrderUncheckedUpdateManyWithoutIdexCabinetNestedInput
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUncheckedUpdateManyWithoutIdexCabinetNestedInput
  }

  export type MatchUpsertWithWhereUniqueWithoutIdexTransactionInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutIdexTransactionInput, MatchUncheckedUpdateWithoutIdexTransactionInput>
    create: XOR<MatchCreateWithoutIdexTransactionInput, MatchUncheckedCreateWithoutIdexTransactionInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutIdexTransactionInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutIdexTransactionInput, MatchUncheckedUpdateWithoutIdexTransactionInput>
  }

  export type MatchUpdateManyWithWhereWithoutIdexTransactionInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutIdexTransactionInput>
  }

  export type MatchScalarWhereInput = {
    AND?: MatchScalarWhereInput | MatchScalarWhereInput[]
    OR?: MatchScalarWhereInput[]
    NOT?: MatchScalarWhereInput | MatchScalarWhereInput[]
    id?: IntFilter<"Match"> | number
    idexTransactionId?: IntFilter<"Match"> | number
    transactionId?: IntFilter<"Match"> | number
    timeDifference?: IntFilter<"Match"> | number
    grossExpense?: FloatFilter<"Match"> | number
    grossIncome?: FloatFilter<"Match"> | number
    grossProfit?: FloatFilter<"Match"> | number
    profitPercentage?: FloatFilter<"Match"> | number
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
  }

  export type IdexTransactionCreateWithoutMatchInput = {
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutIdexTransactionInput
    BybitMatch?: BybitMatchCreateNestedManyWithoutIdexTransactionInput
    IdexCabinet: IdexCabinetCreateNestedOneWithoutIdexTransactionInput
  }

  export type IdexTransactionUncheckedCreateWithoutMatchInput = {
    id?: number
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    cabinetId: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutIdexTransactionInput
    BybitMatch?: BybitMatchUncheckedCreateNestedManyWithoutIdexTransactionInput
  }

  export type IdexTransactionCreateOrConnectWithoutMatchInput = {
    where: IdexTransactionWhereUniqueInput
    create: XOR<IdexTransactionCreateWithoutMatchInput, IdexTransactionUncheckedCreateWithoutMatchInput>
  }

  export type TransactionCreateWithoutMatchInput = {
    externalId?: string | null
    orderNo?: string | null
    dateTime: Date | string
    type: string
    asset: string
    amount: number
    totalPrice: number
    unitPrice: number
    counterparty?: string | null
    status: string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    User: UserCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutMatchInput = {
    id?: number
    externalId?: string | null
    orderNo?: string | null
    dateTime: Date | string
    type: string
    asset: string
    amount: number
    totalPrice: number
    unitPrice: number
    counterparty?: string | null
    status: string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TransactionCreateOrConnectWithoutMatchInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutMatchInput, TransactionUncheckedCreateWithoutMatchInput>
  }

  export type IdexTransactionUpsertWithoutMatchInput = {
    update: XOR<IdexTransactionUpdateWithoutMatchInput, IdexTransactionUncheckedUpdateWithoutMatchInput>
    create: XOR<IdexTransactionCreateWithoutMatchInput, IdexTransactionUncheckedCreateWithoutMatchInput>
    where?: IdexTransactionWhereInput
  }

  export type IdexTransactionUpdateToOneWithWhereWithoutMatchInput = {
    where?: IdexTransactionWhereInput
    data: XOR<IdexTransactionUpdateWithoutMatchInput, IdexTransactionUncheckedUpdateWithoutMatchInput>
  }

  export type IdexTransactionUpdateWithoutMatchInput = {
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutIdexTransactionNestedInput
    BybitMatch?: BybitMatchUpdateManyWithoutIdexTransactionNestedInput
    IdexCabinet?: IdexCabinetUpdateOneRequiredWithoutIdexTransactionNestedInput
  }

  export type IdexTransactionUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    cabinetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
    BybitMatch?: BybitMatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
  }

  export type TransactionUpsertWithoutMatchInput = {
    update: XOR<TransactionUpdateWithoutMatchInput, TransactionUncheckedUpdateWithoutMatchInput>
    create: XOR<TransactionCreateWithoutMatchInput, TransactionUncheckedCreateWithoutMatchInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutMatchInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutMatchInput, TransactionUncheckedUpdateWithoutMatchInput>
  }

  export type TransactionUpdateWithoutMatchInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    asset?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    asset?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutReportNotificationInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportNotificationInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionUncheckedCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportUncheckedCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportUncheckedCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetUncheckedCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportNotificationInput, UserUncheckedCreateWithoutReportNotificationInput>
  }

  export type UserUpsertWithoutReportNotificationInput = {
    update: XOR<UserUpdateWithoutReportNotificationInput, UserUncheckedUpdateWithoutReportNotificationInput>
    create: XOR<UserCreateWithoutReportNotificationInput, UserUncheckedCreateWithoutReportNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportNotificationInput, UserUncheckedUpdateWithoutReportNotificationInput>
  }

  export type UserUpdateWithoutReportNotificationInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUncheckedUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUncheckedUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUncheckedUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CellCreateWithoutRowInput = {
    value?: string | null
    displayValue?: string | null
    calculatedValue?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Column: ColumnCreateNestedOneWithoutCellInput
    Comment?: CommentCreateNestedManyWithoutCellInput
  }

  export type CellUncheckedCreateWithoutRowInput = {
    id?: number
    columnId: number
    value?: string | null
    displayValue?: string | null
    calculatedValue?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Comment?: CommentUncheckedCreateNestedManyWithoutCellInput
  }

  export type CellCreateOrConnectWithoutRowInput = {
    where: CellWhereUniqueInput
    create: XOR<CellCreateWithoutRowInput, CellUncheckedCreateWithoutRowInput>
  }

  export type CellCreateManyRowInputEnvelope = {
    data: CellCreateManyRowInput | CellCreateManyRowInput[]
    skipDuplicates?: boolean
  }

  export type TableCreateWithoutRowInput = {
    name: string
    description?: string | null
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Column?: ColumnCreateNestedManyWithoutTableInput
    Filter?: FilterCreateNestedManyWithoutTableInput
    Section: SectionCreateNestedOneWithoutTableInput
  }

  export type TableUncheckedCreateWithoutRowInput = {
    id?: number
    name: string
    description?: string | null
    sectionId: number
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Column?: ColumnUncheckedCreateNestedManyWithoutTableInput
    Filter?: FilterUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutRowInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutRowInput, TableUncheckedCreateWithoutRowInput>
  }

  export type CellUpsertWithWhereUniqueWithoutRowInput = {
    where: CellWhereUniqueInput
    update: XOR<CellUpdateWithoutRowInput, CellUncheckedUpdateWithoutRowInput>
    create: XOR<CellCreateWithoutRowInput, CellUncheckedCreateWithoutRowInput>
  }

  export type CellUpdateWithWhereUniqueWithoutRowInput = {
    where: CellWhereUniqueInput
    data: XOR<CellUpdateWithoutRowInput, CellUncheckedUpdateWithoutRowInput>
  }

  export type CellUpdateManyWithWhereWithoutRowInput = {
    where: CellScalarWhereInput
    data: XOR<CellUpdateManyMutationInput, CellUncheckedUpdateManyWithoutRowInput>
  }

  export type TableUpsertWithoutRowInput = {
    update: XOR<TableUpdateWithoutRowInput, TableUncheckedUpdateWithoutRowInput>
    create: XOR<TableCreateWithoutRowInput, TableUncheckedCreateWithoutRowInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutRowInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutRowInput, TableUncheckedUpdateWithoutRowInput>
  }

  export type TableUpdateWithoutRowInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUpdateManyWithoutTableNestedInput
    Filter?: FilterUpdateManyWithoutTableNestedInput
    Section?: SectionUpdateOneRequiredWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutRowInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sectionId?: IntFieldUpdateOperationsInput | number
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUncheckedUpdateManyWithoutTableNestedInput
    Filter?: FilterUncheckedUpdateManyWithoutTableNestedInput
  }

  export type FinRowCreateWithoutSalaryInput = {
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    usdtAmount?: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
    exchangeRate?: number | null
    FinRowExpense?: FinRowExpenseCreateNestedManyWithoutFinRowInput
  }

  export type FinRowUncheckedCreateWithoutSalaryInput = {
    id?: number
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    usdtAmount?: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
    exchangeRate?: number | null
    FinRowExpense?: FinRowExpenseUncheckedCreateNestedManyWithoutFinRowInput
  }

  export type FinRowCreateOrConnectWithoutSalaryInput = {
    where: FinRowWhereUniqueInput
    create: XOR<FinRowCreateWithoutSalaryInput, FinRowUncheckedCreateWithoutSalaryInput>
  }

  export type FinRowCreateManySalaryInputEnvelope = {
    data: FinRowCreateManySalaryInput | FinRowCreateManySalaryInput[]
    skipDuplicates?: boolean
  }

  export type SalaryDebtCreateWithoutSalaryInput = {
    amount: number
    debtDate: Date | string
    description?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SalaryDebtUncheckedCreateWithoutSalaryInput = {
    id?: number
    amount: number
    debtDate: Date | string
    description?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SalaryDebtCreateOrConnectWithoutSalaryInput = {
    where: SalaryDebtWhereUniqueInput
    create: XOR<SalaryDebtCreateWithoutSalaryInput, SalaryDebtUncheckedCreateWithoutSalaryInput>
  }

  export type SalaryDebtCreateManySalaryInputEnvelope = {
    data: SalaryDebtCreateManySalaryInput | SalaryDebtCreateManySalaryInput[]
    skipDuplicates?: boolean
  }

  export type SalaryEarningCreateWithoutSalaryInput = {
    amount: number
    earningDate: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SalaryEarningUncheckedCreateWithoutSalaryInput = {
    id?: number
    amount: number
    earningDate: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SalaryEarningCreateOrConnectWithoutSalaryInput = {
    where: SalaryEarningWhereUniqueInput
    create: XOR<SalaryEarningCreateWithoutSalaryInput, SalaryEarningUncheckedCreateWithoutSalaryInput>
  }

  export type SalaryEarningCreateManySalaryInputEnvelope = {
    data: SalaryEarningCreateManySalaryInput | SalaryEarningCreateManySalaryInput[]
    skipDuplicates?: boolean
  }

  export type SalaryPaymentCreateWithoutSalaryInput = {
    amount: number
    paymentDate: Date | string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
  }

  export type SalaryPaymentUncheckedCreateWithoutSalaryInput = {
    id?: number
    amount: number
    paymentDate: Date | string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
  }

  export type SalaryPaymentCreateOrConnectWithoutSalaryInput = {
    where: SalaryPaymentWhereUniqueInput
    create: XOR<SalaryPaymentCreateWithoutSalaryInput, SalaryPaymentUncheckedCreateWithoutSalaryInput>
  }

  export type SalaryPaymentCreateManySalaryInputEnvelope = {
    data: SalaryPaymentCreateManySalaryInput | SalaryPaymentCreateManySalaryInput[]
    skipDuplicates?: boolean
  }

  export type ShiftReportCreateWithoutSalaryInput = {
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    usdtAmount?: number
    currency?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ShiftReportExpense?: ShiftReportExpenseCreateNestedManyWithoutShiftReportInput
  }

  export type ShiftReportUncheckedCreateWithoutSalaryInput = {
    id?: number
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    usdtAmount?: number
    currency?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ShiftReportExpense?: ShiftReportExpenseUncheckedCreateNestedManyWithoutShiftReportInput
  }

  export type ShiftReportCreateOrConnectWithoutSalaryInput = {
    where: ShiftReportWhereUniqueInput
    create: XOR<ShiftReportCreateWithoutSalaryInput, ShiftReportUncheckedCreateWithoutSalaryInput>
  }

  export type ShiftReportCreateManySalaryInputEnvelope = {
    data: ShiftReportCreateManySalaryInput | ShiftReportCreateManySalaryInput[]
    skipDuplicates?: boolean
  }

  export type FinRowUpsertWithWhereUniqueWithoutSalaryInput = {
    where: FinRowWhereUniqueInput
    update: XOR<FinRowUpdateWithoutSalaryInput, FinRowUncheckedUpdateWithoutSalaryInput>
    create: XOR<FinRowCreateWithoutSalaryInput, FinRowUncheckedCreateWithoutSalaryInput>
  }

  export type FinRowUpdateWithWhereUniqueWithoutSalaryInput = {
    where: FinRowWhereUniqueInput
    data: XOR<FinRowUpdateWithoutSalaryInput, FinRowUncheckedUpdateWithoutSalaryInput>
  }

  export type FinRowUpdateManyWithWhereWithoutSalaryInput = {
    where: FinRowScalarWhereInput
    data: XOR<FinRowUpdateManyMutationInput, FinRowUncheckedUpdateManyWithoutSalaryInput>
  }

  export type FinRowScalarWhereInput = {
    AND?: FinRowScalarWhereInput | FinRowScalarWhereInput[]
    OR?: FinRowScalarWhereInput[]
    NOT?: FinRowScalarWhereInput | FinRowScalarWhereInput[]
    id?: IntFilter<"FinRow"> | number
    date?: DateTimeFilter<"FinRow"> | Date | string
    time?: StringFilter<"FinRow"> | string
    shift?: StringFilter<"FinRow"> | string
    startBalance?: FloatFilter<"FinRow"> | number
    endBalance?: FloatFilter<"FinRow"> | number
    employeeId?: IntNullableFilter<"FinRow"> | number | null
    usdtAmount?: FloatFilter<"FinRow"> | number
    comment?: StringNullableFilter<"FinRow"> | string | null
    createdAt?: DateTimeFilter<"FinRow"> | Date | string
    updatedAt?: DateTimeFilter<"FinRow"> | Date | string
    currency?: StringFilter<"FinRow"> | string
    section?: EnumSalarySectionFilter<"FinRow"> | $Enums.SalarySection
    exchangeRate?: FloatNullableFilter<"FinRow"> | number | null
  }

  export type SalaryDebtUpsertWithWhereUniqueWithoutSalaryInput = {
    where: SalaryDebtWhereUniqueInput
    update: XOR<SalaryDebtUpdateWithoutSalaryInput, SalaryDebtUncheckedUpdateWithoutSalaryInput>
    create: XOR<SalaryDebtCreateWithoutSalaryInput, SalaryDebtUncheckedCreateWithoutSalaryInput>
  }

  export type SalaryDebtUpdateWithWhereUniqueWithoutSalaryInput = {
    where: SalaryDebtWhereUniqueInput
    data: XOR<SalaryDebtUpdateWithoutSalaryInput, SalaryDebtUncheckedUpdateWithoutSalaryInput>
  }

  export type SalaryDebtUpdateManyWithWhereWithoutSalaryInput = {
    where: SalaryDebtScalarWhereInput
    data: XOR<SalaryDebtUpdateManyMutationInput, SalaryDebtUncheckedUpdateManyWithoutSalaryInput>
  }

  export type SalaryDebtScalarWhereInput = {
    AND?: SalaryDebtScalarWhereInput | SalaryDebtScalarWhereInput[]
    OR?: SalaryDebtScalarWhereInput[]
    NOT?: SalaryDebtScalarWhereInput | SalaryDebtScalarWhereInput[]
    id?: IntFilter<"SalaryDebt"> | number
    salaryId?: IntFilter<"SalaryDebt"> | number
    amount?: FloatFilter<"SalaryDebt"> | number
    debtDate?: DateTimeFilter<"SalaryDebt"> | Date | string
    description?: StringNullableFilter<"SalaryDebt"> | string | null
    isPaid?: BoolFilter<"SalaryDebt"> | boolean
    createdAt?: DateTimeFilter<"SalaryDebt"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryDebt"> | Date | string
  }

  export type SalaryEarningUpsertWithWhereUniqueWithoutSalaryInput = {
    where: SalaryEarningWhereUniqueInput
    update: XOR<SalaryEarningUpdateWithoutSalaryInput, SalaryEarningUncheckedUpdateWithoutSalaryInput>
    create: XOR<SalaryEarningCreateWithoutSalaryInput, SalaryEarningUncheckedCreateWithoutSalaryInput>
  }

  export type SalaryEarningUpdateWithWhereUniqueWithoutSalaryInput = {
    where: SalaryEarningWhereUniqueInput
    data: XOR<SalaryEarningUpdateWithoutSalaryInput, SalaryEarningUncheckedUpdateWithoutSalaryInput>
  }

  export type SalaryEarningUpdateManyWithWhereWithoutSalaryInput = {
    where: SalaryEarningScalarWhereInput
    data: XOR<SalaryEarningUpdateManyMutationInput, SalaryEarningUncheckedUpdateManyWithoutSalaryInput>
  }

  export type SalaryEarningScalarWhereInput = {
    AND?: SalaryEarningScalarWhereInput | SalaryEarningScalarWhereInput[]
    OR?: SalaryEarningScalarWhereInput[]
    NOT?: SalaryEarningScalarWhereInput | SalaryEarningScalarWhereInput[]
    id?: IntFilter<"SalaryEarning"> | number
    amount?: FloatFilter<"SalaryEarning"> | number
    earningDate?: DateTimeFilter<"SalaryEarning"> | Date | string
    description?: StringNullableFilter<"SalaryEarning"> | string | null
    createdAt?: DateTimeFilter<"SalaryEarning"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryEarning"> | Date | string
    salaryId?: IntFilter<"SalaryEarning"> | number
  }

  export type SalaryPaymentUpsertWithWhereUniqueWithoutSalaryInput = {
    where: SalaryPaymentWhereUniqueInput
    update: XOR<SalaryPaymentUpdateWithoutSalaryInput, SalaryPaymentUncheckedUpdateWithoutSalaryInput>
    create: XOR<SalaryPaymentCreateWithoutSalaryInput, SalaryPaymentUncheckedCreateWithoutSalaryInput>
  }

  export type SalaryPaymentUpdateWithWhereUniqueWithoutSalaryInput = {
    where: SalaryPaymentWhereUniqueInput
    data: XOR<SalaryPaymentUpdateWithoutSalaryInput, SalaryPaymentUncheckedUpdateWithoutSalaryInput>
  }

  export type SalaryPaymentUpdateManyWithWhereWithoutSalaryInput = {
    where: SalaryPaymentScalarWhereInput
    data: XOR<SalaryPaymentUpdateManyMutationInput, SalaryPaymentUncheckedUpdateManyWithoutSalaryInput>
  }

  export type SalaryPaymentScalarWhereInput = {
    AND?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
    OR?: SalaryPaymentScalarWhereInput[]
    NOT?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
    id?: IntFilter<"SalaryPayment"> | number
    salaryId?: IntFilter<"SalaryPayment"> | number
    amount?: FloatFilter<"SalaryPayment"> | number
    paymentDate?: DateTimeFilter<"SalaryPayment"> | Date | string
    comment?: StringNullableFilter<"SalaryPayment"> | string | null
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    currency?: StringFilter<"SalaryPayment"> | string
  }

  export type ShiftReportUpsertWithWhereUniqueWithoutSalaryInput = {
    where: ShiftReportWhereUniqueInput
    update: XOR<ShiftReportUpdateWithoutSalaryInput, ShiftReportUncheckedUpdateWithoutSalaryInput>
    create: XOR<ShiftReportCreateWithoutSalaryInput, ShiftReportUncheckedCreateWithoutSalaryInput>
  }

  export type ShiftReportUpdateWithWhereUniqueWithoutSalaryInput = {
    where: ShiftReportWhereUniqueInput
    data: XOR<ShiftReportUpdateWithoutSalaryInput, ShiftReportUncheckedUpdateWithoutSalaryInput>
  }

  export type ShiftReportUpdateManyWithWhereWithoutSalaryInput = {
    where: ShiftReportScalarWhereInput
    data: XOR<ShiftReportUpdateManyMutationInput, ShiftReportUncheckedUpdateManyWithoutSalaryInput>
  }

  export type ShiftReportScalarWhereInput = {
    AND?: ShiftReportScalarWhereInput | ShiftReportScalarWhereInput[]
    OR?: ShiftReportScalarWhereInput[]
    NOT?: ShiftReportScalarWhereInput | ShiftReportScalarWhereInput[]
    id?: IntFilter<"ShiftReport"> | number
    date?: DateTimeFilter<"ShiftReport"> | Date | string
    time?: StringFilter<"ShiftReport"> | string
    shift?: StringFilter<"ShiftReport"> | string
    startBalance?: FloatFilter<"ShiftReport"> | number
    endBalance?: FloatFilter<"ShiftReport"> | number
    employeeId?: IntNullableFilter<"ShiftReport"> | number | null
    usdtAmount?: FloatFilter<"ShiftReport"> | number
    currency?: StringFilter<"ShiftReport"> | string
    comment?: StringNullableFilter<"ShiftReport"> | string | null
    createdAt?: DateTimeFilter<"ShiftReport"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftReport"> | Date | string
  }

  export type SalaryCreateWithoutSalaryDebtInput = {
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    FinRow?: FinRowCreateNestedManyWithoutSalaryInput
    SalaryEarning?: SalaryEarningCreateNestedManyWithoutSalaryInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutSalaryInput
    ShiftReport?: ShiftReportCreateNestedManyWithoutSalaryInput
  }

  export type SalaryUncheckedCreateWithoutSalaryDebtInput = {
    id?: number
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    FinRow?: FinRowUncheckedCreateNestedManyWithoutSalaryInput
    SalaryEarning?: SalaryEarningUncheckedCreateNestedManyWithoutSalaryInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutSalaryInput
    ShiftReport?: ShiftReportUncheckedCreateNestedManyWithoutSalaryInput
  }

  export type SalaryCreateOrConnectWithoutSalaryDebtInput = {
    where: SalaryWhereUniqueInput
    create: XOR<SalaryCreateWithoutSalaryDebtInput, SalaryUncheckedCreateWithoutSalaryDebtInput>
  }

  export type SalaryUpsertWithoutSalaryDebtInput = {
    update: XOR<SalaryUpdateWithoutSalaryDebtInput, SalaryUncheckedUpdateWithoutSalaryDebtInput>
    create: XOR<SalaryCreateWithoutSalaryDebtInput, SalaryUncheckedCreateWithoutSalaryDebtInput>
    where?: SalaryWhereInput
  }

  export type SalaryUpdateToOneWithWhereWithoutSalaryDebtInput = {
    where?: SalaryWhereInput
    data: XOR<SalaryUpdateWithoutSalaryDebtInput, SalaryUncheckedUpdateWithoutSalaryDebtInput>
  }

  export type SalaryUpdateWithoutSalaryDebtInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    FinRow?: FinRowUpdateManyWithoutSalaryNestedInput
    SalaryEarning?: SalaryEarningUpdateManyWithoutSalaryNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutSalaryNestedInput
    ShiftReport?: ShiftReportUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryUncheckedUpdateWithoutSalaryDebtInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    FinRow?: FinRowUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryEarning?: SalaryEarningUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutSalaryNestedInput
    ShiftReport?: ShiftReportUncheckedUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryCreateWithoutSalaryEarningInput = {
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    FinRow?: FinRowCreateNestedManyWithoutSalaryInput
    SalaryDebt?: SalaryDebtCreateNestedManyWithoutSalaryInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutSalaryInput
    ShiftReport?: ShiftReportCreateNestedManyWithoutSalaryInput
  }

  export type SalaryUncheckedCreateWithoutSalaryEarningInput = {
    id?: number
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    FinRow?: FinRowUncheckedCreateNestedManyWithoutSalaryInput
    SalaryDebt?: SalaryDebtUncheckedCreateNestedManyWithoutSalaryInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutSalaryInput
    ShiftReport?: ShiftReportUncheckedCreateNestedManyWithoutSalaryInput
  }

  export type SalaryCreateOrConnectWithoutSalaryEarningInput = {
    where: SalaryWhereUniqueInput
    create: XOR<SalaryCreateWithoutSalaryEarningInput, SalaryUncheckedCreateWithoutSalaryEarningInput>
  }

  export type SalaryUpsertWithoutSalaryEarningInput = {
    update: XOR<SalaryUpdateWithoutSalaryEarningInput, SalaryUncheckedUpdateWithoutSalaryEarningInput>
    create: XOR<SalaryCreateWithoutSalaryEarningInput, SalaryUncheckedCreateWithoutSalaryEarningInput>
    where?: SalaryWhereInput
  }

  export type SalaryUpdateToOneWithWhereWithoutSalaryEarningInput = {
    where?: SalaryWhereInput
    data: XOR<SalaryUpdateWithoutSalaryEarningInput, SalaryUncheckedUpdateWithoutSalaryEarningInput>
  }

  export type SalaryUpdateWithoutSalaryEarningInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    FinRow?: FinRowUpdateManyWithoutSalaryNestedInput
    SalaryDebt?: SalaryDebtUpdateManyWithoutSalaryNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutSalaryNestedInput
    ShiftReport?: ShiftReportUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryUncheckedUpdateWithoutSalaryEarningInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    FinRow?: FinRowUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryDebt?: SalaryDebtUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutSalaryNestedInput
    ShiftReport?: ShiftReportUncheckedUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryCreateWithoutSalaryPaymentInput = {
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    FinRow?: FinRowCreateNestedManyWithoutSalaryInput
    SalaryDebt?: SalaryDebtCreateNestedManyWithoutSalaryInput
    SalaryEarning?: SalaryEarningCreateNestedManyWithoutSalaryInput
    ShiftReport?: ShiftReportCreateNestedManyWithoutSalaryInput
  }

  export type SalaryUncheckedCreateWithoutSalaryPaymentInput = {
    id?: number
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    FinRow?: FinRowUncheckedCreateNestedManyWithoutSalaryInput
    SalaryDebt?: SalaryDebtUncheckedCreateNestedManyWithoutSalaryInput
    SalaryEarning?: SalaryEarningUncheckedCreateNestedManyWithoutSalaryInput
    ShiftReport?: ShiftReportUncheckedCreateNestedManyWithoutSalaryInput
  }

  export type SalaryCreateOrConnectWithoutSalaryPaymentInput = {
    where: SalaryWhereUniqueInput
    create: XOR<SalaryCreateWithoutSalaryPaymentInput, SalaryUncheckedCreateWithoutSalaryPaymentInput>
  }

  export type SalaryUpsertWithoutSalaryPaymentInput = {
    update: XOR<SalaryUpdateWithoutSalaryPaymentInput, SalaryUncheckedUpdateWithoutSalaryPaymentInput>
    create: XOR<SalaryCreateWithoutSalaryPaymentInput, SalaryUncheckedCreateWithoutSalaryPaymentInput>
    where?: SalaryWhereInput
  }

  export type SalaryUpdateToOneWithWhereWithoutSalaryPaymentInput = {
    where?: SalaryWhereInput
    data: XOR<SalaryUpdateWithoutSalaryPaymentInput, SalaryUncheckedUpdateWithoutSalaryPaymentInput>
  }

  export type SalaryUpdateWithoutSalaryPaymentInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    FinRow?: FinRowUpdateManyWithoutSalaryNestedInput
    SalaryDebt?: SalaryDebtUpdateManyWithoutSalaryNestedInput
    SalaryEarning?: SalaryEarningUpdateManyWithoutSalaryNestedInput
    ShiftReport?: ShiftReportUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryUncheckedUpdateWithoutSalaryPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    FinRow?: FinRowUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryDebt?: SalaryDebtUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryEarning?: SalaryEarningUncheckedUpdateManyWithoutSalaryNestedInput
    ShiftReport?: ShiftReportUncheckedUpdateManyWithoutSalaryNestedInput
  }

  export type TableCreateWithoutSectionInput = {
    name: string
    description?: string | null
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Column?: ColumnCreateNestedManyWithoutTableInput
    Filter?: FilterCreateNestedManyWithoutTableInput
    Row?: RowCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutSectionInput = {
    id?: number
    name: string
    description?: string | null
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
    Column?: ColumnUncheckedCreateNestedManyWithoutTableInput
    Filter?: FilterUncheckedCreateNestedManyWithoutTableInput
    Row?: RowUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutSectionInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutSectionInput, TableUncheckedCreateWithoutSectionInput>
  }

  export type TableCreateManySectionInputEnvelope = {
    data: TableCreateManySectionInput | TableCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type TableUpsertWithWhereUniqueWithoutSectionInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutSectionInput, TableUncheckedUpdateWithoutSectionInput>
    create: XOR<TableCreateWithoutSectionInput, TableUncheckedCreateWithoutSectionInput>
  }

  export type TableUpdateWithWhereUniqueWithoutSectionInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutSectionInput, TableUncheckedUpdateWithoutSectionInput>
  }

  export type TableUpdateManyWithWhereWithoutSectionInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutSectionInput>
  }

  export type TableScalarWhereInput = {
    AND?: TableScalarWhereInput | TableScalarWhereInput[]
    OR?: TableScalarWhereInput[]
    NOT?: TableScalarWhereInput | TableScalarWhereInput[]
    id?: IntFilter<"Table"> | number
    name?: StringFilter<"Table"> | string
    description?: StringNullableFilter<"Table"> | string | null
    sectionId?: IntFilter<"Table"> | number
    isSearchable?: BoolFilter<"Table"> | boolean
    hasPagination?: BoolFilter<"Table"> | boolean
    pageSize?: IntFilter<"Table"> | number
    order?: IntFilter<"Table"> | number
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
  }

  export type SalaryCreateWithoutShiftReportInput = {
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    FinRow?: FinRowCreateNestedManyWithoutSalaryInput
    SalaryDebt?: SalaryDebtCreateNestedManyWithoutSalaryInput
    SalaryEarning?: SalaryEarningCreateNestedManyWithoutSalaryInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutSalaryInput
  }

  export type SalaryUncheckedCreateWithoutShiftReportInput = {
    id?: number
    fullName: string
    position: string
    startDate: Date | string
    payday: number
    paydayMonth?: number | null
    fixedSalary?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    periodic?: $Enums.PeriodType
    payday2?: number | null
    payday3?: number | null
    section?: $Enums.SalarySection
    FinRow?: FinRowUncheckedCreateNestedManyWithoutSalaryInput
    SalaryDebt?: SalaryDebtUncheckedCreateNestedManyWithoutSalaryInput
    SalaryEarning?: SalaryEarningUncheckedCreateNestedManyWithoutSalaryInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutSalaryInput
  }

  export type SalaryCreateOrConnectWithoutShiftReportInput = {
    where: SalaryWhereUniqueInput
    create: XOR<SalaryCreateWithoutShiftReportInput, SalaryUncheckedCreateWithoutShiftReportInput>
  }

  export type ShiftReportExpenseCreateWithoutShiftReportInput = {
    expenseType: string
    amount: number
    currency?: string
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShiftReportExpenseUncheckedCreateWithoutShiftReportInput = {
    id?: number
    expenseType: string
    amount: number
    currency?: string
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShiftReportExpenseCreateOrConnectWithoutShiftReportInput = {
    where: ShiftReportExpenseWhereUniqueInput
    create: XOR<ShiftReportExpenseCreateWithoutShiftReportInput, ShiftReportExpenseUncheckedCreateWithoutShiftReportInput>
  }

  export type ShiftReportExpenseCreateManyShiftReportInputEnvelope = {
    data: ShiftReportExpenseCreateManyShiftReportInput | ShiftReportExpenseCreateManyShiftReportInput[]
    skipDuplicates?: boolean
  }

  export type SalaryUpsertWithoutShiftReportInput = {
    update: XOR<SalaryUpdateWithoutShiftReportInput, SalaryUncheckedUpdateWithoutShiftReportInput>
    create: XOR<SalaryCreateWithoutShiftReportInput, SalaryUncheckedCreateWithoutShiftReportInput>
    where?: SalaryWhereInput
  }

  export type SalaryUpdateToOneWithWhereWithoutShiftReportInput = {
    where?: SalaryWhereInput
    data: XOR<SalaryUpdateWithoutShiftReportInput, SalaryUncheckedUpdateWithoutShiftReportInput>
  }

  export type SalaryUpdateWithoutShiftReportInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    FinRow?: FinRowUpdateManyWithoutSalaryNestedInput
    SalaryDebt?: SalaryDebtUpdateManyWithoutSalaryNestedInput
    SalaryEarning?: SalaryEarningUpdateManyWithoutSalaryNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryUncheckedUpdateWithoutShiftReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payday?: IntFieldUpdateOperationsInput | number
    paydayMonth?: NullableIntFieldUpdateOperationsInput | number | null
    fixedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    periodic?: EnumPeriodTypeFieldUpdateOperationsInput | $Enums.PeriodType
    payday2?: NullableIntFieldUpdateOperationsInput | number | null
    payday3?: NullableIntFieldUpdateOperationsInput | number | null
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    FinRow?: FinRowUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryDebt?: SalaryDebtUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryEarning?: SalaryEarningUncheckedUpdateManyWithoutSalaryNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutSalaryNestedInput
  }

  export type ShiftReportExpenseUpsertWithWhereUniqueWithoutShiftReportInput = {
    where: ShiftReportExpenseWhereUniqueInput
    update: XOR<ShiftReportExpenseUpdateWithoutShiftReportInput, ShiftReportExpenseUncheckedUpdateWithoutShiftReportInput>
    create: XOR<ShiftReportExpenseCreateWithoutShiftReportInput, ShiftReportExpenseUncheckedCreateWithoutShiftReportInput>
  }

  export type ShiftReportExpenseUpdateWithWhereUniqueWithoutShiftReportInput = {
    where: ShiftReportExpenseWhereUniqueInput
    data: XOR<ShiftReportExpenseUpdateWithoutShiftReportInput, ShiftReportExpenseUncheckedUpdateWithoutShiftReportInput>
  }

  export type ShiftReportExpenseUpdateManyWithWhereWithoutShiftReportInput = {
    where: ShiftReportExpenseScalarWhereInput
    data: XOR<ShiftReportExpenseUpdateManyMutationInput, ShiftReportExpenseUncheckedUpdateManyWithoutShiftReportInput>
  }

  export type ShiftReportExpenseScalarWhereInput = {
    AND?: ShiftReportExpenseScalarWhereInput | ShiftReportExpenseScalarWhereInput[]
    OR?: ShiftReportExpenseScalarWhereInput[]
    NOT?: ShiftReportExpenseScalarWhereInput | ShiftReportExpenseScalarWhereInput[]
    id?: IntFilter<"ShiftReportExpense"> | number
    shiftReportId?: IntNullableFilter<"ShiftReportExpense"> | number | null
    expenseType?: StringFilter<"ShiftReportExpense"> | string
    amount?: FloatFilter<"ShiftReportExpense"> | number
    currency?: StringFilter<"ShiftReportExpense"> | string
    date?: DateTimeFilter<"ShiftReportExpense"> | Date | string
    time?: StringFilter<"ShiftReportExpense"> | string
    period?: StringNullableFilter<"ShiftReportExpense"> | string | null
    description?: StringNullableFilter<"ShiftReportExpense"> | string | null
    createdAt?: DateTimeFilter<"ShiftReportExpense"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftReportExpense"> | Date | string
  }

  export type ShiftReportCreateWithoutShiftReportExpenseInput = {
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    usdtAmount?: number
    currency?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Salary?: SalaryCreateNestedOneWithoutShiftReportInput
  }

  export type ShiftReportUncheckedCreateWithoutShiftReportExpenseInput = {
    id?: number
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    employeeId?: number | null
    usdtAmount?: number
    currency?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShiftReportCreateOrConnectWithoutShiftReportExpenseInput = {
    where: ShiftReportWhereUniqueInput
    create: XOR<ShiftReportCreateWithoutShiftReportExpenseInput, ShiftReportUncheckedCreateWithoutShiftReportExpenseInput>
  }

  export type ShiftReportUpsertWithoutShiftReportExpenseInput = {
    update: XOR<ShiftReportUpdateWithoutShiftReportExpenseInput, ShiftReportUncheckedUpdateWithoutShiftReportExpenseInput>
    create: XOR<ShiftReportCreateWithoutShiftReportExpenseInput, ShiftReportUncheckedCreateWithoutShiftReportExpenseInput>
    where?: ShiftReportWhereInput
  }

  export type ShiftReportUpdateToOneWithWhereWithoutShiftReportExpenseInput = {
    where?: ShiftReportWhereInput
    data: XOR<ShiftReportUpdateWithoutShiftReportExpenseInput, ShiftReportUncheckedUpdateWithoutShiftReportExpenseInput>
  }

  export type ShiftReportUpdateWithoutShiftReportExpenseInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: SalaryUpdateOneWithoutShiftReportNestedInput
  }

  export type ShiftReportUncheckedUpdateWithoutShiftReportExpenseInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColumnCreateWithoutTableInput = {
    name: string
    type: $Enums.ColumnType
    width?: number | null
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: string | null
    format?: string | null
    order: number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    Cell?: CellCreateNestedManyWithoutColumnInput
    Filter?: FilterCreateNestedManyWithoutColumnInput
  }

  export type ColumnUncheckedCreateWithoutTableInput = {
    id?: number
    name: string
    type: $Enums.ColumnType
    width?: number | null
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: string | null
    format?: string | null
    order: number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    Cell?: CellUncheckedCreateNestedManyWithoutColumnInput
    Filter?: FilterUncheckedCreateNestedManyWithoutColumnInput
  }

  export type ColumnCreateOrConnectWithoutTableInput = {
    where: ColumnWhereUniqueInput
    create: XOR<ColumnCreateWithoutTableInput, ColumnUncheckedCreateWithoutTableInput>
  }

  export type ColumnCreateManyTableInputEnvelope = {
    data: ColumnCreateManyTableInput | ColumnCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type FilterCreateWithoutTableInput = {
    name: string
    operator: $Enums.FilterOperator
    value?: string | null
    secondValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Column: ColumnCreateNestedOneWithoutFilterInput
  }

  export type FilterUncheckedCreateWithoutTableInput = {
    id?: number
    name: string
    columnId: number
    operator: $Enums.FilterOperator
    value?: string | null
    secondValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type FilterCreateOrConnectWithoutTableInput = {
    where: FilterWhereUniqueInput
    create: XOR<FilterCreateWithoutTableInput, FilterUncheckedCreateWithoutTableInput>
  }

  export type FilterCreateManyTableInputEnvelope = {
    data: FilterCreateManyTableInput | FilterCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type RowCreateWithoutTableInput = {
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Cell?: CellCreateNestedManyWithoutRowInput
  }

  export type RowUncheckedCreateWithoutTableInput = {
    id?: number
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Cell?: CellUncheckedCreateNestedManyWithoutRowInput
  }

  export type RowCreateOrConnectWithoutTableInput = {
    where: RowWhereUniqueInput
    create: XOR<RowCreateWithoutTableInput, RowUncheckedCreateWithoutTableInput>
  }

  export type RowCreateManyTableInputEnvelope = {
    data: RowCreateManyTableInput | RowCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type SectionCreateWithoutTableInput = {
    name: string
    description?: string | null
    slug: string
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SectionUncheckedCreateWithoutTableInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SectionCreateOrConnectWithoutTableInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutTableInput, SectionUncheckedCreateWithoutTableInput>
  }

  export type ColumnUpsertWithWhereUniqueWithoutTableInput = {
    where: ColumnWhereUniqueInput
    update: XOR<ColumnUpdateWithoutTableInput, ColumnUncheckedUpdateWithoutTableInput>
    create: XOR<ColumnCreateWithoutTableInput, ColumnUncheckedCreateWithoutTableInput>
  }

  export type ColumnUpdateWithWhereUniqueWithoutTableInput = {
    where: ColumnWhereUniqueInput
    data: XOR<ColumnUpdateWithoutTableInput, ColumnUncheckedUpdateWithoutTableInput>
  }

  export type ColumnUpdateManyWithWhereWithoutTableInput = {
    where: ColumnScalarWhereInput
    data: XOR<ColumnUpdateManyMutationInput, ColumnUncheckedUpdateManyWithoutTableInput>
  }

  export type ColumnScalarWhereInput = {
    AND?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
    OR?: ColumnScalarWhereInput[]
    NOT?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
    id?: IntFilter<"Column"> | number
    name?: StringFilter<"Column"> | string
    type?: EnumColumnTypeFilter<"Column"> | $Enums.ColumnType
    tableId?: IntFilter<"Column"> | number
    width?: IntNullableFilter<"Column"> | number | null
    isRequired?: BoolFilter<"Column"> | boolean
    isFilterable?: BoolFilter<"Column"> | boolean
    isSummable?: BoolFilter<"Column"> | boolean
    defaultValue?: StringNullableFilter<"Column"> | string | null
    format?: StringNullableFilter<"Column"> | string | null
    order?: IntFilter<"Column"> | number
    options?: JsonNullableFilter<"Column">
    createdAt?: DateTimeFilter<"Column"> | Date | string
    updatedAt?: DateTimeFilter<"Column"> | Date | string
  }

  export type FilterUpsertWithWhereUniqueWithoutTableInput = {
    where: FilterWhereUniqueInput
    update: XOR<FilterUpdateWithoutTableInput, FilterUncheckedUpdateWithoutTableInput>
    create: XOR<FilterCreateWithoutTableInput, FilterUncheckedCreateWithoutTableInput>
  }

  export type FilterUpdateWithWhereUniqueWithoutTableInput = {
    where: FilterWhereUniqueInput
    data: XOR<FilterUpdateWithoutTableInput, FilterUncheckedUpdateWithoutTableInput>
  }

  export type FilterUpdateManyWithWhereWithoutTableInput = {
    where: FilterScalarWhereInput
    data: XOR<FilterUpdateManyMutationInput, FilterUncheckedUpdateManyWithoutTableInput>
  }

  export type RowUpsertWithWhereUniqueWithoutTableInput = {
    where: RowWhereUniqueInput
    update: XOR<RowUpdateWithoutTableInput, RowUncheckedUpdateWithoutTableInput>
    create: XOR<RowCreateWithoutTableInput, RowUncheckedCreateWithoutTableInput>
  }

  export type RowUpdateWithWhereUniqueWithoutTableInput = {
    where: RowWhereUniqueInput
    data: XOR<RowUpdateWithoutTableInput, RowUncheckedUpdateWithoutTableInput>
  }

  export type RowUpdateManyWithWhereWithoutTableInput = {
    where: RowScalarWhereInput
    data: XOR<RowUpdateManyMutationInput, RowUncheckedUpdateManyWithoutTableInput>
  }

  export type RowScalarWhereInput = {
    AND?: RowScalarWhereInput | RowScalarWhereInput[]
    OR?: RowScalarWhereInput[]
    NOT?: RowScalarWhereInput | RowScalarWhereInput[]
    id?: IntFilter<"Row"> | number
    tableId?: IntFilter<"Row"> | number
    order?: IntFilter<"Row"> | number
    isActive?: BoolFilter<"Row"> | boolean
    createdAt?: DateTimeFilter<"Row"> | Date | string
    updatedAt?: DateTimeFilter<"Row"> | Date | string
  }

  export type SectionUpsertWithoutTableInput = {
    update: XOR<SectionUpdateWithoutTableInput, SectionUncheckedUpdateWithoutTableInput>
    create: XOR<SectionCreateWithoutTableInput, SectionUncheckedCreateWithoutTableInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutTableInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutTableInput, SectionUncheckedUpdateWithoutTableInput>
  }

  export type SectionUpdateWithoutTableInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUncheckedUpdateWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutTelegramAccountInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTelegramAccountInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionUncheckedCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportUncheckedCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportUncheckedCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetUncheckedCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTelegramAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTelegramAccountInput, UserUncheckedCreateWithoutTelegramAccountInput>
  }

  export type UserUpsertWithoutTelegramAccountInput = {
    update: XOR<UserUpdateWithoutTelegramAccountInput, UserUncheckedUpdateWithoutTelegramAccountInput>
    create: XOR<UserCreateWithoutTelegramAccountInput, UserUncheckedCreateWithoutTelegramAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTelegramAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTelegramAccountInput, UserUncheckedUpdateWithoutTelegramAccountInput>
  }

  export type UserUpdateWithoutTelegramAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTelegramAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUncheckedUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUncheckedUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUncheckedUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MatchCreateWithoutTransactionInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    IdexTransaction: IdexTransactionCreateNestedOneWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutTransactionInput = {
    id?: number
    idexTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MatchCreateOrConnectWithoutTransactionInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutTransactionInput, MatchUncheckedCreateWithoutTransactionInput>
  }

  export type MatchCreateManyTransactionInputEnvelope = {
    data: MatchCreateManyTransactionInput | MatchCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTransactionInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionUncheckedCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportUncheckedCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportUncheckedCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationUncheckedCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountUncheckedCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetUncheckedCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
  }

  export type MatchUpsertWithWhereUniqueWithoutTransactionInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutTransactionInput, MatchUncheckedUpdateWithoutTransactionInput>
    create: XOR<MatchCreateWithoutTransactionInput, MatchUncheckedCreateWithoutTransactionInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutTransactionInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutTransactionInput, MatchUncheckedUpdateWithoutTransactionInput>
  }

  export type MatchUpdateManyWithWhereWithoutTransactionInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutTransactionInput>
  }

  export type UserUpsertWithoutTransactionInput = {
    update: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateWithoutTransactionInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUncheckedUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUncheckedUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUncheckedUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUncheckedUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUncheckedUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AuditLogCreateWithoutUserInput = {
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    CardBalance?: CardBalanceCreateNestedOneWithoutAuditLogInput
    Card?: CardCreateNestedOneWithoutAuditLogInput
    CardPouring?: CardPouringCreateNestedOneWithoutAuditLogInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: number | null
    cardId?: number | null
    cardPouringId?: number | null
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BybitClipMatchCreateWithoutUserInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitTransactionFromCabinet: BybitTransactionFromCabinetCreateNestedOneWithoutBybitClipMatchInput
    IdexTransaction: IdexTransactionCreateNestedOneWithoutBybitClipMatchInput
    MatchBybitReport?: MatchBybitReportCreateNestedOneWithoutBybitClipMatchInput
  }

  export type BybitClipMatchUncheckedCreateWithoutUserInput = {
    id?: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchBybitReportId?: number | null
  }

  export type BybitClipMatchCreateOrConnectWithoutUserInput = {
    where: BybitClipMatchWhereUniqueInput
    create: XOR<BybitClipMatchCreateWithoutUserInput, BybitClipMatchUncheckedCreateWithoutUserInput>
  }

  export type BybitClipMatchCreateManyUserInputEnvelope = {
    data: BybitClipMatchCreateManyUserInput | BybitClipMatchCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BybitTransactionCreateWithoutUserInput = {
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    bybitMatch?: BybitMatchCreateNestedManyWithoutBybitTransactionInput
  }

  export type BybitTransactionUncheckedCreateWithoutUserInput = {
    id?: number
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    bybitMatch?: BybitMatchUncheckedCreateNestedManyWithoutBybitTransactionInput
  }

  export type BybitTransactionCreateOrConnectWithoutUserInput = {
    where: BybitTransactionWhereUniqueInput
    create: XOR<BybitTransactionCreateWithoutUserInput, BybitTransactionUncheckedCreateWithoutUserInput>
  }

  export type BybitTransactionCreateManyUserInputEnvelope = {
    data: BybitTransactionCreateManyUserInput | BybitTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MatchBybitReportCreateWithoutUserInput = {
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutMatchBybitReportInput
  }

  export type MatchBybitReportUncheckedCreateWithoutUserInput = {
    id?: number
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutMatchBybitReportInput
  }

  export type MatchBybitReportCreateOrConnectWithoutUserInput = {
    where: MatchBybitReportWhereUniqueInput
    create: XOR<MatchBybitReportCreateWithoutUserInput, MatchBybitReportUncheckedCreateWithoutUserInput>
  }

  export type MatchBybitReportCreateManyUserInputEnvelope = {
    data: MatchBybitReportCreateManyUserInput | MatchBybitReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MatchViresReportCreateWithoutUserInput = {
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutMatchViresReportInput
  }

  export type MatchViresReportUncheckedCreateWithoutUserInput = {
    id?: number
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutMatchViresReportInput
  }

  export type MatchViresReportCreateOrConnectWithoutUserInput = {
    where: MatchViresReportWhereUniqueInput
    create: XOR<MatchViresReportCreateWithoutUserInput, MatchViresReportUncheckedCreateWithoutUserInput>
  }

  export type MatchViresReportCreateManyUserInputEnvelope = {
    data: MatchViresReportCreateManyUserInput | MatchViresReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportNotificationCreateWithoutUserInput = {
    notificationTime: Date | string
    reportReceived?: boolean
    reportTime?: Date | string | null
    adminNotified?: boolean
    adminNotifyTime?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ReportNotificationUncheckedCreateWithoutUserInput = {
    id?: number
    notificationTime: Date | string
    reportReceived?: boolean
    reportTime?: Date | string | null
    adminNotified?: boolean
    adminNotifyTime?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ReportNotificationCreateOrConnectWithoutUserInput = {
    where: ReportNotificationWhereUniqueInput
    create: XOR<ReportNotificationCreateWithoutUserInput, ReportNotificationUncheckedCreateWithoutUserInput>
  }

  export type ReportNotificationCreateManyUserInputEnvelope = {
    data: ReportNotificationCreateManyUserInput | ReportNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TelegramAccountCreateWithoutUserInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TelegramAccountUncheckedCreateWithoutUserInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TelegramAccountCreateOrConnectWithoutUserInput = {
    where: TelegramAccountWhereUniqueInput
    create: XOR<TelegramAccountCreateWithoutUserInput, TelegramAccountUncheckedCreateWithoutUserInput>
  }

  export type TelegramAccountCreateManyUserInputEnvelope = {
    data: TelegramAccountCreateManyUserInput | TelegramAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    externalId?: string | null
    orderNo?: string | null
    dateTime: Date | string
    type: string
    asset: string
    amount: number
    totalPrice: number
    unitPrice: number
    counterparty?: string | null
    status: string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    Match?: MatchCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: number
    externalId?: string | null
    orderNo?: string | null
    dateTime: Date | string
    type: string
    asset: string
    amount: number
    totalPrice: number
    unitPrice: number
    counterparty?: string | null
    status: string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    Match?: MatchUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ViresCabinetCreateWithoutUserInput = {
    name?: string | null
    login: string
    password: string
    type: $Enums.PasswordType
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    lastUpdate: Date | string
    ViresTransactionPayin?: ViresTransactionPayinCreateNestedManyWithoutViresCabinetInput
  }

  export type ViresCabinetUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    login: string
    password: string
    type: $Enums.PasswordType
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    lastUpdate: Date | string
    ViresTransactionPayin?: ViresTransactionPayinUncheckedCreateNestedManyWithoutViresCabinetInput
  }

  export type ViresCabinetCreateOrConnectWithoutUserInput = {
    where: ViresCabinetWhereUniqueInput
    create: XOR<ViresCabinetCreateWithoutUserInput, ViresCabinetUncheckedCreateWithoutUserInput>
  }

  export type ViresCabinetCreateManyUserInputEnvelope = {
    data: ViresCabinetCreateManyUserInput | ViresCabinetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ViresClipMatchCreateWithoutUserInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitTransactionFromCabinet: BybitTransactionFromCabinetCreateNestedOneWithoutViresClipMatchInput
    MatchViresReport?: MatchViresReportCreateNestedOneWithoutViresClipMatchInput
    ViresTransactionPayin: ViresTransactionPayinCreateNestedOneWithoutViresClipMatchInput
  }

  export type ViresClipMatchUncheckedCreateWithoutUserInput = {
    id?: number
    viresTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchViresReportId?: number | null
    bybitTransactionId: number
  }

  export type ViresClipMatchCreateOrConnectWithoutUserInput = {
    where: ViresClipMatchWhereUniqueInput
    create: XOR<ViresClipMatchCreateWithoutUserInput, ViresClipMatchUncheckedCreateWithoutUserInput>
  }

  export type ViresClipMatchCreateManyUserInputEnvelope = {
    data: ViresClipMatchCreateManyUserInput | ViresClipMatchCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkSessionCreateWithoutUserInput = {
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    autoCompleted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetCreateNestedManyWithoutWorkSessionInput
  }

  export type WorkSessionUncheckedCreateWithoutUserInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    autoCompleted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUncheckedCreateNestedManyWithoutWorkSessionInput
  }

  export type WorkSessionCreateOrConnectWithoutUserInput = {
    where: WorkSessionWhereUniqueInput
    create: XOR<WorkSessionCreateWithoutUserInput, WorkSessionUncheckedCreateWithoutUserInput>
  }

  export type WorkSessionCreateManyUserInputEnvelope = {
    data: WorkSessionCreateManyUserInput | WorkSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type BybitClipMatchUpsertWithWhereUniqueWithoutUserInput = {
    where: BybitClipMatchWhereUniqueInput
    update: XOR<BybitClipMatchUpdateWithoutUserInput, BybitClipMatchUncheckedUpdateWithoutUserInput>
    create: XOR<BybitClipMatchCreateWithoutUserInput, BybitClipMatchUncheckedCreateWithoutUserInput>
  }

  export type BybitClipMatchUpdateWithWhereUniqueWithoutUserInput = {
    where: BybitClipMatchWhereUniqueInput
    data: XOR<BybitClipMatchUpdateWithoutUserInput, BybitClipMatchUncheckedUpdateWithoutUserInput>
  }

  export type BybitClipMatchUpdateManyWithWhereWithoutUserInput = {
    where: BybitClipMatchScalarWhereInput
    data: XOR<BybitClipMatchUpdateManyMutationInput, BybitClipMatchUncheckedUpdateManyWithoutUserInput>
  }

  export type BybitTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: BybitTransactionWhereUniqueInput
    update: XOR<BybitTransactionUpdateWithoutUserInput, BybitTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<BybitTransactionCreateWithoutUserInput, BybitTransactionUncheckedCreateWithoutUserInput>
  }

  export type BybitTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: BybitTransactionWhereUniqueInput
    data: XOR<BybitTransactionUpdateWithoutUserInput, BybitTransactionUncheckedUpdateWithoutUserInput>
  }

  export type BybitTransactionUpdateManyWithWhereWithoutUserInput = {
    where: BybitTransactionScalarWhereInput
    data: XOR<BybitTransactionUpdateManyMutationInput, BybitTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type BybitTransactionScalarWhereInput = {
    AND?: BybitTransactionScalarWhereInput | BybitTransactionScalarWhereInput[]
    OR?: BybitTransactionScalarWhereInput[]
    NOT?: BybitTransactionScalarWhereInput | BybitTransactionScalarWhereInput[]
    id?: IntFilter<"BybitTransaction"> | number
    orderNo?: StringFilter<"BybitTransaction"> | string
    counterparty?: StringNullableFilter<"BybitTransaction"> | string | null
    status?: StringFilter<"BybitTransaction"> | string
    userId?: IntFilter<"BybitTransaction"> | number
    createdAt?: DateTimeFilter<"BybitTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BybitTransaction"> | Date | string
    amount?: FloatFilter<"BybitTransaction"> | number
    asset?: StringFilter<"BybitTransaction"> | string
    dateTime?: DateTimeFilter<"BybitTransaction"> | Date | string
    originalData?: JsonNullableFilter<"BybitTransaction">
    totalPrice?: FloatFilter<"BybitTransaction"> | number
    type?: StringFilter<"BybitTransaction"> | string
    unitPrice?: FloatFilter<"BybitTransaction"> | number
    processed?: BoolFilter<"BybitTransaction"> | boolean
    extractedPhones?: StringNullableListFilter<"BybitTransaction">
    lastAttemptError?: StringNullableFilter<"BybitTransaction"> | string | null
  }

  export type MatchBybitReportUpsertWithWhereUniqueWithoutUserInput = {
    where: MatchBybitReportWhereUniqueInput
    update: XOR<MatchBybitReportUpdateWithoutUserInput, MatchBybitReportUncheckedUpdateWithoutUserInput>
    create: XOR<MatchBybitReportCreateWithoutUserInput, MatchBybitReportUncheckedCreateWithoutUserInput>
  }

  export type MatchBybitReportUpdateWithWhereUniqueWithoutUserInput = {
    where: MatchBybitReportWhereUniqueInput
    data: XOR<MatchBybitReportUpdateWithoutUserInput, MatchBybitReportUncheckedUpdateWithoutUserInput>
  }

  export type MatchBybitReportUpdateManyWithWhereWithoutUserInput = {
    where: MatchBybitReportScalarWhereInput
    data: XOR<MatchBybitReportUpdateManyMutationInput, MatchBybitReportUncheckedUpdateManyWithoutUserInput>
  }

  export type MatchBybitReportScalarWhereInput = {
    AND?: MatchBybitReportScalarWhereInput | MatchBybitReportScalarWhereInput[]
    OR?: MatchBybitReportScalarWhereInput[]
    NOT?: MatchBybitReportScalarWhereInput | MatchBybitReportScalarWhereInput[]
    id?: IntFilter<"MatchBybitReport"> | number
    reportDate?: DateTimeFilter<"MatchBybitReport"> | Date | string
    totalMatches?: IntFilter<"MatchBybitReport"> | number
    totalProfit?: FloatFilter<"MatchBybitReport"> | number
    averageProfit?: FloatFilter<"MatchBybitReport"> | number
    successRate?: FloatFilter<"MatchBybitReport"> | number
    timeRangeStart?: DateTimeFilter<"MatchBybitReport"> | Date | string
    timeRangeEnd?: DateTimeFilter<"MatchBybitReport"> | Date | string
    notes?: StringNullableFilter<"MatchBybitReport"> | string | null
    idexCabinets?: JsonNullableFilter<"MatchBybitReport">
    createdAt?: DateTimeFilter<"MatchBybitReport"> | Date | string
    updatedAt?: DateTimeFilter<"MatchBybitReport"> | Date | string
    userId?: IntFilter<"MatchBybitReport"> | number
  }

  export type MatchViresReportUpsertWithWhereUniqueWithoutUserInput = {
    where: MatchViresReportWhereUniqueInput
    update: XOR<MatchViresReportUpdateWithoutUserInput, MatchViresReportUncheckedUpdateWithoutUserInput>
    create: XOR<MatchViresReportCreateWithoutUserInput, MatchViresReportUncheckedCreateWithoutUserInput>
  }

  export type MatchViresReportUpdateWithWhereUniqueWithoutUserInput = {
    where: MatchViresReportWhereUniqueInput
    data: XOR<MatchViresReportUpdateWithoutUserInput, MatchViresReportUncheckedUpdateWithoutUserInput>
  }

  export type MatchViresReportUpdateManyWithWhereWithoutUserInput = {
    where: MatchViresReportScalarWhereInput
    data: XOR<MatchViresReportUpdateManyMutationInput, MatchViresReportUncheckedUpdateManyWithoutUserInput>
  }

  export type MatchViresReportScalarWhereInput = {
    AND?: MatchViresReportScalarWhereInput | MatchViresReportScalarWhereInput[]
    OR?: MatchViresReportScalarWhereInput[]
    NOT?: MatchViresReportScalarWhereInput | MatchViresReportScalarWhereInput[]
    id?: IntFilter<"MatchViresReport"> | number
    reportDate?: DateTimeFilter<"MatchViresReport"> | Date | string
    totalMatches?: IntFilter<"MatchViresReport"> | number
    totalProfit?: FloatFilter<"MatchViresReport"> | number
    averageProfit?: FloatFilter<"MatchViresReport"> | number
    successRate?: FloatFilter<"MatchViresReport"> | number
    timeRangeStart?: DateTimeFilter<"MatchViresReport"> | Date | string
    timeRangeEnd?: DateTimeFilter<"MatchViresReport"> | Date | string
    notes?: StringNullableFilter<"MatchViresReport"> | string | null
    idexCabinets?: JsonNullableFilter<"MatchViresReport">
    createdAt?: DateTimeFilter<"MatchViresReport"> | Date | string
    updatedAt?: DateTimeFilter<"MatchViresReport"> | Date | string
    userId?: IntFilter<"MatchViresReport"> | number
  }

  export type ReportNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportNotificationWhereUniqueInput
    update: XOR<ReportNotificationUpdateWithoutUserInput, ReportNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<ReportNotificationCreateWithoutUserInput, ReportNotificationUncheckedCreateWithoutUserInput>
  }

  export type ReportNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportNotificationWhereUniqueInput
    data: XOR<ReportNotificationUpdateWithoutUserInput, ReportNotificationUncheckedUpdateWithoutUserInput>
  }

  export type ReportNotificationUpdateManyWithWhereWithoutUserInput = {
    where: ReportNotificationScalarWhereInput
    data: XOR<ReportNotificationUpdateManyMutationInput, ReportNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type ReportNotificationScalarWhereInput = {
    AND?: ReportNotificationScalarWhereInput | ReportNotificationScalarWhereInput[]
    OR?: ReportNotificationScalarWhereInput[]
    NOT?: ReportNotificationScalarWhereInput | ReportNotificationScalarWhereInput[]
    id?: IntFilter<"ReportNotification"> | number
    notificationTime?: DateTimeFilter<"ReportNotification"> | Date | string
    reportReceived?: BoolFilter<"ReportNotification"> | boolean
    reportTime?: DateTimeNullableFilter<"ReportNotification"> | Date | string | null
    adminNotified?: BoolFilter<"ReportNotification"> | boolean
    adminNotifyTime?: DateTimeNullableFilter<"ReportNotification"> | Date | string | null
    userId?: IntFilter<"ReportNotification"> | number
    createdAt?: DateTimeFilter<"ReportNotification"> | Date | string
    updatedAt?: DateTimeFilter<"ReportNotification"> | Date | string
  }

  export type TelegramAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: TelegramAccountWhereUniqueInput
    update: XOR<TelegramAccountUpdateWithoutUserInput, TelegramAccountUncheckedUpdateWithoutUserInput>
    create: XOR<TelegramAccountCreateWithoutUserInput, TelegramAccountUncheckedCreateWithoutUserInput>
  }

  export type TelegramAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: TelegramAccountWhereUniqueInput
    data: XOR<TelegramAccountUpdateWithoutUserInput, TelegramAccountUncheckedUpdateWithoutUserInput>
  }

  export type TelegramAccountUpdateManyWithWhereWithoutUserInput = {
    where: TelegramAccountScalarWhereInput
    data: XOR<TelegramAccountUpdateManyMutationInput, TelegramAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type TelegramAccountScalarWhereInput = {
    AND?: TelegramAccountScalarWhereInput | TelegramAccountScalarWhereInput[]
    OR?: TelegramAccountScalarWhereInput[]
    NOT?: TelegramAccountScalarWhereInput | TelegramAccountScalarWhereInput[]
    id?: IntFilter<"TelegramAccount"> | number
    telegramId?: StringFilter<"TelegramAccount"> | string
    username?: StringNullableFilter<"TelegramAccount"> | string | null
    firstName?: StringNullableFilter<"TelegramAccount"> | string | null
    lastName?: StringNullableFilter<"TelegramAccount"> | string | null
    userId?: IntFilter<"TelegramAccount"> | number
    createdAt?: DateTimeFilter<"TelegramAccount"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramAccount"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    externalId?: StringNullableFilter<"Transaction"> | string | null
    orderNo?: StringNullableFilter<"Transaction"> | string | null
    dateTime?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    asset?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    totalPrice?: FloatFilter<"Transaction"> | number
    unitPrice?: FloatFilter<"Transaction"> | number
    counterparty?: StringNullableFilter<"Transaction"> | string | null
    status?: StringFilter<"Transaction"> | string
    originalData?: JsonNullableFilter<"Transaction">
    userId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type ViresCabinetUpsertWithWhereUniqueWithoutUserInput = {
    where: ViresCabinetWhereUniqueInput
    update: XOR<ViresCabinetUpdateWithoutUserInput, ViresCabinetUncheckedUpdateWithoutUserInput>
    create: XOR<ViresCabinetCreateWithoutUserInput, ViresCabinetUncheckedCreateWithoutUserInput>
  }

  export type ViresCabinetUpdateWithWhereUniqueWithoutUserInput = {
    where: ViresCabinetWhereUniqueInput
    data: XOR<ViresCabinetUpdateWithoutUserInput, ViresCabinetUncheckedUpdateWithoutUserInput>
  }

  export type ViresCabinetUpdateManyWithWhereWithoutUserInput = {
    where: ViresCabinetScalarWhereInput
    data: XOR<ViresCabinetUpdateManyMutationInput, ViresCabinetUncheckedUpdateManyWithoutUserInput>
  }

  export type ViresCabinetScalarWhereInput = {
    AND?: ViresCabinetScalarWhereInput | ViresCabinetScalarWhereInput[]
    OR?: ViresCabinetScalarWhereInput[]
    NOT?: ViresCabinetScalarWhereInput | ViresCabinetScalarWhereInput[]
    id?: IntFilter<"ViresCabinet"> | number
    name?: StringNullableFilter<"ViresCabinet"> | string | null
    login?: StringFilter<"ViresCabinet"> | string
    password?: StringFilter<"ViresCabinet"> | string
    type?: EnumPasswordTypeFilter<"ViresCabinet"> | $Enums.PasswordType
    createdAt?: DateTimeFilter<"ViresCabinet"> | Date | string
    updatedAt?: DateTimeFilter<"ViresCabinet"> | Date | string
    comment?: StringNullableFilter<"ViresCabinet"> | string | null
    userId?: IntFilter<"ViresCabinet"> | number
    lastUpdate?: DateTimeFilter<"ViresCabinet"> | Date | string
  }

  export type ViresClipMatchUpsertWithWhereUniqueWithoutUserInput = {
    where: ViresClipMatchWhereUniqueInput
    update: XOR<ViresClipMatchUpdateWithoutUserInput, ViresClipMatchUncheckedUpdateWithoutUserInput>
    create: XOR<ViresClipMatchCreateWithoutUserInput, ViresClipMatchUncheckedCreateWithoutUserInput>
  }

  export type ViresClipMatchUpdateWithWhereUniqueWithoutUserInput = {
    where: ViresClipMatchWhereUniqueInput
    data: XOR<ViresClipMatchUpdateWithoutUserInput, ViresClipMatchUncheckedUpdateWithoutUserInput>
  }

  export type ViresClipMatchUpdateManyWithWhereWithoutUserInput = {
    where: ViresClipMatchScalarWhereInput
    data: XOR<ViresClipMatchUpdateManyMutationInput, ViresClipMatchUncheckedUpdateManyWithoutUserInput>
  }

  export type ViresClipMatchScalarWhereInput = {
    AND?: ViresClipMatchScalarWhereInput | ViresClipMatchScalarWhereInput[]
    OR?: ViresClipMatchScalarWhereInput[]
    NOT?: ViresClipMatchScalarWhereInput | ViresClipMatchScalarWhereInput[]
    id?: IntFilter<"ViresClipMatch"> | number
    viresTransactionId?: IntFilter<"ViresClipMatch"> | number
    timeDifference?: IntFilter<"ViresClipMatch"> | number
    grossExpense?: FloatFilter<"ViresClipMatch"> | number
    grossIncome?: FloatFilter<"ViresClipMatch"> | number
    grossProfit?: FloatFilter<"ViresClipMatch"> | number
    profitPercentage?: FloatFilter<"ViresClipMatch"> | number
    createdAt?: DateTimeFilter<"ViresClipMatch"> | Date | string
    updatedAt?: DateTimeFilter<"ViresClipMatch"> | Date | string
    matchViresReportId?: IntNullableFilter<"ViresClipMatch"> | number | null
    userId?: IntFilter<"ViresClipMatch"> | number
    bybitTransactionId?: IntFilter<"ViresClipMatch"> | number
  }

  export type WorkSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkSessionWhereUniqueInput
    update: XOR<WorkSessionUpdateWithoutUserInput, WorkSessionUncheckedUpdateWithoutUserInput>
    create: XOR<WorkSessionCreateWithoutUserInput, WorkSessionUncheckedCreateWithoutUserInput>
  }

  export type WorkSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkSessionWhereUniqueInput
    data: XOR<WorkSessionUpdateWithoutUserInput, WorkSessionUncheckedUpdateWithoutUserInput>
  }

  export type WorkSessionUpdateManyWithWhereWithoutUserInput = {
    where: WorkSessionScalarWhereInput
    data: XOR<WorkSessionUpdateManyMutationInput, WorkSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkSessionScalarWhereInput = {
    AND?: WorkSessionScalarWhereInput | WorkSessionScalarWhereInput[]
    OR?: WorkSessionScalarWhereInput[]
    NOT?: WorkSessionScalarWhereInput | WorkSessionScalarWhereInput[]
    id?: IntFilter<"WorkSession"> | number
    startTime?: DateTimeFilter<"WorkSession"> | Date | string
    endTime?: DateTimeNullableFilter<"WorkSession"> | Date | string | null
    duration?: IntNullableFilter<"WorkSession"> | number | null
    autoCompleted?: BoolFilter<"WorkSession"> | boolean
    userId?: IntFilter<"WorkSession"> | number
    createdAt?: DateTimeFilter<"WorkSession"> | Date | string
    updatedAt?: DateTimeFilter<"WorkSession"> | Date | string
    comment?: StringNullableFilter<"WorkSession"> | string | null
  }

  export type UserCreateWithoutWorkSessionInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkSessionInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionUncheckedCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportUncheckedCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportUncheckedCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationUncheckedCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetUncheckedCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkSessionInput, UserUncheckedCreateWithoutWorkSessionInput>
  }

  export type WorkSessionIdexCabinetCreateWithoutWorkSessionInput = {
    assignedAt?: Date | string
    IdexCabinet: IdexCabinetCreateNestedOneWithoutWorkSessionIdexCabinetInput
  }

  export type WorkSessionIdexCabinetUncheckedCreateWithoutWorkSessionInput = {
    idexCabinetId: number
    assignedAt?: Date | string
  }

  export type WorkSessionIdexCabinetCreateOrConnectWithoutWorkSessionInput = {
    where: WorkSessionIdexCabinetWhereUniqueInput
    create: XOR<WorkSessionIdexCabinetCreateWithoutWorkSessionInput, WorkSessionIdexCabinetUncheckedCreateWithoutWorkSessionInput>
  }

  export type WorkSessionIdexCabinetCreateManyWorkSessionInputEnvelope = {
    data: WorkSessionIdexCabinetCreateManyWorkSessionInput | WorkSessionIdexCabinetCreateManyWorkSessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorkSessionInput = {
    update: XOR<UserUpdateWithoutWorkSessionInput, UserUncheckedUpdateWithoutWorkSessionInput>
    create: XOR<UserCreateWithoutWorkSessionInput, UserUncheckedCreateWithoutWorkSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkSessionInput, UserUncheckedUpdateWithoutWorkSessionInput>
  }

  export type UserUpdateWithoutWorkSessionInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUncheckedUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUncheckedUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUncheckedUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUncheckedUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkSessionIdexCabinetUpsertWithWhereUniqueWithoutWorkSessionInput = {
    where: WorkSessionIdexCabinetWhereUniqueInput
    update: XOR<WorkSessionIdexCabinetUpdateWithoutWorkSessionInput, WorkSessionIdexCabinetUncheckedUpdateWithoutWorkSessionInput>
    create: XOR<WorkSessionIdexCabinetCreateWithoutWorkSessionInput, WorkSessionIdexCabinetUncheckedCreateWithoutWorkSessionInput>
  }

  export type WorkSessionIdexCabinetUpdateWithWhereUniqueWithoutWorkSessionInput = {
    where: WorkSessionIdexCabinetWhereUniqueInput
    data: XOR<WorkSessionIdexCabinetUpdateWithoutWorkSessionInput, WorkSessionIdexCabinetUncheckedUpdateWithoutWorkSessionInput>
  }

  export type WorkSessionIdexCabinetUpdateManyWithWhereWithoutWorkSessionInput = {
    where: WorkSessionIdexCabinetScalarWhereInput
    data: XOR<WorkSessionIdexCabinetUpdateManyMutationInput, WorkSessionIdexCabinetUncheckedUpdateManyWithoutWorkSessionInput>
  }

  export type IdexCabinetCreateWithoutWorkSessionIdexCabinetInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    idexId: number
    login: string
    password: string
    IdexSyncOrder?: IdexSyncOrderCreateNestedManyWithoutIdexCabinetInput
    IdexTransaction?: IdexTransactionCreateNestedManyWithoutIdexCabinetInput
  }

  export type IdexCabinetUncheckedCreateWithoutWorkSessionIdexCabinetInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    idexId: number
    login: string
    password: string
    IdexSyncOrder?: IdexSyncOrderUncheckedCreateNestedManyWithoutIdexCabinetInput
    IdexTransaction?: IdexTransactionUncheckedCreateNestedManyWithoutIdexCabinetInput
  }

  export type IdexCabinetCreateOrConnectWithoutWorkSessionIdexCabinetInput = {
    where: IdexCabinetWhereUniqueInput
    create: XOR<IdexCabinetCreateWithoutWorkSessionIdexCabinetInput, IdexCabinetUncheckedCreateWithoutWorkSessionIdexCabinetInput>
  }

  export type WorkSessionCreateWithoutWorkSessionIdexCabinetInput = {
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    autoCompleted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    User: UserCreateNestedOneWithoutWorkSessionInput
  }

  export type WorkSessionUncheckedCreateWithoutWorkSessionIdexCabinetInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    autoCompleted?: boolean
    userId: number
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
  }

  export type WorkSessionCreateOrConnectWithoutWorkSessionIdexCabinetInput = {
    where: WorkSessionWhereUniqueInput
    create: XOR<WorkSessionCreateWithoutWorkSessionIdexCabinetInput, WorkSessionUncheckedCreateWithoutWorkSessionIdexCabinetInput>
  }

  export type IdexCabinetUpsertWithoutWorkSessionIdexCabinetInput = {
    update: XOR<IdexCabinetUpdateWithoutWorkSessionIdexCabinetInput, IdexCabinetUncheckedUpdateWithoutWorkSessionIdexCabinetInput>
    create: XOR<IdexCabinetCreateWithoutWorkSessionIdexCabinetInput, IdexCabinetUncheckedCreateWithoutWorkSessionIdexCabinetInput>
    where?: IdexCabinetWhereInput
  }

  export type IdexCabinetUpdateToOneWithWhereWithoutWorkSessionIdexCabinetInput = {
    where?: IdexCabinetWhereInput
    data: XOR<IdexCabinetUpdateWithoutWorkSessionIdexCabinetInput, IdexCabinetUncheckedUpdateWithoutWorkSessionIdexCabinetInput>
  }

  export type IdexCabinetUpdateWithoutWorkSessionIdexCabinetInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idexId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    IdexSyncOrder?: IdexSyncOrderUpdateManyWithoutIdexCabinetNestedInput
    IdexTransaction?: IdexTransactionUpdateManyWithoutIdexCabinetNestedInput
  }

  export type IdexCabinetUncheckedUpdateWithoutWorkSessionIdexCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idexId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    IdexSyncOrder?: IdexSyncOrderUncheckedUpdateManyWithoutIdexCabinetNestedInput
    IdexTransaction?: IdexTransactionUncheckedUpdateManyWithoutIdexCabinetNestedInput
  }

  export type WorkSessionUpsertWithoutWorkSessionIdexCabinetInput = {
    update: XOR<WorkSessionUpdateWithoutWorkSessionIdexCabinetInput, WorkSessionUncheckedUpdateWithoutWorkSessionIdexCabinetInput>
    create: XOR<WorkSessionCreateWithoutWorkSessionIdexCabinetInput, WorkSessionUncheckedCreateWithoutWorkSessionIdexCabinetInput>
    where?: WorkSessionWhereInput
  }

  export type WorkSessionUpdateToOneWithWhereWithoutWorkSessionIdexCabinetInput = {
    where?: WorkSessionWhereInput
    data: XOR<WorkSessionUpdateWithoutWorkSessionIdexCabinetInput, WorkSessionUncheckedUpdateWithoutWorkSessionIdexCabinetInput>
  }

  export type WorkSessionUpdateWithoutWorkSessionIdexCabinetInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    autoCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutWorkSessionNestedInput
  }

  export type WorkSessionUncheckedUpdateWithoutWorkSessionIdexCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    autoCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BybitTransactionFromCabinetCreateWithoutBybitCabinetInput = {
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionFromCabinetCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutBybitTransactionFromCabinetInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutBybitTransactionFromCabinetInput
  }

  export type BybitTransactionFromCabinetUncheckedCreateWithoutBybitCabinetInput = {
    id?: number
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionFromCabinetCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutBybitTransactionFromCabinetInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutBybitTransactionFromCabinetInput
  }

  export type BybitTransactionFromCabinetCreateOrConnectWithoutBybitCabinetInput = {
    where: BybitTransactionFromCabinetWhereUniqueInput
    create: XOR<BybitTransactionFromCabinetCreateWithoutBybitCabinetInput, BybitTransactionFromCabinetUncheckedCreateWithoutBybitCabinetInput>
  }

  export type BybitTransactionFromCabinetCreateManyBybitCabinetInputEnvelope = {
    data: BybitTransactionFromCabinetCreateManyBybitCabinetInput | BybitTransactionFromCabinetCreateManyBybitCabinetInput[]
    skipDuplicates?: boolean
  }

  export type BybitOrderInfoCreateWithoutCabinetInput = {
    phoneNumbers?: BybitOrderInfoCreatephoneNumbersInput | string[]
    createdAt?: Date | string
    updatedAt: Date | string
    orderNo: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status: string
    type: string
    amount: number
    totalPrice: number
    processed?: boolean
    unitPrice: number
  }

  export type BybitOrderInfoUncheckedCreateWithoutCabinetInput = {
    id?: number
    phoneNumbers?: BybitOrderInfoCreatephoneNumbersInput | string[]
    createdAt?: Date | string
    updatedAt: Date | string
    orderNo: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status: string
    type: string
    amount: number
    totalPrice: number
    processed?: boolean
    unitPrice: number
  }

  export type BybitOrderInfoCreateOrConnectWithoutCabinetInput = {
    where: BybitOrderInfoWhereUniqueInput
    create: XOR<BybitOrderInfoCreateWithoutCabinetInput, BybitOrderInfoUncheckedCreateWithoutCabinetInput>
  }

  export type BybitOrderInfoCreateManyCabinetInputEnvelope = {
    data: BybitOrderInfoCreateManyCabinetInput | BybitOrderInfoCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type BybitTransactionFromCabinetUpsertWithWhereUniqueWithoutBybitCabinetInput = {
    where: BybitTransactionFromCabinetWhereUniqueInput
    update: XOR<BybitTransactionFromCabinetUpdateWithoutBybitCabinetInput, BybitTransactionFromCabinetUncheckedUpdateWithoutBybitCabinetInput>
    create: XOR<BybitTransactionFromCabinetCreateWithoutBybitCabinetInput, BybitTransactionFromCabinetUncheckedCreateWithoutBybitCabinetInput>
  }

  export type BybitTransactionFromCabinetUpdateWithWhereUniqueWithoutBybitCabinetInput = {
    where: BybitTransactionFromCabinetWhereUniqueInput
    data: XOR<BybitTransactionFromCabinetUpdateWithoutBybitCabinetInput, BybitTransactionFromCabinetUncheckedUpdateWithoutBybitCabinetInput>
  }

  export type BybitTransactionFromCabinetUpdateManyWithWhereWithoutBybitCabinetInput = {
    where: BybitTransactionFromCabinetScalarWhereInput
    data: XOR<BybitTransactionFromCabinetUpdateManyMutationInput, BybitTransactionFromCabinetUncheckedUpdateManyWithoutBybitCabinetInput>
  }

  export type BybitTransactionFromCabinetScalarWhereInput = {
    AND?: BybitTransactionFromCabinetScalarWhereInput | BybitTransactionFromCabinetScalarWhereInput[]
    OR?: BybitTransactionFromCabinetScalarWhereInput[]
    NOT?: BybitTransactionFromCabinetScalarWhereInput | BybitTransactionFromCabinetScalarWhereInput[]
    id?: IntFilter<"BybitTransactionFromCabinet"> | number
    orderNo?: StringFilter<"BybitTransactionFromCabinet"> | string
    counterparty?: StringNullableFilter<"BybitTransactionFromCabinet"> | string | null
    status?: StringFilter<"BybitTransactionFromCabinet"> | string
    createdAt?: DateTimeFilter<"BybitTransactionFromCabinet"> | Date | string
    updatedAt?: DateTimeFilter<"BybitTransactionFromCabinet"> | Date | string
    amount?: FloatFilter<"BybitTransactionFromCabinet"> | number
    asset?: StringFilter<"BybitTransactionFromCabinet"> | string
    dateTime?: DateTimeFilter<"BybitTransactionFromCabinet"> | Date | string
    originalData?: JsonNullableFilter<"BybitTransactionFromCabinet">
    totalPrice?: FloatFilter<"BybitTransactionFromCabinet"> | number
    type?: StringFilter<"BybitTransactionFromCabinet"> | string
    unitPrice?: FloatFilter<"BybitTransactionFromCabinet"> | number
    processed?: BoolFilter<"BybitTransactionFromCabinet"> | boolean
    extractedPhones?: StringNullableListFilter<"BybitTransactionFromCabinet">
    lastAttemptError?: StringNullableFilter<"BybitTransactionFromCabinet"> | string | null
    cabinetId?: IntFilter<"BybitTransactionFromCabinet"> | number
  }

  export type BybitOrderInfoUpsertWithWhereUniqueWithoutCabinetInput = {
    where: BybitOrderInfoWhereUniqueInput
    update: XOR<BybitOrderInfoUpdateWithoutCabinetInput, BybitOrderInfoUncheckedUpdateWithoutCabinetInput>
    create: XOR<BybitOrderInfoCreateWithoutCabinetInput, BybitOrderInfoUncheckedCreateWithoutCabinetInput>
  }

  export type BybitOrderInfoUpdateWithWhereUniqueWithoutCabinetInput = {
    where: BybitOrderInfoWhereUniqueInput
    data: XOR<BybitOrderInfoUpdateWithoutCabinetInput, BybitOrderInfoUncheckedUpdateWithoutCabinetInput>
  }

  export type BybitOrderInfoUpdateManyWithWhereWithoutCabinetInput = {
    where: BybitOrderInfoScalarWhereInput
    data: XOR<BybitOrderInfoUpdateManyMutationInput, BybitOrderInfoUncheckedUpdateManyWithoutCabinetInput>
  }

  export type BybitOrderInfoScalarWhereInput = {
    AND?: BybitOrderInfoScalarWhereInput | BybitOrderInfoScalarWhereInput[]
    OR?: BybitOrderInfoScalarWhereInput[]
    NOT?: BybitOrderInfoScalarWhereInput | BybitOrderInfoScalarWhereInput[]
    id?: IntFilter<"BybitOrderInfo"> | number
    phoneNumbers?: StringNullableListFilter<"BybitOrderInfo">
    createdAt?: DateTimeFilter<"BybitOrderInfo"> | Date | string
    updatedAt?: DateTimeFilter<"BybitOrderInfo"> | Date | string
    orderNo?: StringFilter<"BybitOrderInfo"> | string
    dateTime?: DateTimeFilter<"BybitOrderInfo"> | Date | string
    originalData?: JsonNullableFilter<"BybitOrderInfo">
    status?: StringFilter<"BybitOrderInfo"> | string
    type?: StringFilter<"BybitOrderInfo"> | string
    amount?: IntFilter<"BybitOrderInfo"> | number
    totalPrice?: FloatFilter<"BybitOrderInfo"> | number
    processed?: BoolFilter<"BybitOrderInfo"> | boolean
    unitPrice?: FloatFilter<"BybitOrderInfo"> | number
    bybitCabinetId?: IntFilter<"BybitOrderInfo"> | number
  }

  export type BybitTransactionFromCabinetCreateWithoutBybitClipMatchInput = {
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionFromCabinetCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    BybitCabinet: BybitCabinetCreateNestedOneWithoutBybitTransactionFromCabinetInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutBybitTransactionFromCabinetInput
  }

  export type BybitTransactionFromCabinetUncheckedCreateWithoutBybitClipMatchInput = {
    id?: number
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionFromCabinetCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    cabinetId: number
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutBybitTransactionFromCabinetInput
  }

  export type BybitTransactionFromCabinetCreateOrConnectWithoutBybitClipMatchInput = {
    where: BybitTransactionFromCabinetWhereUniqueInput
    create: XOR<BybitTransactionFromCabinetCreateWithoutBybitClipMatchInput, BybitTransactionFromCabinetUncheckedCreateWithoutBybitClipMatchInput>
  }

  export type IdexTransactionCreateWithoutBybitClipMatchInput = {
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    BybitMatch?: BybitMatchCreateNestedManyWithoutIdexTransactionInput
    IdexCabinet: IdexCabinetCreateNestedOneWithoutIdexTransactionInput
    Match?: MatchCreateNestedManyWithoutIdexTransactionInput
  }

  export type IdexTransactionUncheckedCreateWithoutBybitClipMatchInput = {
    id?: number
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    cabinetId: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitMatch?: BybitMatchUncheckedCreateNestedManyWithoutIdexTransactionInput
    Match?: MatchUncheckedCreateNestedManyWithoutIdexTransactionInput
  }

  export type IdexTransactionCreateOrConnectWithoutBybitClipMatchInput = {
    where: IdexTransactionWhereUniqueInput
    create: XOR<IdexTransactionCreateWithoutBybitClipMatchInput, IdexTransactionUncheckedCreateWithoutBybitClipMatchInput>
  }

  export type MatchBybitReportCreateWithoutBybitClipMatchInput = {
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedOneWithoutMatchBybitReportInput
  }

  export type MatchBybitReportUncheckedCreateWithoutBybitClipMatchInput = {
    id?: number
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    userId?: number
  }

  export type MatchBybitReportCreateOrConnectWithoutBybitClipMatchInput = {
    where: MatchBybitReportWhereUniqueInput
    create: XOR<MatchBybitReportCreateWithoutBybitClipMatchInput, MatchBybitReportUncheckedCreateWithoutBybitClipMatchInput>
  }

  export type UserCreateWithoutBybitClipMatchInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBybitClipMatchInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionUncheckedCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportUncheckedCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportUncheckedCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationUncheckedCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetUncheckedCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBybitClipMatchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBybitClipMatchInput, UserUncheckedCreateWithoutBybitClipMatchInput>
  }

  export type BybitTransactionFromCabinetUpsertWithoutBybitClipMatchInput = {
    update: XOR<BybitTransactionFromCabinetUpdateWithoutBybitClipMatchInput, BybitTransactionFromCabinetUncheckedUpdateWithoutBybitClipMatchInput>
    create: XOR<BybitTransactionFromCabinetCreateWithoutBybitClipMatchInput, BybitTransactionFromCabinetUncheckedCreateWithoutBybitClipMatchInput>
    where?: BybitTransactionFromCabinetWhereInput
  }

  export type BybitTransactionFromCabinetUpdateToOneWithWhereWithoutBybitClipMatchInput = {
    where?: BybitTransactionFromCabinetWhereInput
    data: XOR<BybitTransactionFromCabinetUpdateWithoutBybitClipMatchInput, BybitTransactionFromCabinetUncheckedUpdateWithoutBybitClipMatchInput>
  }

  export type BybitTransactionFromCabinetUpdateWithoutBybitClipMatchInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionFromCabinetUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    BybitCabinet?: BybitCabinetUpdateOneRequiredWithoutBybitTransactionFromCabinetNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutBybitTransactionFromCabinetNestedInput
  }

  export type BybitTransactionFromCabinetUncheckedUpdateWithoutBybitClipMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionFromCabinetUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    cabinetId?: IntFieldUpdateOperationsInput | number
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetNestedInput
  }

  export type IdexTransactionUpsertWithoutBybitClipMatchInput = {
    update: XOR<IdexTransactionUpdateWithoutBybitClipMatchInput, IdexTransactionUncheckedUpdateWithoutBybitClipMatchInput>
    create: XOR<IdexTransactionCreateWithoutBybitClipMatchInput, IdexTransactionUncheckedCreateWithoutBybitClipMatchInput>
    where?: IdexTransactionWhereInput
  }

  export type IdexTransactionUpdateToOneWithWhereWithoutBybitClipMatchInput = {
    where?: IdexTransactionWhereInput
    data: XOR<IdexTransactionUpdateWithoutBybitClipMatchInput, IdexTransactionUncheckedUpdateWithoutBybitClipMatchInput>
  }

  export type IdexTransactionUpdateWithoutBybitClipMatchInput = {
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitMatch?: BybitMatchUpdateManyWithoutIdexTransactionNestedInput
    IdexCabinet?: IdexCabinetUpdateOneRequiredWithoutIdexTransactionNestedInput
    Match?: MatchUpdateManyWithoutIdexTransactionNestedInput
  }

  export type IdexTransactionUncheckedUpdateWithoutBybitClipMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    cabinetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitMatch?: BybitMatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
    Match?: MatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
  }

  export type MatchBybitReportUpsertWithoutBybitClipMatchInput = {
    update: XOR<MatchBybitReportUpdateWithoutBybitClipMatchInput, MatchBybitReportUncheckedUpdateWithoutBybitClipMatchInput>
    create: XOR<MatchBybitReportCreateWithoutBybitClipMatchInput, MatchBybitReportUncheckedCreateWithoutBybitClipMatchInput>
    where?: MatchBybitReportWhereInput
  }

  export type MatchBybitReportUpdateToOneWithWhereWithoutBybitClipMatchInput = {
    where?: MatchBybitReportWhereInput
    data: XOR<MatchBybitReportUpdateWithoutBybitClipMatchInput, MatchBybitReportUncheckedUpdateWithoutBybitClipMatchInput>
  }

  export type MatchBybitReportUpdateWithoutBybitClipMatchInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutMatchBybitReportNestedInput
  }

  export type MatchBybitReportUncheckedUpdateWithoutBybitClipMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutBybitClipMatchInput = {
    update: XOR<UserUpdateWithoutBybitClipMatchInput, UserUncheckedUpdateWithoutBybitClipMatchInput>
    create: XOR<UserCreateWithoutBybitClipMatchInput, UserUncheckedCreateWithoutBybitClipMatchInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBybitClipMatchInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBybitClipMatchInput, UserUncheckedUpdateWithoutBybitClipMatchInput>
  }

  export type UserUpdateWithoutBybitClipMatchInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBybitClipMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUncheckedUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUncheckedUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUncheckedUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUncheckedUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BybitClipMatchCreateWithoutBybitTransactionFromCabinetInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    IdexTransaction: IdexTransactionCreateNestedOneWithoutBybitClipMatchInput
    MatchBybitReport?: MatchBybitReportCreateNestedOneWithoutBybitClipMatchInput
    User: UserCreateNestedOneWithoutBybitClipMatchInput
  }

  export type BybitClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput = {
    id?: number
    idexTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchBybitReportId?: number | null
    userId: number
  }

  export type BybitClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput = {
    where: BybitClipMatchWhereUniqueInput
    create: XOR<BybitClipMatchCreateWithoutBybitTransactionFromCabinetInput, BybitClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput>
  }

  export type BybitClipMatchCreateManyBybitTransactionFromCabinetInputEnvelope = {
    data: BybitClipMatchCreateManyBybitTransactionFromCabinetInput | BybitClipMatchCreateManyBybitTransactionFromCabinetInput[]
    skipDuplicates?: boolean
  }

  export type BybitCabinetCreateWithoutBybitTransactionFromCabinetInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    bybitEmail: string
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    BybitOrderInfo?: BybitOrderInfoCreateNestedManyWithoutCabinetInput
  }

  export type BybitCabinetUncheckedCreateWithoutBybitTransactionFromCabinetInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    bybitEmail: string
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    BybitOrderInfo?: BybitOrderInfoUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type BybitCabinetCreateOrConnectWithoutBybitTransactionFromCabinetInput = {
    where: BybitCabinetWhereUniqueInput
    create: XOR<BybitCabinetCreateWithoutBybitTransactionFromCabinetInput, BybitCabinetUncheckedCreateWithoutBybitTransactionFromCabinetInput>
  }

  export type ViresClipMatchCreateWithoutBybitTransactionFromCabinetInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    MatchViresReport?: MatchViresReportCreateNestedOneWithoutViresClipMatchInput
    User: UserCreateNestedOneWithoutViresClipMatchInput
    ViresTransactionPayin: ViresTransactionPayinCreateNestedOneWithoutViresClipMatchInput
  }

  export type ViresClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput = {
    id?: number
    viresTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchViresReportId?: number | null
    userId: number
  }

  export type ViresClipMatchCreateOrConnectWithoutBybitTransactionFromCabinetInput = {
    where: ViresClipMatchWhereUniqueInput
    create: XOR<ViresClipMatchCreateWithoutBybitTransactionFromCabinetInput, ViresClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput>
  }

  export type ViresClipMatchCreateManyBybitTransactionFromCabinetInputEnvelope = {
    data: ViresClipMatchCreateManyBybitTransactionFromCabinetInput | ViresClipMatchCreateManyBybitTransactionFromCabinetInput[]
    skipDuplicates?: boolean
  }

  export type BybitClipMatchUpsertWithWhereUniqueWithoutBybitTransactionFromCabinetInput = {
    where: BybitClipMatchWhereUniqueInput
    update: XOR<BybitClipMatchUpdateWithoutBybitTransactionFromCabinetInput, BybitClipMatchUncheckedUpdateWithoutBybitTransactionFromCabinetInput>
    create: XOR<BybitClipMatchCreateWithoutBybitTransactionFromCabinetInput, BybitClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput>
  }

  export type BybitClipMatchUpdateWithWhereUniqueWithoutBybitTransactionFromCabinetInput = {
    where: BybitClipMatchWhereUniqueInput
    data: XOR<BybitClipMatchUpdateWithoutBybitTransactionFromCabinetInput, BybitClipMatchUncheckedUpdateWithoutBybitTransactionFromCabinetInput>
  }

  export type BybitClipMatchUpdateManyWithWhereWithoutBybitTransactionFromCabinetInput = {
    where: BybitClipMatchScalarWhereInput
    data: XOR<BybitClipMatchUpdateManyMutationInput, BybitClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetInput>
  }

  export type BybitCabinetUpsertWithoutBybitTransactionFromCabinetInput = {
    update: XOR<BybitCabinetUpdateWithoutBybitTransactionFromCabinetInput, BybitCabinetUncheckedUpdateWithoutBybitTransactionFromCabinetInput>
    create: XOR<BybitCabinetCreateWithoutBybitTransactionFromCabinetInput, BybitCabinetUncheckedCreateWithoutBybitTransactionFromCabinetInput>
    where?: BybitCabinetWhereInput
  }

  export type BybitCabinetUpdateToOneWithWhereWithoutBybitTransactionFromCabinetInput = {
    where?: BybitCabinetWhereInput
    data: XOR<BybitCabinetUpdateWithoutBybitTransactionFromCabinetInput, BybitCabinetUncheckedUpdateWithoutBybitTransactionFromCabinetInput>
  }

  export type BybitCabinetUpdateWithoutBybitTransactionFromCabinetInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bybitEmail?: StringFieldUpdateOperationsInput | string
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    BybitOrderInfo?: BybitOrderInfoUpdateManyWithoutCabinetNestedInput
  }

  export type BybitCabinetUncheckedUpdateWithoutBybitTransactionFromCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bybitEmail?: StringFieldUpdateOperationsInput | string
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    BybitOrderInfo?: BybitOrderInfoUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type ViresClipMatchUpsertWithWhereUniqueWithoutBybitTransactionFromCabinetInput = {
    where: ViresClipMatchWhereUniqueInput
    update: XOR<ViresClipMatchUpdateWithoutBybitTransactionFromCabinetInput, ViresClipMatchUncheckedUpdateWithoutBybitTransactionFromCabinetInput>
    create: XOR<ViresClipMatchCreateWithoutBybitTransactionFromCabinetInput, ViresClipMatchUncheckedCreateWithoutBybitTransactionFromCabinetInput>
  }

  export type ViresClipMatchUpdateWithWhereUniqueWithoutBybitTransactionFromCabinetInput = {
    where: ViresClipMatchWhereUniqueInput
    data: XOR<ViresClipMatchUpdateWithoutBybitTransactionFromCabinetInput, ViresClipMatchUncheckedUpdateWithoutBybitTransactionFromCabinetInput>
  }

  export type ViresClipMatchUpdateManyWithWhereWithoutBybitTransactionFromCabinetInput = {
    where: ViresClipMatchScalarWhereInput
    data: XOR<ViresClipMatchUpdateManyMutationInput, ViresClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetInput>
  }

  export type BybitClipMatchCreateWithoutMatchBybitReportInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitTransactionFromCabinet: BybitTransactionFromCabinetCreateNestedOneWithoutBybitClipMatchInput
    IdexTransaction: IdexTransactionCreateNestedOneWithoutBybitClipMatchInput
    User: UserCreateNestedOneWithoutBybitClipMatchInput
  }

  export type BybitClipMatchUncheckedCreateWithoutMatchBybitReportInput = {
    id?: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    userId: number
  }

  export type BybitClipMatchCreateOrConnectWithoutMatchBybitReportInput = {
    where: BybitClipMatchWhereUniqueInput
    create: XOR<BybitClipMatchCreateWithoutMatchBybitReportInput, BybitClipMatchUncheckedCreateWithoutMatchBybitReportInput>
  }

  export type BybitClipMatchCreateManyMatchBybitReportInputEnvelope = {
    data: BybitClipMatchCreateManyMatchBybitReportInput | BybitClipMatchCreateManyMatchBybitReportInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutMatchBybitReportInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchBybitReportInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionUncheckedCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportUncheckedCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationUncheckedCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetUncheckedCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchBybitReportInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchBybitReportInput, UserUncheckedCreateWithoutMatchBybitReportInput>
  }

  export type BybitClipMatchUpsertWithWhereUniqueWithoutMatchBybitReportInput = {
    where: BybitClipMatchWhereUniqueInput
    update: XOR<BybitClipMatchUpdateWithoutMatchBybitReportInput, BybitClipMatchUncheckedUpdateWithoutMatchBybitReportInput>
    create: XOR<BybitClipMatchCreateWithoutMatchBybitReportInput, BybitClipMatchUncheckedCreateWithoutMatchBybitReportInput>
  }

  export type BybitClipMatchUpdateWithWhereUniqueWithoutMatchBybitReportInput = {
    where: BybitClipMatchWhereUniqueInput
    data: XOR<BybitClipMatchUpdateWithoutMatchBybitReportInput, BybitClipMatchUncheckedUpdateWithoutMatchBybitReportInput>
  }

  export type BybitClipMatchUpdateManyWithWhereWithoutMatchBybitReportInput = {
    where: BybitClipMatchScalarWhereInput
    data: XOR<BybitClipMatchUpdateManyMutationInput, BybitClipMatchUncheckedUpdateManyWithoutMatchBybitReportInput>
  }

  export type UserUpsertWithoutMatchBybitReportInput = {
    update: XOR<UserUpdateWithoutMatchBybitReportInput, UserUncheckedUpdateWithoutMatchBybitReportInput>
    create: XOR<UserCreateWithoutMatchBybitReportInput, UserUncheckedCreateWithoutMatchBybitReportInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchBybitReportInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchBybitReportInput, UserUncheckedUpdateWithoutMatchBybitReportInput>
  }

  export type UserUpdateWithoutMatchBybitReportInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchBybitReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUncheckedUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUncheckedUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUncheckedUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUncheckedUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMatchViresReportInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchViresReportInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionUncheckedCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportUncheckedCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationUncheckedCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetUncheckedCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchViresReportInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchViresReportInput, UserUncheckedCreateWithoutMatchViresReportInput>
  }

  export type ViresClipMatchCreateWithoutMatchViresReportInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitTransactionFromCabinet: BybitTransactionFromCabinetCreateNestedOneWithoutViresClipMatchInput
    User: UserCreateNestedOneWithoutViresClipMatchInput
    ViresTransactionPayin: ViresTransactionPayinCreateNestedOneWithoutViresClipMatchInput
  }

  export type ViresClipMatchUncheckedCreateWithoutMatchViresReportInput = {
    id?: number
    viresTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    userId: number
    bybitTransactionId: number
  }

  export type ViresClipMatchCreateOrConnectWithoutMatchViresReportInput = {
    where: ViresClipMatchWhereUniqueInput
    create: XOR<ViresClipMatchCreateWithoutMatchViresReportInput, ViresClipMatchUncheckedCreateWithoutMatchViresReportInput>
  }

  export type ViresClipMatchCreateManyMatchViresReportInputEnvelope = {
    data: ViresClipMatchCreateManyMatchViresReportInput | ViresClipMatchCreateManyMatchViresReportInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMatchViresReportInput = {
    update: XOR<UserUpdateWithoutMatchViresReportInput, UserUncheckedUpdateWithoutMatchViresReportInput>
    create: XOR<UserCreateWithoutMatchViresReportInput, UserUncheckedCreateWithoutMatchViresReportInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchViresReportInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchViresReportInput, UserUncheckedUpdateWithoutMatchViresReportInput>
  }

  export type UserUpdateWithoutMatchViresReportInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchViresReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUncheckedUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUncheckedUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUncheckedUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ViresClipMatchUpsertWithWhereUniqueWithoutMatchViresReportInput = {
    where: ViresClipMatchWhereUniqueInput
    update: XOR<ViresClipMatchUpdateWithoutMatchViresReportInput, ViresClipMatchUncheckedUpdateWithoutMatchViresReportInput>
    create: XOR<ViresClipMatchCreateWithoutMatchViresReportInput, ViresClipMatchUncheckedCreateWithoutMatchViresReportInput>
  }

  export type ViresClipMatchUpdateWithWhereUniqueWithoutMatchViresReportInput = {
    where: ViresClipMatchWhereUniqueInput
    data: XOR<ViresClipMatchUpdateWithoutMatchViresReportInput, ViresClipMatchUncheckedUpdateWithoutMatchViresReportInput>
  }

  export type ViresClipMatchUpdateManyWithWhereWithoutMatchViresReportInput = {
    where: ViresClipMatchScalarWhereInput
    data: XOR<ViresClipMatchUpdateManyMutationInput, ViresClipMatchUncheckedUpdateManyWithoutMatchViresReportInput>
  }

  export type UserCreateWithoutViresCabinetInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutViresCabinetInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionUncheckedCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportUncheckedCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportUncheckedCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationUncheckedCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutViresCabinetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutViresCabinetInput, UserUncheckedCreateWithoutViresCabinetInput>
  }

  export type ViresTransactionPayinCreateWithoutViresCabinetInput = {
    createdAt: Date | string
    sum_rub: number
    sum_usdt: number
    card: string
    fio: string
    bank: string
    uuid: string
    ViresClipMatch?: ViresClipMatchCreateNestedManyWithoutViresTransactionPayinInput
  }

  export type ViresTransactionPayinUncheckedCreateWithoutViresCabinetInput = {
    id?: number
    createdAt: Date | string
    sum_rub: number
    sum_usdt: number
    card: string
    fio: string
    bank: string
    uuid: string
    ViresClipMatch?: ViresClipMatchUncheckedCreateNestedManyWithoutViresTransactionPayinInput
  }

  export type ViresTransactionPayinCreateOrConnectWithoutViresCabinetInput = {
    where: ViresTransactionPayinWhereUniqueInput
    create: XOR<ViresTransactionPayinCreateWithoutViresCabinetInput, ViresTransactionPayinUncheckedCreateWithoutViresCabinetInput>
  }

  export type ViresTransactionPayinCreateManyViresCabinetInputEnvelope = {
    data: ViresTransactionPayinCreateManyViresCabinetInput | ViresTransactionPayinCreateManyViresCabinetInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutViresCabinetInput = {
    update: XOR<UserUpdateWithoutViresCabinetInput, UserUncheckedUpdateWithoutViresCabinetInput>
    create: XOR<UserCreateWithoutViresCabinetInput, UserUncheckedCreateWithoutViresCabinetInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutViresCabinetInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutViresCabinetInput, UserUncheckedUpdateWithoutViresCabinetInput>
  }

  export type UserUpdateWithoutViresCabinetInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutViresCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUncheckedUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUncheckedUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUncheckedUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ViresTransactionPayinUpsertWithWhereUniqueWithoutViresCabinetInput = {
    where: ViresTransactionPayinWhereUniqueInput
    update: XOR<ViresTransactionPayinUpdateWithoutViresCabinetInput, ViresTransactionPayinUncheckedUpdateWithoutViresCabinetInput>
    create: XOR<ViresTransactionPayinCreateWithoutViresCabinetInput, ViresTransactionPayinUncheckedCreateWithoutViresCabinetInput>
  }

  export type ViresTransactionPayinUpdateWithWhereUniqueWithoutViresCabinetInput = {
    where: ViresTransactionPayinWhereUniqueInput
    data: XOR<ViresTransactionPayinUpdateWithoutViresCabinetInput, ViresTransactionPayinUncheckedUpdateWithoutViresCabinetInput>
  }

  export type ViresTransactionPayinUpdateManyWithWhereWithoutViresCabinetInput = {
    where: ViresTransactionPayinScalarWhereInput
    data: XOR<ViresTransactionPayinUpdateManyMutationInput, ViresTransactionPayinUncheckedUpdateManyWithoutViresCabinetInput>
  }

  export type ViresTransactionPayinScalarWhereInput = {
    AND?: ViresTransactionPayinScalarWhereInput | ViresTransactionPayinScalarWhereInput[]
    OR?: ViresTransactionPayinScalarWhereInput[]
    NOT?: ViresTransactionPayinScalarWhereInput | ViresTransactionPayinScalarWhereInput[]
    id?: IntFilter<"ViresTransactionPayin"> | number
    cabinetId?: IntFilter<"ViresTransactionPayin"> | number
    createdAt?: DateTimeFilter<"ViresTransactionPayin"> | Date | string
    sum_rub?: FloatFilter<"ViresTransactionPayin"> | number
    sum_usdt?: FloatFilter<"ViresTransactionPayin"> | number
    card?: StringFilter<"ViresTransactionPayin"> | string
    fio?: StringFilter<"ViresTransactionPayin"> | string
    bank?: StringFilter<"ViresTransactionPayin"> | string
    uuid?: StringFilter<"ViresTransactionPayin"> | string
  }

  export type BybitTransactionFromCabinetCreateWithoutViresClipMatchInput = {
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionFromCabinetCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutBybitTransactionFromCabinetInput
    BybitCabinet: BybitCabinetCreateNestedOneWithoutBybitTransactionFromCabinetInput
  }

  export type BybitTransactionFromCabinetUncheckedCreateWithoutViresClipMatchInput = {
    id?: number
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionFromCabinetCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
    cabinetId: number
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutBybitTransactionFromCabinetInput
  }

  export type BybitTransactionFromCabinetCreateOrConnectWithoutViresClipMatchInput = {
    where: BybitTransactionFromCabinetWhereUniqueInput
    create: XOR<BybitTransactionFromCabinetCreateWithoutViresClipMatchInput, BybitTransactionFromCabinetUncheckedCreateWithoutViresClipMatchInput>
  }

  export type MatchViresReportCreateWithoutViresClipMatchInput = {
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedOneWithoutMatchViresReportInput
  }

  export type MatchViresReportUncheckedCreateWithoutViresClipMatchInput = {
    id?: number
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    userId?: number
  }

  export type MatchViresReportCreateOrConnectWithoutViresClipMatchInput = {
    where: MatchViresReportWhereUniqueInput
    create: XOR<MatchViresReportCreateWithoutViresClipMatchInput, MatchViresReportUncheckedCreateWithoutViresClipMatchInput>
  }

  export type UserCreateWithoutViresClipMatchInput = {
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutViresClipMatchInput = {
    id?: number
    name: string
    passCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastNotification?: Date | string | null
    role?: $Enums.UserRole
    bybitApiSecret?: string | null
    bybitApiToken?: string | null
    lastBybitSyncAt?: Date | string | null
    lastBybitSyncStatus?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    BybitClipMatch?: BybitClipMatchUncheckedCreateNestedManyWithoutUserInput
    BybitTransaction?: BybitTransactionUncheckedCreateNestedManyWithoutUserInput
    MatchBybitReport?: MatchBybitReportUncheckedCreateNestedManyWithoutUserInput
    MatchViresReport?: MatchViresReportUncheckedCreateNestedManyWithoutUserInput
    ReportNotification?: ReportNotificationUncheckedCreateNestedManyWithoutUserInput
    TelegramAccount?: TelegramAccountUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    ViresCabinet?: ViresCabinetUncheckedCreateNestedManyWithoutUserInput
    WorkSession?: WorkSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutViresClipMatchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutViresClipMatchInput, UserUncheckedCreateWithoutViresClipMatchInput>
  }

  export type ViresTransactionPayinCreateWithoutViresClipMatchInput = {
    createdAt: Date | string
    sum_rub: number
    sum_usdt: number
    card: string
    fio: string
    bank: string
    uuid: string
    ViresCabinet: ViresCabinetCreateNestedOneWithoutViresTransactionPayinInput
  }

  export type ViresTransactionPayinUncheckedCreateWithoutViresClipMatchInput = {
    id?: number
    cabinetId: number
    createdAt: Date | string
    sum_rub: number
    sum_usdt: number
    card: string
    fio: string
    bank: string
    uuid: string
  }

  export type ViresTransactionPayinCreateOrConnectWithoutViresClipMatchInput = {
    where: ViresTransactionPayinWhereUniqueInput
    create: XOR<ViresTransactionPayinCreateWithoutViresClipMatchInput, ViresTransactionPayinUncheckedCreateWithoutViresClipMatchInput>
  }

  export type BybitTransactionFromCabinetUpsertWithoutViresClipMatchInput = {
    update: XOR<BybitTransactionFromCabinetUpdateWithoutViresClipMatchInput, BybitTransactionFromCabinetUncheckedUpdateWithoutViresClipMatchInput>
    create: XOR<BybitTransactionFromCabinetCreateWithoutViresClipMatchInput, BybitTransactionFromCabinetUncheckedCreateWithoutViresClipMatchInput>
    where?: BybitTransactionFromCabinetWhereInput
  }

  export type BybitTransactionFromCabinetUpdateToOneWithWhereWithoutViresClipMatchInput = {
    where?: BybitTransactionFromCabinetWhereInput
    data: XOR<BybitTransactionFromCabinetUpdateWithoutViresClipMatchInput, BybitTransactionFromCabinetUncheckedUpdateWithoutViresClipMatchInput>
  }

  export type BybitTransactionFromCabinetUpdateWithoutViresClipMatchInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionFromCabinetUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutBybitTransactionFromCabinetNestedInput
    BybitCabinet?: BybitCabinetUpdateOneRequiredWithoutBybitTransactionFromCabinetNestedInput
  }

  export type BybitTransactionFromCabinetUncheckedUpdateWithoutViresClipMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionFromCabinetUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    cabinetId?: IntFieldUpdateOperationsInput | number
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetNestedInput
  }

  export type MatchViresReportUpsertWithoutViresClipMatchInput = {
    update: XOR<MatchViresReportUpdateWithoutViresClipMatchInput, MatchViresReportUncheckedUpdateWithoutViresClipMatchInput>
    create: XOR<MatchViresReportCreateWithoutViresClipMatchInput, MatchViresReportUncheckedCreateWithoutViresClipMatchInput>
    where?: MatchViresReportWhereInput
  }

  export type MatchViresReportUpdateToOneWithWhereWithoutViresClipMatchInput = {
    where?: MatchViresReportWhereInput
    data: XOR<MatchViresReportUpdateWithoutViresClipMatchInput, MatchViresReportUncheckedUpdateWithoutViresClipMatchInput>
  }

  export type MatchViresReportUpdateWithoutViresClipMatchInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutMatchViresReportNestedInput
  }

  export type MatchViresReportUncheckedUpdateWithoutViresClipMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutViresClipMatchInput = {
    update: XOR<UserUpdateWithoutViresClipMatchInput, UserUncheckedUpdateWithoutViresClipMatchInput>
    create: XOR<UserCreateWithoutViresClipMatchInput, UserUncheckedCreateWithoutViresClipMatchInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutViresClipMatchInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutViresClipMatchInput, UserUncheckedUpdateWithoutViresClipMatchInput>
  }

  export type UserUpdateWithoutViresClipMatchInput = {
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutViresClipMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    passCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastNotification?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bybitApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bybitApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastBybitSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastBybitSyncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutUserNestedInput
    BybitTransaction?: BybitTransactionUncheckedUpdateManyWithoutUserNestedInput
    MatchBybitReport?: MatchBybitReportUncheckedUpdateManyWithoutUserNestedInput
    MatchViresReport?: MatchViresReportUncheckedUpdateManyWithoutUserNestedInput
    ReportNotification?: ReportNotificationUncheckedUpdateManyWithoutUserNestedInput
    TelegramAccount?: TelegramAccountUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    ViresCabinet?: ViresCabinetUncheckedUpdateManyWithoutUserNestedInput
    WorkSession?: WorkSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ViresTransactionPayinUpsertWithoutViresClipMatchInput = {
    update: XOR<ViresTransactionPayinUpdateWithoutViresClipMatchInput, ViresTransactionPayinUncheckedUpdateWithoutViresClipMatchInput>
    create: XOR<ViresTransactionPayinCreateWithoutViresClipMatchInput, ViresTransactionPayinUncheckedCreateWithoutViresClipMatchInput>
    where?: ViresTransactionPayinWhereInput
  }

  export type ViresTransactionPayinUpdateToOneWithWhereWithoutViresClipMatchInput = {
    where?: ViresTransactionPayinWhereInput
    data: XOR<ViresTransactionPayinUpdateWithoutViresClipMatchInput, ViresTransactionPayinUncheckedUpdateWithoutViresClipMatchInput>
  }

  export type ViresTransactionPayinUpdateWithoutViresClipMatchInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sum_rub?: FloatFieldUpdateOperationsInput | number
    sum_usdt?: FloatFieldUpdateOperationsInput | number
    card?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    ViresCabinet?: ViresCabinetUpdateOneRequiredWithoutViresTransactionPayinNestedInput
  }

  export type ViresTransactionPayinUncheckedUpdateWithoutViresClipMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    cabinetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sum_rub?: FloatFieldUpdateOperationsInput | number
    sum_usdt?: FloatFieldUpdateOperationsInput | number
    card?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type ViresClipMatchCreateWithoutViresTransactionPayinInput = {
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    BybitTransactionFromCabinet: BybitTransactionFromCabinetCreateNestedOneWithoutViresClipMatchInput
    MatchViresReport?: MatchViresReportCreateNestedOneWithoutViresClipMatchInput
    User: UserCreateNestedOneWithoutViresClipMatchInput
  }

  export type ViresClipMatchUncheckedCreateWithoutViresTransactionPayinInput = {
    id?: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchViresReportId?: number | null
    userId: number
    bybitTransactionId: number
  }

  export type ViresClipMatchCreateOrConnectWithoutViresTransactionPayinInput = {
    where: ViresClipMatchWhereUniqueInput
    create: XOR<ViresClipMatchCreateWithoutViresTransactionPayinInput, ViresClipMatchUncheckedCreateWithoutViresTransactionPayinInput>
  }

  export type ViresClipMatchCreateManyViresTransactionPayinInputEnvelope = {
    data: ViresClipMatchCreateManyViresTransactionPayinInput | ViresClipMatchCreateManyViresTransactionPayinInput[]
    skipDuplicates?: boolean
  }

  export type ViresCabinetCreateWithoutViresTransactionPayinInput = {
    name?: string | null
    login: string
    password: string
    type: $Enums.PasswordType
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    lastUpdate: Date | string
    User: UserCreateNestedOneWithoutViresCabinetInput
  }

  export type ViresCabinetUncheckedCreateWithoutViresTransactionPayinInput = {
    id?: number
    name?: string | null
    login: string
    password: string
    type: $Enums.PasswordType
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    userId: number
    lastUpdate: Date | string
  }

  export type ViresCabinetCreateOrConnectWithoutViresTransactionPayinInput = {
    where: ViresCabinetWhereUniqueInput
    create: XOR<ViresCabinetCreateWithoutViresTransactionPayinInput, ViresCabinetUncheckedCreateWithoutViresTransactionPayinInput>
  }

  export type ViresClipMatchUpsertWithWhereUniqueWithoutViresTransactionPayinInput = {
    where: ViresClipMatchWhereUniqueInput
    update: XOR<ViresClipMatchUpdateWithoutViresTransactionPayinInput, ViresClipMatchUncheckedUpdateWithoutViresTransactionPayinInput>
    create: XOR<ViresClipMatchCreateWithoutViresTransactionPayinInput, ViresClipMatchUncheckedCreateWithoutViresTransactionPayinInput>
  }

  export type ViresClipMatchUpdateWithWhereUniqueWithoutViresTransactionPayinInput = {
    where: ViresClipMatchWhereUniqueInput
    data: XOR<ViresClipMatchUpdateWithoutViresTransactionPayinInput, ViresClipMatchUncheckedUpdateWithoutViresTransactionPayinInput>
  }

  export type ViresClipMatchUpdateManyWithWhereWithoutViresTransactionPayinInput = {
    where: ViresClipMatchScalarWhereInput
    data: XOR<ViresClipMatchUpdateManyMutationInput, ViresClipMatchUncheckedUpdateManyWithoutViresTransactionPayinInput>
  }

  export type ViresCabinetUpsertWithoutViresTransactionPayinInput = {
    update: XOR<ViresCabinetUpdateWithoutViresTransactionPayinInput, ViresCabinetUncheckedUpdateWithoutViresTransactionPayinInput>
    create: XOR<ViresCabinetCreateWithoutViresTransactionPayinInput, ViresCabinetUncheckedCreateWithoutViresTransactionPayinInput>
    where?: ViresCabinetWhereInput
  }

  export type ViresCabinetUpdateToOneWithWhereWithoutViresTransactionPayinInput = {
    where?: ViresCabinetWhereInput
    data: XOR<ViresCabinetUpdateWithoutViresTransactionPayinInput, ViresCabinetUncheckedUpdateWithoutViresTransactionPayinInput>
  }

  export type ViresCabinetUpdateWithoutViresTransactionPayinInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutViresCabinetNestedInput
  }

  export type ViresCabinetUncheckedUpdateWithoutViresTransactionPayinInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BybitMatchCreateManyBybitTransactionInput = {
    id?: number
    idexTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BybitMatchUpdateWithoutBybitTransactionInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    IdexTransaction?: IdexTransactionUpdateOneRequiredWithoutBybitMatchNestedInput
  }

  export type BybitMatchUncheckedUpdateWithoutBybitTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BybitMatchUncheckedUpdateManyWithoutBybitTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyCardInput = {
    id?: number
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    userId: number
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: number | null
    cardPouringId?: number | null
  }

  export type CardBalanceCreateManyCardInput = {
    id?: number
    date: Date | string
    startBalance: number
    endBalance: number
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
  }

  export type CardPouringCreateManyCardInput = {
    id?: number
    pouringDate: Date | string
    initialAmount: number
    initialDate: Date | string
    finalAmount?: number | null
    finalDate?: Date | string | null
    pouringAmount: number
    withdrawalAmount?: number | null
    withdrawalDate?: Date | string | null
    collectorName?: string | null
    status?: $Enums.CardStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AuditLogUpdateWithoutCardInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    CardBalance?: CardBalanceUpdateOneWithoutAuditLogNestedInput
    CardPouring?: CardPouringUpdateOneWithoutAuditLogNestedInput
    User?: UserUpdateOneRequiredWithoutAuditLogNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: NullableIntFieldUpdateOperationsInput | number | null
    cardPouringId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditLogUncheckedUpdateManyWithoutCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: NullableIntFieldUpdateOperationsInput | number | null
    cardPouringId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CardBalanceUpdateWithoutCardInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUpdateManyWithoutCardBalanceNestedInput
  }

  export type CardBalanceUncheckedUpdateWithoutCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutCardBalanceNestedInput
  }

  export type CardBalanceUncheckedUpdateManyWithoutCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardPouringUpdateWithoutCardInput = {
    pouringDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: FloatFieldUpdateOperationsInput | number
    initialDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    finalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pouringAmount?: FloatFieldUpdateOperationsInput | number
    withdrawalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    withdrawalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutCardPouringNestedInput
  }

  export type CardPouringUncheckedUpdateWithoutCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    pouringDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: FloatFieldUpdateOperationsInput | number
    initialDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    finalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pouringAmount?: FloatFieldUpdateOperationsInput | number
    withdrawalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    withdrawalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutCardPouringNestedInput
  }

  export type CardPouringUncheckedUpdateManyWithoutCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    pouringDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: FloatFieldUpdateOperationsInput | number
    initialDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    finalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pouringAmount?: FloatFieldUpdateOperationsInput | number
    withdrawalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    withdrawalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCardStatusFieldUpdateOperationsInput | $Enums.CardStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyCardBalanceInput = {
    id?: number
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    userId: number
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardId?: number | null
    cardPouringId?: number | null
  }

  export type AuditLogUpdateWithoutCardBalanceInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    Card?: CardUpdateOneWithoutAuditLogNestedInput
    CardPouring?: CardPouringUpdateOneWithoutAuditLogNestedInput
    User?: UserUpdateOneRequiredWithoutAuditLogNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutCardBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardId?: NullableIntFieldUpdateOperationsInput | number | null
    cardPouringId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditLogUncheckedUpdateManyWithoutCardBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardId?: NullableIntFieldUpdateOperationsInput | number | null
    cardPouringId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditLogCreateManyCardPouringInput = {
    id?: number
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    userId: number
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: number | null
    cardId?: number | null
  }

  export type AuditLogUpdateWithoutCardPouringInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    CardBalance?: CardBalanceUpdateOneWithoutAuditLogNestedInput
    Card?: CardUpdateOneWithoutAuditLogNestedInput
    User?: UserUpdateOneRequiredWithoutAuditLogNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutCardPouringInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: NullableIntFieldUpdateOperationsInput | number | null
    cardId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditLogUncheckedUpdateManyWithoutCardPouringInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: NullableIntFieldUpdateOperationsInput | number | null
    cardId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentCreateManyCellInput = {
    id?: number
    text: string
    author?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CommentUpdateWithoutCellInput = {
    text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutCellInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutCellInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CellCreateManyColumnInput = {
    id?: number
    rowId: number
    value?: string | null
    displayValue?: string | null
    calculatedValue?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type FilterCreateManyColumnInput = {
    id?: number
    name: string
    tableId: number
    operator: $Enums.FilterOperator
    value?: string | null
    secondValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CellUpdateWithoutColumnInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Row?: RowUpdateOneRequiredWithoutCellNestedInput
    Comment?: CommentUpdateManyWithoutCellNestedInput
  }

  export type CellUncheckedUpdateWithoutColumnInput = {
    id?: IntFieldUpdateOperationsInput | number
    rowId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUncheckedUpdateManyWithoutCellNestedInput
  }

  export type CellUncheckedUpdateManyWithoutColumnInput = {
    id?: IntFieldUpdateOperationsInput | number
    rowId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilterUpdateWithoutColumnInput = {
    name?: StringFieldUpdateOperationsInput | string
    operator?: EnumFilterOperatorFieldUpdateOperationsInput | $Enums.FilterOperator
    value?: NullableStringFieldUpdateOperationsInput | string | null
    secondValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Table?: TableUpdateOneRequiredWithoutFilterNestedInput
  }

  export type FilterUncheckedUpdateWithoutColumnInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    operator?: EnumFilterOperatorFieldUpdateOperationsInput | $Enums.FilterOperator
    value?: NullableStringFieldUpdateOperationsInput | string | null
    secondValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilterUncheckedUpdateManyWithoutColumnInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    operator?: EnumFilterOperatorFieldUpdateOperationsInput | $Enums.FilterOperator
    value?: NullableStringFieldUpdateOperationsInput | string | null
    secondValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinRowExpenseCreateManyFinRowInput = {
    id?: number
    expenseType: string
    amount: number
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
  }

  export type FinRowExpenseUpdateWithoutFinRowInput = {
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type FinRowExpenseUncheckedUpdateWithoutFinRowInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type FinRowExpenseUncheckedUpdateManyWithoutFinRowInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
  }

  export type IdexSyncOrderCreateManyIdexCabinetInput = {
    id?: number
    createdAt?: Date | string
    updatedAt: Date | string
    processed?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.IdexSyncOrderStatus
    startSyncAt?: Date | string | null
    endSyncAt?: Date | string | null
    pages?: IdexSyncOrderCreatepagesInput | number[]
  }

  export type IdexTransactionCreateManyIdexCabinetInput = {
    id?: number
    externalId: bigint | number
    paymentMethodId: bigint | number
    wallet: string
    amount: JsonNullValueInput | InputJsonValue
    total: JsonNullValueInput | InputJsonValue
    status: number
    approvedAt?: string | null
    expiredAt?: string | null
    createdAtExternal: string
    updatedAtExternal: string
    extraData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type WorkSessionIdexCabinetCreateManyIdexCabinetInput = {
    workSessionId: number
    assignedAt?: Date | string
  }

  export type IdexSyncOrderUpdateWithoutIdexCabinetInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumIdexSyncOrderStatusFieldUpdateOperationsInput | $Enums.IdexSyncOrderStatus
    startSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: IdexSyncOrderUpdatepagesInput | number[]
  }

  export type IdexSyncOrderUncheckedUpdateWithoutIdexCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumIdexSyncOrderStatusFieldUpdateOperationsInput | $Enums.IdexSyncOrderStatus
    startSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: IdexSyncOrderUpdatepagesInput | number[]
  }

  export type IdexSyncOrderUncheckedUpdateManyWithoutIdexCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processed?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumIdexSyncOrderStatusFieldUpdateOperationsInput | $Enums.IdexSyncOrderStatus
    startSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: IdexSyncOrderUpdatepagesInput | number[]
  }

  export type IdexTransactionUpdateWithoutIdexCabinetInput = {
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutIdexTransactionNestedInput
    BybitMatch?: BybitMatchUpdateManyWithoutIdexTransactionNestedInput
    Match?: MatchUpdateManyWithoutIdexTransactionNestedInput
  }

  export type IdexTransactionUncheckedUpdateWithoutIdexCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
    BybitMatch?: BybitMatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
    Match?: MatchUncheckedUpdateManyWithoutIdexTransactionNestedInput
  }

  export type IdexTransactionUncheckedUpdateManyWithoutIdexCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentMethodId?: BigIntFieldUpdateOperationsInput | bigint | number
    wallet?: StringFieldUpdateOperationsInput | string
    amount?: JsonNullValueInput | InputJsonValue
    total?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableStringFieldUpdateOperationsInput | string | null
    expiredAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtExternal?: StringFieldUpdateOperationsInput | string
    updatedAtExternal?: StringFieldUpdateOperationsInput | string
    extraData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkSessionIdexCabinetUpdateWithoutIdexCabinetInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WorkSession?: WorkSessionUpdateOneRequiredWithoutWorkSessionIdexCabinetNestedInput
  }

  export type WorkSessionIdexCabinetUncheckedUpdateWithoutIdexCabinetInput = {
    workSessionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkSessionIdexCabinetUncheckedUpdateManyWithoutIdexCabinetInput = {
    workSessionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BybitClipMatchCreateManyIdexTransactionInput = {
    id?: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchBybitReportId?: number | null
    userId: number
  }

  export type BybitMatchCreateManyIdexTransactionInput = {
    id?: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MatchCreateManyIdexTransactionInput = {
    id?: number
    transactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BybitClipMatchUpdateWithoutIdexTransactionInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUpdateOneRequiredWithoutBybitClipMatchNestedInput
    MatchBybitReport?: MatchBybitReportUpdateOneWithoutBybitClipMatchNestedInput
    User?: UserUpdateOneRequiredWithoutBybitClipMatchNestedInput
  }

  export type BybitClipMatchUncheckedUpdateWithoutIdexTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchBybitReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BybitClipMatchUncheckedUpdateManyWithoutIdexTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchBybitReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BybitMatchUpdateWithoutIdexTransactionInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitTransaction?: BybitTransactionUpdateOneRequiredWithoutBybitMatchNestedInput
  }

  export type BybitMatchUncheckedUpdateWithoutIdexTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BybitMatchUncheckedUpdateManyWithoutIdexTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutIdexTransactionInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Transaction?: TransactionUpdateOneRequiredWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutIdexTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyWithoutIdexTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CellCreateManyRowInput = {
    id?: number
    columnId: number
    value?: string | null
    displayValue?: string | null
    calculatedValue?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CellUpdateWithoutRowInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUpdateOneRequiredWithoutCellNestedInput
    Comment?: CommentUpdateManyWithoutCellNestedInput
  }

  export type CellUncheckedUpdateWithoutRowInput = {
    id?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUncheckedUpdateManyWithoutCellNestedInput
  }

  export type CellUncheckedUpdateManyWithoutRowInput = {
    id?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    displayValue?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinRowCreateManySalaryInput = {
    id?: number
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    usdtAmount?: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
    section?: $Enums.SalarySection
    exchangeRate?: number | null
  }

  export type SalaryDebtCreateManySalaryInput = {
    id?: number
    amount: number
    debtDate: Date | string
    description?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SalaryEarningCreateManySalaryInput = {
    id?: number
    amount: number
    earningDate: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SalaryPaymentCreateManySalaryInput = {
    id?: number
    amount: number
    paymentDate: Date | string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    currency?: string
  }

  export type ShiftReportCreateManySalaryInput = {
    id?: number
    date: Date | string
    time: string
    shift: string
    startBalance: number
    endBalance: number
    usdtAmount?: number
    currency?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type FinRowUpdateWithoutSalaryInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    FinRowExpense?: FinRowExpenseUpdateManyWithoutFinRowNestedInput
  }

  export type FinRowUncheckedUpdateWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    FinRowExpense?: FinRowExpenseUncheckedUpdateManyWithoutFinRowNestedInput
  }

  export type FinRowUncheckedUpdateManyWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    section?: EnumSalarySectionFieldUpdateOperationsInput | $Enums.SalarySection
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SalaryDebtUpdateWithoutSalaryInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    debtDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryDebtUncheckedUpdateWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    debtDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryDebtUncheckedUpdateManyWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    debtDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryEarningUpdateWithoutSalaryInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    earningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryEarningUncheckedUpdateWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    earningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryEarningUncheckedUpdateManyWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    earningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUpdateWithoutSalaryInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type SalaryPaymentUncheckedUpdateWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type SalaryPaymentUncheckedUpdateManyWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type ShiftReportUpdateWithoutSalaryInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShiftReportExpense?: ShiftReportExpenseUpdateManyWithoutShiftReportNestedInput
  }

  export type ShiftReportUncheckedUpdateWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShiftReportExpense?: ShiftReportExpenseUncheckedUpdateManyWithoutShiftReportNestedInput
  }

  export type ShiftReportUncheckedUpdateManyWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    shift?: StringFieldUpdateOperationsInput | string
    startBalance?: FloatFieldUpdateOperationsInput | number
    endBalance?: FloatFieldUpdateOperationsInput | number
    usdtAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableCreateManySectionInput = {
    id?: number
    name: string
    description?: string | null
    isSearchable?: boolean
    hasPagination?: boolean
    pageSize?: number
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TableUpdateWithoutSectionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUpdateManyWithoutTableNestedInput
    Filter?: FilterUpdateManyWithoutTableNestedInput
    Row?: RowUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUncheckedUpdateManyWithoutTableNestedInput
    Filter?: FilterUncheckedUpdateManyWithoutTableNestedInput
    Row?: RowUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateManyWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSearchable?: BoolFieldUpdateOperationsInput | boolean
    hasPagination?: BoolFieldUpdateOperationsInput | boolean
    pageSize?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftReportExpenseCreateManyShiftReportInput = {
    id?: number
    expenseType: string
    amount: number
    currency?: string
    date: Date | string
    time: string
    period?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShiftReportExpenseUpdateWithoutShiftReportInput = {
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftReportExpenseUncheckedUpdateWithoutShiftReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftReportExpenseUncheckedUpdateManyWithoutShiftReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    period?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColumnCreateManyTableInput = {
    id?: number
    name: string
    type: $Enums.ColumnType
    width?: number | null
    isRequired?: boolean
    isFilterable?: boolean
    isSummable?: boolean
    defaultValue?: string | null
    format?: string | null
    order: number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type FilterCreateManyTableInput = {
    id?: number
    name: string
    columnId: number
    operator: $Enums.FilterOperator
    value?: string | null
    secondValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type RowCreateManyTableInput = {
    id?: number
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ColumnUpdateWithoutTableInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    width?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    isSummable?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cell?: CellUpdateManyWithoutColumnNestedInput
    Filter?: FilterUpdateManyWithoutColumnNestedInput
  }

  export type ColumnUncheckedUpdateWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    width?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    isSummable?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cell?: CellUncheckedUpdateManyWithoutColumnNestedInput
    Filter?: FilterUncheckedUpdateManyWithoutColumnNestedInput
  }

  export type ColumnUncheckedUpdateManyWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    width?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    isSummable?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilterUpdateWithoutTableInput = {
    name?: StringFieldUpdateOperationsInput | string
    operator?: EnumFilterOperatorFieldUpdateOperationsInput | $Enums.FilterOperator
    value?: NullableStringFieldUpdateOperationsInput | string | null
    secondValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Column?: ColumnUpdateOneRequiredWithoutFilterNestedInput
  }

  export type FilterUncheckedUpdateWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    columnId?: IntFieldUpdateOperationsInput | number
    operator?: EnumFilterOperatorFieldUpdateOperationsInput | $Enums.FilterOperator
    value?: NullableStringFieldUpdateOperationsInput | string | null
    secondValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilterUncheckedUpdateManyWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    columnId?: IntFieldUpdateOperationsInput | number
    operator?: EnumFilterOperatorFieldUpdateOperationsInput | $Enums.FilterOperator
    value?: NullableStringFieldUpdateOperationsInput | string | null
    secondValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RowUpdateWithoutTableInput = {
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cell?: CellUpdateManyWithoutRowNestedInput
  }

  export type RowUncheckedUpdateWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cell?: CellUncheckedUpdateManyWithoutRowNestedInput
  }

  export type RowUncheckedUpdateManyWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateManyTransactionInput = {
    id?: number
    idexTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MatchUpdateWithoutTransactionInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    IdexTransaction?: IdexTransactionUpdateOneRequiredWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: number
    entityType: string
    entityId: number
    action: $Enums.AuditAction
    timestamp?: Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: number | null
    cardId?: number | null
    cardPouringId?: number | null
  }

  export type BybitClipMatchCreateManyUserInput = {
    id?: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchBybitReportId?: number | null
  }

  export type BybitTransactionCreateManyUserInput = {
    id?: number
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
  }

  export type MatchBybitReportCreateManyUserInput = {
    id?: number
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MatchViresReportCreateManyUserInput = {
    id?: number
    reportDate: Date | string
    totalMatches: number
    totalProfit: number
    averageProfit: number
    successRate: number
    timeRangeStart: Date | string
    timeRangeEnd: Date | string
    notes?: string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ReportNotificationCreateManyUserInput = {
    id?: number
    notificationTime: Date | string
    reportReceived?: boolean
    reportTime?: Date | string | null
    adminNotified?: boolean
    adminNotifyTime?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TelegramAccountCreateManyUserInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: number
    externalId?: string | null
    orderNo?: string | null
    dateTime: Date | string
    type: string
    asset: string
    amount: number
    totalPrice: number
    unitPrice: number
    counterparty?: string | null
    status: string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ViresCabinetCreateManyUserInput = {
    id?: number
    name?: string | null
    login: string
    password: string
    type: $Enums.PasswordType
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
    lastUpdate: Date | string
  }

  export type ViresClipMatchCreateManyUserInput = {
    id?: number
    viresTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchViresReportId?: number | null
    bybitTransactionId: number
  }

  export type WorkSessionCreateManyUserInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    autoCompleted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    comment?: string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    CardBalance?: CardBalanceUpdateOneWithoutAuditLogNestedInput
    Card?: CardUpdateOneWithoutAuditLogNestedInput
    CardPouring?: CardPouringUpdateOneWithoutAuditLogNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: NullableIntFieldUpdateOperationsInput | number | null
    cardId?: NullableIntFieldUpdateOperationsInput | number | null
    cardPouringId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    cardBalanceId?: NullableIntFieldUpdateOperationsInput | number | null
    cardId?: NullableIntFieldUpdateOperationsInput | number | null
    cardPouringId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BybitClipMatchUpdateWithoutUserInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUpdateOneRequiredWithoutBybitClipMatchNestedInput
    IdexTransaction?: IdexTransactionUpdateOneRequiredWithoutBybitClipMatchNestedInput
    MatchBybitReport?: MatchBybitReportUpdateOneWithoutBybitClipMatchNestedInput
  }

  export type BybitClipMatchUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchBybitReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BybitClipMatchUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchBybitReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BybitTransactionUpdateWithoutUserInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    bybitMatch?: BybitMatchUpdateManyWithoutBybitTransactionNestedInput
  }

  export type BybitTransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    bybitMatch?: BybitMatchUncheckedUpdateManyWithoutBybitTransactionNestedInput
  }

  export type BybitTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MatchBybitReportUpdateWithoutUserInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutMatchBybitReportNestedInput
  }

  export type MatchBybitReportUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutMatchBybitReportNestedInput
  }

  export type MatchBybitReportUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchViresReportUpdateWithoutUserInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutMatchViresReportNestedInput
  }

  export type MatchViresReportUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutMatchViresReportNestedInput
  }

  export type MatchViresReportUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMatches?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    averageProfit?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    timeRangeStart?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRangeEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    idexCabinets?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportNotificationUpdateWithoutUserInput = {
    notificationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reportReceived?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotified?: BoolFieldUpdateOperationsInput | boolean
    adminNotifyTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportNotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reportReceived?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotified?: BoolFieldUpdateOperationsInput | boolean
    adminNotifyTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reportReceived?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotified?: BoolFieldUpdateOperationsInput | boolean
    adminNotifyTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramAccountUpdateWithoutUserInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramAccountUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramAccountUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    asset?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Match?: MatchUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    asset?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Match?: MatchUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    asset?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViresCabinetUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    ViresTransactionPayin?: ViresTransactionPayinUpdateManyWithoutViresCabinetNestedInput
  }

  export type ViresCabinetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    ViresTransactionPayin?: ViresTransactionPayinUncheckedUpdateManyWithoutViresCabinetNestedInput
  }

  export type ViresCabinetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumPasswordTypeFieldUpdateOperationsInput | $Enums.PasswordType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViresClipMatchUpdateWithoutUserInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUpdateOneRequiredWithoutViresClipMatchNestedInput
    MatchViresReport?: MatchViresReportUpdateOneWithoutViresClipMatchNestedInput
    ViresTransactionPayin?: ViresTransactionPayinUpdateOneRequiredWithoutViresClipMatchNestedInput
  }

  export type ViresClipMatchUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    viresTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchViresReportId?: NullableIntFieldUpdateOperationsInput | number | null
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
  }

  export type ViresClipMatchUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    viresTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchViresReportId?: NullableIntFieldUpdateOperationsInput | number | null
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
  }

  export type WorkSessionUpdateWithoutUserInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    autoCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUpdateManyWithoutWorkSessionNestedInput
  }

  export type WorkSessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    autoCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    WorkSessionIdexCabinet?: WorkSessionIdexCabinetUncheckedUpdateManyWithoutWorkSessionNestedInput
  }

  export type WorkSessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    autoCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkSessionIdexCabinetCreateManyWorkSessionInput = {
    idexCabinetId: number
    assignedAt?: Date | string
  }

  export type WorkSessionIdexCabinetUpdateWithoutWorkSessionInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    IdexCabinet?: IdexCabinetUpdateOneRequiredWithoutWorkSessionIdexCabinetNestedInput
  }

  export type WorkSessionIdexCabinetUncheckedUpdateWithoutWorkSessionInput = {
    idexCabinetId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkSessionIdexCabinetUncheckedUpdateManyWithoutWorkSessionInput = {
    idexCabinetId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BybitTransactionFromCabinetCreateManyBybitCabinetInput = {
    id?: number
    orderNo: string
    counterparty?: string | null
    status: string
    createdAt?: Date | string
    updatedAt: Date | string
    amount: number
    asset: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice: number
    type: string
    unitPrice: number
    processed?: boolean
    extractedPhones?: BybitTransactionFromCabinetCreateextractedPhonesInput | string[]
    lastAttemptError?: string | null
  }

  export type BybitOrderInfoCreateManyCabinetInput = {
    id?: number
    phoneNumbers?: BybitOrderInfoCreatephoneNumbersInput | string[]
    createdAt?: Date | string
    updatedAt: Date | string
    orderNo: string
    dateTime: Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status: string
    type: string
    amount: number
    totalPrice: number
    processed?: boolean
    unitPrice: number
  }

  export type BybitTransactionFromCabinetUpdateWithoutBybitCabinetInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionFromCabinetUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    BybitClipMatch?: BybitClipMatchUpdateManyWithoutBybitTransactionFromCabinetNestedInput
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutBybitTransactionFromCabinetNestedInput
  }

  export type BybitTransactionFromCabinetUncheckedUpdateWithoutBybitCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionFromCabinetUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
    BybitClipMatch?: BybitClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetNestedInput
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetNestedInput
  }

  export type BybitTransactionFromCabinetUncheckedUpdateManyWithoutBybitCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    asset?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    totalPrice?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    extractedPhones?: BybitTransactionFromCabinetUpdateextractedPhonesInput | string[]
    lastAttemptError?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BybitOrderInfoUpdateWithoutCabinetInput = {
    phoneNumbers?: BybitOrderInfoUpdatephoneNumbersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNo?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type BybitOrderInfoUncheckedUpdateWithoutCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    phoneNumbers?: BybitOrderInfoUpdatephoneNumbersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNo?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type BybitOrderInfoUncheckedUpdateManyWithoutCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    phoneNumbers?: BybitOrderInfoUpdatephoneNumbersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNo?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    originalData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type BybitClipMatchCreateManyBybitTransactionFromCabinetInput = {
    id?: number
    idexTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchBybitReportId?: number | null
    userId: number
  }

  export type ViresClipMatchCreateManyBybitTransactionFromCabinetInput = {
    id?: number
    viresTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchViresReportId?: number | null
    userId: number
  }

  export type BybitClipMatchUpdateWithoutBybitTransactionFromCabinetInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    IdexTransaction?: IdexTransactionUpdateOneRequiredWithoutBybitClipMatchNestedInput
    MatchBybitReport?: MatchBybitReportUpdateOneWithoutBybitClipMatchNestedInput
    User?: UserUpdateOneRequiredWithoutBybitClipMatchNestedInput
  }

  export type BybitClipMatchUncheckedUpdateWithoutBybitTransactionFromCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchBybitReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BybitClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchBybitReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ViresClipMatchUpdateWithoutBybitTransactionFromCabinetInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MatchViresReport?: MatchViresReportUpdateOneWithoutViresClipMatchNestedInput
    User?: UserUpdateOneRequiredWithoutViresClipMatchNestedInput
    ViresTransactionPayin?: ViresTransactionPayinUpdateOneRequiredWithoutViresClipMatchNestedInput
  }

  export type ViresClipMatchUncheckedUpdateWithoutBybitTransactionFromCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    viresTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchViresReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ViresClipMatchUncheckedUpdateManyWithoutBybitTransactionFromCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    viresTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchViresReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BybitClipMatchCreateManyMatchBybitReportInput = {
    id?: number
    idexTransactionId: number
    bybitTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    userId: number
  }

  export type BybitClipMatchUpdateWithoutMatchBybitReportInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUpdateOneRequiredWithoutBybitClipMatchNestedInput
    IdexTransaction?: IdexTransactionUpdateOneRequiredWithoutBybitClipMatchNestedInput
    User?: UserUpdateOneRequiredWithoutBybitClipMatchNestedInput
  }

  export type BybitClipMatchUncheckedUpdateWithoutMatchBybitReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BybitClipMatchUncheckedUpdateManyWithoutMatchBybitReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    idexTransactionId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ViresClipMatchCreateManyMatchViresReportInput = {
    id?: number
    viresTransactionId: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    userId: number
    bybitTransactionId: number
  }

  export type ViresClipMatchUpdateWithoutMatchViresReportInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUpdateOneRequiredWithoutViresClipMatchNestedInput
    User?: UserUpdateOneRequiredWithoutViresClipMatchNestedInput
    ViresTransactionPayin?: ViresTransactionPayinUpdateOneRequiredWithoutViresClipMatchNestedInput
  }

  export type ViresClipMatchUncheckedUpdateWithoutMatchViresReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    viresTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
  }

  export type ViresClipMatchUncheckedUpdateManyWithoutMatchViresReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    viresTransactionId?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
  }

  export type ViresTransactionPayinCreateManyViresCabinetInput = {
    id?: number
    createdAt: Date | string
    sum_rub: number
    sum_usdt: number
    card: string
    fio: string
    bank: string
    uuid: string
  }

  export type ViresTransactionPayinUpdateWithoutViresCabinetInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sum_rub?: FloatFieldUpdateOperationsInput | number
    sum_usdt?: FloatFieldUpdateOperationsInput | number
    card?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    ViresClipMatch?: ViresClipMatchUpdateManyWithoutViresTransactionPayinNestedInput
  }

  export type ViresTransactionPayinUncheckedUpdateWithoutViresCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sum_rub?: FloatFieldUpdateOperationsInput | number
    sum_usdt?: FloatFieldUpdateOperationsInput | number
    card?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    ViresClipMatch?: ViresClipMatchUncheckedUpdateManyWithoutViresTransactionPayinNestedInput
  }

  export type ViresTransactionPayinUncheckedUpdateManyWithoutViresCabinetInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sum_rub?: FloatFieldUpdateOperationsInput | number
    sum_usdt?: FloatFieldUpdateOperationsInput | number
    card?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type ViresClipMatchCreateManyViresTransactionPayinInput = {
    id?: number
    timeDifference: number
    grossExpense: number
    grossIncome: number
    grossProfit: number
    profitPercentage: number
    createdAt?: Date | string
    updatedAt: Date | string
    matchViresReportId?: number | null
    userId: number
    bybitTransactionId: number
  }

  export type ViresClipMatchUpdateWithoutViresTransactionPayinInput = {
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BybitTransactionFromCabinet?: BybitTransactionFromCabinetUpdateOneRequiredWithoutViresClipMatchNestedInput
    MatchViresReport?: MatchViresReportUpdateOneWithoutViresClipMatchNestedInput
    User?: UserUpdateOneRequiredWithoutViresClipMatchNestedInput
  }

  export type ViresClipMatchUncheckedUpdateWithoutViresTransactionPayinInput = {
    id?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchViresReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
  }

  export type ViresClipMatchUncheckedUpdateManyWithoutViresTransactionPayinInput = {
    id?: IntFieldUpdateOperationsInput | number
    timeDifference?: IntFieldUpdateOperationsInput | number
    grossExpense?: FloatFieldUpdateOperationsInput | number
    grossIncome?: FloatFieldUpdateOperationsInput | number
    grossProfit?: FloatFieldUpdateOperationsInput | number
    profitPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchViresReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    bybitTransactionId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}